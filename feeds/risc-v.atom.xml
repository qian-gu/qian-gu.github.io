<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's Blog - RISC-V</title><link href="https://qian-gu.github.io/" rel="alternate"></link><link href="https://qian-gu.github.io/feeds/risc-v.atom.xml" rel="self"></link><id>https://qian-gu.github.io/</id><updated>2024-04-13T14:26:00+08:00</updated><subtitle>Read &gt;&gt; Think &gt;&gt; Write</subtitle><entry><title>RISC-V Book 阅读笔记</title><link href="https://qian-gu.github.io/posts/risc-v/riscv-book-note.html" rel="alternate"></link><published>2024-04-13T14:26:00+08:00</published><updated>2024-04-13T14:26:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2024-04-13:/posts/risc-v/riscv-book-note.html</id><summary type="html">&lt;p&gt;The RISC-V Reader: An Open Architecture Atlas 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#risc-v"&gt;为什么要有 RISC-V？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#isa"&gt;ISA 设计导论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32irisc-v"&gt;RV32I：RISC-V 基础整数指令集&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#rv32i"&gt;RV32I 指令格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_1"&gt;RV32I 寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_2"&gt;RV32I 整数计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_3"&gt;RV32I 取数和存数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_4"&gt;RV32I 条件分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_5"&gt;RV32I 无条件跳转&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_6"&gt;其他 RV32I 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#risc-v_1"&gt;RISC-V 汇编语言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;函数调用过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32m"&gt;RV32M：乘法和除法指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_5"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32f-rv32d"&gt;RV32F 和 RV32D：单精度和双精度浮点数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_6"&gt;浮点寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;浮点取数、存数和算术运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32a"&gt;RV32A：原子指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_9"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32c"&gt;RV32C：压缩指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_10"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32v"&gt;RV32V：向量&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_11"&gt;向量计算指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_12"&gt;向量寄存器和动态类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_13"&gt;向量取数和存数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_14"&gt;向量操作的并行度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_15"&gt;向量操作的条件执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_16"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv6464"&gt;RV64：64 位地址指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_17"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv3264"&gt;RV32/64 特权架构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_18"&gt;机器模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_19"&gt;机器模式的异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_20"&gt;嵌入式系统中的用户模式和进程隔离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_21"&gt;现代操作系统的监管模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_22"&gt;页式虚拟内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_23"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="risc-v"&gt;为什么要有 RISC-V？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大道至简。&lt;/p&gt;
&lt;p&gt;—— 列奥纳多 · 达 · 芬奇（Leonardo da Vinci）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年轻、开放、模块化。&lt;/p&gt;
&lt;h3 id="isa"&gt;ISA 设计导论&lt;/h3&gt;
&lt;p&gt;计算机架构师在设计 ISA 时需要遵守的基本原则和做出权衡，评价一个 ISA 的 7 个指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;ISA 越简单，area 越小，成本越低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简洁&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;简洁不光可以节省制造成本，还能节省设计和验证时间，降低文档开销，使得用户更加容易了解和使用。高端 implement 可以通过组合简单指令来提升性能，但是如果直接在 ISA 中添加更大、更复杂的指令会给低端 implement 带来负担。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;完成相同的任务，RISC 比 CISC 需要的指令更多，但是 RISC 因为其 ISA 的简洁性，可以通过更高的时钟频率和更小的 CPI 来弥补。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;架构和实现分离&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;延迟分支槽：MIPS-32 ISA 在 architecture 层面解决某一时期某个 implement 的问题，导致其他和后续的 implement 为了保持向后兼容不得不做一些无用的工作。&lt;/p&gt;
&lt;p&gt;架构师除了不应该加入那些仅有助于一个 implement 的功能，也不应该加入阻碍某些实现的功能。比如 ARM-32 提供的 load multiple 指令，这个指令可以提升单发射 pipeline 的性能，但是会对多发射 pipeline 带来负面影响。因为简单的多发射实现无法支持 load multiple 指令和其他指令的并行调度，所以要么实现更复杂的多发射机制，要么降低这种情况下的指令吞吐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升空间&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;随着摩尔定律的终结，大幅提高性价比的唯一途径是 DSA（为特定领域添加自定义指令，如 DL、AR 等），所以 ISA 必须预留操作码空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码大小&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;让代码变短是 ISA 架构师的目标，因为可以降低所需存储器的面积（嵌入式的一项巨大成本），降低 I$ 的 miss ratio，从而降低功耗（访问片外 DRAM 代价远高于片上 SRAM）并提升性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;易于编程 / 编译 / 链接&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;GPR 数量越多，编译器和汇编程序员的工作越轻松。ARM-32 有 16 个寄存器，X86-32 只有 8 个，现代 ISA 都有相对较多的 32 个。&lt;/p&gt;
&lt;p&gt;位置无关代码（Position Independent Code, PIC）有助于支持动态链接，因为共享库的代码可以放在不同地址。PC 相对分支和数据寻址是 PIC 的福音，RISC-V 支持 PC 相对寻址，但是 x86-32 和 MIPS-32 不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;ISA 就好比俄罗斯方块中的方块形状集合，集合要设计的够用且不冗余。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用形式逻辑方法容易看出，存在某种抽象的 [ 指令集 ]，足以控制和执行任意操作序列 …… 现在看来，选择一款 [ 指令集 ] 的真正决定性因素更多是实用性：[ 指令集 ] 所需装置的简洁性，应用于实际重要问题的清晰度，以及处理这些问题的速度。
——[Burks et al. 1946]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RISC-V 是一款最新的、清晰的、简约的、开放的 ISA，它以过去 ISA 所犯错误为鉴。RISC-V 架构师的目标是让它能用于从最小到最快的所有计算设备。遵循冯 · 诺依曼在 1940 年代的建议，RISC-V 强调简洁性以保持低成本，同时拥有大量寄存器和直观的指令执行速度，从而帮助编译器和汇编语言程序员将实际的重要问题转换为适当的高效代码。&lt;/p&gt;
&lt;h2 id="rv32irisc-v"&gt;RV32I：RISC-V 基础整数指令集&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;…… 提升计算性能并让用户切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不到的特性将不会在硬件上实现 ……&lt;/p&gt;
&lt;p&gt;—— 法兰 · 艾伦（Frances Elizabeth “Fran” Allen），1981&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="rv32i"&gt;RV32I 指令格式&lt;/h3&gt;
&lt;p&gt;简洁的指令格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：四种基础格式 R(egister) + I(mmediate) + S(tore) + U(pper) + 两种扩展格式 B(ranch) + J(ump)&lt;/li&gt;
&lt;li&gt;性能：支持 3 个操作数&lt;/li&gt;
&lt;li&gt;性能：rs1，rs2，rd 位置固定，在 dec 前访问 GPR&lt;/li&gt;
&lt;li&gt;性能：imm 的符号位永远在 inst[31]，符号位扩展可在 dec 前进行&lt;/li&gt;
&lt;li&gt;易于编程：全 0 和全 1 为非法指令&lt;/li&gt;
&lt;li&gt;成本：精心挑选 op_code，使得 datapath 相同的指令共享 op_code，从而简化控制逻辑&lt;/li&gt;
&lt;li&gt;提升空间：RV32I 占用 32bit 指令编码空间不到 1/8，预留指令编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_1"&gt;RV32I 寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于编程：RISC-V = 32 个 GPR + 1 PC；ARM-32 = 16 个 GPR（包含 PC）&lt;/li&gt;
&lt;li&gt;简洁：实现相同功能，设置 x0 为常 0 可以简化操作，额外设置 PC 可以简化分支预测复杂度，且少占用一个 GPR&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_2"&gt;RV32I 整数计算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：imm 总是符号位扩展，所以无需 imm 版本的 sub 指令&lt;/li&gt;
&lt;li&gt;简洁：虽然 branch 支持 2 个 GPR 之间的所有运算关系，还是提供 slt 方便处理更复杂的条件表达式&lt;/li&gt;
&lt;li&gt;易于编程：lui 搭配后续一条指令，可以构造出 32bit 的 imm；auipc 搭配 jal/jalr 可以实现相对于 PC 的任意偏移跳转和数据访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_3"&gt;RV32I 取数和存数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32I 只支持一种标准寻址模式： &lt;strong&gt;偏移寻址&lt;/strong&gt; ，即跳转地址 = 寄存器 + imm[11:0]&lt;/li&gt;
&lt;li&gt;简洁：没有栈指令，ABI 中指定 x2 为 sp 就能使得标准寻址模式具有 push/pop 的优点，无需增加 ISA 复杂度&lt;/li&gt;
&lt;li&gt;易于编程：ARM-32 和 MIPS-32 要求数据按其长度对齐，RISC-V 无此要求&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;因为一条 32bit 指令无法容纳 32bit 地址，所以 linker 通常要把每个符号调整成 2 条 RV32I 指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据地址，需要调整为 lui 和 addi&lt;/li&gt;
&lt;li&gt;对于代码地址，需要调整为 auipc 和 jalr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候跳转距离没那么大，此时并不需要两条，linker 会多趟扫描代码，尽可能优化成一条 jal 指令（包含 imm[19:0]，可以寻址前后 1MB），这个过程叫做 linker relaxation。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="rv32i_4"&gt;RV32I 条件分支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RISC-V 没有 MIPS-32 的延迟分支，也没有 ARM-32 和 x86-32 的条件码&lt;/li&gt;
&lt;li&gt;简洁：auipc 的 imm 为 0 就可以得到当前 PC，x86-32 需要先调用函数把 PC push，然后读出 PC，最后再 pop&lt;/li&gt;
&lt;li&gt;简洁：大部分程序都忽略整数的算术溢出，所以 RISC-V 让软件检测溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_5"&gt;RV32I 无条件跳转&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32I 不支持复杂的过程调用指令，如 x86-32 的 enter/leave，Tensilica 的 register windows&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;p class="admonition-title"&gt;Info&lt;/p&gt;
&lt;p&gt;register windows：通过远多于 32 个 GPR 来加速函数调用。在函数调用时，为其分配新的一组 32 个寄存器（也称为窗口），为了支持传参，两个函数的窗口会重叠，即有些寄存器同时属于两个相邻的窗口。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="rv32i_6"&gt;其他 RV32I 指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RISC-V 通过 memory-map IO 来访问设备，没有 x86-32 的专用 I/O 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;那些遗忘过去的人注定要重蹈覆辙。&lt;/p&gt;
&lt;p&gt;—— 乔治 · 桑塔亚那（George Santayana），1905&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;得益于起步时间比过去的 ISA 晚 20∼30 年，RISC-V 架构师可以实践 Santayana 的建议，借鉴包括 RISC-I 在内不同 ISA 的设计，取其精华，去其糟粕。此外，RISC-V 国际基金会将以可选扩展的方式缓慢地演进指令集，以规避给过去的成功 ISA 造成麻烦的野蛮生长现象。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;图 2.7 按照 7 个评价指标汇总了 ARM-32、MIPS-32、x86-32 和 RV32I 的对比&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="risc-v_1"&gt;RISC-V 汇编语言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给看似困难的问题找到简单的解法往往令人满足，而最好的解法通常是简单的。&lt;/p&gt;
&lt;p&gt;—— 伊凡 · 苏泽兰（Ivan Sutherland）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_3"&gt;函数调用过程&lt;/h3&gt;
&lt;p&gt;通常分为 6 个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;caller 将参数放到 callee 可访问的位置&lt;/li&gt;
&lt;li&gt;调换到 callee 的入口（使用 jal）&lt;/li&gt;
&lt;li&gt;获取函数所需的局部存储资源，按需保存 GPR&lt;/li&gt;
&lt;li&gt;执行函数功能&lt;/li&gt;
&lt;li&gt;将返回值放到 caller 可访问的位置，恢复 GPR，释放局部存储资源&lt;/li&gt;
&lt;li&gt;将控制权返回给 caller（使用 ret）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;保存寄存器由 callee 负责维护，重新解释上述过程如下：&lt;/p&gt;
&lt;p&gt;在 caller 中执行 call 指令跳转进入 callee 后，callee 首先做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配 stack frame，为保存现场准备资源&lt;/li&gt;
&lt;li&gt;将 callee 需要维护的保存寄存器存储到 stack 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 callee 完成功能后，执行 ret 指令前做两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 stack 向保存寄存器恢复现场&lt;/li&gt;
&lt;li&gt;恢复保存寄存器 &lt;code&gt;sp&lt;/code&gt; == 释放 stack frame（局部资源）&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;为了提升性能，应尽量把变量放在 GPR 中而不是内存中，同时要避免因为保存和恢复 GPR 而频繁访问内存。RISC-V 有足够的寄存器兼顾两者：既能把操作数放在 GPR，又能减少保存和恢复它们的次数。关键在于，一些寄存器不保证其值在函数调用前后保持一致，称为临时寄存器；另一些能保证，称为保存寄存器。不再调用其他函数的函数称为叶子函数。当一个叶子函数只有少量参数和局部变量时，可将其分配到寄存器，无需分配到内存。大部分函数调用均如此，此时程序无需将寄存器保存到内存。&lt;/p&gt;
&lt;p&gt;典型例子 main 函数调用 prinf：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 编译，将 c 代码转化为 asm 代码，结果如图 3.6&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello.s&lt;span class="w"&gt; &lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;hello.c
&lt;span class="c1"&gt;# 编译，将 asm 代码转化为 .o 文件，.o 文件无法直接查看，需要先 dump，结果如图 3.7&lt;/span&gt;
&lt;span class="c1"&gt;# 其中一些指令的地址字段是 0，需要 linker 填充&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello.o&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;hello.s
objdump&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;hello.o&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;hello.o.dump
&lt;span class="c1"&gt;# 链接，将 .o 文件转化为 elf 文件，elf 文件无法直接查看，需要先 dump，结果如图 3.8&lt;/span&gt;
&lt;span class="c1"&gt;# 地址字段已替换&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello&lt;span class="w"&gt; &lt;/span&gt;hello.c
objdump&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;hello&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;hello.dump
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_4"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;保持简洁，直接。&lt;/p&gt;
&lt;p&gt;—— 凯利 · 约翰逊（Kelly Johnson），提出 “KISS 原则 ” 的航空工程师，1960&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;汇编器向简洁的 RISC-V ISA 增加了 60 条伪指令，在不增加硬件开销的同时令 RISC-V 代码更易于读写。RISC-V 提供一系列简单有效的机制，可降低成本、提高性能、易于编程。&lt;/p&gt;
&lt;h2 id="rv32m"&gt;RV32M：乘法和除法指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;若无必要，勿增实体。&lt;/p&gt;
&lt;p&gt;—— 奥卡姆的威廉（William of Occam），约 1320&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在几乎任何处理器上，执行速度：移位 &amp;gt; 乘法 &amp;gt;&amp;gt; 除法。&lt;/li&gt;
&lt;li&gt;除以常数，可以转化成乘以一个近似的倒数，再校正积的高位部分&lt;/li&gt;
&lt;li&gt;ARM-32 在 2005 之后才添加了除法指令；MISP-32 使用特殊的寄存器作为乘除法的 rd，所以需要额外的传送指令，会降低性能，增加体系结构的状态，降低切换任务的速度&lt;/li&gt;
&lt;li&gt;mulh 和 mulhu 可以检查乘法溢出&lt;/li&gt;
&lt;li&gt;除数为 0 不会产生 trap，所以可以只在需要时通过 beqz 检查除数是否为 0&lt;/li&gt;
&lt;li&gt;mulhsu 对 multi-word singed 乘法很有用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_5"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;最便宜、最快且最可靠的组件是那些不存在的组件。&lt;/p&gt;
&lt;p&gt;—— 切斯特 · 戈登 · 贝尔（C. Gordon Bell），著名小型计算机架构师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv32f-rv32d"&gt;RV32F 和 RV32D：单精度和双精度浮点数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;达成完美之时并非无所可增，而是无所可减。&lt;/p&gt;
&lt;p&gt;—— 安托万 · 德 · 圣埃克絮佩里（Antoine de Saint-Exupéry），《人的大地》，1939&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_6"&gt;浮点寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：4 种指令格式中 rs 和 rd 只有 5bit 刚好表达 32 个 x 寄存器，为了保持指令格式不变，为浮点另外设置一组（32 个）f 寄存器&lt;/li&gt;
&lt;li&gt;如果只支持 RV32F 则 FLEN=32，如果支持 RV32D 则 FLEN=64&lt;/li&gt;
&lt;li&gt;fcsr 用于存放 round mode 和精确异常 flag&lt;/li&gt;
&lt;li&gt;ARM-32 和 MIPS-32 有 32 个 float 寄存器，但是只有 16 个 double 寄存器（把两个 float 拼接成一个 double 使用）&lt;/li&gt;
&lt;li&gt;x86-32 浮点运算早期使用 stack 而不是寄存器，后续版本增加了 8 个 64bit 浮点寄存器&lt;/li&gt;
&lt;li&gt;ARM-32 和 x86-32 不支持 x 和 f 寄存器之间直接传送数据的指令，要实现该功能，必须先写内存，再读内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_7"&gt;浮点取数、存数和算术运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：许多浮点运算（矩阵乘法）在乘法后立即执行一次加法 / 减法，所以 RISC-V 提供了 fmadd、fmsub、fnmadd、fnmsub 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_8"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;少即是多。&lt;/p&gt;
&lt;p&gt;—— 罗伯特 · 勃朗宁（Robert Browning），1855。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv32a"&gt;RV32A：原子指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一切事物都应该尽量简单，但不能过分简单。&lt;/p&gt;
&lt;p&gt;—— 阿尔伯特 · 爱因斯坦（Albert Einstein），1933&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RV32A 用于同步的原子操作有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子内存操作（atomic memory operation，AMO）&lt;/li&gt;
&lt;li&gt;预订取数 / 条件存数（load reserved / store conditional）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为何 RV32A 要提供两种原子操作？答案是对应两种区别很大的使用场景。&lt;/p&gt;
&lt;p&gt;场景一：编程语言开发者假定顶层的 ISA 提供原子的 compare-and-swap 操作：比较某寄存器和另一寄存器寻址的内存值，若相等，则将第 3 个寄存器的值与内存值交换。这是一种通用的同步原语，基于它可以实现其他任意 word 同步操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 用 lr/sc 对内存 M[a0] 进行 compare-and-swap
# 期望的旧值在 a1 中；期望的新值在 a2 中
0: lr.w a3, (a0)  # 取出旧值
4: bne a3, a1, 80  # 旧值是否等于 a1？
8: sc.w a3, a2, (a0)  # 如果相等，则换入新值
c: bnez a3, 0  # 如果失败，重试
... compare-and-swap 成功后的代码 ...
...
80:  # compare-and-swap 失败
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;场景二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 用 AMO 实现 test-and-set 自旋锁，用于保护临界区
0: li t0, 1 # 初始化锁值
4: amoswap.w.aq t1, t0, (a0) # 尝试获取锁
8: bnez t1, 4 # 若失败则重试
... 临界区代码 ..
20: amoswap.w.rl x0, x0, (a) # 释放锁
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_9"&gt;结语&lt;/h3&gt;
&lt;p&gt;RV32A 是可选的，一个不支持它的 RISC-V 处理器会更简单。然而，正如爱因 斯坦所言，一切事物都应该尽量简单，但不能过分简单。RV32A 正是如此，许多场景 都离不开它。&lt;/p&gt;
&lt;h2 id="rv32c"&gt;RV32C：压缩指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;小即是美。&lt;/p&gt;
&lt;p&gt;—— 恩斯特 · 弗里德里希 · 舒马赫（E. F. Schumacher），1973&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码大小：以前的 ISA 为缩减代码大小而添加很多指令和指令格式，ARM 和 MIPS 分别对 ISA 重新设计了两遍：ARM 设计了 ARM Thumb 和 Thumb2，MIPS 则设计了 MIPS16 和 microMIPS。这些新 ISA 给处理器和编译器带来额外的设计开销，同时还增加汇编语言程序员的认知负担。&lt;/li&gt;
&lt;li&gt;简洁：RV32C 采用一种新方法：每条短指令都必须对应一条标准的 32 位 RISC-V 指 令。此外，16 位指令仅对汇编器和链接器可见，并由它们决定是否将标准指令替换为相应的短指令。编译器开发者和汇编语言程序员无需关心 RV32C 指令及其格式，他 们只需知道最终得到的程序比大部分情况下更小。&lt;/li&gt;
&lt;li&gt;成本：尽管处理器设计者不能忽略 RV32C 指令，但能通过以下技巧降低实现开销：在执 行指令前通过一个译码器将所有 16 位指令翻译成相应的 32 位指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么有些架构师会跳过 RV32C：16bit 的 RV32C 和 32bit 的 RV32I 混合在一起会恶化 decoder 的时序，而在高性能处理器中，dec 本身就是时序瓶颈，所以很难处理这种情况。典型例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superscalar 一个 cycle 内 decode 多条指令&lt;/li&gt;
&lt;li&gt;宏融合 macrofusion：decoder 把多条指令组合成更复杂的指令来执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_10"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;我本能写出更短的信，但我没有时间。&lt;/p&gt;
&lt;p&gt;—— 布莱兹 · 帕斯卡（Blaise Pascal），1656。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RV32C 让 RISC-V 编译出当今几乎最短的代码。您几乎能将其视为硬件辅助的伪指令。但这里汇编器将其隐藏起来，汇编语言程序员和编译器开发者无需感知。&lt;/p&gt;
&lt;h2 id="rv32v"&gt;RV32V：向量&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我追求简洁，无法理解复杂的事物。&lt;/p&gt;
&lt;p&gt;—— 西摩 · 克雷（Seymour Cray）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;性能：注数据级并行，该技术用于可在大量数据上并发计算的目标应用程序。最著名的数据级并行架构是 SIMD（Single Instruction Multiple Data，单指令多数据）。&lt;/li&gt;
&lt;li&gt;架构和实现分离：将向量长度和每个时钟周期的最大操作次数与指令编码分离，是向量架构的关键。向量微架构师可灵活设计数据并行硬件单元，不会影响程序员，而程序员无需重写代码即可享受更长向量的好处。&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：向量架构的指令数量比 SIMD 架构少得多。而且，与 SIMD 不同，向量架构的编译技术十分完善。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_11"&gt;向量计算指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RV32IMAFD 每一条整数和浮点计算指令基本都有对应的向量版本&lt;/li&gt;
&lt;li&gt;每条向量指令根据操作数的类型，有多个版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_12"&gt;向量寄存器和动态类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32 个名称以 v 开头的向量寄存器，但每个向量寄存器的元素数量并不固定，取决于操作的位宽和向量寄存器堆大小，后者由处理器设计者决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VLEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每个 VRF 的位宽，单位为 bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mvl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单条指令能正确运行的最大向量元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待处理的向量元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;易于编程 / 编译 / 链接：RV32V 采取将数据类型和位宽与向量寄存器关联的新方法，而不是与指令操作码关联。程序在执行向量计算指令前，先在向量寄存器中设置数据类型和位宽。使用动态寄存器类型可大幅减少向量指令数量。动态类型向量架构能降低汇编语言程序员的认知负担和编译器中代码生成器的复杂度。&lt;/li&gt;
&lt;li&gt;向量架构不如 SIMD 架构流行的一个原因是，大家担心添加很大的向量寄存器会增加中断时保存和恢复程序（上下文切换）的开销。动态寄存器类型有助于改善此情况。根据 RV32V 约定，软件在不使用向量指令时需要禁用所有向量寄存器，这意味着处理器既具备向量寄存器的性能优势，又仅在向量指令执行过程中发生中断时才引入额外的上下文切换开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_13"&gt;向量取数和存数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于编程 / 编译 / 链接：虽然可以设置 stride = 1 使得 stride 兼容 unistride，但是提供 unistride 指令可以缩小代码体积和指令数。（vlds/vsts 需要 2 个 rs，而 vld/vst 只需要 1 个）&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：为了支持稀疏数组，提供 index 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_14"&gt;向量操作的并行度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：向量元素之间独立，硬件可以并行计算，每个 cycle 计算的元素数量由 VLEN 和 EEW 决定&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：在 SIMD 架构中，由 ISA 架构师决定每个 cycle 并行操作的最大数量和每个寄存器的元素数量，如果寄存器位宽翻倍，则指令数也翻倍，还需要同步修改编译器。RV32V 则由 implementation 决定，无需修改 ISA 和编译器，同一份 RV32V 程序，无需修改（修改代码和重新编译）就可以同时在最简单或最激进的向量处理器上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_15"&gt;向量操作的条件执行&lt;/h3&gt;
&lt;p&gt;一些向量计算包含 if 语句。向量架构不依赖于条件分支，而是用掩码禁止部分元素的向量操作。&lt;/p&gt;
&lt;h3 id="_16"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;若代码可向量化，最好的架构就是向量架构。&lt;/p&gt;
&lt;p&gt;—— 吉姆 · 史密斯（Jim Smith）于 1994 年在国际计算机体系结构研讨会（ISCA）上的主题演讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv6464"&gt;RV64：64 位地址指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机设计中只有一种错误难以恢复 —— 用于存储器寻址和存储管理的地址位 不足。&lt;/p&gt;
&lt;p&gt;—— 切斯特 · 戈登 · 贝尔，1976&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码大小：RV64 基本上是 RV32 的超集，唯一例外是压缩指令。&lt;/li&gt;
&lt;li&gt;与 RISC-V 不同，ARM 决定采用最大主义方法来设计 ISA。&lt;/li&gt;
&lt;li&gt;成本：程序大小的差异显著，让 RV64 要么能通过较低的指令缓存缺失率提升性能，要么在缺失率尚可接受的前提下，采用更小的指令缓存来降低成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_17"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;成为先驱的一个问题是你总会犯错误，而我永远不想成为先驱。在看到先驱所犯错误后，第二个做这件事才是最好的。&lt;/p&gt;
&lt;p&gt;—— 西摩 · 克雷（Seymour Cray），第一台超级计算机的架构师，1976 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;64 位架构更能体现 RISC-V 设计的合理性，这对 20 年后才开始设计的我们是更容易实现的，因为我们能借鉴先驱经验，取其精华，去其糟粕。&lt;/p&gt;
&lt;h2 id="rv3264"&gt;RV32/64 特权架构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;简洁是可靠性的前提。&lt;/p&gt;
&lt;p&gt;—— 艾兹赫尔 · 韦伯 · 戴克斯特拉（Edsger W. Dijkstra）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高特权模式通常能访问低特权模式的所有功能，同时还具备若干低特权模式下不可用的额外功能，如中断处理和 I/O 操作。处理器通常在最低特权模式下运行，当发生中断和异常时，则将控制权转移到更高特权的模式。&lt;/p&gt;
&lt;p&gt;RV 的 3 种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;machine mode&lt;/li&gt;
&lt;li&gt;supervisor mode&lt;/li&gt;
&lt;li&gt;user mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特权架构指令很少，但是增加了若干 csr 来实现其新增功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32 和 RV64 特权架构，两者的差异仅体现在整数寄存器的位宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_18"&gt;机器模式&lt;/h3&gt;
&lt;p&gt;机器模式最重要的特性是拦截和处理异常 exception（不寻常的 runtime event）。RISC-V 将 exception 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步异常 synchronous exception：指令执行的结果，比如访问非法地址，指令 opcode 无效&lt;/li&gt;
&lt;li&gt;中断 interrupt：和指令流异步的外部事件，比如鼠标点击。标准中断源有 3 个&lt;ul&gt;
&lt;li&gt;软件 software：通过写入一个内存映射寄存器触发，通常用于一个 hart 通知另一个 hart，此机制在其他架构中称为处理器间中断 interprocessor interrupt&lt;/li&gt;
&lt;li&gt;时钟 timer：mtime &amp;gt;= mtimecmp（内存映射寄存器）时触发&lt;/li&gt;
&lt;li&gt;外部来源 external：由 PLIC（大部分外设都挂载在它上面）产生，PLIC 因平台而异&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC-V 允许不对齐访存，但是仍包含访存地址不对齐异常。原因是考虑到不对齐访存的硬件实现较复杂，且出现频率很低，因此一些硬件实现方案选择不支持不对齐的普通访存操作。这类处理器需要陷入异常处理程序，然后通过一系列较小的对齐访存操作，来在软件中模拟不对齐访存。应用程序代码对此一无所知：不对齐访存操作仍然正确执行，虽然执行得慢，但硬件实现却很简单。此外，高性能处理器亦可在硬件中实现不对齐访存。&lt;/p&gt;
&lt;h3 id="_19"&gt;机器模式的异常处理&lt;/h3&gt;
&lt;p&gt;异常处理必须的 8 个 csr：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;全拼&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mstatus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Status&lt;/td&gt;
&lt;td&gt;维护各种状态，如全局中断使能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Interrupt Pending&lt;/td&gt;
&lt;td&gt;记录当前的中断请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mie&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Interrupt Enable&lt;/td&gt;
&lt;td&gt;维护处理器的中断使能状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mcause&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Exception Cause&lt;/td&gt;
&lt;td&gt;指示发生了何种异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mtvec&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Trap Vector&lt;/td&gt;
&lt;td&gt;存放发生异常时处理器跳转的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mtval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Trap Value&lt;/td&gt;
&lt;td&gt;存放当前自陷相关的额外信息，如地址异常的故障地址、非法指令异常的指令，发生其他异常时其值为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mepc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Exception PC&lt;/td&gt;
&lt;td&gt;指向发生异常的指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mscratch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Scratch&lt;/td&gt;
&lt;td&gt;向异常处理程序提供一个字的临时存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;M-mode 响应 exception 的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先检查条件 mstatus.MIE = 1，mie 和 mip 的 bit 位，满足条件后原子性地完成以下步骤&lt;/li&gt;
&lt;li&gt;将 exception 指令的 PC 保存到 mepc，然后把 PC 设置为 mtvec&lt;ul&gt;
&lt;li&gt;对于 synchronous exception：mepc 指向触发 exception 的指令&lt;/li&gt;
&lt;li&gt;对于 interrupt：mepc 指向 ISR 后恢复执行的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把 exception 原因写入 mcause，并把故障地址或其他相关信息写入 mtval&lt;/li&gt;
&lt;li&gt;把 MIE 的旧值保存到 MPIE，把 mstatus.MIE 清零以屏蔽 interrupt&lt;/li&gt;
&lt;li&gt;把 exception 发生前的模式保存到 mstatus.MPP，然后把模式更改为 M&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CSR 中没有记录当前的 privilege 等级，只有 MPP、SPP、UPP，所以软件无法查询得知当前处于哪个模式，原因是 ISA 认为软件开发人员应该准确地知道每段代码所处的特权等级，无需查询。
从硬件设计的角度，内部需要有一个寄存器来记录当前状态，否则无法判断当前等级是否有权限执行某些指令。该内部寄存器未开放给软件，所以在 ISA CSR 中也不可见。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;mscratch 的作用：提供一种快速的保存 - 恢复机制，可以直接把某个 XRF 写入到 mscratch，而不是 stack 中。如果需要保存更多的寄存器，一般 mscratch 指向一片空闲的内存，ISR 可以根据需求把想要的任意个寄存器内容写入到该空间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先用 csrrw 指令交换 mscratch 和 a0 的内容（mscratch 是 csr，普通指令无法直接使用，必须先交换到 XRF 中。因为 ISR 没有参数，所以 a0 是空闲 XRF，可以用来和 mscratch 交换）&lt;/li&gt;
&lt;li&gt;将任意个 XRF 保存到内存中&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;li&gt;处理完后再从内存中恢复数据到 XRF&lt;/li&gt;
&lt;li&gt;用 csrrw 交换 mscratch 和 a0，恢复内容&lt;/li&gt;
&lt;li&gt;用 mret 返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# example：timer 中断的 ISR。&lt;/span&gt;
&lt;span class="c1"&gt;# 假设&lt;/span&gt;
&lt;span class="c1"&gt;# 1. mstatus.MIE=1 已打开全局中断使能&lt;/span&gt;
&lt;span class="c1"&gt;# 2. timer 中断使能 mie[7]=1 已打开&lt;/span&gt;
&lt;span class="c1"&gt;# 3. mtvec 设置为本处理程序的地址&lt;/span&gt;
&lt;span class="c1"&gt;# 4. mscratch 指向一段 16Byte 的临时缓冲区&lt;/span&gt;

&lt;span class="c1"&gt;# step1. 交换 mscratch 和 a0。a0 保持空闲内存供后续普通指令使用，mscratch 保存 a0 旧值，用于后续恢复&lt;/span&gt;
&lt;span class="nf"&gt;csrrw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mscratch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;

&lt;span class="c1"&gt;# step2. 保存 XRF 到空闲内存。因为后续要使用到 a1, a2, a3, a4 这几个 XRF，所以先保存旧值&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# step3. 中断处理&lt;/span&gt;
&lt;span class="c1"&gt;# 解析中断原因&lt;/span&gt;
&lt;span class="nf"&gt;csrr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mcause&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 读出异常原因&lt;/span&gt;
&lt;span class="nf"&gt;bgez&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;exception&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# 若非中断则跳转，bgez 的 rs 是 signed 类型，中断对应的 MSB = 1 为负数&lt;/span&gt;
&lt;span class="nf"&gt;andi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0x3f&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# 单独取出中断原因&lt;/span&gt;
&lt;span class="nf"&gt;li&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;# a2 = 时钟中断号&lt;/span&gt;
&lt;span class="nf"&gt;bne&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;otherInt&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# 若非 timer 中断则跳转&lt;/span&gt;
&lt;span class="c1"&gt;# 处理 timer 中断，递增 mtimecmp&lt;/span&gt;
&lt;span class="nf"&gt;la&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mtimecmp&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# mtimecmp 是 memory map csr，读出该地址的到 a1&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 读出 mtimecmp 的低 32bit 到 a2&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 读出 mtimecmp 的高 32bit 到 a3&lt;/span&gt;
&lt;span class="nf"&gt;addi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# 给 mtimecmp 的低 32bit 加上 1000，求和结果保存到 a4&lt;/span&gt;
&lt;span class="nf"&gt;sltu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 计算进位，如果和 a4 比加数 a2 小，说明有进位，进位保存在 a2 中&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 把进位加到 mtimecmp 的高位 a3 上&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 保存递增后的 mtimecmp 高位&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 保存递增后的 mtimecmp 低位&lt;/span&gt;

&lt;span class="c1"&gt;# step4. 恢复 XRF, a1, a2, a3, a4&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# step5. 恢复 a0 和 mscratch 旧值&lt;/span&gt;
&lt;span class="nf"&gt;csrrw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mscratch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;

&lt;span class="c1"&gt;# step6. 从 ISR 返回&lt;/span&gt;
&lt;span class="nf"&gt;mret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_20"&gt;嵌入式系统中的用户模式和进程隔离&lt;/h3&gt;
&lt;p&gt;并非所有代码都是可信任的：底层 OS 代码可行度较高，可以访问所有硬件资源；应用程序代码可行度较低，需要进行限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制 U 模式代码可执行的指令（M 模式指令）和访问的资源（M 模式 CSR）&lt;/li&gt;
&lt;li&gt;限制 U 模式代码只能访问各自的内存，即 PMP（指定哪些内存可以让 U 模式访问）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_21"&gt;现代操作系统的监管模式&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id="_22"&gt;页式虚拟内存&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id="_23"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一项又一项的研究表明，最优秀的设计师能更轻松地设计出更快、更小、更简洁、更明了的结构。伟大和平凡之间相差近一个数量级。&lt;/p&gt;
&lt;p&gt;—— 弗雷德 · 布鲁克斯（Fred Brooks, Jr.）, 1986.&amp;gt; 一款指令集的 7 个评价标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本&lt;/li&gt;
&lt;li&gt;简洁&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;架构和实现分离&lt;/li&gt;
&lt;li&gt;提升空间&lt;/li&gt;
&lt;li&gt;代码大小&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;围绕这 7 个评价指标从全系统角度向读者介绍 RISC-V 的精巧设计和众多的取舍考量。&lt;/p&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>RISC-V Spec 阅读笔记 #2 —— Privileged ISA</title><link href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-2-privileged.html" rel="alternate"></link><published>2021-03-25T17:29:00+08:00</published><updated>2021-03-25T17:29:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-03-25:/posts/risc-v/risc-v-spec-notes-2-privileged.html</id><summary type="html">&lt;p&gt;Volume II: Privileged ISA 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#software-stack-terminology"&gt;Software Stack Terminology&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#privilege-levels"&gt;Privilege Levels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debug-mode"&gt;Debug Mode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#control-and-status-registers-csrs"&gt;Control and Status Registers (CSRs)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#address-mapping-conventions"&gt;Address Mapping Conventions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#csr-listing"&gt;CSR Listing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#field-specifications"&gt;Field Specifications&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#wpri"&gt;WPRI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#wlrl"&gt;WLRL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#warl"&gt;WARL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#csr-width-modulation"&gt;CSR Width Modulation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#machine-level-isa"&gt;Machine-Level ISA&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#machine-level-csrs"&gt;Machine-Level CSRs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#machine-mode-privileged-instructions"&gt;Machine-Mode Privileged Instructions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reset"&gt;Reset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nmi"&gt;NMI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pma"&gt;PMA&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#main-memory-io-empty"&gt;Main memory / IO / empty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#supported-access-type"&gt;Supported Access Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#atomicity"&gt;Atomicity&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#amo"&gt;AMO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reservability-pma"&gt;Reservability PMA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#alignment"&gt;Alignment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#memory-ording-pmas"&gt;Memory Ording PMAs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#coherenece-and-cacheability"&gt;Coherenece and Cacheability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#idempotency"&gt;Idempotency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#pmp"&gt;PMP&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pmp-csrs"&gt;PMP CSRs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pmpcfg"&gt;pmpcfg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pmpaddr"&gt;pmpaddr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#address-matching"&gt;address matching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#locking"&gt;locking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#priority-and-matching"&gt;priority and matching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#paging"&gt;Paging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#supervisor-level-isa"&gt;Supervisor-Level ISA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Privileged ISA 文档的版本号 :20190608-Priv-MSU-Ratified&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Unprivileged 的补集，包含了运行操作系统和支持外设所需要的特权指令、额外功能。&lt;/p&gt;
&lt;h3 id="software-stack-terminology"&gt;Software Stack Terminology&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ABI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Application Binary Interface, ABI = user-level ISA + ABI calls to AEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SBI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Supervisor Binary Interface, SBI = user-level + supervisor-level ISA + SBI calls to SEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HBI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hypervisor Binary Interface, HBI = user-level ISA + HBI calls to HEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;AEE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Application Execution Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HEE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hypervisor Execution Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;观察 spec 中的示意图，可以发现整个 stack 的结构本质上就是不断套娃的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最简单是 “ 裸机系统 ”&lt;/p&gt;
&lt;p&gt;ABI 作为中间抽象借口，隐藏了底层 AEE 的实现细节，对上面的 Application 提供了一个标准抽象借口，这样上层的 Application 就不需要再关心底层实现，这样 AEE 的实现可以更灵活，可以直接用 RISC-V 硬件实现，也可以是一个运行在其他架构机器上的模拟器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套第一层娃，支持单操作系统&lt;/p&gt;
&lt;p&gt;在 ABI 和 AEE 之间插入一层 OS，Application 和 OS 之间通过 ABI 交互，OS 和 SEE 之间通过 SBI 交互。同理，SEE 的实现也可以是真实的硬件，也可以是 hypervisor 提供的虚拟机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套第二层娃，虚拟机支持多操作系统&lt;/p&gt;
&lt;p&gt;在 OS 和 SEE 之间再插入新的一层 hypervisor，每个 OS 通过 SBI 和 hypervisor 交互，hypervisor 通过 HBI 和底层的 HEE 交互。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个 stack 的核心思想可以总结为：&lt;strong&gt;通过抽象的 Interface 对上层提供统一标准借口，隔离底层细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RISC-V 的硬件不仅要实现 Privileged ISA，还要包含一些其他功能才能完整支持各种执行环境（AEE、SEE、HEE）。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;大部分的 supervisor-level ISA 在定义的时候，都没有把 SBI 从 execution environment 或者是硬件平台中分离出来，这样会导致虚拟化和开发新硬件平台时变得更复杂。&lt;/p&gt;
&lt;p&gt;目前 RISC-V 的 ABI、SBI、HBI 都还在定义中。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="privilege-levels"&gt;Privilege Levels&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;User/Application&lt;/td&gt;
&lt;td&gt;&lt;code&gt;U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;Supervisor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;-Reserved-&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Machine&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一共定义了 3 个特权层次，其中 M 是强制要求所有实现都必须支持的，M 的层次最高，它可以不受限制地访问底层的完整硬件资源，一般最简实现只支持 M 即可。U 模式是为了支持传统的 Application，S 模式则是为了支持 OS。&lt;/p&gt;
&lt;p&gt;每个 level 都会有一组核心 Privileged ISA，再附加一些可选的扩展指令和变种指令。任何一个实现可以根据资源和目标折中选择支持 3 种 level 的组合。这些 level 是通过 CSR 来定义的，任何一个 hart 任何时候必然处于 3 种 level 中的某一种。&lt;/p&gt;
&lt;p&gt;允许的组合：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别数量&lt;/th&gt;
&lt;th&gt;支持的模式&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;简单嵌入式系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;M, U&lt;/td&gt;
&lt;td&gt;带安全功能的嵌入式系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;M, S, U&lt;/td&gt;
&lt;td&gt;运行 Unix-like 的操作系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="debug-mode"&gt;Debug Mode&lt;/h3&gt;
&lt;p&gt;Debug 可以看做是一个比 M 模式级别更高的特权模式，可能会有一些专用的 CSR 和地址空间。RISC-V 的 debug 模式定义在另外一个标准文档中。&lt;/p&gt;
&lt;h2 id="control-and-status-registers-csrs"&gt;Control and Status Registers (CSRs)&lt;/h2&gt;
&lt;p&gt;RISC-V 中的 opcode &lt;code&gt;SYSTEM&lt;/code&gt; 用来编码所有的特权指令，这些指令可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zicsr&lt;/code&gt; 子集中定义的 atomically read-modify-write CSR 的指令 ( 即 CSR 指令 )&lt;/li&gt;
&lt;li&gt;其他 privileged 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 Unprivileged ISA 中描述的 CSR 之外，implementation 还可以包含一些其他 CSR，这些 CSR 在某些特权级别下可以通过 &lt;code&gt;Zicsr&lt;/code&gt; 中的指令进行访问。虽然 CSR 和特权指令都绑定了某个特权等级，但是也可以被更高等级访问。&lt;/p&gt;
&lt;h3 id="address-mapping-conventions"&gt;Address Mapping Conventions&lt;/h3&gt;
&lt;p&gt;CSR 的编址使用独立的 12bit 空间，所以理论上最多可以编码 4096 个 CSR。一般的惯例是，最高的 4bit 用来编码 CSR 的读写属性，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;csr[11:10]&lt;/code&gt; 表示 CSR 的读写属性，00/01/10 = read/write，11=read-only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;csr[9:8]&lt;/code&gt; 表示可以访问该 CSR 的最低特权等级，00 = User，01 = Supervisor，10 = Hypervisor，11 = Machine&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 使用高位 bit 来表示访问的最低权限，这种方法可以简化硬件检错电路，提供更大的 CSR 地址空间。但是这种方法确实会约束 CSR 的地址映射。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;出现下列情况，会抛出一个 illegal instruction exception：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问一个不存在的 CSR&lt;/li&gt;
&lt;li&gt;访问的特权等级不够高&lt;/li&gt;
&lt;li&gt;对一个 RO 类型的 CSR 进行写操作（一个 R/W 类型的 CSR 的某些字段可能是 RO 类型，对这些字段的写操作应该被忽略掉。）&lt;/li&gt;
&lt;li&gt;M 模式下访问 debug CSR 地址段的 CSR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;spec 还对 standard 和 custom CSR 地址做了区间划分，custom 区间作为保留地址段，在未来也不会被重定义。&lt;/p&gt;
&lt;p&gt;M-mode 的 0x7A0~0x7BF 地址段留作 debug 用，其中 0x7A0~0x7AF 可以在 M-mode 下访问，剩余的 0x7B0~0x7BF 只能在 debug mode 下访问。如果在 M-mode 下访问后面这段地址，implementation 应该触发 illegal instruction exception。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;高效虚拟化要求在虚拟环境中尽可能多地以 native 方式执行指令，而特权访问则 trap 到 virtual machine monitor 中。有些 CSR 在低特权等级下为 RO 属性，但是在高特权等级下为 RW 属性，这种 CSR 会被 shadowed 到另外一个新的 CSR 地址。这样就可以在正常 tarp 非法访问的同时， 避免错误 trap 本来运行的低特权访问。目前 counter 类 CSR 是唯一被 shadow 的 CSR。
比如 hpmcounter3~hpmcounter31 的属性分别为 URO 和 MRW，且在 U-level 和 M-level 分别有映射地址。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="csr-listing"&gt;CSR Listing&lt;/h3&gt;
&lt;p&gt;所有的 CSR 可以分类两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user-level standard CSR：包括 timer、counter、FP CSR 和 N 子集添加的 CSR。&lt;/li&gt;
&lt;li&gt;Privileged CSR：剩余的 CSR 都必须在某个更高的特权等级下才能访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是：并不是所有的 implementation 都要实现所有的 CSR。&lt;/p&gt;
&lt;h3 id="field-specifications"&gt;Field Specifications&lt;/h3&gt;
&lt;h4 id="wpri"&gt;WPRI&lt;/h4&gt;
&lt;p&gt;Reserved Writes Preserve Values, Reads Ignore Values&lt;/p&gt;
&lt;p&gt;某些 R/W field 留作未来使用。对于这些 field，软件应该忽略读到的值，向这个 CSR 的其他 field 写入值时，硬件应该保持 reserved field 的原值。为了前向兼容，未实现这些 reserved field 的 implementation 应该直接 tie0。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;为了简化软件模型，reserved field 在未来进行向后兼容的重新定义时，必须处理好使用一组非原子性 read/modify/write 指令序列来更新其他字段的场景。否则，原始的 CSR 定义必须声明该 field 只能原子性地更新，比如通过两条 set/clear 指令组成的序列。如果修改过程中的中间值不合法，则可能会有潜在的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="wlrl"&gt;WLRL&lt;/h4&gt;
&lt;p&gt;Write/Read Only Legal Values&lt;/p&gt;
&lt;p&gt;某些 R/W filed 只能配置一些 legal value，其他值作为保留不能使用。软件只能向这些 filed 写入 legal value，而且除非该 field 本身就存储着 legal value（比如上次写入 / 复位等），否则软件也读不到 legal value。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;implementation 只需要有足够的 bit 能表示所有的 legal value 即可，但是软件读取时必须返回完整的所有 bit。比如某个字段的 legal value 为 0~8，共需要 4-bit 表示，表示范围内的 9 ~ 15 为 illegal value。软件读取时，即使当前值为 7，只需要 3bit，硬件仍然要返回完整的 4bit。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当写入 illegal value 时，implementation 可以（但不是强制）触发一个 illegal instruction exception。当写入 illegal value 后，软件读取的值由硬件决定，可以是任意一个值，但是必须满足确定性原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确定性原理：旧值和写入的新非法值确定，返回值也必须是确定性的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="warl"&gt;WARL&lt;/h4&gt;
&lt;p&gt;Write Any Values, Reads Legal Values&lt;/p&gt;
&lt;p&gt;某些 R/W field 只支持一组 legal value，但是允许写入任何值。当写入 illegal value 后，软件读回的一定是 legal value。假设写该 field 没有其他副作用，则可以向其中逐个写入配置值后再重新读出，通过这种方法就能知道支持的 legal value 集合。&lt;/p&gt;
&lt;p&gt;当写入 illegal value 时，implementation 不会触发 exception。写入 illegal value 后，软件会读到一个任意 legal value。同理，该 legal value 必须满足确定性原理。&lt;/p&gt;
&lt;h3 id="csr-width-modulation"&gt;CSR Width Modulation&lt;/h3&gt;
&lt;p&gt;当 CSR 的位宽发生变化时（比如修改 MXLEN 或 UXLEN），CSR 的新位宽和 writable field 的值由以下算法决定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;previous-width CSR 的 value 被复制到一个相同位宽的临时寄存器中。&lt;/li&gt;
&lt;li&gt;对于 previous-width CSR 的 RO bit，临时寄存器的对应 bit 设置为 0。&lt;/li&gt;
&lt;li&gt;将临时寄存器的位宽修改为 new width。&lt;ul&gt;
&lt;li&gt;如果 new-width &lt;span class="math"&gt;\(W\)&lt;/span&gt; &amp;lt; previous-width，则只保留临时寄存器的低 W bit。&lt;/li&gt;
&lt;li&gt;如果 new-width &lt;span class="math"&gt;\(W\)&lt;/span&gt; &amp;gt; previous-width，则将临时寄存器 0 扩展到 W bit。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;new-width CSR 的每个 writable field 等于临时寄存器的对应 bit 的 value。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改 CSR 位宽不属于 read/write CSR，所以不会产生任何 side effect。&lt;/p&gt;
&lt;h2 id="machine-level-isa"&gt;Machine-Level ISA&lt;/h2&gt;
&lt;p&gt;TODO: here&lt;/p&gt;
&lt;p&gt;M-mode 的特权等级最高，而且是唯一强制要求实现模式，它用于访问底层硬件，是上电复位后进入的第一个模式。M-mode 包含一个可扩展的核心 ISA，具体实现可以根据支持的特权等级和自身的硬件特性来扩展它。&lt;/p&gt;
&lt;h3 id="machine-level-csrs"&gt;Machine-Level CSRs&lt;/h3&gt;
&lt;p&gt;略。&lt;/p&gt;
&lt;h3 id="machine-mode-privileged-instructions"&gt;Machine-Mode Privileged Instructions&lt;/h3&gt;
&lt;p&gt;一共 6 条，可以分成 3 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统调用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ECALL&lt;/code&gt;, &lt;code&gt;EBREAK&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trap 返回&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MRET&lt;/code&gt;, &lt;code&gt;SRET&lt;/code&gt;, &lt;code&gt;URET&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WFI&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WFI&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="reset"&gt;Reset&lt;/h3&gt;
&lt;p&gt;一旦复位，要满足下面要求，除此之外的状态不做要求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hart 必须处于 M-mode，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus&lt;/code&gt; 的 &lt;code&gt;MIE&lt;/code&gt; 和 &lt;code&gt;MPRV&lt;/code&gt; 字段要复位成 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;misa&lt;/code&gt; 字段要复位到支持的最大子集和最宽的 &lt;code&gt;MXLEN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pc&lt;/code&gt; 要复位到实现预先定义好的 reset vector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mcause&lt;/code&gt; 要保存导致复位的原因&lt;/li&gt;
&lt;li&gt;PMP 的 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 字段设置为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="nmi"&gt;NMI&lt;/h3&gt;
&lt;p&gt;Non-Maskable Interrupts 的作用是发生硬件错误时，不管中断使能是否打开，直接跳转到预先定义好的 NMI vector，在 M-mode 下运行。&lt;code&gt;mepc&lt;/code&gt; 保存发生 NMI 的下一条指令；&lt;code&gt;mcause&lt;/code&gt; 保存导致 NMI 的原因，具体值由实现自定义，但是 0 表示 unknown，所以如果实现不关心 NMI 的原因，那么直接保存 0 即可。&lt;/p&gt;
&lt;h3 id="pma"&gt;PMA&lt;/h3&gt;
&lt;p&gt;一个完整系统中的地址空间包含了各种各样的 address region，有些是 memory，有些是 memory-mapped 的 CSR，还有些是空洞 hole；有些 memory region 不支持读 / 写 / 执行，有些不支持 subword/sublock 粒度的访问；有些不支持原子性操作；有些不支持 cache coherence 或拥有不同的 memory model。同理，memory mapped 的 CSR 在访问位宽、原子操作、read/write 访问是否有副作用等方面也各不相同。在 RISC-V 系统中，物理地址 region 的这些属性有一个专门的术语 &lt;code&gt;Physical Memory Attributes (PMAs)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PMA 是硬件的固有属性，在系统运行时几乎不会变化。&lt;/strong&gt; 和 PMP 不同，PMA 不会随着运行程序的上下文发生变化。有些 memory region 的 PMA 属性在 chip design 时就已经确定了，比如片上 ROM。另外一些在 board design 时确定，比如片外总线上挂载的是什么芯片。片外总线上可以挂载一些支持冷 / 热拔插的设备。某些设备可以在运行时支持重配置 PMA 以支持不同的用途，比如一个片上 RAM 在某个应用在中被缓存到私有 cache 中，也可以在另外一个应用中被配置为共享的 uncacheable 空间。&lt;/p&gt;
&lt;p&gt;大部分系统都要求硬件在一旦确定物理地址之后，在后续 pipeline stage 中做一些必要的 PMA 检查，因为有些特定操作并不是所有 region 都支持，或者有些操作需要获取 PMA 当前的配置值。虽然某些架构是在 virtual page 中声明 PMA，然后通过 TLB 来告诉 pipeline 这些信息，但是这个方法会将一些 platform 信息注入到 virtual layer，而且一旦某个 page table 中某个 memory region 没有被正确初始化，就会导致系统错误。另外，可用的 page size 对于设置 PMA 来说可能并不是最优选择，这会导致地址空间碎片以及浪费宝贵的 TLB entry。&lt;/p&gt;
&lt;p&gt;RISC-V 则把 PMA 分离出来，并且用一个独立的硬件 PMA checker 进行检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分情况下，每个 region 的 PMA 是在系统设计时就已经确定了的，所以可以直接在 PMA checker 中以硬连线的方式实现。&lt;/li&gt;
&lt;li&gt;对于 runtime 可配置的 PMA，则可以通过一些 memory mapped CSR 对每个 region 以合适的粒度进行配置（比如片上 SRAM 可以灵活地划分为 cacheable 和 uncacheable 区域）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包括虚实地址转化引起的隐式访问在内，任何访问物理地址的行为都会触发 PMA 检查。为了帮助系统 debug，规范强烈建议：&lt;strong&gt;尽可能精确地捕获导致 PMA 检查失败的物理地址访问。&lt;/strong&gt; 精确的 PMA 违例包括 instruction/load/store access-fault exception 以及虚拟内存的 page fault。实际中并不能一直捕获到精确异常，比如探测某些以访问失败作为发现机制的一部分的 legacy bus 时，从 slave device 返回的 error response 是非精确异常。&lt;/p&gt;
&lt;p&gt;为了正确地访问设备或者是控制其他硬件单元（比如 DMA）去访问 memory，PMA 对软件来说必须是可读的。因为 PMA 和硬件平台的设计紧密相关，很多 PMA 来自平台规格，所以软件可以通过访问平台信息的方式来获取 PMA 信息。某些 device，特别是 legacy bus，不支持通过探索尝试的方式获取 PMA，如果对其发起一个不支持的访问，则会返回 error response 或 timeout。通常，平台相关的 machine code 会提取这些 PMA 信息并通过某种标准表示方式将其转发给上层特权等级更低的软件。 &lt;/p&gt;
&lt;p&gt;对于 platform 支持的可配置 PMA，应该提供一个接口，通过该接口向运行在 machine mode 的 driver 发送配置请求，由 driver 进行正确的配置。比如，切换某些 memory region 的 cacheability 可能会涉及到一些 platform 相关的操作，比如只能在 machine mode 下进行的 cache flush。&lt;/p&gt;
&lt;p&gt;常见的 PMA 大概包含下面几方面。&lt;/p&gt;
&lt;h4 id="main-memory-io-empty"&gt;Main memory / IO / empty&lt;/h4&gt;
&lt;p&gt;对于一个 memory region 来说，最重要的属性就是它映射的是常规 main memory 还是 I/O 设备或空洞。main memory 拥有一些后文描述的属性，而 I/O 设备的属性会更广泛一些。非 main memory 的 memory，比如 device scratchpad RAM，被归类为 I/O 段。空地址段会被归类不支持任何访问的 I/O 空间。&lt;/p&gt;
&lt;h4 id="supported-access-type"&gt;Supported Access Type&lt;/h4&gt;
&lt;p&gt;描述 region 支持从 8bit Byte 到 long multi-word burst 之间的哪些访问位宽，以及每种访问位宽是否支持非对齐访问。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;虽然运行在 RISC-V hart 上的软件不能直接生成对 memory 的 burst 访问，但是软件可以对 DMA 进行编程来访问 I/O 设备，所以需要知道支持哪些位宽访问。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;main memory 永远都支持所有 device 要求的所有 width 下的 read/write 操作，同时可以声明是否支持 instruction fetch。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;某些平台可能会强制要求所有 main memory 都支持 instruction fetch，而某些平台可能会禁止在某些 main memory region 进行 instruction fetch。&lt;/li&gt;
&lt;li&gt;在某些 case 中，processor/device 可能支持一些其他访问位宽，但是必须兼容 main memory 支持的访问类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;I/O region 可以指定每种位宽支持的 R/W/X 组合。&lt;/p&gt;
&lt;p&gt;对于基于 page 的 virtual memory，I/O 和 memory region 可以指定支持哪些 hardware page table read/write 组合。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;类 unix 系统通常要求所有 cacheable main memory 都支持 page table walk。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="atomicity"&gt;Atomicity&lt;/h4&gt;
&lt;p&gt;Atomicity PMA 描述 region 支持哪些原子指令，原子指令可以分为 LR/SC 和 AMO 两类。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;某些平台可能强制要求 cacheable main memory 必须支持系统中所有 processor 的所有原子指令。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="amo"&gt;AMO&lt;/h5&gt;
&lt;p&gt;AMO 的支持可以分为&lt;code&gt;AMONone&lt;/code&gt;，&lt;code&gt;AMOSwap&lt;/code&gt;，&lt;code&gt;AMOLogical&lt;/code&gt;，&lt;code&gt;AMOArithmetic&lt;/code&gt; 共 4 个等级，main memory 和 I/O 可能支持部分子集或完全不支持 AMO 操作。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;spec 推荐 I/O region 尽可能支持 AMOLogical。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="reservability-pma"&gt;Reservability PMA&lt;/h5&gt;
&lt;p&gt;对 LR/SC 访问的支持可以分为 &lt;code&gt;RsrvNone&lt;/code&gt;，&lt;code&gt;RsrvNonEventual&lt;/code&gt;，&lt;code&gt;RsrvEventual&lt;/code&gt; 共 3 个等级。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spec 推荐 main memory region 尽可能支持 &lt;code&gt;RsrvEventual&lt;/code&gt;。大部分 I/O region 不支持 LR/SC 访问，因为这些访问最方便建构在 cache-coherence 方案之上，但是有些可能支持 &lt;code&gt;RsrvEventual&lt;/code&gt; 或 &lt;code&gt;RsrvNonEventual&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;当 LR/SC 访问 &lt;code&gt;RsrvNonEventual&lt;/code&gt; 的 memory region 时，当软件检测到无法访问时，软件应该提供备选的 fall-back 机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h5 id="alignment"&gt;Alignment&lt;/h5&gt;
&lt;p&gt;支持 aligned LR/SC 和 aligned AMO 访问的 memory region 可能还支持 misaligned LR/SC 和 misaligned AMO 以某些位宽访问某些地址。如果 misaligned LR/SC 或 AMO 以某种位宽访问某个地址时触发了 address-misaligned exception，那么所有以该位宽访问该地址的 load，store，LR/SC 和 AMO 访问都应该触发 address-misaligned exception。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;A 子集不支持非对齐的 LR/SC 和 AMO 访问。非对齐 AMO 访问由 &lt;code&gt;Zam&lt;/code&gt; 子集提供，非对齐的 LR/SC 访问目前还没有标准化，所以非对齐的 LR/SC 访问必须触发 exception。&lt;/p&gt;
&lt;p&gt;当非对齐的 AMO 触发 address-misaligned exception 时，强制要求非对齐的 load，store 也触发 address-misaligned exception，这样就可以模拟 M-mode trap handler 中的 misaligned AMO 访问。该 handler 使用 global mutex，在 critical section 模拟该访问，以这样的方式保证原子性。当非对齐 load/store 的 handler 使用同一个 mutex 时，以该位宽访问该地址的所有访问都是 mutually atomic。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于某些非对齐访问，implementation 可以通过触发 access-fault exception 的方式表明不应该在 trap handler 中模拟该行为。当以某种位宽访问某个地址时，如果所有 misaligned AMO 和 LR/SC 都触发了 access-fault exception，那么以该位宽访问该地址的所有常规非对齐 load/store 则不要求原子性执行。&lt;/p&gt;
&lt;h4 id="memory-ording-pmas"&gt;Memory Ording PMAs&lt;/h4&gt;
&lt;p&gt;为了实现 FENCE 指令和原子指令 order bit 提供的 order 功能，地址空间被分为 main memory 和 I/O 两类。&lt;/p&gt;
&lt;p&gt;一个 hart 对 main memory region 的访问不仅能被其他 hart 观测到，也会被其他能对 main memory 发起访问的 device（比如 DMA）观测到。coherent main memory 的 memory model 要么是 RVWMO 要么是 RVTSO，incoherent main memory region 的 memory model 由 implementation 决定。&lt;/p&gt;
&lt;p&gt;一个 hart 对 I/O region 的访问不仅能被其他 hart 和 bus master device 观测到，也会被目标 I/O slave
device 观测到。I/O region 的访问要么是 relax order 要么是 strong order：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 relax order 访问 I/O region，其他 hart 和 master device 观测到的行为和以 RVWMO 访问 main memory region 类似。&lt;/li&gt;
&lt;li&gt;以 strong order 访问 I/O region，其他 hart 和 master device 观测到的为 program order。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="coherenece-and-cacheability"&gt;Coherenece and Cacheability&lt;/h4&gt;
&lt;p&gt;coherenece 是针对单个物理地址而言的属性，表示某个 agent 对该地址的 write 对系统中的其他 agent 都可见。注意，不要把 coherence 和 memory consistency model 混淆，内存一致性模型规定给定某个地址的历史读写信息后，读该地址的返回值应该是什么。RISC-V 中不鼓励使用 hardware incoherent region，因为它会导致软件复杂化，性能和功耗恶化。&lt;/p&gt;
&lt;p&gt;一个地址段的 cacheability 属性不会改变软件对该地址段的 view，这些 view 不包括其他 PMA 中规定的属性（比如 main memory 和 I/O 空间的划分、访问顺序、支持的访问类型、支持的原子操作、coherence 等）。因此，cacheability 在指令集中被视为 M-mode 软件管理的 platform level setting。&lt;/p&gt;
&lt;p&gt;当一个 platform 支持对某个 memory region 配置 cacheability 时，一个和 platform 相关的 M-mode routine 负责修改配置，并在必要时 flush cache。因此，只有在 cacheability 的变换的这段时间内系统为 incoherent，这种中间的变化状态不应该对 S/U mode 可见。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;指令集将 cache 分为了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master private：每个 master 私有&lt;/li&gt;
&lt;li&gt;master shared：位于 master 和 slave 之间，可能有多级&lt;/li&gt;
&lt;li&gt;slave private：由 slave 私有，对 coherence 无影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于不支持 cache 的 share memory region 来说，coherence 很直观，PMA 只需要表明该 region 不支持被 private 或 shared cache。&lt;/p&gt;
&lt;p&gt;对于 read-only 的 memory region 来说，coherence 也很直观，无需 coherence 机制就可以被多个 agent 安全地多次 cache。PMA 只需要表明该 region 只支持 read，不支持 write 即可。&lt;/p&gt;
&lt;p&gt;有些 read-write memory region 可能只支持一个 agent 访问，这种场景下无需 coherence 机制就可以被 master private cache。PMA 会表明该 region 可以被 cache，而且可以被 cache 在一个 shared cache 中，因为其他 agent 不会访问该 region。&lt;/p&gt;
&lt;p&gt;如果一个 agent 可以 cache 一个 read-write region，且该 region 也可以被其他 agent 访问（无论是否为 cache 或 no cache），都需要一套 cache-coherence 机制。如果没有 hardware cache coherence，则必须提供 software cohere scheme，但是通常软件实现都比较困难且存在严重的性能问题。hardware coherence scheme 通常需要更复杂的硬件，也会影响到性能，但是对软件是不可见的。&lt;/p&gt;
&lt;p&gt;对于每个支持 hardware coherence 的 region 来说，PMA 应该表明该 region 支持 coherence 且当系统中 coherence controller 有多个时，PMA 要指明该 region 使用哪个 controller。对于某些系统来说，controller 是下一级 cache，而该级 cache 的 coherence 又依赖于下下级 cache。&lt;/p&gt;
&lt;p&gt;platform 中的大部分 memory region 对软件来说都是 coherent 的，因为这些 region 的 PMA 属性都是固定的，要么 uncached，要么 read-only，要么 hardware cache-coherent，要么只能由一个 agent 访问。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果 PMA 表明该 region 不支持 cache，则对该 memory region 的访问必须由 memory 自身来满足，不能依靠任何 cache。&lt;/p&gt;
&lt;h4 id="idempotency"&gt;Idempotency&lt;/h4&gt;
&lt;p&gt;幂等性 idempotency：执行多次和一次的效果一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main memory region 是 idempotent。&lt;/li&gt;
&lt;li&gt;I/O region 的 read/write idempotent 是分开的：read 具有幂等性，而 write 不具有。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果访问不具有幂等性，也就是说会产生潜在的副作用，那么必须避免 speculative 或 redundant 访问（因为他们都可能会导致多次访问）。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;虽然 hardware 会对 non-idempotent region 避免 speculative 或 redundant 访问，但是还是有必要确保软件或编译优化不会对 non-idempotent region 生成投机访问。&lt;/p&gt;
&lt;p&gt;non-idempotent region 可能不支持非对齐访问。非对齐访问应该触发 access-fault exception 而不是 address-misaligned exception，以此来表明软件不应该通过拆分成多次小颗粒的访问来模拟非对齐访问，因为这种行为会引起预期之外的副作用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于 non-idempotent region 来说，不允许 implementat 提前或投机地进行 implicit
read/write，除非是以下特例。&lt;/p&gt;
&lt;p&gt;当进行非投机的 implicit read 时，允许 implementation 额外从包含本次 implicit read 地址的 NAPOT region 中读取任意长度的数据量。而且如果是 instruction fetcch，允许 implementat 额外从下一个 NAPOT region 中读取任意 byte 数据量。这些额外的读数据可以作为后续的提前或投机访问的结果。这些 NAPOT region 的大小由 implementation 决定，但是必须不超过支持的最小 page size。&lt;/p&gt;
&lt;h3 id="pmp"&gt;PMP&lt;/h3&gt;
&lt;p&gt;为了安全运行以及故障隔离，需要限制 hart 上运行的软件可以访问的物理地址，这个需求可以通过一个可选的 &lt;code&gt;Physical Memory Protection (PMP)&lt;/code&gt; 单元实现，它可以为每个 hart 提供每个 memory region 的访问属性控制寄存器。PMP 和 PMA 是并列关系，同步进行检查。&lt;/p&gt;
&lt;p&gt;虽然 PMP 的访问粒度是和平台相关的，但是标准的 PMP 编码支持的最小 region 大小为 4 Byte。某些 region 的特权属性可以直接用 hardwire 实现，比如某些 region 只有 M-mode 下可访问。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;不同平台对 PMP 的需求不同，有些平台还会额外提供其他的 PMP 指令来增强 / 代替本小节描述的方案。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当 core 运行在 S/U-mode 时，PMP checker 会检查所有的访问，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S/U-mode 下的取指&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus.MPRV = 0&lt;/code&gt; 时 S/U-mode 下的数据访存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus.MPRV = 1&lt;/code&gt; 且 &lt;code&gt;mstatus.MPP&lt;/code&gt; 包含 S/U 时任何 mode 下的数据访存&lt;/li&gt;
&lt;li&gt;S-mode 下的虚拟地址翻译时对 page table 的访问&lt;/li&gt;
&lt;li&gt;( 可选地 ) M-mode 下且 locked region 的访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，PMP 设置 S/U-mode 下的访问权限（默认无权限），在 M-mode 默认有所有地址的权限。&lt;/p&gt;
&lt;p&gt;违反 PMP 的访问会被 core 捕获，触发精确异常。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;PMP 主要检查的是 S-mode 和 U-mode，因为用户程序运行在这两个级别中。而 M-mode 下 core 必须拥有全部的访问权限，所以 M-mode 不是 PMP 的主要应用场景。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="pmp-csrs"&gt;PMP CSRs&lt;/h4&gt;
&lt;p&gt;spec 规定最多支持 16 个 PMP region，每个 region 由一个 8-bit 配置寄存器 &lt;code&gt;pmpxcfg&lt;/code&gt; + 一个 MXLEN-bit 的地址寄存器 &lt;code&gt;pmpaddrx&lt;/code&gt; 共同描述。所有 PMP CSR 均为 WARL，且只能在 M-mode 下访问。&lt;/p&gt;
&lt;h5 id="pmpcfg"&gt;pmpcfg&lt;/h5&gt;
&lt;p&gt;为了最小化上下文切换的代价，&lt;code&gt;pmpxcfg&lt;/code&gt; 是按照小端模式密集存储在一起的。所以可以算出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32 需要 4 个 CSR (&lt;code&gt;pmpcfg0&lt;/code&gt; ~ &lt;code&gt;pmpcfg3&lt;/code&gt;) 来存储 &lt;code&gt;pmp0cfg&lt;/code&gt; ~ &lt;code&gt;pmp15cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RV64 需要 2 个偶数下标 CSR &lt;code&gt;pmpcfg0&lt;/code&gt;, &lt;code&gt;pmpcfg2&lt;/code&gt; 来存储 &lt;code&gt;pmp0cfg&lt;/code&gt; ~ &lt;code&gt;pmp15cfg&lt;/code&gt;，奇数下标 &lt;code&gt;pmpcfg1&lt;/code&gt;, &lt;code&gt;pmpcfg3&lt;/code&gt; 是非法的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;RV64 不使用奇数下标 pmpcfg 的原因：减小支持多种 MXLEN 的代价。比如，无论是 RV32 还是 RV64，PMP entry 8~11 都在 pmpcfg2 中。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;每个 8bit 的 &lt;code&gt;pmpxcfg&lt;/code&gt; 规定了对应 region 的 L/A/X/W/R 五个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 W/R/X 被置 1 时，表示该 region 允许 write/read/instruction execution。当无权限时，触发对应的 store/load/instruction access fault。&lt;/li&gt;
&lt;li&gt;A 字段表示 &lt;code&gt;pmpaddrx&lt;/code&gt; 的地址匹配模式，支持 OFF/TOR/NA4/NAPOT 共 4 种模式。&lt;/li&gt;
&lt;li&gt;L 字段表示该 region 被 lock，无法向 &lt;code&gt;pmpxcfg&lt;/code&gt; 和 &lt;code&gt;pmpaddrx&lt;/code&gt; 写入新值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 MXLEN 发生变化时，&lt;code&gt;pmpxcfg&lt;/code&gt; 的值保留不变，但是出现在对应的 &lt;code&gt;pmpcfgy&lt;/code&gt; 的对应 bit 中。比如当 MXLEN 从 64 变化到 32 时，&lt;code&gt;pmp4cfg&lt;/code&gt; 从 &lt;code&gt;pmpcfg0[39:32]&lt;/code&gt; 移动到 &lt;code&gt;pmpcfg1[7:0]&lt;/code&gt;。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;implementation 可以实现 &lt;code&gt;pmpxcfg&lt;/code&gt; 寄存器，然后根据 MXLEN 用多个 &lt;code&gt;pmpxcfg&lt;/code&gt; 组合得到 &lt;code&gt;pmpcfgy&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="pmpaddr"&gt;pmpaddr&lt;/h5&gt;
&lt;p&gt;PMP 地址寄存器为 CSR &lt;code&gt;pmpaddr0&lt;/code&gt; ~ &lt;code&gt;pmpaddr63&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32：每个 pmpaddr 保存 addr[33:2]，即 34bit 地址&lt;/li&gt;
&lt;li&gt;RV64：每个 pmpaddr 保存 addr[55:2]，即 56bit 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 PMP region 颗粒度可能大于 4 Byte，所以并不是 pmpaddr 的每个 bit 都会被实现，所以 pmpaddr 为 WARL。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;因为 Sv32 page-based 虚拟地址方案支持 34bit 地址空间，所以 RV32 PMP 要支持比 XLEN 更大的地址区间。同理，Sv39 和 Sv48 page-based 虚拟地址方案支持 56bit 地址空间，所以 RV64 PMP 需要覆盖相同地址范围。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虽然 PMP region 的最小粒度为 4 Byte，但是 platform 可以定义更粗的颗粒度。一般来说，PMP region 的颗粒度必须保持一致，为 &lt;span class="math"&gt;\(2^{G+2}\)&lt;/span&gt; Byte。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class="math"&gt;\(G \geq 1\)&lt;/span&gt; 时，NA4 模式不可用&lt;/li&gt;
&lt;li&gt;当 &lt;span class="math"&gt;\(G \geq 2\)&lt;/span&gt; 且 pmpcfg.A[1] = 1 时，为 NAPOT 模式，读出的 pmpaddr[G-2:0] 为全 1。&lt;/li&gt;
&lt;li&gt;当 &lt;span class="math"&gt;\(G \geq 1\)&lt;/span&gt; 且 pmpcfg.A[1] = 0 时，为 OFF/TOR 模式，读出的 pmpaddr[G-1:0] 为全 0。pmpaddr[G-1:0] 并不会影响到 TOR 下的地址匹配逻辑。（从这条规则可以推理出下面软件检测 PMP region 粒度的方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;颗粒度 != 容量，所有 region 的颗粒度必须相同，但是大小可以不同。&lt;/li&gt;
&lt;li&gt;最小颗粒度决定了 G，也决定了 pmpaddr[G-2:0] 的值，所以硬件可以 hardwire 实现，不需要使用寄存器。&lt;/li&gt;
&lt;li&gt;虽然修改 pmpxcfg.A 会影响到 pmpaddrx 的读出结果，但实际上并不会改变底层 pmpaddrx 存储的 bit。特别是，当 pmpxcfg.A 从 NAPOT 改到 TOR，又从 TOR 该回 NAPOT，pmpaddrx[G-1] 都会保持原值不变。&lt;/li&gt;
&lt;li&gt;从分类讨论描述可以推断出来，NAPOT 模式下 PMP region 地址和容量对齐；TOR 模式下地址和容量无对齐约束。比如最小粒度为 4KB，region size = 32 KB，则 NAPOT 模式下地址必须为 32 KB 的整数倍，如 32 KB，64 KB，96 KB 等；而 TOR 模式下地址只需要是 4KB 的整数倍即可，如 4KB，8KB，12KB 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;软件可以通过以下方式得到 PMP region 的粒度：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向 pmp0cfg 写入全 0，将地址匹配设置为 OFF&lt;/li&gt;
&lt;li&gt;向 pmpaddr0 写入全 1&lt;/li&gt;
&lt;li&gt;读回 pmpaddr0，如果 LSB 1 为 bit[G]，则粒度为 &lt;span class="math"&gt;\(2^{G+2}\)&lt;/span&gt; Byte&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;这个方法的原理：根据前面的规则，OFF 模式下读到的 pmpaddr[G-1:0] 为全 0，pmpaddr[MXLEN-1 : G] 为全 1。所以 LSB 1 的下标就是 G，从而可以根据公式算出粒度。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="address-matching"&gt;address matching&lt;/h5&gt;
&lt;p&gt;pmpxcfg.A 决定了如何翻译和使用 pmpaddrx 的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAPOT 模式利用 region 容量和起始地址对齐的约束，只靠 pmpadddr 一个寄存器就可以同时表示 region 容量和 region 起始地址。因为对于 2 的幂次对齐的地址，其实低位是冗余的，可以用这些低位来表示容量。&lt;/li&gt;
&lt;li&gt;TOR 模式下，第 i 个 entry 的地址区间为 [&lt;span class="math"&gt;\(pmpaddr_{i-1}\)&lt;/span&gt;, &lt;span class="math"&gt;\(pmpaddr_i\)&lt;/span&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="locking"&gt;locking&lt;/h5&gt;
&lt;p&gt;pmpxcfg.L = 1 表示该 entry 被 lock，当 pmpxcfg.L = 1 时，会忽略对 pmpxcfg 和 pmpaddrx 的写操作。如果 pmpxcfg.L = 1 且 pmpxcfg.A = TOR，则对 &lt;span class="math"&gt;\(pmpaddr_{x-1}\)&lt;/span&gt; 的写操作也会被忽略掉。&lt;/p&gt;
&lt;p&gt;L 和 A 无关，即使 pmpxcfg.A = OFF，置位 L 也会 lock 该 entry。一旦 entry 被 lock，就只能通过复位来释放。&lt;/p&gt;
&lt;p&gt;L 字段除了 lock 功能外，还会表示是否在 M-mode 下进行 R/W/X 权限检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 L = 1，强制 M/S/U mode 都会检查权限&lt;/li&gt;
&lt;li&gt;当 L = 0，不检查 M-mode 下访问的权限（所有访问都 success），只检查 S/U mode 下的 R/W/X 权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="priority-and-matching"&gt;priority and matching&lt;/h5&gt;
&lt;p&gt;地址匹配逻辑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="data:image/png;base64,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" class="uml" alt="uml diagram" title="PMP &amp;#22320;&amp;#22336;&amp;#21305;&amp;#37197;&amp;#36923;&amp;#36753;" /&gt;&lt;/p&gt;
&lt;p&gt;failed 的访问会触发对应 exception。单条指令可能会拆分出多个非原子访问序列（比如非对齐访问，访问虚地址 etc），一旦序列中某个访问 failed，即使其他访问 success 且产生了副作用，仍然会触发 exception。&lt;/p&gt;
&lt;h4 id="paging"&gt;Paging&lt;/h4&gt;
&lt;p&gt;PMP 机制支持基于 page 技术的 Virtual-Memory 系统。当启用 page 时，访问虚拟地址的指令可能会产生多次物理地址访问，包括隐式的查询 page table，PMP 会检查所有的这些物理地址访问。隐式查询 page table 时为 S-mode。&lt;/p&gt;
&lt;p&gt;spec 允许支持虚拟地址的 implementation 在实际物理地址访问前投机地进行地址翻译，而且允许把翻译结果缓存起来。从地址翻译到发起物理地址访问，PMP 检查可以发生在这段时间内的任何时候，所以当 PMP CSR 被修改后，M-mode 的软件必须把最新的配置同步到虚拟地址系统已经任何 PMP 翻译缓存中。具体方法：修改 PMP CSR 后使用 rs1 = x0 和 rs2 = x0 的 &lt;code&gt;SFENCE.VMA&lt;/code&gt; 指令。&lt;/p&gt;
&lt;p&gt;如果不支持虚拟系统，则不需要 &lt;code&gt;SFENCE.VMA&lt;/code&gt; 指令。&lt;/p&gt;
&lt;h2 id="supervisor-level-isa"&gt;Supervisor-Level ISA&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>RISC-V Spec 阅读笔记 #1 —— Unprivileged ISA</title><link href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-1-unprivileged.html" rel="alternate"></link><published>2020-11-17T21:55:00+08:00</published><updated>2020-11-17T21:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-11-17:/posts/risc-v/risc-v-spec-notes-1-unprivileged.html</id><summary type="html">&lt;p&gt;Volume I: Unprivileged ISA 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Unprivileged ISA 文档的版本号 :20191213&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;RISC-V 的目标可以说非常宏大、也非常务实，可以用这几个关键词来概括：完全 open、可实现、通用、模块化、可扩展。RISC-V 在定义时尽可能地规避了具体的实现细节（虽然 ISA 中有些设计是出于实现考虑的），所以这个 ISA 应该当成各种不同实现方案的统一软件可见接口，而非某种特定微架构实现的专属。整个手册分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Volume I: Unpriviledge ISA&lt;/li&gt;
&lt;li&gt;Volume II: Priviledge ISA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设计这些 ISA 时都遵循了 “ 尽量移除对特定微架构依赖 ” 的原则，这样可以在简化 ISA 同时保证 implementation 最大程度的灵活性。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;ISA 作为软件和硬件之间的接口，其地位非常重要。曾经有很多各种各样的 ISA，其中大部分都随着历史消亡了，只剩下个别占领了市场主流，并不断演进。但是目前大部分 ISA 被商业产权保护，普通人无法使用，而且因为要向后兼容而有历史包袱，在这样的背景下，RISC-V 最早起源于 UC Berkeley 的教学需求，逐渐发展壮大，如今在业界如火如荼。&lt;/p&gt;
&lt;p&gt;定义一个新的 ISA 并不是简单定义指令集就足够的，还需要大量的投入，比如文档、编译器工具链、测试套件、教学材料等等，即使这些都全做出来了别人也不一定会用，做出来简单，要想推动整个生态是件非常难的事情。看看 RISC-V 基金的董事会和赞助商，就会发现全是著名科技公司和大佬，也只有他们才能集整个产业界的力量推动新的 ISA 发展。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;ISA 之所以叫架构，是因为它作为软硬件世界之间的桥梁，不仅仅包含了指令集，还需要包含很多其他内容，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;存储模型&lt;/li&gt;
&lt;li&gt;软件可见的处理器状态 GPR + CSR + PC&lt;/li&gt;
&lt;li&gt;指令集&lt;/li&gt;
&lt;li&gt;系统模型：状态 + 特权级别  + 中断 / 异常&lt;/li&gt;
&lt;li&gt;外部接口： I/O + 管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hardware-platform-terminology"&gt;Hardware Platform Terminology&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hardware platform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RISC-V core + non-RISC-V core + accelerator + memory + I/O + interconnect&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;core&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含独立的 IFU 的模块，一个 core 可能包含多个 &lt;code&gt;hart&lt;/code&gt; 和 &lt;code&gt;coprocessor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;coprocessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;附着在 RISC-V core 上，大部分情况下由 RISC-V 指令流控制，但是具有架构状态和有限的自主控制权来运行扩展指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;accelerator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不可编程的固定函数单元 or 针对特定任务的可以自动运行的 core，如 I/O 加速器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="software-execution-environment-and-harts"&gt;Software Execution Environment and Harts&lt;/h3&gt;
&lt;p&gt;RISC-V 程序的行为依赖于它的执行环境，&lt;code&gt;EEI (Execution Environment Interface)&lt;/code&gt; 定义了下面这些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的初始状态&lt;/li&gt;
&lt;li&gt;Hart 的数量和类型&lt;/li&gt;
&lt;li&gt;hart 支持的特权模式&lt;/li&gt;
&lt;li&gt;memory/IO 的访问及特性&lt;/li&gt;
&lt;li&gt;每个 hart 支持的合法指令，即 ISA&lt;/li&gt;
&lt;li&gt;中断和异常的处理方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EEI 的典型例子有 Linux &lt;code&gt;ABI (Application Binary Interface)&lt;/code&gt; 和 RISC-V &lt;code&gt;SBI (Supervisor Binary Interface)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;EEI 的实现方式有多种：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实现方式&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bare metal&lt;/td&gt;
&lt;td&gt;由硬件直接实现的 hart，指令可以访问所有的物理地址空间，硬件平台定义上电复位后的执行环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS&lt;/td&gt;
&lt;td&gt;通过复用 hart 和虚拟地址控制访问 memory ，OS 可以实现多个用户层级的 execution environment（即多个 thread）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hypervisor&lt;/td&gt;
&lt;td&gt;对 guest OS 访问提供多个 supervisor 级别的 execution environment（即多个虚拟机）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emulator&lt;/td&gt;
&lt;td&gt;在另一个硬件平台（如 x86）上模拟 RISC-V 的 hart，比如 Spike、QEMU、rv8 等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Hardware Thread&lt;/code&gt;：随着处理器技术的发展，现在的处理器已经突破了多核的概念，在单个核心中包含多个硬件线程的技术叫做硬件超线程 &lt;code&gt;Hyper-threading&lt;/code&gt;，每个硬件线程有自己独立的 RF 等上下文资源，但是不同线程共享同一份运算资源，所以面积效率很高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hart&lt;/code&gt;：为了区别多核，RISC-V 定义的术语，取 Hardware Thread 之意，包含自动取指和执行所涉及的硬件资源的统称。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;一般软件的接口都比实际硬件接口更加抽象，因为 EEI 越抽象移植性就越好。通常 EEI 都是一层一层堆叠在一起的，上层的 EEI 依赖于下层的 EEI。&lt;/li&gt;
&lt;li&gt;hart 由 execution environment 提供，所以可能会出现 guest hart 数量比 host hart 数量多的情况，即时分复用。这种情况下，由 execution environment 确保每个 hart 行为正常，尤其是要支持 guest hart 抢占 host hart。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="isa-overview"&gt;ISA Overview&lt;/h3&gt;
&lt;p&gt;RISCV ISA 由必选的 Base Integer ISA 和其他可选 ISA 组成，完整的子集列表直接看 spec 即可。其中必选的 base interger ISA 和以前的 RISC 处理器的 ISA 非常相似，只是去掉了分支延迟槽并支持了可选的变长编码。I 子集是一个精心设计过的针对工具链来说合理的最小化集合，基于它可以实现一个基本的软硬件 “ 骨架 ”，并进一步定制化。I 子集一共有 4 种形式，它们的区别在于 register 的位宽、register 的数量、寻址空间大小： &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;XLEN (register 位宽 )&lt;/th&gt;
&lt;th&gt;registe 数量&lt;/th&gt;
&lt;th&gt;寻址空间范围 (Byte)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{32}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{64}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV32E&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{32}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV128I&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{128}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;4 个 base ISA 被当作完全不同的 ISA 来对待，所以有个常见问题：&lt;/p&gt;
&lt;p&gt;Q：为什么不设计一个统一的 ISA，即让 RV32I 是 RV64I 的严格子集？一些早期 ISA(SPARC, MIPS) 就采用了这样的设计规则，使得可以在 64bit 的硬件上运行 32bit 的程序。&lt;/p&gt;
&lt;p&gt;A：ISA 分开设计的主要优点是可以针对某个子集独立优化，不需要为支持其他子集而消耗资源，主要缺点则是当在一个 ISA 上模拟另外一个 ISA 时的硬件更复杂。实际上寻址模式和捕获非法指令的不同往往意味着即使某两个 ISA 是子集关系仍然需要两套电路以及某种模式切换，而且 RISC-V 的 base ISA 之间的相似性可以降低多版本的开销。虽然理论上可以把 32bit 的 lib 和 64bit 的代码链接在一起，但因为程序调用和系统调用接口的不同实际中并不可行。&lt;/p&gt;
&lt;p&gt;RISC-V 的特权架构中 misa 寄存器有个字段专门用来控制在同一份电路上可模拟的 unprivileged ISA，而且可以看到最新的 SPARC 和 MIPS 也放弃了对在 64bit 系统上直接运行 32bit 程序的支持。&lt;/p&gt;
&lt;p&gt;另外一个相关的问题是：为什么相同的 32bit 加法在 RV32I 和 RV64I 中的 opcode 不同？应该遵守字面意思，W 后缀表示 word（32bit），D 后缀表示 double word（64bibt），按如下方式编码，这样和 LW 的编码方式也能保持统一。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;32-bit add&lt;/th&gt;
&lt;th&gt;64-bit add&lt;/th&gt;
&lt;th&gt;32-bit load&lt;/th&gt;
&lt;th&gt;64-bit load&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;ADDW&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;ADDW&lt;/td&gt;
&lt;td&gt;ADDD&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;LD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;而目前的设计为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;32-bit add&lt;/th&gt;
&lt;th&gt;64-bit add&lt;/th&gt;
&lt;th&gt;32-bit load&lt;/th&gt;
&lt;th&gt;64-bit load&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;ADDW&lt;/td&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;LD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;实际上一开始确实是按照提议的方式编码的，但是在后来的演进过程中修改为目前的方式。之所以把 32bit 加法的编码设置成不兼容，目的是为了消除 RV32I 中的不对称性（RV32I 有 ADDW 和 AND 但是没有 ANDW）。从事后复盘看目前的方式是不合理的，主要原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时设计两个 ISA，而不是是一层一层地叠加&lt;/li&gt;
&lt;li&gt;设计 ISA 时的一个理念：RV64I 必须完全包含 RV32I（RV32I 已经使用了 ADD，所以 RV64I 只能修改指令的含义，并新增 ADDW）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 RV32I 和 RV64I 已经 frozen 了，所以无法修改了，目前看这样做几乎没有什么实际问题。以后可以将 W 后缀作为某个 RV32I 变种的扩展集，这样就能在 RV32I 和 RV64I 之间保持一致的编码了。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="memory"&gt;Memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;寻址范围是 &lt;span class="math"&gt;\(2^{XLEN}\)&lt;/span&gt; Byte&lt;/li&gt;
&lt;li&gt;1 word = 32bit(4Byte)；1 halfword = 16bit(2Byte)；1 doubleword = 64bit(8Byte)，1 quadword = 128bbit(16Byte)，和 XLEN 无关&lt;/li&gt;
&lt;li&gt;memory 地址是循环的，最大的地址溢出后自动回到 0 地址，硬件计算地址时以 &lt;span class="math"&gt;\(2^{XLEN}\)&lt;/span&gt; 为模会自动忽略溢出即可&lt;/li&gt;
&lt;li&gt;由 execution environment 将硬件资源映射到 hart 的地址空间中，通常地址空间被分成了不同段，如 memory、I/O device 等，每个段有自己的属性&lt;/li&gt;
&lt;li&gt;多个 hart 的 memory 可以完全一样，也可以完全独立或部分重叠&lt;/li&gt;
&lt;li&gt;memory 访问可以分为 implicit 和 explicit 两类&lt;ul&gt;
&lt;li&gt;implicit access：取指操作，没有对应的指令，硬件自动读取。这种类型的访问可以提前进行（比如 I$ 指令预取），当需要和 store 数据同步时必须用 fence 或 cache control 指令显式地同步&lt;/li&gt;
&lt;li&gt;explicit access：load/store 指令的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RISC-V 默认使用 &lt;code&gt;RVWMO(RISC-V Weak Memory Ordering)&lt;/code&gt; 作为内存一致性模型，实现也可以选择约束更强的 TSO(Total Store Ordering) 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="base-isa-encoding"&gt;Base ISA Encoding&lt;/h3&gt;
&lt;p&gt;RISC-V 指令可以是变长的，但是所有 base ISA 都按照 16bit 对齐，即其指令长度都是 16bit 的倍数。&lt;/p&gt;
&lt;p&gt;使用术语 &lt;code&gt;IALIGN&lt;/code&gt;（单位为 bits）表示指令对齐约束，IALIGN 的取值只能是 16 或 32：base ISA 的 IALIGN 是 32，C 子集和其他扩展 ISA 可以是 16。&lt;/p&gt;
&lt;p&gt;使用术语 &lt;code&gt;ILEN&lt;/code&gt;（单位为 bits）表示实现支持的最大指令长度，它永远是 &lt;code&gt;IALIGN&lt;/code&gt; 的整数倍。&lt;/p&gt;
&lt;p&gt;Base ISA 既可以是大端模式，也可以是小端模式，但是指令存储一定是以 16bit 为单位的数据包的小端模式。&lt;/p&gt;
&lt;h3 id="exceptions-traps-interrupts"&gt;Exceptions, Traps, Interrupts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Exception&lt;/code&gt; 表示指令执行中处理器本身出现异常情况而停止执行当前程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupt&lt;/code&gt; 表示外部异步事件导致处理器停止执行当前程序，转而去完成其他事情，完成后再继续之前的程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trap&lt;/code&gt; 表示由 exception 或 interrput 导致的 CPU 控制权向 trap handler 的转移过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 种不同的 trap：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Contained&lt;/th&gt;
&lt;th&gt;Requested&lt;/th&gt;
&lt;th&gt;Invisible&lt;/th&gt;
&lt;th&gt;Fatal&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Execution terminates ?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Software is oblivious?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handled by environment?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="rv32i-base-isa"&gt;RV32I Base ISA&lt;/h2&gt;
&lt;p&gt;一共有 40 条指令，查询 reference card 即可。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一些资料中会描述说 I 指令集包含 47 条指令，这里有点歧义。以前的历史版本中 I 确实有 47 条指令，但是在最新的版本中，有 7 条指令被移了出来，只剩下只包 40 条指令，通常所说的 47 条指令是把另外两个必要的子集也包含在内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Zifencei&lt;/code&gt; 子集：包含 1 条指令 &lt;code&gt;FENCE.I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Zicsr&lt;/code&gt; 子集：包含 6 条 csr 相关的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些实现中，可能会把 ECALL/EBREAK 当成一条永远 trap 的硬件指令来处理，且把 FENCE 指令当成 NOP 来处理，这时 I 子集的指令条数就缩水到了 38 条。&lt;/p&gt;
&lt;p&gt;除了 A 子集需要特殊的硬件来支持原子性操作之外，RV32I 基本上可以模拟任何其他子集。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="programmers-model"&gt;Programmers' Model&lt;/h3&gt;
&lt;p&gt;RV32I 的 Unpriviledged state 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器 XRF：一共有 32 个，XLEN=32，其中 x0 为常数 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSR&lt;/code&gt;：内部寄存器，专有的 12bit 地址编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有个特殊的 register：&lt;code&gt;pc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;I 子集只涉及通用寄存器，CSR 寄存器在后面的 &lt;code&gt;Zicsr&lt;/code&gt; 部分介绍。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV32I 中没有定义 stack pointer 和 return address 寄存器，而是直接使用某个 XRF。标准的软件调用规范中指定了 x1 作为 return address，x2 保存 sp。遵守这个规范可以生成最小体积的代码。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一个 ISA 中寄存器的个数对代码体积、性能、功耗有巨大的影响。到底应该设计多少个 register 也是有讲究的，有种意见是对于 I 子集只用 16bit 的指令编码配合 16 个 register 就已经足够了，但是如果指令中包含 3 个寄存器地址，则光地址就需要 12bit，只剩了 4bit 来编码 opcode，这基本上是不可能的。而如果指令只包含 2 个地址，那么实现相同功能就需要更多的指令，降低效率。为了简化硬件设计也应该避免 24bit 这种中间长度的指令格式，所以最终选择了 32bit 的指令来编码配合 32 个寄存器。寄存器数量多一些对性能提升也有帮助，比如 loop unrolling, software pipelining, cache tiling 这些技术都对寄存器数量有很大的需求。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="format"&gt;Format&lt;/h3&gt;
&lt;p&gt;主要有 4 种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; (Register)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; (Immediate) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; (Store)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&lt;/code&gt; (Upper)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 branch 或 jump 指令跳转的地址没有 4Byte 对齐时，会在 branch/jump 指令处产生 exception。当支持 16bit 指令时 (IALIGN = 16)，对齐约束放宽到 16 的倍数。&lt;/p&gt;
&lt;p&gt;RISC-V 的指令格式是精心设计过的，目的就是为了简化硬件的译码电路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32I 的指令长度都是 32bit，按照 4Byte 对齐存储&lt;/li&gt;
&lt;li&gt;所有指令中的 rs1, rs2, rd 都在固定位置&lt;/li&gt;
&lt;li&gt;所有指令中的立即数都是按照有符号的方式扩展（除了 CSR 指令中的 5bit 立即数）&lt;/li&gt;
&lt;li&gt;所有立即数都放在指令可用空间的最左边 bit 位置&lt;/li&gt;
&lt;li&gt;所有立即数的符号位都在指令的固定位置 bit[31]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：和蜂鸟总结的 dec 优势对比，查缺补漏&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;译码模块中 register 标识符的逻辑通常都是关键路径，所以 RISC-V 在设计指令格式的时候，不管是什么格式类型的指令，都把标识符放在固定位置，付出的代价则是指令中立即数的位置会随着指令类型变化。&lt;/p&gt;
&lt;p&gt;实际上，大部分立即数的位宽要么很小，要么就要占满 XLEN bit，RISC-V 选择了一种非对称的方式切分立即数（用两条指令来搬运一个立即数：第一条指令搬运低 12bit，第二条指令搬运剩余的 20bit），这样做的好处是可以增加常规指令可用的 opcode 编码空间。&lt;/p&gt;
&lt;p&gt;所有立即数都是符号为扩展的，因为我们没有发现 MIPS 中按 0 扩展能带来什么好处，这样做同时也能最大限度地保持 ISA 的简洁。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因为立即数的原因，所以有了另外两个变种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; (Branch) 类型：它和 &lt;code&gt;S&lt;/code&gt; 一样都用 12bit 来编码立即数，唯一区别是 B 中的立即数是 S 中立即数的 2 倍，也就是说 S 中的 12bit 表示 imm[11:0]，而 B 中的 12bit 表示 imm[12:1]，而且这 12bit 在指令中的位置是精心设计过的，并不是简单移位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; (Jump) 类型：它和 &lt;code&gt;U&lt;/code&gt; 的关系也是类似的，唯一区别是 U 和 J 需要 shift 的 bit 位数不一样，同理，立即数的位置是精心设计过的，并不是简单填充&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;立即数的符号位扩展是其关键路径之一，RISC-V 把所有立即数的符号位都放在第 31bit，好处是可以让符号位扩展和译码并行。&lt;/p&gt;
&lt;p&gt;虽然有些复杂的实现会给 branch 和 jump 指令计算分配专有加法器，所以并不会受益于不同指令中的立即数位置固定的设计，但是我们想降低最简实现的硬件成本。通过变换立即数的 bit 位置，而不是使用动态的硬件 mux，指令信号的 fanout 和 mux 数量大概减少为原来的一半。而这种混乱的立即数编码带来的开销可以忽略不计。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下面分类描述 I 子集的 40 条指令，大概可以分成 4 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;整数计算指令&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制转移指令&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Load/Store 指令&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Memory 顺序指令&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统调用和断点&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="integer-computational-instructions"&gt;Integer Computational Instructions&lt;/h3&gt;
&lt;p&gt;整数计算指令只有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I-type&lt;/code&gt;：register 和 immediate 相计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R-type&lt;/code&gt;：register 和 register 相计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两类都会有 rd 寄存器来保存结果，rs 和 rd 都为 XRF，而且都不会产生算术异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;我们并没有设计特殊的指令集来检测 overflow，因为可以用 branch 指令很廉价的实现这个功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数加法的 overflow 检查只需要在 add 指令后面加一条 branch 指令即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add t0, t1, t2
bltu t0, t1, overflw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有符号数加法，如果已知一个操作数的符号（I 类型加法），那么只需要在 add 后面加一条 branch 指令即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;addi t0, t1, +imm
blt t0, t1, overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一般的有符号数 R 类型的加法，需要 3 条指令来检测求和结果是否比任何一个加数都小（除非一个操作数是负数）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add t0, t1, t2
slti t3, t2, 0
slt t4, t0, t1
bne t3, t4, overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SLTIU&lt;/code&gt; 指令需要先对立即数进行符号位扩展，然后再当成无符号数来比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOP&lt;/code&gt; 是伪指令，以 &lt;code&gt;ADDI x0, x0, 0&lt;/code&gt; 的方式实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LUI&lt;/code&gt; 和 &lt;code&gt;AUIPC&lt;/code&gt; 都是 U 类型的格式，用来组装一个 32it 数据，区别是 &lt;code&gt;LUI&lt;/code&gt; 只做组装，而 &lt;code&gt;AUIPC&lt;/code&gt; 完成组装后还会有一个额外的加法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AUIPC&lt;/code&gt; 指令支持以 “ 双指令序列 ” 的方式访问当前 PC 的任意 offset 位置，既可以用来做控制流的转移，也可以用来做数据访问，可以访问相对于当前 PC 值的任意 32-bit 地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制流转移： AUIPC + JALR 组合，AUIPC 先把目标地址的高 20bit 存储到 rd 中，然后这个 rd 作为 JAL 的 rs，叠加上 imm 就可以算出完整的 32bit 目标地址&lt;/li&gt;
&lt;li&gt;数据访问： AUIPC + LOAD/STORD，AUIPC 先把目标地址的高 20bit 存储到 rd 中，然后这个 rd 作为 ld/st 的 rs，叠加上 imm 就可以算出完整的 32bit 目标地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：看蜂鸟，补充实际指令序列的例子&lt;/p&gt;
&lt;p&gt;原理：AUIPC 已经包含了立即数的高 20bit，所以只需要其他指令配合产生立即数的低 12it 即可。&lt;/p&gt;
&lt;p&gt;虽然获取当前 PC 值可以通过把 AUIPC 的立即数设置为 0 来实现，也可以通过 &lt;code&gt;JAL +4&lt;/code&gt; 的方式实现，但是后者的问题在于可能会导致流水线停顿或者是污染 BTB。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一般 NOP 指令都用来处理地址边界问题以使得指令对齐，或者为指令修改预留空间。虽然 NOP 的实现方式有很多种，我们只定义了一种作为示范，给微架构层面的优化留有空间，同时也可以使得汇编代码的可读性更好。NOP 指令也可以用 HINT 指令来实现。&lt;/p&gt;
&lt;p&gt;选用 ADDI 来实现 NOP 的原因是，这样占用的资源最少（除非是在 decode 阶段把它优化掉了），只需要读一个 register，而且在超标量处理器中加法器是最常见的操作，AGU 可以像计算地址一样直接执行这条指令，其他的 register-register 指令（比如 ADD 或 logical 指令、shift 指令）都需要额外的硬件才能完成。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="control-transfer-instructions"&gt;Control Transfer Instructions&lt;/h3&gt;
&lt;p&gt;控制流相关的指令一共有两类，而且都没有 delay slot（延迟槽），如果跳转地址没有对齐，则会产生一个不对齐异常。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转 jump&lt;/li&gt;
&lt;li&gt;有条件分支 branch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 &lt;code&gt;JAL&lt;/code&gt; 指令属于 J-type，所以它包含了 imm[20:1] bit，所以可以跳转的范围是 [-1MB, +1MB] 内。JAL 会把自己后面的指令地址 (pc+4) 存到 rd 中，方便跳回后继续执行。一般标准的软件调用惯例是 rd = x1 作为返回地址，x5 作为 alternate link register。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这个 alternate link register 可以在保留常规的返回地址寄存器 rd 不变前提下支持调用一些 millicode，之所以选择 x5 是因为在标准调用中它是一个临时寄存器，而且和 x1 的编码只有 1bit 不同。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;无条件 jump 指令（JAL 和 JALR）都使用 PC 的相对地址来支持地址不相关的代码。JALR 和 LUI 组合在一起可以访问 32bit 地址空间中的任一位置，首先 LUI 把目标地址的高 20bit 搬运到寄存器中，然后 JALR 把低 12bit 加上去就可以算出完整的 32bit 目标地址。同理，AUIPC 和 JALR 也可以跳转到相对于 PC 的任意 32bit 地址。&lt;/p&gt;
&lt;p&gt;需要注意的是，JALR 不会像 branch 指令一样从 imm[1] 开始编码（2 的倍数），JALR 编码的是 imm[11:0]，这样做的好处是可以避免硬件中立即数格式太多的问题。&lt;/p&gt;
&lt;p&gt;JALR 执行的时候，会把计算出的 target address 的 LSB 清零，这样做的好处是可以稍微简化硬件设计，同时还可以空余出 1bit 空间来存储更多辅助信息。虽然这么会导致错误检查的逻辑变复杂，所以有些轻微的性能损失，因为发生了指令地址错误很快就触发异常，所以问题不大。&lt;/p&gt;
&lt;p&gt;当 rs1=x0 时，JALR 可以用来实现单指令调用子程序，在 [-2KB, 2KB] 范围内跳转，可以实现 small runtime lib 的快速调用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RAS 预测是高性能 IFU 中的常见功能，但是前提是要能准确区分出函数调用和返回，协议规定了 JAL 和 JALR 所使用的寄存器序号可以用来辅助 RAS 预测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 JAL 的 rd=x1 或者是 rd=x5，那么就是函数调用，要把 rd 寄存器的值 push 进 RAS，保存返回地址&lt;/li&gt;
&lt;li&gt;如果 JAL 的 rs=x1 或者是 rs=x5，那么就是函数调用返回，要从 RSA pop 出返回地址，用于 IFU 预测下一个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遵守协议的规定，compiler 和 core 配合就可以最大化地提高 RAS 的预测准确度。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;有些 ISA 使用了特别的 bit 位来标识辅助 RAS，我们使用隐式的方式（约定寄存器号）来减少对编码空间的占用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;所有的 branch 指令都是 B-type，所以它编码了 imm[12:1] bit，所以可以跳转的范围是 [-4KB, 4KB] 之间。&lt;/p&gt;
&lt;p&gt;协议规定软件要假设硬件是 BTFN 算法的方式，依次进行优化，这样可以提高低端 CPU 的预测性能。不同于其他 ISA，RISC-V 规定无条件跳转必须使用 JAL(rd=x0)，而不能用条件设置为 true 的 branch 指令。因为 jump 指令要比 branch 的跳转范围大，而且不会污染条件 branch 的预测表。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;条件 branch 指令被设计成包含两个 register 的算数比较的方式（同 PA-RISC、Xtensa、MIPS R6），没有使用以下方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用条件码 condition code（x86、ARM、SPARC、PowerPC）&lt;/li&gt;
&lt;li&gt;只使用一个 register 和 0 做比较（Alpha，MIPS）&lt;/li&gt;
&lt;li&gt;两个寄存器只用于比较是否相等（MIPS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样设计的主要原因是把比较和分支合并在一起更加适合常规流水线，不需要使用额外的 condition code，也不需要使用寄存器保存中间结果，可以减少代码体积，降低 IFU 的带宽，还可以在 IF 阶段就被提前检测到，即使是和 0 比较这种设计，也会引入不可忽略的 latency。这样设计付出的硬件代价也很小近似可以忽略。另外融合的指令可以在流水线的上游更早地观测到，更早地预测。&lt;/p&gt;
&lt;p&gt;曾经考虑过在指令编码中加入静态分支提示，但最终并没有加，理由是虽然静态分支提示可以缓解动态预测器的压力，但是代价是会占用更多的编码空间，还需要软件做 profiling 才能获得最好的结果，而一旦 profiling 和实际不一致，性能就很差。&lt;/p&gt;
&lt;p&gt;没有包含类似 ARM 条件码的原因是：条件码需要占用指令的额外 bit，需要额外的指令来设置 / 清除，增加了硬件复杂度，而和它一起配合使用的静态预测的效果可能并不好。&lt;/p&gt;
&lt;p&gt;有很多方法可以动态地把不可预测的前向分支转化为可预测的代码，以避免流水线的 flush 代价。其中最简单的就是只 flush IFU 中的指令，而不是整个 pipeline 上的所有代码。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="load-and-store-instructions"&gt;Load and Store Instructions&lt;/h3&gt;
&lt;p&gt;RISC-V 是一个 load-store 体系结构，即只有 load/store 才可以访问 memory，计算指令只能和寄存器打交道，而且 RISC-V 的端序是 byte 地址不变的。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 load 指令的 rd 是 x0，即使读回来的数据被丢弃了，也必须报一个任意类型的 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在一个端序是 byte 地址不变的系统中，有下列特性：如果某个 1 byte 的数据被 store 在某种端序的 memory 的某个地址中，那么从那个地址中 load 1 byte 数据返回的数据也是那个值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小端系统：一个多 byte 数据，LSB 被存储在 memory 的低位地址，剩余数据的地址按照顺序递增，load 指令会把低位地址的数据搬运到 register 的 LSB 中&lt;/li&gt;
&lt;li&gt;大端系统：一个多 byte 数据，MSB 被存储在 memory 的低位地中，剩余数据的地址按照顺序递减，load 指令会把高位地址的数据搬运到 register 的 LSB 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RV32I 的地址空间是 32bit，按照 byte 地址访问，由 EEI 规定合法的地址段。无论端序如何，如果访问地址是天然对齐的，那么就不会产生任何异常，如果访问地址不是天然对齐的（访问数据量是 32bit，地址按照 4byte 对齐；访问数据量是 16bit，地址按照 2byte 对齐），那么具体行为取决于 EEI。EEI 可以允许非对齐访问，由硬件或者软件处理，也可以不允许非对齐访问，直接抛出异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;非对齐访问在移植旧代码、使用 packed-SIMD 扩展的应用程序、处理外部打包的数据结构时很有用。之所以通过 load/store 来允许 EEI 自主选择非对其访问的处理方式，目的就是想简化硬件设计。&lt;/p&gt;
&lt;p&gt;有一种备选方案：在 base ISA 中不允许非对齐访问，额外再设计一个 ISA 来支持非对齐访问，比如某些特殊指令或者是硬件特殊的寻址模式。这个方案的问题在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊指令使用难度大，导致 ISA 复杂化&lt;/li&gt;
&lt;li&gt;要么处理器添加了额外状态（CSR），要么导致现有 CSR 的访问复杂化&lt;/li&gt;
&lt;li&gt;面向 for 循环的 packd-SIMD 程序可能要根据数据对齐模式修改多个版本的代码，使得代码生成复杂化，产生额外开销&lt;/li&gt;
&lt;li&gt;新的硬件寻址模式必然要消耗大量的指令编码空间，而且也要消耗一些硬件资源来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;即使实现了非对齐访问，在某些实现中可能性能很差；而且硬件处理非对齐访问时可能会将其拆分成多个子指令来处理，此时需要额外的同步机制来保证访问的原子性。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;标准中非对齐访问的原子性不是必须的，这样 EEI 就可以自由选择是用不可见的 machine trap 还是软件 handler 来处理非对齐访问。如果硬件支持非对齐访问，那么软件只需要直接用简单的 load/store 即可，发生非对齐访问时，硬件会自动优化。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="memory-ordering-instructions"&gt;Memory Ordering Instructions&lt;/h3&gt;
&lt;p&gt;RISC-V 支持在一个单一的用户地址空间内运行多个 hart，每个 hart 都有自己的 pc 和 register，执行自己的指令流。而由 EEI 来完成 hart 的创建和管理。不同 hart 之间可以通过共享存储器来实现通信和同步，又因为 RISC-V 使用存储器松散一致性模型 &lt;code&gt;RVWMO&lt;/code&gt;，所以需要 FENCE 指令来定义另外一个 hart 观测到本 hart 的指令执行顺序。从原则上讲，另外一个 hart 只能先观测到 FENCE 前的指令行为，然后才能观测到 FENCE 之后的指令行为，即 FENCE 像一道屏障一样，隔断了前后的指令流。&lt;/p&gt;
&lt;p&gt;RISC-V 把数据存储器访问分为了 4 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I：设备读 device-input&lt;/li&gt;
&lt;li&gt;O：设备写 device-output&lt;/li&gt;
&lt;li&gt;R：存储器读 device-read&lt;/li&gt;
&lt;li&gt;W：存储器写 device-write&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配合前后的概念，所以可以实现很多种组合，达到非常精细的控制。&lt;/p&gt;
&lt;p&gt;FENCE 的 fm 字段取值为 1000，predecessor = RW，successor = RW 时，为 FENCE.TSO 指令，效果为 predecessor 的 load 和 successor 所有 memory 操作保序，predecessor 的 store 和 successor 的所有 store 保序，但是并未规定 predecessor 中的 non-AMO store 和 successor 的 non-AMO load 之间保序。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;FENCE.TSO 是 FENCE 的可选扩展，因为 FENCE 的基本定义要求忽略 I/O 和 memory 字段全局实现 fence，所以 FENCE.TSO 和 FENCE 是兼容的。&lt;/p&gt;
&lt;p&gt;FENCE 中没有定义的字段 rs1 和 rd 是为了将来更细精度的扩展而保留的。为了保持前向兼容，硬件应该忽略这些 bit 位，同时软件应该将这些 bit 位设置为全 0。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;我们选择松散一致性模型的目的是让一个简单的微架构能获得高性能的同时也方便未来进行扩展。将 I/O 和 memory 操作分离开来的好处是可以避免不必要的串行化。一个简单的微架构可以忽略 FENCE 中的前序和后序字段，保守地把所有的 FENCE 指令都当成最严格的 FENCE 指令来执行即可。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="environment-call-and-breakpoints"&gt;Environment Call and Breakpoints&lt;/h3&gt;
&lt;p&gt;系统指令用来访问系统功能，可能会要求特权访问，全部是 I 类型的指令。大概可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性地 read-modify-write CSR 的指令&lt;/li&gt;
&lt;li&gt;其他特权指令&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;系统指令的目的是使得简单实现中可以触发软件 trap handler 实现功能，而一些高端实现可能直接用硬件实现该指令。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;ECALL 和 EBREAK 都向 EEI 会出发一条精确异常来请求复位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ECALL&lt;/code&gt; 用来向 EEI 发送服务请求，请求的参数则一般放在寄存器文件中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EBREAK&lt;/code&gt; 用来把控制权转移给 debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hint-instructions"&gt;HINT Instructions&lt;/h3&gt;
&lt;p&gt;HINT 指令一般用来给微架构传递性能提示。RV32I 给 HINT 预留了大量的编码空间，且全部用 rd = x0 的计算指令来表示。所以 HINT 和 NOP 类似，只会导致 pc 向前移动以及改变性能计数器，除此之外不会改变硬件架构中任何可见的状态。实现中直接把 HINT 忽略也是符合标准的。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;HINT 设计成这样的目的是方便硬件实现。简单实现中既可以把 HINT 当成一条恰好并不会产生任何影响的指令来走完所有 pipeline stage，也可以直接把它丢弃。&lt;/p&gt;
&lt;p&gt;虽然 HINT 编码空间很大，而且划分了 standard 空间和 custom 空间，但是目前还没有定义好 standard HINT。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="zifencei"&gt;Zifencei&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;先讨论一个问题：假设一个指令流，前面的有条指令向 memory 某个地址 store 了一个新值，后面需要从该地址取指，那么后面的指令一定可以读取到前面的新值吗？&lt;/p&gt;
&lt;p&gt;答案是：不一定。因为 pipeline 是有深度的，假设前面的这两条指令是背靠背的，那么前序指令结果还没写入的时候后续指令已经完成了取指、译码，开始执行了，所以后续取指的是旧值。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，引入了 FENCE.I 指令，用来约束 store 和取值之间的顺序关系。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个子集只包含一条指令 &lt;code&gt;FENCE.I&lt;/code&gt;，它可以实现对同一个 hart 的 instruction memory 的写指令和取指之间的显式的同步控制，目前这是确保 hart 内部 store 对 instruction fetch 可见的唯一标准机制。&lt;/p&gt;
&lt;p&gt;这条指令用来同步一个 hart 的 data 和 instruction 之间的关系，如果没有这条指令，RISC-V 就无法保证后续的取值操作能观测到前序的 store 结果。因为 FENCE.I 只用来处理单个 hart 内部的关系，所以如果有多个 hart，为了保证某个 hart 的 store 结果可以被其他 hart 观测到，应该在 FENCE.I 之前先调用一条 FENCE 指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step1：本 hart 完成 store 指令&lt;/li&gt;
&lt;li&gt;step2：本 hart 执行 fence 指令&lt;/li&gt;
&lt;li&gt;step3：本 hart 请求所有 hart 执行 fence.i 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;为了支持各种不同的实现，FENCE.I 指令做过精心的设计。简单实现可以直接 flush 流水线，清空 I-cache 即可。复杂一些的实现可能会有更高级的操作。&lt;/p&gt;
&lt;p&gt;FENCI.I 之前是 I 子集的一部分，但是因为下面两个原因，从 I 子集中挪了出来，不再是必须实现的指令了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某些系统中，实现 FENCE.I 的代价很大。比如有些设计中 I-cache 和 D-cache 都是 incoherent 形式，一旦遇到 FENCE.I 指令，就必须清空两个 cache。如果在共享 cache / memory 之前有多级独立的 I/D cache，这个问题会更加严重&lt;/li&gt;
&lt;li&gt;在类 Unix 系统中，这条指令并没有强大到足以在 user level 使用。因为 FENCE.I 只能处理 hart 内部的同步，但是 OS 可能会在遇到 FENCE.I 时重新调度 user hart，所以现在 Linux ABI 都是要求产生一个系统调用来保证取指的 coherent&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="rv32e"&gt;RV32E&lt;/h2&gt;
&lt;p&gt;RV32E 是专门为嵌入式 Embedded 设计的 ISA，目前还是 draft 1.9 状态，它和 RV32I 的唯一区别就是把 register 的数量减少到了 16 个。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;实际上一开始是拒绝专门设计一个新的子 ISA 的，但是后来考虑到 32bit MCU 的需求，最终定义了这个子集，将来可能还会有 RV64E。&lt;/p&gt;
&lt;p&gt;我们发现在 RV32I 的小核中，高 16 个 register 大概占了 core 面积的 1/4（除 memory 之外），所以去掉这 16 个 register 可以节省大约 25% 的面积和功耗。&lt;/p&gt;
&lt;p&gt;这个改变也对软件的调用惯例和 ABI 提出了要求。&lt;/p&gt;
&lt;p&gt;RV32E 可以和任何标准 extension 组合使用。曾经考虑过 F、D、Q 和 RV32E 配合时，定义一个新版的只有 16-entry 的 FP register file，但是最终放弃了，计划定义一个 &lt;code&gt;zfinx&lt;/code&gt; 扩展 ，它计算 FP 时直接使用 integer register file，所以省去了 FP register file 和 XRF 之间的搬运操作。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV32E 的 ISA 和 RV32I 完全一样，但是因为 register 只有 16 个，所有指令中 index 的字段可以释放出几 bit，未来的标准指令扩展都不会用到这些字段，所以可以给自定义扩展指令来使用。&lt;/p&gt;
&lt;h2 id="rv64i"&gt;RV64I&lt;/h2&gt;
&lt;p&gt;RV64I 是 RV32I 的扩展。和 RV32I 的区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XLEN&lt;/code&gt; 变成了 64，即 register 的位宽是 64bit。&lt;/li&gt;
&lt;li&gt;RV64I 的大部分指令的操作数位宽都是 XLEN bit，但是也有一些附加的指令来操作 32bit 的数，这些指令都在 opcode 后面加了 &lt;code&gt;W&lt;/code&gt; 后缀来区分（W = word）。这些 &lt;code&gt;*W&lt;/code&gt; 指令会忽略掉高 32bit 数据，产生的结果也只保留 32bit 结果，然后把它符号位扩展到 64bit 后保存在 register 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rv128i"&gt;RV128I&lt;/h2&gt;
&lt;p&gt;目前还是 draft 1.7 状态，定义这个子 ISA 的目的就是为了支持更大的地址空间。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;目前暂时还不是很清楚我们什么时候需要比 64bit 更大的地址空间，世界上 Top500 的超级计算机拥有超过 1PB 的 DRAM，这需要超过 50bit 的地址线。一些仓储级的计算机已经包含了更大的 DRAM，而且固态硬盘和 interconnect 技术的发展可以能会产生更大地址空间的需求。万亿级别的系统研究需要 100PB 的空间，大概占用 57 根地址线。根据历史增长速度看，大概在 2030 年前就有可能超过 64bit 的范围。&lt;/p&gt;
&lt;p&gt;历史证明，无论何时只要出现地址不够用的情况，architect 设计者们就会重复以前的争论，使用各种技术（如 segmentation，96-bit 地址，软件规避等方法）来扩充寻址范围，但是最终，128bit 的寻址方案将作为最简单、最佳解决方案而被采用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV128I 在 RV64I 的基础上定义，就如同 RV64I 在 RV32I 上定义一样，保留了 &lt;code&gt;*W&lt;/code&gt; 指令不变，只不过新增了如何在 128bit 寄存器中操作 64bit 的指令，用 &lt;code&gt;*D&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;为了提升和 RV64I 的兼容性，和 RV64I 兼容 RV32I 的做法相反，可能会把 RV64I ADDI 的指令编码定义为 RV64I ADDD，然后在之前的 opcode &lt;code&gt;OP-64&lt;/code&gt; 新增一个 RV128I ADDQ，同时将 &lt;code&gt;OP-64&lt;/code&gt; 的编码定义为 &lt;code&gt;OP-128&lt;/code&gt;。即目前的编码规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不带后缀的指令操作数位宽为 XLEN&lt;/li&gt;
&lt;li&gt;通过后缀 &lt;code&gt;W&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 指定操作数位宽为 word 或 doubleword&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;未来的编码规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不带后缀的指令从操作数位宽为 word&lt;/li&gt;
&lt;li&gt;指令中带后缀 &lt;code&gt;W&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 指定操作数位宽为 word 或 doubleword&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h2 id="zicsr"&gt;Zicsr&lt;/h2&gt;
&lt;p&gt;RISC-V 专门定义了一组 (control and status register, CSR) 寄存器来记录配置和运行状态，这些寄存器是内部寄存器，使用专有的 12bit 地址编码空间。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 主要是在 Priviledge 架构中使用，但是 Unpriviledge 架构中也会用到一些，比如计数器和计时器，浮点状态等。&lt;/p&gt;
&lt;p&gt;因为计数器和计时器等不再是 base ISA 中的必须强制性实现的了，所以访问这些 CSR 的指令就独立出来自成一章。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;只要程序中有指令会修改或者是行为受 CSR 影响，那么就会发生隐式或是显式的 CSR 访问。比如说，在某些修改或受 CSR 影响的指令执行完之后，后续修改 CSR 或受 CSR 影响的指令执行之前，会产生 CSR 访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一条带有 CSR 读的指令，在指令执行之前会先读回 CSR 的状态&lt;/li&gt;
&lt;li&gt;对于一条带有 CSR 写的指令，在指令执行之后会更新 CSR 的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSR 的访问是 weakly ordered，所以其他 hart 观测 CSR 的顺序可能和程序中的顺序不一样，特别是，CSR 和 memory 的访问没有顺序关系，除非 CSR 会修改访问 memory 指令的执行，或者是使用特权指令集中定义的 Memory-Ordering PMAs 做了明确的顺序要求。对于 FENCE 指令来说，CSR 读被当作设备输入 (I)，CSR 写被当作设备输出 (O)。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 按照第二卷中 Memory-Ordering PMAs 章节定义的 weakly ordered memory-mapped I/O region 模型操作，所以 CSR 的访问顺序和 memory-mapped I/O 访问的约束一致。&lt;/p&gt;
&lt;p&gt;对 CSR 的顺序设置约束的原因是为了支持对主存及 memory-mapped I/O 访问和 time CSR 的排序。除了 &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;cycle&lt;/code&gt;, &lt;code&gt;mycle&lt;/code&gt; 这三类 CSR，两卷标准中定义的其他 CSR 都对其他 hart 不可见，所以这些 CSR 的访问顺序和 FENCE 的顺序可以是任意顺序，都是符合标准的。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="counter"&gt;Counter&lt;/h2&gt;
&lt;p&gt;RISC-V 定义了 32 个 64bit 的 Unpriviledge 只读性能计数器和计时器，其中前 3 个有特定的含义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CSR 名字&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CYCLE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 执行到当前的周期数，使用 RDCYCLE[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TIME&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 的 wall-clock 周期数，使用 RDTIME[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;INSTRET&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 退休的总指令数量，使用 RDINSTRET[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以通过一组非特权指令通过 0xC00-0xC1F 地址访问（高 32bit 可以用 0xC80-0xC9F 访问）这些计数器 / 计时器。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这个子集之前是在 RV32I 中，后来分离出来单独作为一个子集，目前是 draft 2.0 版本，目测以后也不会大改。&lt;/p&gt;
&lt;p&gt;在 V2.2 版本中这 3 个 CSR 指令作为 RV32I 的一部分是强制实现的，但是现在独立后就不是强制性的了，但是还是推荐实现这 3 个 CSR，因为它们对于基本的性能分析、自适应、动态优化来说是必不可少的。而且也应该以较小的代价实现其他计数器，来辅助诊断性能问题。&lt;/p&gt;
&lt;p&gt;这些计数器必须是 64bit，即使是 RV32I 也是如此，否则位宽太少软件很难判断是否发生了 overflow。（简单算一下就知道 64bit 的表示范围非常大，可以覆盖任何性能计数的需求）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;剩余的 29 个 CSR 名称为 &lt;code&gt;hpmcounter3&lt;/code&gt;-&lt;code&gt;hpmcounter31&lt;/code&gt;（hardware performance counter），它们作为可编程的计数器能针对某些事件进行计数，这些计数器可以通过特权指令来配置。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;特权架构中定义了访问和配置这些 hpm 的 privileged CSR，这些 hpm 可以用来对一些硬件指标做统计，比如执行的 F 指令条数，L1 I$ 的 miss 次数等等。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="m-extension"&gt;M Extension&lt;/h2&gt;
&lt;p&gt;把乘除法指令从 I 子集中分离出来，可以简化低端 core 的实现，或者对于那些乘除法不常出现的应用，用另外一个加速器来实现。&lt;/p&gt;
&lt;p&gt;如果同时需要乘法结果的高低两部分，推荐使用下面的顺序，同时保证 rs1 和 rs2 的值和顺序不变，且 rdh != rs1 or rs2：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;MULH&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="no"&gt;S&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdh&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;span class="nf"&gt;MUL&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="no"&gt;rdl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样硬件实现时会把它们融合成一条指令来执行，只进行一次乘法。&lt;/p&gt;
&lt;p&gt;同理，除法也可以按照类似的方法实现，硬件实现时只会进行一次除法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;DIV&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;span class="nf"&gt;REM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MUL 不需要（没必要）区分 signed/unsigned，MULH 则需要区分 singed/unsigned&lt;/li&gt;
&lt;li&gt;大多数 ISA 中除以 0 都会触发异常，跳转到 trap，但是 RISC-V 做了简化，不会产生异常，可以简化硬件实现&lt;/li&gt;
&lt;li&gt;RISC-V 的所有的计算指令都不会产生 exception&lt;/li&gt;
&lt;li&gt;RISC-V 虽然不会产生 exception，但是对除 0 的结果做了特殊规定：商的所有 bit 设置为全 1&lt;/li&gt;
&lt;li&gt;设置为全 1 是精心设计过的：对于无符号除法来说，全 1 就是最大值，而且也天然符合硬件除法器的输出，无需任何修改；对于有符号除法来说，一般都是先转成无符号来算，所以也没有问题。这样设计可以最大程度地简化硬件设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="a-extension"&gt;A Extension&lt;/h2&gt;
&lt;p&gt;A 子集包含了对 memory 进行原子性的 read-modify-write 操作的指令，目的是同步多个共享同一个 memory 空间的不同 hart。
A 指令支持 unordered, acquire, release, sequentially 等各种内存一致性模型，这些指令可以让 RISC-V 支持 RCsc 存储器一致性模型。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;经过大量辩论后，编程语言社区和体系结构社区最后达成一致：用 release consistency 作为存储器一致性模型，所以围绕着这个模型建立了 A 子集。&lt;/p&gt;
&lt;p&gt;背景知识：3 种最有代表性的内存一致性模型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;访问 memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;按序一致性模型 Sequential Consistency Model&lt;/td&gt;
&lt;td&gt;每个 hart 看到的都是 program-order&lt;/td&gt;
&lt;td&gt;原子性、串行化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;松散一致性模型 Relaxed Consistency Model&lt;/td&gt;
&lt;td&gt;每个 hart 可以改变自己的存储器访问顺序&lt;/td&gt;
&lt;td&gt;性能、功能 balance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;释放一致性模型 Release Consistency Model&lt;/td&gt;
&lt;td&gt;支持 acquire-release 机制&lt;/td&gt;
&lt;td&gt;更加松散&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;已知 base 子集使用的是 relaxed 模型，配合 FENCE 指令可以实现额外的顺序控制。但是为了更加高效地支持 release 模型，每个 A 指令都新增了两 bit：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ac&lt;/code&gt; 字段：表明本指令是 acquire 访问（上锁），屏障了它之后的 memory 操作，即在它之后的 memory 访问必须要等到这条 A 指令结束后才能开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rl&lt;/code&gt; 字段：表明本指令是 release 访问（释放锁），屏蔽了它之前的 memory 操作，即它必须等前面的 memory 访问都结束了才能开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果两个字段都是 0, 则这条 A 指令没有任何附加的约束；如果两个字段都是 1，则这条 A 指令是 sequential 模型，只能在前序指令结束、后序指令开始前执行。&lt;/p&gt;
&lt;p&gt;A 子集主要包含两大类指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Atomic Memory Operations, &lt;code&gt;AMO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些指令都是原子性的，也就是说读回数据和写回结果这段时间内这个地址不允许其他任何指令访问，也就是对这个地址 “ 上锁 ”。AMO 指令要求必须是对齐访问（32-bit 数据按照 4-byte 对齐；64-bit 数据要求按照 8-byte 对齐），否则会产生异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;设计 AMO 指令的原因是在高度并行系统中它比 LR/SC 指令的伸缩性更好。对于简单实现，可以直接用 LR/SC 来等价实现 AMO；而对于一个复杂实现，可以在 memory 控制器中实现 AMO 指令，而且如果 rd = x0 时可以优化掉读 memory 的操作。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;AMO 可以用来实现 memory 中的 parallel reductions，还可以用来更新 I/O 设备映射出的寄存器（比如 setting, clearing, toggle 比他位）。&lt;/p&gt;
&lt;p&gt;通过设置 ac/rl 字段，AMO 可以用来高效地实现 C11/C++ 11 中的 atmic memory operations。虽然 &lt;code&gt;FENCE R, RW&lt;/code&gt; 可以实现 acquire 效果，&lt;code&gt;FENCE RW, W&lt;/code&gt; 可以实现 release 效果，但是和 AMO 比起来引入了不必要的额外约束，所以 AMO 实现更加高效。&lt;/p&gt;
&lt;p&gt;下面是一个自旋锁的例子，整个流程就是 test-and-test-and-set，先测试锁是否可获取，如果可以就尝试获取，尝试完了测试是否获取成功，获取成功了就开始执行核心代码，核心代码执行完后再释放锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    li          t0, 1   # initialize swap value
again:
    lw            t1, (a0)      # load lock, lock is stored in a0 address
    bnez          t1, again     # check if lock is held
    amoswap.w.aq  t1, t0, (a0)  # attempt to acquire lock
    bnez          t1, again     # check agian
    # ...
    # critical section.
    # ...
    amoswap.w.r1  x0, x0, (a0)  # release lock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Load-Reserved/Store-Conditional, &lt;code&gt;LR&lt;/code&gt;/&lt;code&gt;SC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和 ARM 中的 Load-Exclusive/Store-Exclusive 类似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rvwmo-model"&gt;RVWMO Model&lt;/h2&gt;
&lt;h2 id="f-extension"&gt;F Extension&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="d-extension"&gt;D Extension&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="extending-risc-v"&gt;Extending RISC-V&lt;/h2&gt;
&lt;h2 id="isa-extension-naming-conventions"&gt;ISA Extension Naming Conventions&lt;/h2&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry></feed>