<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Qian's Blog</title><link href="https://qian-gu.github.io/" rel="alternate"></link><link href="https://qian-gu.github.io/feeds/all.atom.xml" rel="self"></link><id>https://qian-gu.github.io/</id><updated>2025-10-11T23:30:00+08:00</updated><subtitle>Read &gt;&gt; Think &gt;&gt; Write</subtitle><entry><title>《Attention Is All You Need》 笔记</title><link href="https://qian-gu.github.io/posts/algorithm/attention-is-all-you-need-bi-ji.html" rel="alternate"></link><published>2025-10-11T23:30:00+08:00</published><updated>2025-10-11T23:30:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2025-10-11:/posts/algorithm/attention-is-all-you-need-bi-ji.html</id><summary type="html">&lt;p&gt;Transformer 论文笔记。&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#backgroud"&gt;Backgroud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#model-architecture"&gt;Model Architecture&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#encoder-and-decoder-stack"&gt;encoder and decoder stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#attention"&gt;Attention&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#scaled-dot-product-attention"&gt;Scaled Dot-Product Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#multi-head-attention"&gt;Multi-Head Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#multi-head-attention-in-model"&gt;Multi-head Attention in Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#point-wise-feed-forward-networks"&gt;Point-wise Feed-Forward Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#embedding-and-softmax"&gt;Embedding and Softmax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#positional-embedding"&gt;Positional Embedding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#why-self-attention"&gt;Why Self-Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#result"&gt;Result&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;Ref&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景知识：encoder-decoder&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;encoder-decoder 模型是 NLP 领域的概念，不是指具体的算法，而是一类算法的统称，是一个通用框架，在这个框架下可以使用不同算法解决不同任务。&lt;/p&gt;
&lt;p&gt;encoder 的作用：将现实问题转化为数学问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="encoder" src="/images/attention-is-all-you-need-note/encoder.png.webp"&gt;&lt;/p&gt;
&lt;p&gt;decoder 的作用：将数学问题转化为现实问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="decoder" src="/images/attention-is-all-you-need-note/decoder.png.webp"&gt;&lt;/p&gt;
&lt;p&gt;两个连在一起：&lt;/p&gt;
&lt;p&gt;&lt;img alt="encoder-decoder" src="/images/attention-is-all-you-need-note/encoder-decoder.png.webp"&gt;&lt;/p&gt;
&lt;p&gt;需要注意的两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无论输入输出的长度是多少，中间向量 C 的长度固定，显然长序列会有数据损失。&lt;/li&gt;
&lt;li&gt;根据任务不同，encoder 和 decoder 可以用不同的视线，如 RNN，LSTM 或 GRU 等。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景知识：seq2seq&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;seq2seq 如字面意思，输入一个 sequence，输出一个 sequence，重点在于 sequence 的长度是可变的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="nmt-model-fast" src="/images/attention-is-all-you-need-note/nmt-model-fast.gif"&gt;&lt;/p&gt;
&lt;p&gt;典型的序列转换模型通常包括一个编码器（encoder）和一个解码器（decoder）。encoder 负责将输入序列编码成一个固定长度的隐状态表示，而 decoder 则利用这个隐状态表示生成目标序列。&lt;/p&gt;
&lt;p&gt;在这些模型中，循环神经网络（RNN）和卷积神经网络（CNN）是从前最常见的架构。然而，2017 年以来，基于注意力机制的 Transformer 架构（即本论文介绍的架构）因其并行计算能力和处理长距离依赖关系的优势，成为序列转换任务中的新宠。&lt;/p&gt;
&lt;p&gt;在 transformer 之前，主流方法是 RNN 或者 CNN，但是两者都有各自的缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RNN 通过隐藏状态可以记住所有历史，但是隐藏状态只能递归计算，无法并行化；&lt;/li&gt;
&lt;li&gt;CNN 可以并行计算，但是对长距离 token 之间相关性的建模能力很弱。它只能对 kernel size 内的 token 之间的相关性建模，如果需要建模长距离相关性，则必须级联很多层；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;transformer 试图结合两者的优点：既能建模长距离，又能并行化。&lt;/p&gt;
&lt;p&gt;Q：seq2seq 和 encoder-decoder 的区别：&lt;/p&gt;
&lt;p&gt;A：seq2seq 强调目的，encoder-decoder 强调方法，seq2seq 使用的方法基本上都属于 encoder-decoder 模型。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景知识：embedding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机要处理任何信息都必须先将其转化成数值，比如人类可以理解的单词，但是因为每个单词有多重属性，只转化出 1 个值能表达信息的能力有限，所以一般会转成多个值，这些值组合在一起形成 1 个向量，即该 token 的向量表示 &lt;code&gt;embedding vector&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景知识：attention&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;encoder-docoder 架构中的中间向量 C 是固定长度，所以对于长序列，压缩后的会有信息丢失，算法效果不好。attention 机制中的 encoder 编码完的结果不再是一个固定长度的中间向量 C，而是一个向量序列，这样就能解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="attention" src="/images/attention-is-all-you-need-note/attention-arch.png.webp"&gt;&lt;/p&gt;
&lt;p&gt;主要有两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有信息丢失。&lt;/li&gt;
&lt;li&gt;重要 token 和次要 token 权重不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;attention 机制和人类处理信息的方式类似：优先关注重要信息。我们阅读一段文字时，不会平均分配注意力到每个字上面，而是会重点阅读和问题（query）相关的文字（key 和 value）。&lt;/p&gt;
&lt;p&gt;attention 通过计算 query 和 key 的相似度，动态地调整对 input 的关注程度，所以能更有效地处理复杂任务。在数学上 attention 机制就是对 Source 中的元素的 Value 加权求和，而 Query 和 Key 用来计算对应 Value 的权重系数：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Attention(Query, Source) = \sum_{i=1}^{L_x}a_i * Value_i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class="math"&gt;\(L_x\)&lt;/span&gt; 表示序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(a_i = sofmax(Sim_i) = \frac{e^{Sim_i}}{\sum_{j=1}^{L_x}e^{Sim_j}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为两个 token 对应两个向量，所以衡量两个 token 之间的相似度 &lt;span class="math"&gt;\(Sim_i\)&lt;/span&gt; 也就变成了衡量两个向量之间的相似度。一般使用的方法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cos 相似度：&lt;span class="math"&gt;\(s(q, k) = \frac{q^T k}{\lvert q \rvert \cdot \lvert k \rvert}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;向量点积：&lt;span class="math"&gt;\(s(q, k) = q^T k\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;attention 一般分为下图的 3 个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，query 和 key 计算相似度，得到打分 score；&lt;/li&gt;
&lt;li&gt;第二步，将 score 归一化，得到每个 value 的 weight；&lt;/li&gt;
&lt;li&gt;第三步，用 weight 对 value 加权求和；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="attention" src="/images/attention-is-all-you-need-note/attention.png"&gt;&lt;/p&gt;
&lt;p&gt;注意：上图中的 query，key，value 可以是标量，也可以是向量。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RNN、LSTM、特别是 Gated Recurrent Neural Network 在语言建模和机器翻译等序列建模和转换任务中已经是公认的 SOTA 方法。业界有很多方法持续扩展递归语言模型和 encoder-decoder 架构的能力边界。&lt;/li&gt;
&lt;li&gt;循环模型一般沿着输入和输出进行计算，根据前一隐藏状态 &lt;span class="math"&gt;\(h_{t-1}\)&lt;/span&gt; 和当前位置 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 计算当前隐藏状态 &lt;span class="math"&gt;\(h_t\)&lt;/span&gt;，&lt;strong&gt;这种递归顺序阻碍了训练的并行化。特别是在长序列中更加明显，因为有限的内存阻碍了跨样本的 batch 并行处理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;尽管通过 factorization trick 和 conditional computation 可以大幅提高递归模型的计算效率，在某种情况下还提高了模型性能，但是递归的顺序计算约束仍然存在。&lt;/li&gt;
&lt;li&gt;在各种任务中，attention 机制已经成为序列模型和转换任务重不可或缺的组成部分，因为它可以在不考虑 sequence 中 token 的距离的情况下建立依赖关系。但是除了少数情况，大部分情况下 attention 都和循环网络结合使用。&lt;/li&gt;
&lt;li&gt;本文提出一种名为 &lt;code&gt;transformer&lt;/code&gt; 的新模型架构，完全抛弃了递归网络，只依赖 attention 机制捕捉输入输出之间的全局相关性。这种架构可以有更高的并行度，只需要在 8 个 P100 上训练 12 个小时就能在翻译任务上达到 SOTA。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="backgroud"&gt;Backgroud&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;减少顺序计算的需求也催生了 ByteNet 和 CONVS2S 等模型，它们都采用 CNN 作为基本 block，并行计算所有输入、输出之间的 hidden representation。&lt;/li&gt;
&lt;li&gt;但是这些模型中，在任意两个输入、输出位置之间建立相关性需要的操作数，会随着位置距离的增加而增加，在 ByteNet 中线性关系，在 CONVS2S 中为对数关系。所以学习远距离之间的依赖变得很困难。&lt;/li&gt;
&lt;li&gt;transformer 可以将这个复杂度降低为常数，但是代价是平均注意力 weight 可能会降低有效分辨率，我们通过 multihead attention 机制来克服这个问题。&lt;/li&gt;
&lt;li&gt;self-attention 是一种通过序列不同位置之间的相关性来计算序列 representation 的 attention 机制，应用在很多任务中。&lt;/li&gt;
&lt;li&gt;transformer 是第一个只依赖 attention 机制的模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="model-architecture"&gt;Model Architecture&lt;/h2&gt;
&lt;p&gt;大部分序列转换 model 都基于 encoder-decoder 架构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;encoder 把输入序列 &lt;span class="math"&gt;\((x_1, x_2, \dots, x_n)\)&lt;/span&gt; 转化为一个连续的向量表示 &lt;span class="math"&gt;\(z = (z_1, z_2, \dots, z_n)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;给定 &lt;span class="math"&gt;\(z\)&lt;/span&gt;，decoder 以一次生成 1 个字符的方式生成输出序列 &lt;span class="math"&gt;\((y_1, y_2, \dots, y_n)\)&lt;/span&gt;，每一步都是自回归的，即每次都会将之前的输出也作为输入的一部分；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;transformer 也遵循这样的结构，encoder 和 decoder 都基于堆叠的 self-attention 和 point-wise fc 层。&lt;/p&gt;
&lt;p&gt;&lt;img alt="model-arch" src="/images/attention-is-all-you-need-note/model-arch.png"&gt;&lt;/p&gt;
&lt;h3 id="encoder-and-decoder-stack"&gt;encoder and decoder stack&lt;/h3&gt;
&lt;p&gt;encoder 由 N = 6 个完全相同的 layer 堆叠组成，每个 layer 由 2 个 sub-layer 组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个 sub-layer 是 multi-head self-attention；&lt;/li&gt;
&lt;li&gt;第二个 sub-layer 是一个简单的 point-wise fc 前馈网络；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 sub-layer 的输出都采用 residual 连接后接一个 layer norm 层，最终输出为 &lt;span class="math"&gt;\(LayerNorm(x + sublayer(x))\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\(sublayer(x)\)&lt;/span&gt; 为 sub-layer 本身的函数功能。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;residual 的目的是防止网络退化；&lt;/li&gt;
&lt;li&gt;layer norm 的目的是对每一层的 activation 进行归一化；&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;为了实现 residual 连接，所有 sub-layer，包括 embedding 在内，输出维度均为 &lt;span class="math"&gt;\(d_{model} = 512\)&lt;/span&gt;，一般设置为训练时的最长 sequence 的 token 数量。&lt;/p&gt;
&lt;p&gt;decoder 也由 N = 6 个完全相同的 layer 堆叠组成，除了 encoder 中的两个 sub-layer 外，decoder 中还额外插入了第三个 sub-layer，该 sub-layer 对 encoder output 做 multi-head attention 处理。 &lt;/p&gt;
&lt;p&gt;和 encoder 类似，decoder 的每个 sub-layer 也使用 residual + layer norm 连接。此外 decoder 中的 self-attention 还做了特殊设计，以防止后续位置的信息被添加到当前位置信息中，这种 mask 机制和 embedding 的偏移机制相结合，可以确保位置 i 只依赖小于 i 的已知输出，保证了 decoder 的自回归性。&lt;/p&gt;
&lt;h3 id="attention"&gt;Attention&lt;/h3&gt;
&lt;p&gt;attention 机制是一种将 query 和 1 组 key-value pair 映射为 output 的过程，其中 query，keys, values，output 都是 vector。&lt;/p&gt;
&lt;p&gt;output 是 values 的加权求和，每个 value 的权重由 query 和对应的 key 的 competibility function 计算得到。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;本文用到 competibility function 是 dot-product。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="scaled-dot-product-attention"&gt;Scaled Dot-Product Attention&lt;/h4&gt;
&lt;p&gt;&lt;img alt="attention" src="/images/attention-is-all-you-need-note/multi-head-attention.png"&gt;&lt;/p&gt;
&lt;p&gt;本文的 attention 叫做 scaled dot-product attention：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入为 queries 和 keys，维度均为 &lt;span class="math"&gt;\(d_k\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;计算 queries 和所有 keys 之间的点乘计算相关性，然后除以 &lt;span class="math"&gt;\(\sqrt d_k\)&lt;/span&gt; 进行缩放；&lt;/li&gt;
&lt;li&gt;然后通过 softmax 得到每个 value 的权重；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际在 GPU 上跑时，多个 quries 打包成一个矩阵 &lt;span class="math"&gt;\(Q\)&lt;/span&gt; 后并行计算，同理 key 和 value 也打包成矩阵 &lt;span class="math"&gt;\(K\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(V\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Attention(Q, K, V) = softmax(\frac{QK^T}{\sqrt d_k}) V\)&lt;/span&gt;&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;attention 的矩阵形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第零步，输入序列被转化成 3 类数据 &lt;span class="math"&gt;\(Q\)&lt;/span&gt;，&lt;span class="math"&gt;\(K\)&lt;/span&gt;，&lt;span class="math"&gt;\(V\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;输入序列一共有 n 个 token，每个 token 被 embedding 映射成 1 个维度为 &lt;span class="math"&gt;\(d_{model}\)&lt;/span&gt; 的向量表示，则所有 token 的向量表示组合在一起形成一个矩阵 &lt;span class="math"&gt;\(X \in \mathbb{R}^{n \times d_{model}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;矩阵 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 分别和矩阵 &lt;span class="math"&gt;\(W^Q \in \mathbb{R}^{d_{model} \times d_{model}}\)&lt;/span&gt;，&lt;span class="math"&gt;\(W^K \in \mathbb{R}^{d_{model} \times d_{model}}\)&lt;/span&gt;，&lt;span class="math"&gt;\(W^V \in \mathbb{R}^{d_{model} \times d_{model}}\)&lt;/span&gt; 矩阵乘得到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(Q \in \mathbb{R}^{n \times d_{model}}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(K \in \mathbb{R}^{n \times d_{model}}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(V \in \mathbb{R}^{n \times d_{model}}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="QKV" src="/images/attention-is-all-you-need-note/QKV.png"&gt;&lt;/p&gt;
&lt;p&gt;第一步，打分。计算 query 和 keys 之间的相似度，可以通过 dot-product 完成。相似度越高，说明这个 key 和 query 越相关。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(QK^T \in \mathbb{R}^{n \times n}\)&lt;/span&gt;，每一行的每个 element 表示该行 token 与所有 token 之间的相关性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="QKT" src="/images/attention-is-all-you-need-note/QKT.png"&gt;&lt;/p&gt;
&lt;p&gt;第二步，计算权重。将这些相似度通过 softmax 函数转化为概率权重。&lt;/p&gt;
&lt;p&gt;sofmax 后矩阵维度不变，仍为 &lt;span class="math"&gt;\(n \times n\)&lt;/span&gt;，每 1 行对应一个 token 与其他 token 的相关性，每个行向量求和是 1。&lt;/p&gt;
&lt;p&gt;&lt;img alt="softmax" src="/images/attention-is-all-you-need-note/softmax.png"&gt;&lt;/p&gt;
&lt;p&gt;第三步，加权求和。用这些权重对所有 value 进行加权求和，相关性强的 value 向量权重大，相关性弱的 value 向量权重小。这样模型就输出了一个综合所有相关值的信息，而且突出了重要信息而忽略了不相关信息。&lt;/p&gt;
&lt;p&gt;用每个行向量和 V 矩阵的对应行相乘，行向量的 element 广播乘 V 矩阵的行向量，如 element0 和 V 矩阵第一个行向量做广播乘，element1 和 V 矩阵第二个行向量做广播乘，依次类推。这些加权后的 value 向量之间做 elementwise 的求和，结果是一个行向量，维度为 &lt;span class="math"&gt;\(1 \times d_{model}\)&lt;/span&gt;，为输入 token 的编码输出结果。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Z1" src="/images/attention-is-all-you-need-note/Z1.png"&gt;&lt;/p&gt;
&lt;p&gt;因为一共有 n 个 token，所以输出矩阵的维度为 &lt;span class="math"&gt;\(n \times d_{model}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Z" src="/images/attention-is-all-you-need-note/Z.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看出来，每个 token 的输出向量不再是独立的，而是包含了上下文信息。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;最常见的 attention 有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;additive attention：用一个单层的前馈网络计算兼容性；&lt;/li&gt;
&lt;li&gt;dot-product attention：和本文的 scaled dot-prodcut attention 相似，唯一的区别是不包含除以缩放因子 &lt;span class="math"&gt;\(\sqrt d_k\)&lt;/span&gt; 的步骤；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管两种 attention 的计算量相同，但是 dot-product attention 要快得多，空间效率也更高，因为它可以利用高度优化的矩阵乘代码加速。&lt;/p&gt;
&lt;p&gt;Q：为什么需要缩放因子？&lt;/p&gt;
&lt;p&gt;A：当 &lt;span class="math"&gt;\(d_k\)&lt;/span&gt; 很大时，点积的幅值会很大，导致 softmax 的梯度非常小，所以需要除以 &lt;span class="math"&gt;\(\sqrt d_k\)&lt;/span&gt;。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;比如 q 和 k 都是均值为 0，方差为 1 的向量，则它们的点积的均值为 0，方差为 &lt;span class="math"&gt;\(d_k\)&lt;/span&gt;，为了抵消这种影响，需要将点积缩放 &lt;span class="math"&gt;\(\frac{1}{\sqrt d_k}\)&lt;/span&gt; 倍。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="multi-head-attention"&gt;Multi-Head Attention&lt;/h4&gt;
&lt;p&gt;相比于维度为 &lt;span class="math"&gt;\(d_{model}\)&lt;/span&gt; 的单头 attention，multi-head 能更有效地捕捉信息，因为 multi-head 能同时关注到不同位置的多种特征信息，相比之下只有一个 head 则平均化了这些信息，从而限制了模型的表达能力。&lt;/p&gt;
&lt;p&gt;multi-head attention 算法过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把 queries，keys，values 分别 linear projection 映射 h 次，每次用不同的学习到的参数，且每次映射后的 queries，keys，values 的维度缩小为 &lt;span class="math"&gt;\(d_k\)&lt;/span&gt;，&lt;span class="math"&gt;\(d_k\)&lt;/span&gt;，&lt;span class="math"&gt;\(d_v\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;在每次映射后的 queries，keys，values 版本上的计算 attention，每次产生 &lt;span class="math"&gt;\(d_v\)&lt;/span&gt; 维的 output；&lt;/li&gt;
&lt;li&gt;将这些 output concat 到一起后再做一次 linear projection，得到最终 output；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(MultiHead(Q, K, V) = Concat(head_1, head_2, \dots, head_h)W^O\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(head_i = Attention(QW_i^Q, KW_i^K, VW_i^V)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(W^Q \in \mathbb{R}^{d_{model} \times d_k}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(W^K \in \mathbb{R}^{d_{model} \times d_k}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(W^V \in \mathbb{R}^{d_{model} \times d_v}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(W^O \in \mathbb{R}^{hd_v \times d_{model}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在本文中 &lt;span class="math"&gt;\(h = 8\)&lt;/span&gt;，&lt;span class="math"&gt;\(d_k = d_v = d_{model}/h = 64\)&lt;/span&gt;，因为每个 head 的维度都变小了，所以总计算量和单一 attention 近似相同。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;从 &lt;span class="math"&gt;\(W^Q\)&lt;/span&gt;，&lt;span class="math"&gt;\(W^K\)&lt;/span&gt;，&lt;span class="math"&gt;\(W^V\)&lt;/span&gt;，&lt;span class="math"&gt;\(W^O\)&lt;/span&gt; 的维度可以看出来，multi-head 就是将单 head 的大维度 &lt;span class="math"&gt;\(d_{model}\)&lt;/span&gt; 等分成了 h 份，分别算出各自的 attention output 后重新 concat 到一起恢复出原来的大维度。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img alt="decoder" src="/images/attention-is-all-you-need-note/transformer_multi-headed_self-attention-recap.png"&gt;&lt;/p&gt;
&lt;h4 id="multi-head-attention-in-model"&gt;Multi-head Attention in Model&lt;/h4&gt;
&lt;p&gt;transformer 以 3 种方式应用 multi-head attention：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;encoder-decoder attention：queries 来自前一个 decoder layer，而 keys 和 values 来自 encoder output，这样使得 decoder 的每个位置都能关注到所有输入位置。&lt;/li&gt;
&lt;li&gt;encoder 中的 self-attention：所有的 queries，keys 和 values 都来自同一个地方 —— 前一个 encoder layer 的输出。encoder layer 中的每个位置都能关注到前一个 attention layer 的所有位置。&lt;/li&gt;
&lt;li&gt;decoder 中的 self-attention：所有位置都能关注到当前位置及以前位置，为了保持 decoder 的自回归性，需要阻止 decoder 中的信息向左流动。具体是通过 mask 将 softmax 的非法输入的值改为 &lt;span class="math"&gt;\(-\infty\)&lt;/span&gt; 来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;一般的 encoder-decoder 架构中 source 和 target 不同，attention 发生在 target 的 query 和 source 的所有 key，value 之间，而 self-attention 发生在 source 内部，或者 target 内部。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;单个 output token 的产生过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="decoder-1" src="/images/attention-is-all-you-need-note/transformer_decoding_1.gif"&gt;&lt;/p&gt;
&lt;p&gt;多个 output token 自回归过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="decoder-2" src="/images/attention-is-all-you-need-note/transformer_decoding_2.gif"&gt;&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;encoder stack 的最终输出是 K，V 矩阵，用于每个 decoder 的 encoder-decoder attention。所有 encoder 只在训练时有用，推理时只需要 decoder 就足够了。&lt;/p&gt;
&lt;p&gt;Q：decoder attention 仍然是 attention，每次输出一个 token 对应的一个维度为 &lt;span class="math"&gt;\(1 \times d_{model}\)&lt;/span&gt; 的向量，如何从这个向量得到输出 token？&lt;/p&gt;
&lt;p&gt;A：linear + softmax。&lt;/p&gt;
&lt;p&gt;首先 linear，即 fc 层，将 decoder 的输出 vector 映射为一个非常非常大的 logits vector，该 vector 的维度即 model 的字典大小，每个值表示对应字的 score。&lt;/p&gt;
&lt;p&gt;其次，softmax 将每个 score 转化为概率，然后选择概率最大的字输出。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="point-wise-feed-forward-networks"&gt;Point-wise Feed-Forward Networks&lt;/h3&gt;
&lt;p&gt;每个 encoder layer 和 decoder layer 中除了 attention sub-layer 之外，还包含一个 FFN。该网络结构为两个线性变换中间插入了一个 ReLU。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(FFN(x) = max(0, xW_1 + b_1)W_2 + b_2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然所有位置都使用相同的线性变换公式，但是每层不同位置的 weight 都不同，所以这个线性变换也可以当成是 k=1 的 convolution。&lt;/p&gt;
&lt;p&gt;输入、输出的 &lt;span class="math"&gt;\(d_{model} = 512\)&lt;/span&gt;，中间层的维度为 &lt;span class="math"&gt;\(d_{ff} = 2048\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id="embedding-and-softmax"&gt;Embedding and Softmax&lt;/h3&gt;
&lt;p&gt;和其他序列转换模型类似，本文也通过 learned embedding 将输入、输出 token 映射成维度为 &lt;span class="math"&gt;\(d_{model}\)&lt;/span&gt; 的 vector。&lt;/p&gt;
&lt;p&gt;本文也使用常见的基于 learned linear transformation 和 softmax 将 decoder 的输出转化为下一个 token 出现的概率。&lt;/p&gt;
&lt;p&gt;在我们的模型中，两个 embedding layer 和 pre-softmax linear transformation 共享相同的 weight，其中 embedding layers 给 weight 乘以 &lt;span class="math"&gt;\(\sqrt{d_{model}}\)&lt;/span&gt; 进行了缩放。&lt;/p&gt;
&lt;h3 id="positional-embedding"&gt;Positional Embedding&lt;/h3&gt;
&lt;p&gt;因为网络中没有 RNN 和 CNN，所以为了建模序列的顺序信息，必须注入序列中 token 的相对和绝对位置信息，具体方法是：&lt;/p&gt;
&lt;p&gt;将 positional embedding 添加到 encoder 和 decoder 的 embedding layer 中，而且 positional embedding 的维度也为 &lt;span class="math"&gt;\(d_{model}\)&lt;/span&gt;，以便两者可以求和。&lt;/p&gt;
&lt;p&gt;positional embedding 的方法有很多种（学习到的 or 固定参数的），本文使用的方法是不同频率的 sin 和 cos 函数：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(PE_{(pos, 2i)} = sin(pos/1000^{2i/d_{model}})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(PE_{(pos, 2i+1)} = cos(pos/1000^{2i/d_{model}})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class="math"&gt;\(pos\)&lt;/span&gt; 为 position，&lt;span class="math"&gt;\(i\)&lt;/span&gt; 为 dimension。即 position embedding 的每个维度都是一个 sin 曲线。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;选择 sin 曲线的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sin 函数是一个周期函数，当 sequence 变得比训练 sequence 更长时也能算出来；&lt;/li&gt;
&lt;li&gt;可以很容易地根据相对位置算出 positional embedding：&lt;span class="math"&gt;\(sin(A+B) = sin(A)cos(B) + cos(A)sin(B)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;positional embedding 的值是直接 element-wise 加到 embedding 的值上面的，而不是 concat。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;试验表明 learned 方式效果相同，但是我们选择了 sin 函数的版本，因为它使模型更能适应比训练更长的序列。&lt;/p&gt;
&lt;h2 id="why-self-attention"&gt;Why Self-Attention&lt;/h2&gt;
&lt;p&gt;本文对比了 self-attention layer 和其他序列转换 encoder-decoder 中常见的 RNN/CNN layer，基于以下 3 点考虑最终选择了 self-attention。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每层的计算量；&lt;/li&gt;
&lt;li&gt;可并行计算的比例，通过所需的最小顺序计算量来衡量；&lt;/li&gt;
&lt;li&gt;网络中 long-range dependencies 之间的 path-length（序列转换中的关键挑战，path-length 越短模型学习 long-range dependencies 的能力越强）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="complex" src="/images/attention-is-all-you-need-note/complex.png"&gt;&lt;/p&gt;
&lt;p&gt;对于第二点顺序计算量：&lt;/p&gt;
&lt;p&gt;self-attention 连接了任意两个位置，所以任意两个位置之间相关性的顺序计算量为常数 O(1) ，即只需要一步就可以得到，而 RNN 需要迭代 O(n) 次顺序操作才能得到；&lt;/p&gt;
&lt;p&gt;对于第一点计算量：&lt;/p&gt;
&lt;p&gt;当序列长度 n &amp;lt; 表示维度 d 时，self-attention 比 RNN 更快。一般来说都满足这个条件。对于很长的序列，则 self-attention 不如 RNN，但是这个问题可以通过限制 self-attention 的半径来解决。&lt;/p&gt;
&lt;p&gt;kernel 大小 k &amp;lt; n 的 conv 无法连接所有的 input-ouput pair，如果要实现这个目标，需要级联 O(n/k) 个 conv 或者 &lt;span class="math"&gt;\(O(log_k(n))\)&lt;/span&gt; 个 dilated conv。一般来说 conv 的复杂度约为 RNN 的 k 倍。separable conv 可以降低复杂度到 &lt;span class="math"&gt;\(O(k \cdot n \cdot d + n \cdot k^2)\)&lt;/span&gt;，当 n = k 时，它的复杂度和本文所用的 self-attention + point-wise forward layer 相同。&lt;/p&gt;
&lt;p&gt;self-attention 的另外一个好处是模型更加可解释，不仅每个 head 学习到不同的任务，多个 head 还表现出和句子语法和语义相关的行为。&lt;/p&gt;
&lt;h2 id="result"&gt;Result&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;单一 head 比 multi-head 差；&lt;/li&gt;
&lt;li&gt;head 数量过多也会变差；&lt;/li&gt;
&lt;li&gt;减小 &lt;span class="math"&gt;\(d_k\)&lt;/span&gt; 会损害效果，设计比点积更复杂的 competibility function 可能是有益的；&lt;/li&gt;
&lt;li&gt;更大的模型一般效果更好；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;本文提出了 transformer 网络：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个完全基于 attention 的序列转换模型，用 multi-head self-attention 代替传统 encoder-decoder 中的 recurrent layer；&lt;/li&gt;
&lt;li&gt;对于翻译任务，transformer 的训练速度明显比其他基于 RNN 和 CNN 的模型更快，翻译效果 SOTA；&lt;/li&gt;
&lt;li&gt;计划将 transformer 扩展到除 text 之外其他模态的应用中；&lt;/li&gt;
&lt;li&gt;计划研究 local，restricted transformer 来处理大数据量的 input/output，比如 image，audio，video；&lt;/li&gt;
&lt;li&gt;另外一个研究目标：让生成过程尽量避免顺序执行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://easyai.tech/ai-definition/encoder-decoder-seq2seq/"&gt;Encoder-Decoder 和 Seq2Seq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://jalammar.github.io/illustrated-transformer/"&gt;The Illustrated Transformer&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Algorithm"></category><category term="Transformer"></category><category term="Attention"></category></entry><entry><title>开源 IC 工具/库 —— verible</title><link href="https://qian-gu.github.io/posts/tools/verible.html" rel="alternate"></link><published>2025-05-29T01:17:00+08:00</published><updated>2025-05-29T01:17:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2025-05-29:/posts/tools/verible.html</id><summary type="html">&lt;p&gt;总结 verible 的常用使用方法&lt;/p&gt;</summary><content type="html">&lt;h2 id="verible"&gt;Verible&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/chipsalliance/verible"&gt;verible&lt;/a&gt; 是一个由 Chips Alliance 开发的 SystemVerilog 开发者工具套件，包括解析器、风格检查器、格式化工具和语言服务器。Verible 的主要任务是解析 SystemVerilog（IEEE 1800-2017），适用于多种应用场景，如开发者工具。它支持解析未经预处理的源文件，适用于单文件应用，如风格检查和格式化。此外，Verible 还可以适应解析预处理的源文件，这是真实编译器和工具链所需要的。&lt;/p&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;从源码编译要安装一大堆工具，最省事的方法是从 github 上下载最新 release 的二进制文件，下载后把路径添加到 &lt;code&gt;$PATH&lt;/code&gt; 变量即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;export&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;/.local/verible/bin:&lt;span class="nv"&gt;$PATH&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;命令行能自动补全则说明安装成功。&lt;/p&gt;
&lt;h3 id="formatter"&gt;Formatter&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;--helpfull&lt;/code&gt; 选项查看 formatter 支持的选项，大部分都顾名思义，其中有个别选项含义有点模糊，记录如下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--column_limit&lt;/code&gt; 看名字似乎是 format 自动 wrap 代码到最大列，实际上并不是。这个 flag 设置了 formatter 生效的最大列宽，当代码列宽超过这个值时就会停止 format，不再对后续 line 做 format。所以还是需要我们自己手动 wrap 或者依靠编辑器自动换行。&lt;/p&gt;
&lt;p&gt;虽然不能自动插入换行，但是 formatter 可以自动删除冗余的换行，把多行合并成一行（所谓的换行是冗余的，就是删除多行之间的换行后合并成的一行仍然没有超过 column_limit）。如果多行合并后超出了 column_limit，则完全不进行合并。比如一个 assign 语句分成了 3 行写，每行的列宽分别为 70，5，10，且设置的 column_limit 为 80，那么因为 70+5+10 &amp;gt; 80，即使 70+5 &amp;lt; 80，也并不会合并前两行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--line_break_penalty&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--over_column_limit_penalty&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--wrap_spaces&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--named_parameter_alignment&lt;/code&gt;：子模块例化时 parameter 传参括号的对齐位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--named_parameter_indentation&lt;/code&gt;：子模块例化时 port 括号的对齐位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--port_declarations_right_align_packed_dimensions&lt;/code&gt;：packed array port 向右对齐，即最低维度对齐。（很有用）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--port_declarations_right_align_unpacked_dimensions&lt;/code&gt;：unpacked array port 向右对齐，即最低维度对齐。（很有用）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--try_wrap_long_lines&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和其他工具的集成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vs code：插件 SystemVerilog and Verilog Formatter&lt;/li&gt;
&lt;li&gt;vim：neoformat&lt;/li&gt;
&lt;/ul&gt;</content><category term="Tools"></category><category term="IC-tools"></category><category term="verible"></category></entry><entry><title>深入理解 C 指针读书笔记</title><link href="https://qian-gu.github.io/posts/cs/understanding-and-using-c-pointers-notes.html" rel="alternate"></link><published>2024-04-14T16:55:00+08:00</published><updated>2024-04-14T16:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2024-04-14:/posts/cs/understanding-and-using-c-pointers-notes.html</id><summary type="html">&lt;p&gt;总结 C 指针用法&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;第一章 认识指针&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;指针和内存&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;为什么要精通指针？（指针的用途）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;声明指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;如何阅读声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;地址操作符 &amp;amp;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;间接引用操作符 *&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;指向函数的指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#null"&gt;null 的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#void"&gt;void 指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;全局和静态指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_10"&gt;指针的长度和类型&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#size_t"&gt;size_t&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#intptr_t-uintptr_t"&gt;intptr_t  和 uintptr_t&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_11"&gt;指针操作符&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_12"&gt;指针算术运算&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_13"&gt;指针常见用法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_14"&gt;多层间接引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_15"&gt;常量与指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#c"&gt;第二章 C 的动态内存管理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_16"&gt;动态内存分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_17"&gt;迷途指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_18"&gt;第三章 指针和函数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_19"&gt;程序的栈和堆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_20"&gt;通过指针传递和返回数据&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_21"&gt;修改实参&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_22"&gt;只读实参&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_23"&gt;返回指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_24"&gt;传递指针的指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_25"&gt;函数指针&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_26"&gt;声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_27"&gt;使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_28"&gt;第四章 指针和数组&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_29"&gt;数组概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_30"&gt;指针表示法和数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_31"&gt;传递一维数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_32"&gt;指针数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_33"&gt;指针和多维数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_34"&gt;传递多维数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_35"&gt;第五章 指针和字符串&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_36"&gt;字符串基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_37"&gt;字符串声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_38"&gt;字符串字面量池&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_39"&gt;字符串初始化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_40"&gt;标准字符串操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_41"&gt;传递字符串&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_42"&gt;参数声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_43"&gt;传递参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_44"&gt;返回字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_45"&gt;函数指针和字符串的例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_46"&gt;第六章 指针和结构体&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_47"&gt;声明结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_48"&gt;结构体对齐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_49"&gt;释放结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mallocfree"&gt;避免 malloc/free 开销&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_50"&gt;指针和结构体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_51"&gt;第七章 安全问题和指针误用&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_52"&gt;指针的声明和初始化问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_53"&gt;指针的使用问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_54"&gt;内存释放问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_55"&gt;使用静态工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_56"&gt;第八章 其他重要内容&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_57"&gt;指针类型转化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#restrict"&gt;别名、强别名和 restrict 关键字&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_58"&gt;别名&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_59"&gt;强别名&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#restrict_1"&gt;restrict 关键字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_60"&gt;线程和指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_61"&gt;面向对象&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_62"&gt;不透明指针实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#c_1"&gt;C 中的多态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_63"&gt;读书感悟&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;第一章 认识指针&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;理解指针的关键在于理解 C 程序如何管理内存。归根结底，指针包含的就是内存地址。不理解组织和管理内存的方式，就很难理解指针的工作方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_2"&gt;指针和内存&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;内存类型&lt;/th&gt;
&lt;th&gt;作用域&lt;/th&gt;
&lt;th&gt;生命周期&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;全局内存&lt;/td&gt;
&lt;td&gt;整个文件&lt;/td&gt;
&lt;td&gt;应用程序的生命周期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;静态内存&lt;/td&gt;
&lt;td&gt;声明它的函数内部&lt;/td&gt;
&lt;td&gt;应用程序的生命周期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动内存（局部内存）&lt;/td&gt;
&lt;td&gt;声明它的函数内部&lt;/td&gt;
&lt;td&gt;函数执行时间内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动态内存&lt;/td&gt;
&lt;td&gt;由引用该内存的指针决定&lt;/td&gt;
&lt;td&gt;直到内存释放&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;指针变量包含内存中别的变量、对象或函数的地址。对象就是内存分配函数（比如 malloc）分配的内存。指针通常根据所指的数据类型来声明。对象可以是任何 C 数据类型，如整数、字符、字符串或结构体。然而，指针本身并没有包含所引用数据的类型信息，指针只包含地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_3"&gt;为什么要精通指针？（指针的用途）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;写出快速高效的代码&lt;/li&gt;
&lt;li&gt;为解决很多类问题提供方便的途径&lt;/li&gt;
&lt;li&gt;支持动态内存分配&lt;/li&gt;
&lt;li&gt;使表达式变得紧凑和简洁&lt;/li&gt;
&lt;li&gt;提供用指针传递数据结构的能力而不会带来庞大的开销&lt;/li&gt;
&lt;li&gt;保护作为参数传递给函数的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用指针可以写出快速高效的代码是因为指针更接近硬件。也就是说，编译器可以更容易地把操作翻译成机器码。指针附带的开销一般不像别的操作符那样大。&lt;/p&gt;
&lt;p&gt;紧凑的表达式有很强的表达能力，但也比较晦涩，因为很多程序员并不能完全理解指针表示法。紧凑的表达式应该用来满足特定的需要，而不是为了晦涩而晦涩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_4"&gt;声明指针&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 星号两边的空格无关紧要，下面的几个声明是等价的。空白符的使用是个人喜好&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;星号将变量声明为指针。这是一个重载过的符号，因为它也用在乘法和解引指针上。&lt;/p&gt;
&lt;p&gt;指针的实现中没有内部信息表明自己指向的是什么类型的数据或者内容是否合法。&lt;/p&gt;
&lt;p&gt;尽管不经过初始化就可以使用指针，但只有初始化后，指针才会正常工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;任何变量都有两个熟悉：value 和 address，指针变量的 value = 被指向对象的地址。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;指针变量的类型是 &lt;strong&gt;指针&lt;/strong&gt;，如 &lt;code&gt;int *&lt;/code&gt; 和 &lt;code&gt;char *&lt;/code&gt; 等。虽然有些系统中，&lt;code&gt;int*&lt;/code&gt; 和 &lt;code&gt;int&lt;/code&gt; 都是 32bit 数据，但是它们的类型不同，所以不能直接把 &lt;code&gt;int&lt;/code&gt; 变量赋值给 &lt;code&gt;int *&lt;/code&gt; 指针。但是可以强转后赋值，即 &lt;code&gt;int *pi = (int *)num&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;为了避免解引用未初始化的指针导致错误，声明指针变量时尽快初始化是一个好习惯。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="_5"&gt;如何阅读声明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;倒过来读。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 1. pci 是一个变量&lt;/span&gt;
&lt;span class="c1"&gt;// 2. pci 是一个指针变量&lt;/span&gt;
&lt;span class="c1"&gt;// 3. pci 是一个指向整数的指针变量&lt;/span&gt;
&lt;span class="c1"&gt;// 4. pci 是一个指向整数常量的指针变量&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="_6"&gt;地址操作符 &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;因为指针保存的 value 是地址，所以 可以用地址操作符来给指针赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于 &lt;code&gt;int *pi&lt;/code&gt; 来说，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何变量，直接引用表示取该变量的 value，即指针变量 pi 指向的变量的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;pi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任何变量，地址操作符返回该变量的 address，取指针变量 pi 自身的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_7"&gt;间接引用操作符 &lt;code&gt;*&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 返回指针变量指向的对象的 value，这个过程叫做指针解引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// print 5&lt;/span&gt;
&lt;span class="c1"&gt;// 解引用的结果既可以当左值，又可以当右值。&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// print 200&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="_8"&gt;指向函数的指针&lt;/h4&gt;
&lt;p&gt;指针指向的对象可以是函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 指针变量的名称为 foo&lt;/span&gt;
&lt;span class="c1"&gt;// 被指向的对象（函数）没有形参，也没有返回值&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="null"&gt;null 的概念&lt;/h4&gt;
&lt;p&gt;几个近似但不同的概念：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;null 概念&lt;/td&gt;
&lt;td&gt;通过 null 指针常量来支持的一种抽象，这个常量可以是也可以不是 0，C 程序员不需要关心实际的内部表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null 指针常量&lt;/td&gt;
&lt;td&gt;null 指针没有指向任何内存区域，两个 null 指针总是相等的。每个类型的指针都有对应的 null 指针类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NULL 宏&lt;/td&gt;
&lt;td&gt;把整数常量 0 强转为 void 指针，即 &lt;code&gt;#define NULL ((void *)0)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ASCII 字符 NUL&lt;/td&gt;
&lt;td&gt;全 0 的字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null 字符串&lt;/td&gt;
&lt;td&gt;C 语言的字符串是必须以 0 结尾的字符序列，NUL 字符串是空字符串，不包含任何字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null 语句&lt;/td&gt;
&lt;td&gt;只有一个分号的语句&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;null 指针和未初始化的指针不是一回事，未初始化的指针可能包含任何值，null 指针则不会指向任何内存地址。任何时候都不能解引用 null 指针，因为它指向的不是合法地址。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;不能直接把 int 变量赋值给指针，但是一个例外情况是&lt;strong&gt;可以把常数 0 直接赋值给任何指针&lt;/strong&gt;，但是不能赋值其他常数。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// valid assignment&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// invalid assignment&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Q：用不用 NULL？&lt;/p&gt;
&lt;p&gt;A：取决于个人喜好，NULL 比 0 的含义更加清晰，提醒正在使用指针&lt;/p&gt;
&lt;h4 id="void"&gt;void 指针&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;void 指针具有和 char* 指针相同的形式和内存对齐方式&lt;/li&gt;
&lt;li&gt;void 指针永远都不会和其他类型的指针相等，但是两个赋值为 NULL 的 void 指针是相等的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通用指针，用来存放任何数据类型的引用。任何类型的指针都可以转成 void 指针，然后再转回到原来的类型。转回后的结果和原始指针的 value 是相等的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Value of pi: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Value of pi: 100&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Value of pi: %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Value of pi: 100&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void 指针只能用来作为数据指针，不能用作函数指针&lt;/li&gt;
&lt;li&gt;一旦指针被转为 void 指针后，就可以再次被转为其他任意类型的指针，所以要小心使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h4 id="_9"&gt;全局和静态指针&lt;/h4&gt;
&lt;p&gt;全局 / 静态指针声明时就会被自动初始化为 NULL：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;globalpi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;staticpi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="_10"&gt;指针的长度和类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据指针的长度通常都是一样的，和指针类型无关&lt;/li&gt;
&lt;li&gt;函数指针长度可能和数据指针长度不同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用指针时常用的四种预定义类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ptrdiff_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;intptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uintptr_t&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="size_t"&gt;size_t&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义：C 中任何对象可以达到的最大长度&lt;/li&gt;
&lt;li&gt;用途：用于安全地表示长度。&lt;/li&gt;
&lt;li&gt;用法：是 &lt;code&gt;sizeof&lt;/code&gt; 的返回值类型，也是 &lt;code&gt;malloc&lt;/code&gt; 和 &lt;code&gt;strlen&lt;/code&gt; 函数的参数&lt;/li&gt;
&lt;li&gt;声明：实现相关，一般出现在一个或多个标准头文件中，如 &lt;code&gt;stdio.h&lt;/code&gt; 和 &lt;code&gt;stdlib.h&lt;/code&gt;。一般 32 位系统上是 32，64 位系统上是 64&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#ifndef __SIZE_T&lt;/span&gt;
&lt;span class="cp"&gt;#define __SIZE_T&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;&lt;code&gt;size_t&lt;/code&gt; 可以用来存放指针，但是假定 &lt;code&gt;size_t&lt;/code&gt; 和指针一样长不是个好主意。&lt;code&gt;intptr_t&lt;/code&gt; 是更好的选择。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="intptr_t-uintptr_t"&gt;intptr_t  和 uintptr_t&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用途：存放指针地址&lt;/li&gt;
&lt;li&gt;用法：提供一种可移植且安全的方法声明指针，且和系统中使用的指针长度相同。把指针转化成整数时很有用&lt;/li&gt;
&lt;li&gt;一般来说，&lt;code&gt;intptr_t&lt;/code&gt; 比 &lt;code&gt;uintptr_t&lt;/code&gt; 更灵活&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免把指针转化成整数。如果指针是 64bit，整数只有 32bit 时会丢失信息&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;intptr_t&lt;/code&gt; 和 &lt;code&gt;uintptr_t&lt;/code&gt; 时，必须先强转才能赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;
&lt;span class="kt"&gt;uintptr_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// error&lt;/span&gt;
&lt;span class="kt"&gt;uintptr_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;uintptr_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// okay&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="_11"&gt;指针操作符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;声明指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;解引用&lt;/td&gt;
&lt;td&gt;得到指向对象的 value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指向&lt;/td&gt;
&lt;td&gt;得到指针指向结构的字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;加&lt;/td&gt;
&lt;td&gt;指针加法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;减&lt;/td&gt;
&lt;td&gt;指针减法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相等、不相等&lt;/td&gt;
&lt;td&gt;指针比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大于、大于等于、小于、小于等于&lt;/td&gt;
&lt;td&gt;指针比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;( 数据类型 )&lt;/td&gt;
&lt;td&gt;转换&lt;/td&gt;
&lt;td&gt;转化指针类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_12"&gt;指针算术运算&lt;/h4&gt;
&lt;p&gt;数据指针可以执行以下几种算术运算：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算术运算&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;l_ptr = r_ptr + integer&lt;/td&gt;
&lt;td&gt;&lt;p&gt;参与指针算术运算的整数的单位是 &lt;code&gt;sizeof(ptr)&lt;/code&gt;，&lt;/p&gt;l_ptr 的 value = r_ptr 的 value + integer * sizeof(r_ptr)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ptr - integer&lt;/td&gt;
&lt;td&gt;&lt;p&gt;参与指针算术运算的整数的单位是 &lt;code&gt;sizeof(ptr)&lt;/code&gt;，&lt;/p&gt;l_ptr 的 value = r_ptr 的 value - integer * sizeof(r_ptr)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ptr - ptr&lt;/td&gt;
&lt;td&gt;它们之间相差的 “ 单位 ” 的数量，&lt;code&gt;ptrdiff_t&lt;/code&gt; 是指针差值的可移植方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ptr 和 ptr 比较&lt;/td&gt;
&lt;td&gt;一般没有用途，特殊情况：指针和数组元素比较，判断数组元素的相对顺序，和指针差值类似，结果的正负号表示前后顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_13"&gt;指针常见用法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多层间接引用&lt;/li&gt;
&lt;li&gt;常量指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_14"&gt;多层间接引用&lt;/h4&gt;
&lt;p&gt;即指针套娃，常见例子：双重指针，如 &lt;code&gt;argv&lt;/code&gt; 给 main 函数传参。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A Tale of Two Cities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Wuthering Heights&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Don Quixote&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Odyssey&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Moby-Dick&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hamlet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Gulliver&amp;#39;s Travels&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;bestBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;englishBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;bestBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;bestBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;bestBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;englishBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;englishBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;englishBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;englishBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;titles&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;englishBooks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Wuthering Heights&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;间接引用没有层数限制，但是层数过多会让人迷惑，难以维护。&lt;/p&gt;
&lt;h4 id="_15"&gt;常量与指针&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指针&lt;/th&gt;
&lt;th&gt;被指向的对象&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;指针 value 可修改&lt;/th&gt;
&lt;th&gt;被指向对象 value 可修改&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;非 const&lt;/td&gt;
&lt;td&gt;非 const&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int *pci&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;普通指针&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;非 const&lt;/td&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;td&gt;&lt;code&gt;const int *pci&lt;/code&gt; 或 &lt;code&gt;int const *pci&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指向 const 的指针&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;td&gt;非 const&lt;/td&gt;
&lt;td&gt;&lt;code&gt;int *const cpi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;const 指针&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;td&gt;&lt;code&gt;const int *const cpci&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指向 const 对象的 const 指针，很少用到&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;const 和数据类型关键字的顺序不重要，但是 const 和 * 的顺序非常重要！&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 指向 const 的指针，两者等价&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 指针是 const&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 从右向左读：pci 是一个普通指针，指向对象的类型为 int 常量&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="c1"&gt;// 1. pci 可以被修改指向其他对象&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="c1"&gt;// 2. 可以解引用 pci 以读取被指向对象的 value&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="c1"&gt;// 3. 不能解引用 pci 来修改被指向对象的 value&lt;/span&gt;

&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// legal&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pci&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// illegal&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 从右向左读：cpi 是一个常数，它的类型是指针，指向对象的类型为 int&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="c1"&gt;// cpi 的 value 必须被初始化，指向的对象必须是非常量的 int&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="c1"&gt;// cpi 的 value 初始化后就不能再修改，因为 cpi 是个 const&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="c1"&gt;// cpi 指向的对象的 value 可以被修改&lt;/span&gt;

&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cpi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// legal&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cpi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// legal&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Warning: limit 是 const，被非 const 的 cpi 指向后，可能会被 *cpi 非法修改&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="c"&gt;第二章 C 的动态内存管理&lt;/h2&gt;
&lt;p&gt;内存类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态内存：栈 &lt;code&gt;stack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;动态内存：堆 &lt;code&gt;heap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_16"&gt;动态内存分配&lt;/h3&gt;
&lt;p&gt;具体可用的函数取决于系统，大部分系统的 stdlib.h 文件中都有如下函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void malloc(size_t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从 heap 分配内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;realloc()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在之前分配的基础上，重新分配为更大（小）的部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;calloc()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从 heap 分配内存并清零， &lt;code&gt;calloc&lt;/code&gt; = &lt;code&gt;malloc&lt;/code&gt; + &lt;code&gt;memset&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;free()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;释放空间到 heap&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;malloc 只分配空间，不初始化&lt;/li&gt;
&lt;li&gt;成功后返回首字节的地址&lt;/li&gt;
&lt;li&gt;分配内存时用 sizeof 操作符提高移植性&lt;/li&gt;
&lt;li&gt;每次申请时，堆管理器会额外分配空间来管理&lt;/li&gt;
&lt;li&gt;初始化静态 / 全局变量时不能调用 malloc 函数&lt;/li&gt;
&lt;li&gt;静态变量的解决方法：可以先声明再赋值 &lt;code&gt;static int *pi; pi = malloc(sizeof(int));&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全局变量无解：全局变量必须在函数和可执行代码外部声明，赋值必须出现在函数中&lt;/li&gt;
&lt;li&gt;reallocate 如果是空间变小，直接归还多余空间；如果空间变大，则重新开辟并复制旧内存&lt;/li&gt;
&lt;li&gt;C99 引入了变长数组 (VLA），数组长度可以 runtime 决定&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在编译器看来，初始化操作符 &lt;code&gt;=&lt;/code&gt; 和赋值操作符 &lt;code&gt;=&lt;/code&gt; 不一样&lt;/li&gt;
&lt;li&gt;VLA 有 runtime 开销，而且一旦函数退出，立即释放内存&lt;/li&gt;
&lt;li&gt;VLA 的长度不能改变，一旦分配就固定了，如果长度需要可变，需要使用 &lt;code&gt;realloc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;malloc 必须和 free 对称使用，防止内存泄漏。通常的做法是把被释放的指针赋值为 NULL。两种常见的内存泄露：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;丢失内存地址&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 变长数组 VLA&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;compute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 内存泄漏&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;忘记调用 free&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_17"&gt;迷途指针&lt;/h3&gt;
&lt;p&gt;迷途指针：内存已经释放，还在引用原始内存的指针。&lt;/p&gt;
&lt;p&gt;迷途指针造成的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果访问内存，行为不可预期&lt;/li&gt;
&lt;li&gt;如果内存为不可访问，则是段错误&lt;/li&gt;
&lt;li&gt;潜在的安全隐患&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;迷途指针的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 1. 访问已释放的内存&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// pi 迷途指针：已释放&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// p2 迷途指针：空间已通过 p1 释放&lt;/span&gt;


&lt;span class="c1"&gt;// 2. 访问无效的局部变量&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// pi 迷途指针：tmp 已失效&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如何处理迷途指针：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;释放指针后设置为 NULL（无法解决多个指针的问题）&lt;/li&gt;
&lt;li&gt;写一个特殊函数代替 free&lt;/li&gt;
&lt;li&gt;第三方检测工具&lt;/li&gt;
&lt;li&gt;垃圾回收（非标准技术，不属于语言的一部分）&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_18"&gt;第三章 指针和函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;指针指向数据，作为函数参数：把数据传递给函数，允许函数对其进行修改&lt;/li&gt;
&lt;li&gt;指针指向函数，动态控制程序执行流&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_19"&gt;程序的栈和堆&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;程序栈是支持函数执行的内存区域，通常和堆共享。也就是说，它们共享同一块内存区域。程序栈通常占据这块区域的下部，而堆用的则是上部。&lt;/p&gt;
&lt;p&gt;程序栈存放栈帧（stack frame），栈帧有时候也称为活跃记录（activation record）或活跃帧（activation frame）。栈帧存放函数参数和局部变量。&lt;/p&gt;
&lt;p&gt;调用函数时，函数的栈帧被推到栈上，栈向上 “ 长出 ” 一个栈帧。当函数终止时，其栈帧从程序栈上弹出。栈帧所使用的内存不会被清理，但最终可能会被推到程序栈上的另一个栈帧覆盖。&lt;/p&gt;
&lt;p&gt;动态分配的内存来自堆，堆向下 “ 生长 ”。随着内存的分配和释放，堆中会布满碎片。尽管堆是向下生长的，但这只是个大体方向，实际上内存可能在堆上的任意位置分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;栈帧由以下几种元素组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回地址：函数完成后要返回的程序内部地址&lt;/li&gt;
&lt;li&gt;局部数据存储：为局部变量分配的内存&lt;/li&gt;
&lt;li&gt;参数存储：为函数参数分配的内存&lt;/li&gt;
&lt;li&gt;栈指针和基指针：运行时系统用来管理栈的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;栈指针通常指向栈顶部。基指针（帧指针）通常存在并指向栈帧内部的地址，比如返回地址，用来协助访问栈帧内部的元素。这两个指针都不是 C 指针，它们是运行时系统管理程序栈的地址。如果运行时系统用 C 实现，这些指针倒真是 C 指针。&lt;/p&gt;
&lt;p&gt;系统在创建栈帧时，将参数以跟声明时相反的顺序推到帧上，通常，接下来会推入函数调用的返回地址，然后是局部变量。推入它们的顺序跟其在代码中列出的顺序相反。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;推入 stack frame 的顺序是：size，arr，return_address，sum，地址依次变小（因为 stack 是 “ 向上 ” 生长，栈的实际生长方向跟实现相关）&lt;/li&gt;
&lt;li&gt;for 语句块中的 i 没有被包含到 stack frame 中。C 语言把语句块当成微型函数，在合适的时机将其推入栈或弹出栈&lt;/li&gt;
&lt;li&gt;精确的地址可能会变化，不过顺序一般不变。这一点很重要，因为它可以解释参数和变量内存分配的相对顺序&lt;/li&gt;
&lt;li&gt;将栈帧推到程序栈上时，系统可能会耗尽内存，这种情况称为栈溢出，通常会导致程序非正常终止&lt;/li&gt;
&lt;li&gt;要牢记每个线程通常都会有自己的程序栈。一个或多个线程访问内存中的同一个对象可能会导致冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_20"&gt;通过指针传递和返回数据&lt;/h3&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不用把对象声明为全局可访问，就可以让多个函数访问所引用的对象&lt;/li&gt;
&lt;li&gt;不需要复制对象&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;要在函数中修改数据，就要用指针传递数据。&lt;/p&gt;
&lt;p&gt;传递参数（包括指针）时，传递的是它们的值。也就是说，传递给函数的是参数值的一个副本。当涉及大型数据结构时，传递参数的指针会更高效。&lt;/p&gt;
&lt;p&gt;传递对象的指针意味着不需要复制对象，但可以通过指针访问对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_21"&gt;修改实参&lt;/h4&gt;
&lt;p&gt;必须用指针的形式，不能使用值传递的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;swapWithPointers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pnum1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pnum2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pnum1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pnum1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pnum2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pnum2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// num1 和 num2 是实参 n1 和 n2 的副本，在 swap() 中修改形参 num1 和 num2 不会改变 n1 和 n2 的值 &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// pnum1 和 pnum2 是实参 &amp;amp;n1 和 &amp;amp;n2 的副本，&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 在 swapWithPointers() 中操作 *pnum1 和 *pnum2 实际就是在操作 n1 和 n2，因为是同一个地址&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;swapWithPointers&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;函数参数地址传递时，本质上还是按照值传递的方式操作实参的副本，但是因为副本和实参指向同一片地址，所以效果上是直接修改实参的值。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="_22"&gt;只读实参&lt;/h4&gt;
&lt;p&gt;如果希望参数对函数是只读的，那么就可以传递指向常量的指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;passingAddressOfConstants&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_23"&gt;返回指针&lt;/h4&gt;
&lt;p&gt;从函数返回指针可能的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回未初始化的指针&lt;/li&gt;
&lt;li&gt;返回指向无效地址的指针&lt;/li&gt;
&lt;li&gt;返回局部变量的指针&lt;/li&gt;
&lt;li&gt;返回指针但是没有释放内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_24"&gt;传递指针的指针&lt;/h4&gt;
&lt;p&gt;传递指针时，传递的是指针的 value。实际操作的是实参指针的副本，形参指针。如果想修改实参指针，就需要传递指针的指针。&lt;/p&gt;
&lt;h3 id="_25"&gt;函数指针&lt;/h3&gt;
&lt;h4 id="_26"&gt;声明&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 最右边的括号里面是被指向函数的形参表，此例子为空&lt;/span&gt;
&lt;span class="c1"&gt;// 最左边是被指向函数的返回值，此例子为 void&lt;/span&gt;
&lt;span class="c1"&gt;// 中间是变量的名称，此例子为 foo&lt;/span&gt;
&lt;span class="c1"&gt;// * 表示本变量是一个指针变量&lt;/span&gt;
&lt;span class="c1"&gt;// 如果去掉第一对括号，就变成了函数原型的声明，这个括号让这个声明变成了一个名为 foo 的函数指针，* 表示这是个指针&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;

&lt;span class="c1"&gt;// 一些其他例子&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 传入 double，返回 int&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 传入 char 指针，返回 void&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f3&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 传入两个 int，返回 double 指针&lt;/span&gt;

&lt;span class="c1"&gt;// 注意区分下面两个&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;f4&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// f4 是一个函数，传入 void，返回 int*&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f5&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// f5 是一个函数指针，传入 void，返回 int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_27"&gt;使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;函数指针的 value 是被指向函数的地址&lt;/li&gt;
&lt;li&gt;函数名和数组名类似，保存的就是该对象的起始地址，所以可以直接把函数名赋值给函数指针，就像直接把数组名赋值给数据指针一样&lt;/li&gt;
&lt;li&gt;也可以对函数名 / 数组名取地址，但是没必要，编译器会忽略取地址符号&lt;/li&gt;
&lt;li&gt;一般为了方便，会为函数指针定义一个 typedef&lt;/li&gt;
&lt;li&gt;函数指针和其他类型一样，可以作为形参，也可以作为返回值&lt;/li&gt;
&lt;li&gt;函数指针和其他类型一样，可以作为数组的类型&lt;/li&gt;
&lt;li&gt;函数指针还可以参与比较运算&lt;/li&gt;
&lt;li&gt;不同类型的函数指针之间可以转化，类似于数据指针之间的转换&lt;/li&gt;
&lt;li&gt;函数指针不能和数据指针之间转换&lt;/li&gt;
&lt;li&gt;函数指针转换时不能用 &lt;code&gt;void *&lt;/code&gt;，而应该用 &lt;code&gt;typedef void (*fptrBase)()&lt;/code&gt;，即一个形参和返回值都为 void 的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;使用函数指针时必须小心，因为 C 不会检查参数传递是否正确。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;例子 1：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 声明函数指针&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 使用函数指针&lt;/span&gt;
&lt;span class="c1"&gt;// 方式 1：直接把函数名赋值给函数指针&lt;/span&gt;
&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 方式 2：取地址符号，没必要&lt;/span&gt;
&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d squared is %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// 定义 typedef 方便使用函数指针&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;funcptr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;funcptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptr2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;fptr2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d squared is %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptr2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;例子 2：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;substract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 函数指针作为形参&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;compute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;substract&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// 函数指针作为返回值&lt;/span&gt;
&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;substract&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;evaluate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;例子 3：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 函数指针数组&lt;/span&gt;
&lt;span class="c1"&gt;// 数组的名字为 operations，类型为 operation，数组的长度为 128，所有元素都被初始化为 NULL&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// 不使用 typedef 的等效声明&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;operations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;])(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// 数组长度为 128，下标和 ASCII 码的前 128 个字符对应，所以可以用下面的方式给数组的元素赋值&lt;/span&gt;
&lt;span class="n"&gt;operations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;operations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;substract&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;evaluateArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluateArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;evaluateArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;例子 4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 函数指针比较&lt;/span&gt;
&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fptr points to add function&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fptr does not point to add function&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;例子 5：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 函数指针的转换&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptrBase&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptrToSingleInt&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptrToTwoInts&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;fptrBase&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;basePointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;fptrToSingleInt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptrFirst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;basePointer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fptrBase&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;fptrFirst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;fptrFirst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fptrToTwoInts&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;basePointer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptrFirst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="_28"&gt;第四章 指针和数组&lt;/h2&gt;
&lt;h3 id="_29"&gt;数组概述&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;数组是能用索引访问的同质元素连续集合。这里所说的连续是指数组的元素在内存中是相邻的，中间不存在空隙，而同质是指元素都是同一类型的。&lt;/p&gt;
&lt;p&gt;C99 标准引入了变长数组，在此之前，支持变长数组的技术是用 realloc 函数实现的。&lt;/p&gt;
&lt;p&gt;C 并没有强制规定边界，用无效的索引访问数组会造成不可预期的行为。&lt;/p&gt;
&lt;p&gt;数组名字只是引用了一块内存。&lt;/p&gt;
&lt;p&gt;对数组做 sizeof 操作会得到为该数组分配的字节数，要知道元素的数量，只需将数组长度除以元素长度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 5&lt;/span&gt;

&lt;span class="c1"&gt;// 2 行 3 列&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;}};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_30"&gt;指针表示法和数组&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;数组表示法和指针表示法在某种意义上可以互换。不过，它们并不完全相同。&lt;/p&gt;
&lt;p&gt;单独使用数组名字时会返回数组地址。我们可以把地址赋给指针。&lt;/p&gt;
&lt;p&gt;数组表示法可以理解为 “ 偏移并解引用 ”，&lt;code&gt;vector[2]&lt;/code&gt; 表示从 vector 开始，向右偏移 2 个位置，然后解引用这个位置获取其值，其中 vector 是指向数据开始位置的指针。&lt;/p&gt;
&lt;p&gt;几种等价的写法：&lt;code&gt;&amp;amp;vector[10]&lt;/code&gt; == &lt;code&gt;vecotr + 10&lt;/code&gt; == &lt;code&gt;&amp;amp;pv[10]&lt;/code&gt; == &lt;code&gt;pv + 10&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数组和指针的差别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vecotr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector[i]&lt;/code&gt; 和 &lt;code&gt;*(pv + i)&lt;/code&gt; 结果相同，但是生成的汇编代码不同，大部分情况下可忽略：&lt;code&gt;vector[i]&lt;/code&gt; 的汇编是从 vector 开始移动 i 个位置，取出内容；&lt;code&gt;*(pv + i)&lt;/code&gt; 的汇编是从 vector 地址开始，在地址上加 i 后取出该地址的值&lt;/li&gt;
&lt;li&gt;sizeof 对数组和指针返回的结果不同：sizeof(vector) = 20，sizeof(pv) = 4&lt;/li&gt;
&lt;li&gt;pv 是一个左值，左值可修改；vector 是个右值，不能修改&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 把 vector[0] 的地址赋值给 pv，即 pv 指向 vector 的第一个元素，而不是数组本身&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 和上面等价&lt;/span&gt;

&lt;span class="c1"&gt;// 注意：返回的是整个数组的指针，pv 是个指针，指向的对象是 int [5]&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vecotr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// pv[i] 即对 pv 的 value 加上 i 之后，对新地址解引用返回被指向的对象的 value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_31"&gt;传递一维数组&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将一维数组作为参数传递给函数实际是通过值来传递数组的地址，这样信息传递就更高效，因为我们不需要传递整个数组，从而也就不需要在栈上分配内存。通常，这也意味着要传递数组长度，否则在函数看来，我们只有数组的地址而不知道其长度。&lt;/p&gt;
&lt;p&gt;除非数组内部有信息告诉我们数组的边界，否则在传递数组时也需要传递长度信息。如果数组内存储的是字符串，我们可以依赖 NUL 字符来判断何时停止处理数组。一般来说，如果不知道数组长度，就无法处理其元素。&lt;/p&gt;
&lt;p&gt;我们可以使用下面两种表示法中的一种在函数声明中声明数组：数组表示法和指针表示法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 方式一：数组表示法&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 等价于&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 方式二：指针表示法&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 等价于&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_32"&gt;指针数组&lt;/h3&gt;
&lt;p&gt;指针数组：数组元素的类型为指针，即一系列的指针形成的数组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// arr 是数组名，数组每个元素的类型为 int *，即 int 指针&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_33"&gt;指针和多维数组&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;}};&lt;/span&gt;
&lt;span class="c1"&gt;// (*pmatrix) 表示 pmatrix 是一个指针，指向的对象类型是 int [5]，因为 pmatrix 本身就是指针（和数组等价），所以 pmatrix 指向的是二维数组，数组的第二维的大小是 5&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmatrix&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pmatrix&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 6&lt;/span&gt;
&lt;span class="c1"&gt;// matrix[i][j] 表示第 i 行第 j 列个元素，地址为 matrix + i*sizeof(row) + j*sizeof(element)&lt;/span&gt;
&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 2&lt;/span&gt;

&lt;span class="c1"&gt;// pmatrix 是一个数组，数组长度为 5，元素类型为 int*&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pmatrix&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_34"&gt;传递多维数组&lt;/h3&gt;
&lt;p&gt;多维数组作为函数参数时，在声明函数时需要决定两件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 数组表示法 or 指针表示法&lt;/li&gt;
&lt;li&gt;如何传递数组的形态，即数组的维度和每一维度的大小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 两种方法都需要指定列数，因为编译器要知道每行的大小。多维数组，除了第一维，其他维度都需要指定大小&lt;/span&gt;
&lt;span class="c1"&gt;// 数组表示法&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;display2DArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[][&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 指针表示法&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;display2DArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 调用示例&lt;/span&gt;
&lt;span class="n"&gt;display2DArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 错误：语法合法，但是和预期效果不同，表示 arr 是个一维数组，数组长度是 5，元素类型是 int*&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;display2DArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="_35"&gt;第五章 指针和字符串&lt;/h2&gt;
&lt;h3 id="_36"&gt;字符串基础&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串是以 ASCII 字符 NUL 结尾的字符序列。ASCII 字符 NUL 表示为 \0。字符串通常存储在数组或者从堆上分配的内存中。不过，并非所有的字符数组都是字符串，字符数组可能没有 NUL 字符。&lt;/p&gt;
&lt;p&gt;C 中有两种类型的字符串：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单字节字符串：由 &lt;code&gt;char&lt;/code&gt; 数据类型组成的序列&lt;/li&gt;
&lt;li&gt;宽字节字符串：由 &lt;code&gt;wchar_t&lt;/code&gt; 数据类型组成的序列。&lt;code&gt;wchar_t&lt;/code&gt; 数据类型用来表示宽字符，要么是 16 位宽，要么是 32 位宽。主要用来支持非拉丁字符集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串的长度是字符串中除了 NUL 字符之外的字符数。为字符串分配内存时，要记得为所有的字符再加上 NUL 字符分配足够的空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt; 和 &lt;code&gt;NUL&lt;/code&gt; 不同，&lt;code&gt;NULL&lt;/code&gt; 用来表示特殊指针，通常定义为 &lt;code&gt;((void*)0)&lt;/code&gt;，而 &lt;code&gt;NUL&lt;/code&gt; 是一个 char，定义为 &lt;code&gt;\0&lt;/code&gt;。两者不能混用。&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;字符常量&lt;/strong&gt;是单引号引起来的字符序列。字符常量通常由一个字符组成，也可以包含多个字符，比如转义字符。在 C 中，它们的类型是 int。char 的长度是 1，而字符字面量的长度是 4。这个看似异常的现象乃语言设计者有意为之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_37"&gt;字符串声明&lt;/h4&gt;
&lt;p&gt;三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字面量：双引号引起来的字符序列，通常用于初始化，位于字符串字面量池中&lt;/li&gt;
&lt;li&gt;字符数组：&lt;code&gt;char header[32]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符指针：&lt;code&gt;char *header&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;不要把&lt;strong&gt;字符串字面量&lt;/strong&gt;和单引号引起来的字符搞混，后者是&lt;strong&gt;字符字面量&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="_38"&gt;字符串字面量池&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;定义字面量时通常会将其分配在字面量池中，这个内存区域保存了组成字符串的字符序列。多次用到同一个字面量时，字面量池中通常只有一份副本。这样会减少应用程序占用的内存。通常认为字面量是不可变的，因此只有一份副本不会有什么问题。不过，认定只有一份副本或者字面量不可变不是一种好做法，大部分编译器有关闭字面量池的选项，一旦关闭，字面量可能生成多个副本，每个副本拥有自己的地址。&lt;/p&gt;
&lt;p&gt;字符串字面量一般分配在只读内存中，所以是不可变的。字符串字面量在哪里使用，或者它是全局、静态或局部的都无关紧要，从这个角度讲，字符串字面量不存在作用域的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_39"&gt;字符串初始化&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;初始化字符串采用的方法取决于变量是被声明为字符数组还是字符指针，字符串所用的内存要么是数组要么是指针指向的一块内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;字符数组&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用字符字面量初始化&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;strcpy&lt;/code&gt; 函数初始化&lt;/li&gt;
&lt;li&gt;逐字符赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;不能把字符串字面量的地址赋值给数组名字，下面的例子是错误的。&lt;code&gt;char header2[]; header2 = "Media Player";&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 方法 1 字符字面量：数组长度为 13，保持 12 个字符 + 结尾的 NUL&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 方法 2 strcpy 函数&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 方法 3 逐字符赋值&lt;/span&gt;
&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符指针&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用字符字面量初始化&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;strcpy&lt;/code&gt; 函数初始化&lt;/li&gt;
&lt;li&gt;逐地址赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 注意要用 strlen 而不是 sizeof，另外要算上结尾符 NUL。strlen 返回字符串的长度，sizeof 返回数组 / 指针的长度&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 方法 1 字符字面量&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 方法 2 strcpy 函数&lt;/span&gt;
&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Media Player&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 方法 3 逐地址赋值&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;字符串可以在内存中的多个位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// “Chapter” 在字符串字面量池中&lt;/span&gt;
&lt;span class="c1"&gt;// 全局内存中开辟一个指针，指向字符串字面量池中的 &amp;quot;Chapter\0&amp;quot; 字符串&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;globalHeader&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 全局内存中开辟了一块独立空间，保存的内容是 &amp;quot;Chapter\0&amp;quot;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;globalArrayHeader&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;displayHeader&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 全局内存中开辟一个指针，指向字符串字面量池中的 &amp;quot;Chapter\0&amp;quot; 字符串&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;staticHeader&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// stack 中开辟了一个指针，指向字符串字面量池中的 &amp;quot;Chapter\0&amp;quot; 字符串&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;localHeader&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 全局内存中开辟了一块独立空间，保存的内容是 &amp;quot;Chapter\0&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;staticArrayHeader&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// stack 中开辟了一块独立空间，保存的内容是 &amp;quot;Chapter\0&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;localArrayHeader&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// stack 中开辟了一个指针，指向 heap 空间的 &amp;quot;Chapter\0&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;heapHeader&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heapHeader&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Chapter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_40"&gt;标准字符串操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比较 &lt;code&gt;int strcmp(const char *s1, const char *s2);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复制 &lt;code&gt;char* strcpy(char *s1, const char *s2);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;拼接&lt;code&gt;char* strcat(char *s1, const char *s2);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_41"&gt;传递字符串&lt;/h3&gt;
&lt;h4 id="_42"&gt;参数声明&lt;/h4&gt;
&lt;p&gt;和字符串声明类似，声明字符串作为函数参数时也有两种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;char 数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;stringLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[]);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;char 指针&lt;/p&gt;
&lt;p&gt;在参数列表中，把参数声明为 char 指针&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 字符串参数类型用 char* 声明&lt;/span&gt;
&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;stringLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_43"&gt;传递参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;参数声明方式不影响传参方式，参数用字符数组方式声明，也可以用字符指针传参&lt;/li&gt;
&lt;li&gt;如果需要保护传入的字符串，可以用 &lt;code&gt;const char* string&lt;/code&gt; 来声明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;simpleArray&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;simple string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;simplePtr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;simple string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;simplePtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;simple string&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 以数组方式传递&lt;/span&gt;
&lt;span class="c1"&gt;// 方式 1：传递数组名（数组名和指针等效，指向第一个元素的地址）&lt;/span&gt;
&lt;span class="n"&gt;stringLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;simpleArray&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// 方式 2：对数组名取地址，冗余且会有 warning&lt;/span&gt;
&lt;span class="n"&gt;stringLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;simpleArray&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// 方式 3：对数组第一个元素取首地址，冗余&lt;/span&gt;
&lt;span class="n"&gt;stringLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;simpleArray&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]));&lt;/span&gt;

&lt;span class="c1"&gt;// 以指针方式调用，只需要传递指针名&lt;/span&gt;
&lt;span class="n"&gt;stringLength&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;simplePtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;最典型的例子：给 main 传递参数：argc 表示参数的个数，argv 是个一维数组，数组元素类型为字符串指针，每个指针引用一个命令行参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;argv[%d] %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 可等价声明为&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_44"&gt;返回字符串&lt;/h3&gt;
&lt;p&gt;函数返回字符串，实际返回的是字符串的地址，所以需要关注的问题是如何返回合法的地址。可以返回以下三种对象之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字面量&lt;/li&gt;
&lt;li&gt;动态分配的内存：被调函数 malloc，调用者 free&lt;/li&gt;
&lt;li&gt;局部字符串变量：可能会被破坏，避免这种用法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 对象 1：字面量&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;returnALiteral&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Boston Processing Center&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 对象 2：动态分配内存，blanks 动态申请，由调用者负责释放&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;blanks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;spaces&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;spaces&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blanks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 对象 3：局部字符串变量&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;blanks&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;spaces&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;spaces&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_45"&gt;函数指针和字符串的例子&lt;/h3&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写一个 sort 函数对字符串进行排序，排序算法不限&lt;/li&gt;
&lt;li&gt;sort 排序比较字符串时有两种方式，直接比较 or 忽略大小写比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每一种比较方式写一个函数，compare 和 compareIgnoreCase&lt;/li&gt;
&lt;li&gt;sort 通过函数指针选择具体的比较方式，好处是只需要一份 sort 代码就可以实现任意排序方式，不需要硬编码具体的比较函数名&lt;/li&gt;
&lt;li&gt;字符串作为参数传递给 sort 和 compare，compareIgnoreCase 等函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;
&lt;span class="normal"&gt;59&lt;/span&gt;
&lt;span class="normal"&gt;60&lt;/span&gt;
&lt;span class="normal"&gt;61&lt;/span&gt;
&lt;span class="normal"&gt;62&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 比较方式 1：直接比较&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;compare&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 比较方式 2：忽略大小写&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;compareIgnoreCase&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stringToLower&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stringToLower&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// stringToLower 中申请动态内存，调用者用完后主动释放，避免内存泄漏&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;stringToLower&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 形参为 const，所以本地为变量申请空间，需要调用者负责释放&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tolower&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 申明函数指针&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 基于冒泡排序的 sort 函数&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fptrOperation&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 相邻字符串比较并排序&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// 一旦需要交换顺序，标记 swap 重新再遍历一遍所有字符串&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 打印结果&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;displayNames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s  &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 构造测试用例&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Ted&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;carol&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Alice&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;alice&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// 测试 1&lt;/span&gt;
&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compare&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;displayNames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 测试 2&lt;/span&gt;
&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compareIgnoreCase&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;displayNames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="_46"&gt;第六章 指针和结构体&lt;/h2&gt;
&lt;h3 id="_47"&gt;声明结构体&lt;/h3&gt;
&lt;p&gt;结构体有两种声明方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;简单声明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;strcut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 typedef&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;_person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 直接例化&lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Emily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 通过指针例化&lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="n"&gt;pterPerson&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Emily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_48"&gt;结构体对齐&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为结构体分配内存时，分配的内存大小至少是各个字段的长度和。不过，实际长度通常会大于这个和，因为结构体的各字段之间可能会有填充。某些数据类型需要对齐到特定边界就会产生填充。
这些额外内存的分配意味着几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要谨慎使用指针算术运算&lt;/li&gt;
&lt;li&gt;结构体数组的元素之间可能存在额外的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;填充的气泡可能在结构体的内部，也可能在结构体的尾部。&lt;/p&gt;
&lt;h3 id="_49"&gt;释放结构体&lt;/h3&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;C 语言中，系统不会自动为结构体内部的指针分配内存，类似的，结构体消失时，也不会自动释放结构体内部指针指向的内存。在 Person 例子中，用户必须自己初始化和释放 firstName, lastName，title。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;initializePerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ln&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ln&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ln&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;deallocatePerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;firstName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="mallocfree"&gt;避免 malloc/free 开销&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;重复分配然后释放结构体会产生一些开销，可能导致巨大的性能瓶颈。解决这个问题的一种办法是为分配的结构体单独维护一个表。当用户不再需要某个结构体实例时，将其返回结构体池中。当我们需要某个实例时，从结构体池中获取一个对象。如果池中没有可用的元素，我们就动态分配一个实例。这种方法高效地维护一个结构体池，能按需使用和重复使用内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define LIST_SIZE 10&lt;/span&gt;

&lt;span class="c1"&gt;// 用指针数组表示资源池，每个元素指向一块动态申请的内存，用来存放结构体&lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;LIST_SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;// NULL 表示该位置没有被使用，可以被获取&lt;/span&gt;
&lt;span class="c1"&gt;// 资源池一开始不动态申请，只有在需要才申请，一旦申请后就循环使用（get 和 return），&lt;/span&gt;
&lt;span class="c1"&gt;// 循环使用时 get 和 return 不会再动态申请和释放。&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;initializeList&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LIST_SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 返回第一个 NULL，如果都被占用，就临时分配一个空间&lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;getPerson&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LIST_SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 将结构体返回给 list 中第一个 NULL 位置，如果资源池已满，就直接释放掉&lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;returnPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LIST_SIZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;deallocatePerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 使用示例&lt;/span&gt;
&lt;span class="n"&gt;initializeList&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getPerson&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;initializePerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Ralph&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Fitsgerald&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Mr.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;displayPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;returnPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptrPerson&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这种方法的问题：list 长度固定，无法灵活适配变长的需求，可能会频繁申请或浪费空间。可以用更加复杂的管理策略来管理 list 的长度。&lt;/p&gt;
&lt;h3 id="_50"&gt;指针和结构体&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;指针可以为简单或复杂的数据结构提供更多的灵活性。这些灵活性可能来自动态内存分配，也可能来自切换指针引用的便利性。内存无需像数组那样是连续的，只要总的内存大小对就可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几种可以用指针实现的常用数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;队列：一般用链表实现&lt;/li&gt;
&lt;li&gt;栈：一般用链表实现&lt;/li&gt;
&lt;li&gt;树：基于链表，每个 node 有多个 next&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_51"&gt;第七章 安全问题和指针误用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 C 的某些特性，用 C 写安全的应用程序跟用其他语言有所不同。比如说，C 不会阻止程序员越过数组边界写入，这样会导致内存损坏，也会引发安全风险。此外，误用指针通常也是很多安全问题的根本原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_52"&gt;指针的声明和初始化问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不正确的指针声明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// ptr1 类型是 int*, ptr2 类型是 int&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 正确写法&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ptr2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 每个变量声明独占一行更好，或者用宏定义&lt;/span&gt;
&lt;span class="cp"&gt;#define PINT int*&lt;/span&gt;
&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 更好的方法是用 typedef&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;PINT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用前未初始化（野指针）&lt;/p&gt;
&lt;p&gt;处理野指针的 3 种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总是用 NULL 初始化指针&lt;/li&gt;
&lt;li&gt;用 assert 函数&lt;/li&gt;
&lt;li&gt;用第三方工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_53"&gt;指针的使用问题&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;很多安全问题聚焦的是缓冲区溢出的概念，覆写对象边界以外的内存就会导致缓冲区溢出。下面几种情况可能导致缓冲区溢出：
+ 访问数组元素时没有检查索引值
+ 对数组指针做指针算术运算时不够小心
+ 用 gets 这样的函数从标准输入读取字符串
+ 误用 strcpy 和 strcat 这样的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测试 NULL&lt;/p&gt;
&lt;p&gt;一定要检查 malloc 的返回值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 分配失败&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 正常处理&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误使用解引用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 正确，pi 指向 num&lt;/span&gt;
&lt;span class="c1"&gt;// 星号把 pi 声明为指针，而不是解引用&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 错误，把 num 的地址赋值给 pi 指向的内存，但是 pi 还没有被初始化&lt;/span&gt;
&lt;span class="c1"&gt;// 星号对 pi 解引用&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迷途指针：引用已释放的空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;越界访问数组&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误计算数组长度&lt;/p&gt;
&lt;p&gt;将数组传递给函数时，一定要同时传递数组长度。这个信息帮助函数避免越过数组边界。不能简单依靠 NUL，因为外部传入的数组内容可能不正确。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// strcpy 允许缓冲区溢出，所以 name 中保存的是 8 个字符 Alexande，没有结尾的 NUL&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Alexander&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误使用 sizeof&lt;/p&gt;
&lt;p&gt;试图检查指针边界但方法错误，sizeof 返回的是 byte 大小。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// 错误，sizeof(buffer) 返回值为 20 * 4byte = 80&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 正确&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一定要匹配指针类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有界指针（限制指针的有效区域）&lt;/p&gt;
&lt;p&gt;C 没有对有界指针提供直接支持，不过程序员可以显式地确保这个机制。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define SIZE 32&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 有效&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 无效，错误分支&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;C++ 智能指针提供了一种模仿指针同时支持边界检查的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串的安全问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用 strcpy 和 strcat 这类字符串函数，稍不留神就会引发缓冲区溢出&lt;/li&gt;
&lt;li&gt;gets 函数从标准输入读取一个字符串，并把字符保存在目标缓冲区中，它可能会越过缓冲区的声明长度写入。如果字符串太长的话，就会发生缓冲区溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针算术运算和结构体&lt;/p&gt;
&lt;p&gt;只对数组使用指针算术运算，因为数组肯定分配在连续的内存块上。不应该将它们用在结构体内，因为结构体的字段可能分配在不连续的内存区域。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;即使结构体内部全部对齐，虽然通常分配在一起，但也有可能分配在离散地址上。更好的做法是不要用指针算术运算，而是将指针直接指向结构体的字段，最保险的做法是根本不用指针。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;_item&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;partNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;quantity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;binNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 危险做法，通常不会出错，但不一定&lt;/span&gt;
&lt;span class="n"&gt;Item&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;12345&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;107&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;partNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Quantity: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 更好的方法，不用指针运算&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quantity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Quantity: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 最好的做法，不用指针&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Quantity: %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quantity&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数指针的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误 1：只使用函数名，实际表示该函数的地址&lt;/li&gt;
&lt;li&gt;错误 2：函数和函数指针的签名不同，可以编译但是输出不确定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 错误 1：只有函数名时，表示函数地址，一般不会为 0，所以条件永远为真&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 类似错误：省略了值的比较&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 正确&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 错误 2：add 和 fptrCompute 签名不同，一个两个形参，一个三个形参&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fptrCompute&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_54"&gt;内存释放问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重复释放：释放后总是将其置为 NULL&lt;/li&gt;
&lt;li&gt;清除敏感数据：用完马上覆写，因为一般 OS 不会清零内存，会直接分配给别的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_55"&gt;使用静态工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编译器 &lt;code&gt;-Wall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他工具，提供比编译器更强的诊断功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_56"&gt;第八章 其他重要内容&lt;/h2&gt;
&lt;h3 id="_57"&gt;指针类型转化&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在指针与整数之间来回转换和在指针与 void 指针之间来回转换不同。&lt;/p&gt;
&lt;p&gt;有时候容易将句柄和指针搞混。句柄是系统资源的引用，对资源的访问通过句柄实现。不过，句柄一般不提供对资源的直接访问，指针则包含了资源的地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="restrict"&gt;别名、强别名和 restrict 关键字&lt;/h3&gt;
&lt;h4 id="_58"&gt;别名&lt;/h4&gt;
&lt;p&gt;别名：如果两个指针引用同一内存地址，我们称一个指针是另一个指针的别名。别名可以修改指向对象的 value，所以编译器无法优化，每次引用时必须执行机器级别的 ld 和 st，频繁 ld/st 会很低效。在某些情况下，编译器还必须关心操作执行的顺序。&lt;/p&gt;
&lt;h3 id="_59"&gt;强别名&lt;/h3&gt;
&lt;p&gt;强别名：不允许一种类型的指针成为另一种类型的指针的别名。需要关闭强别名的代码可能意味着差劲的内存访问实践，如果可能的话，花些时间解决这些问题，而不是关闭强别名。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器并非总能准确地报告别名相关的警告，有时候会漏报，有时候会虚报，最终还是要靠程序员定位别名问题。&lt;/li&gt;
&lt;li&gt;编译器总是假定 char 指针是任意对象的潜在别名，所以，大部分情况下可以安全地使用。不过，把其他数据类型的指针转换成 char 指针，再把 char 指针转换成其他数据类型的指针，则会导致未定义的行为，应该避免这么做。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h4 id="restrict_1"&gt;restrict 关键字&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;C 编译器默认假设指针有别名，用 restrict 关键字可以在声明指针时告诉编译器这个指针没有别名，这样就允许编译器产生更高效的代码。很多情况下这是通过缓存指针实现的，不过要记住这只是个建议，编译器也可以选择不优化代码。如果用了别名，那么执行代码会导致未定义行为，编译器不会因为破坏强别名假设而提供任何警告信息。&lt;/p&gt;
&lt;p&gt;新开发的代码应该尽量对指针声明使用 restrict 关键字，这样会产生更高效的代码，而修改已有代码可能就不划算了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_60"&gt;线程和指针&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;线程之间共享数据会引发一些问题。常见的问题是数据损坏。&lt;/p&gt;
&lt;p&gt;指针是在另一个线程中引用数据的常见方式，很多时候会用互斥锁保护数据。&lt;/p&gt;
&lt;p&gt;大家普遍认可的定义是如果一个线程的事件导致另一个线程的函数调用，就称为回调。将回调函数的指针传递给线程，而函数的某个事件会引发对回调函数的调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_61"&gt;面向对象&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;C 不支持面向对象编程，不过，借助不透明指针，我们也可以使用 C 封装数据以及支持某种程度的多态行为。&lt;/p&gt;
&lt;p&gt;不透明指针用来在 C 中实现数据封装。一种方法是在头文件中声明不包含任何实现细节的结构体，然后在实现文件中定义与数据结构的特定实现配合使用的函数。数据结构的用户可以看到声明和函数原型，但是实现会被隐藏（在．c/.obj 文件中）。&lt;/p&gt;
&lt;p&gt;只有使用数据结构所需的信息会对用户可见，如果太多的内部信息可见，用户可能会使用这些信息，从而产生依赖。一旦内部结构发生变化，用户的代码可能就会失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_62"&gt;不透明指针实例&lt;/h4&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义一个链表，实现对链表的封装&lt;/li&gt;
&lt;li&gt;链表支持 4 个操作，获取链表，删除链表，添加节点，删除头节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链表在头文件中声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//link.h&lt;/span&gt;

&lt;span class="c1"&gt;// Data 声明为 void*，这样允许处理任何类型的数据&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// 声明 typedef，但是结构体 _linkedList 的定义在 .c 文件中，对用户隐藏&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;_linkedList&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 链表支持的 4 个操作&lt;/span&gt;
&lt;span class="c1"&gt;// 1. 获取一个 LinkedList 实例&lt;/span&gt;
&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;getLinkedListInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// 2. 传入实例指针，删除链表实例&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;removeLinkedListInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 3. 将 Data 插入到链表头部&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;addNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// 4. 删除链表头结点&lt;/span&gt;
&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;removeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;链表在源文件中实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们不允许用户看到链表内部结构以及使用链表内部结构，并且会对用户隐藏结构体的任何变化。&lt;/li&gt;
&lt;li&gt;只有四个支持函数的签名对用户是可见的，否则，用户就无法利用或修改实现细节。我们封装了链表结构及其支持函数，从而减轻了用户的负担。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// link.c&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;link.h&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// 定义结点&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;_node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;_node&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// 定义链表，只需要头指针&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;_linkedList&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// 4 个操作的实现&lt;/span&gt;

&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;getLinkedListInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;removeLinkedListInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 潜在的内存泄露，解决方法：传递一个释放数据的成员函数&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;addNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;removeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LinedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;使用实例：用前面章节的 Person 结构体来创建并使用链表 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们只能在 link.c 文件中创建 _linkedList 结构体的实例，这是因为如果没有完整的结构体声明就无法使用 sizeof 操作符。比如说，如果你试图在 main 函数中为这个结构体分配内存，会得到一个语法错误。&lt;/li&gt;
&lt;li&gt;类型不完整是因为编译器看不到 link.c 文件中的实际定义。它只能看到 _linkedList 结构体的类型定义，而看不到结构体的实现细节。&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;link.h&amp;quot;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;getLinkedListInstance&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;initializePerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Peter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Underwood&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Manager&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;addNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;initializePerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sue&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Stevenson&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Developer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;addNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;removeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;displayPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;removeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;displayPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;removeLinkedListInstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="c_1"&gt;C 中的多态&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;C++ 这类面向对象语言的多态是建立在基类及派生类之间继承关系的基础上的。C 不支持继承，所以我们得模拟结构体之间的继承。&lt;/p&gt;
&lt;p&gt;结构体的变量分配顺序对这种技术的工作原理影响很大。当我们创建一个派生类 / 结构体的实例时，会先分配基类 / 结构体的变量，然后分配派生类 / 结构体的变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;理解从类实例化来的对象如何分配内存是理解面向对象语言中继承和多态工作原理的关键。我们在 C 中使用这种技术时，这一点仍然适用。&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;当对一个类 / 结构体执行函数时，其行为取决于它所作用的对象是什么。比如说，对 Shape 调用打印函数就会显示一个 Shape，对 Rectangle 调用打印函数就会显示 Rectangle。在面向对象编程语言中这通常是通过虚表（或者 VTable）实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;strcut 和 class 等效，可以包含数据和函数指针，函数指针相当于 class 的成员函数，只是 struct 没有访问保护，都是 public&lt;/li&gt;
&lt;li&gt;从 base struct 中派生出来的 struct 通过给函数指针赋值，实现重载，进而实现多态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_63"&gt;读书感悟&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大量使用 struct 对变量进行封装&lt;/li&gt;
&lt;li&gt;大量使用（数据 + 函数）指针提供灵活的操作，而且可以简化代码&lt;/li&gt;
&lt;li&gt;大量使用 typedef 对类型进行重命名，以简化代码&lt;/li&gt;
&lt;/ul&gt;</content><category term="CS"></category><category term="C"></category><category term="pointer"></category></entry><entry><title>RISC-V Book 阅读笔记</title><link href="https://qian-gu.github.io/posts/risc-v/riscv-book-note.html" rel="alternate"></link><published>2024-04-13T14:26:00+08:00</published><updated>2024-04-13T14:26:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2024-04-13:/posts/risc-v/riscv-book-note.html</id><summary type="html">&lt;p&gt;The RISC-V Reader: An Open Architecture Atlas 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#risc-v"&gt;为什么要有 RISC-V？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#isa"&gt;ISA 设计导论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32irisc-v"&gt;RV32I：RISC-V 基础整数指令集&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#rv32i"&gt;RV32I 指令格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_1"&gt;RV32I 寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_2"&gt;RV32I 整数计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_3"&gt;RV32I 取数和存数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_4"&gt;RV32I 条件分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_5"&gt;RV32I 无条件跳转&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32i_6"&gt;其他 RV32I 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#risc-v_1"&gt;RISC-V 汇编语言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;函数调用过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32m"&gt;RV32M：乘法和除法指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_5"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32f-rv32d"&gt;RV32F 和 RV32D：单精度和双精度浮点数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_6"&gt;浮点寄存器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;浮点取数、存数和算术运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32a"&gt;RV32A：原子指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_9"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32c"&gt;RV32C：压缩指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_10"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv32v"&gt;RV32V：向量&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_11"&gt;向量计算指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_12"&gt;向量寄存器和动态类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_13"&gt;向量取数和存数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_14"&gt;向量操作的并行度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_15"&gt;向量操作的条件执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_16"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv6464"&gt;RV64：64 位地址指令&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_17"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rv3264"&gt;RV32/64 特权架构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_18"&gt;机器模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_19"&gt;机器模式的异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_20"&gt;嵌入式系统中的用户模式和进程隔离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_21"&gt;现代操作系统的监管模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_22"&gt;页式虚拟内存&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_23"&gt;结语&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="risc-v"&gt;为什么要有 RISC-V？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大道至简。&lt;/p&gt;
&lt;p&gt;—— 列奥纳多 · 达 · 芬奇（Leonardo da Vinci）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年轻、开放、模块化。&lt;/p&gt;
&lt;h3 id="isa"&gt;ISA 设计导论&lt;/h3&gt;
&lt;p&gt;计算机架构师在设计 ISA 时需要遵守的基本原则和做出权衡，评价一个 ISA 的 7 个指标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;成本&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;ISA 越简单，area 越小，成本越低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简洁&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;简洁不光可以节省制造成本，还能节省设计和验证时间，降低文档开销，使得用户更加容易了解和使用。高端 implement 可以通过组合简单指令来提升性能，但是如果直接在 ISA 中添加更大、更复杂的指令会给低端 implement 带来负担。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;完成相同的任务，RISC 比 CISC 需要的指令更多，但是 RISC 因为其 ISA 的简洁性，可以通过更高的时钟频率和更小的 CPI 来弥补。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;架构和实现分离&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;延迟分支槽：MIPS-32 ISA 在 architecture 层面解决某一时期某个 implement 的问题，导致其他和后续的 implement 为了保持向后兼容不得不做一些无用的工作。&lt;/p&gt;
&lt;p&gt;架构师除了不应该加入那些仅有助于一个 implement 的功能，也不应该加入阻碍某些实现的功能。比如 ARM-32 提供的 load multiple 指令，这个指令可以提升单发射 pipeline 的性能，但是会对多发射 pipeline 带来负面影响。因为简单的多发射实现无法支持 load multiple 指令和其他指令的并行调度，所以要么实现更复杂的多发射机制，要么降低这种情况下的指令吞吐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提升空间&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;随着摩尔定律的终结，大幅提高性价比的唯一途径是 DSA（为特定领域添加自定义指令，如 DL、AR 等），所以 ISA 必须预留操作码空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码大小&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;让代码变短是 ISA 架构师的目标，因为可以降低所需存储器的面积（嵌入式的一项巨大成本），降低 I$ 的 miss ratio，从而降低功耗（访问片外 DRAM 代价远高于片上 SRAM）并提升性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;易于编程 / 编译 / 链接&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;GPR 数量越多，编译器和汇编程序员的工作越轻松。ARM-32 有 16 个寄存器，X86-32 只有 8 个，现代 ISA 都有相对较多的 32 个。&lt;/p&gt;
&lt;p&gt;位置无关代码（Position Independent Code, PIC）有助于支持动态链接，因为共享库的代码可以放在不同地址。PC 相对分支和数据寻址是 PIC 的福音，RISC-V 支持 PC 相对寻址，但是 x86-32 和 MIPS-32 不支持。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;ISA 就好比俄罗斯方块中的方块形状集合，集合要设计的够用且不冗余。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="_1"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用形式逻辑方法容易看出，存在某种抽象的 [ 指令集 ]，足以控制和执行任意操作序列 …… 现在看来，选择一款 [ 指令集 ] 的真正决定性因素更多是实用性：[ 指令集 ] 所需装置的简洁性，应用于实际重要问题的清晰度，以及处理这些问题的速度。
——[Burks et al. 1946]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RISC-V 是一款最新的、清晰的、简约的、开放的 ISA，它以过去 ISA 所犯错误为鉴。RISC-V 架构师的目标是让它能用于从最小到最快的所有计算设备。遵循冯 · 诺依曼在 1940 年代的建议，RISC-V 强调简洁性以保持低成本，同时拥有大量寄存器和直观的指令执行速度，从而帮助编译器和汇编语言程序员将实际的重要问题转换为适当的高效代码。&lt;/p&gt;
&lt;h2 id="rv32irisc-v"&gt;RV32I：RISC-V 基础整数指令集&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;…… 提升计算性能并让用户切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不到的特性将不会在硬件上实现 ……&lt;/p&gt;
&lt;p&gt;—— 法兰 · 艾伦（Frances Elizabeth “Fran” Allen），1981&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="rv32i"&gt;RV32I 指令格式&lt;/h3&gt;
&lt;p&gt;简洁的指令格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：四种基础格式 R(egister) + I(mmediate) + S(tore) + U(pper) + 两种扩展格式 B(ranch) + J(ump)&lt;/li&gt;
&lt;li&gt;性能：支持 3 个操作数&lt;/li&gt;
&lt;li&gt;性能：rs1，rs2，rd 位置固定，在 dec 前访问 GPR&lt;/li&gt;
&lt;li&gt;性能：imm 的符号位永远在 inst[31]，符号位扩展可在 dec 前进行&lt;/li&gt;
&lt;li&gt;易于编程：全 0 和全 1 为非法指令&lt;/li&gt;
&lt;li&gt;成本：精心挑选 op_code，使得 datapath 相同的指令共享 op_code，从而简化控制逻辑&lt;/li&gt;
&lt;li&gt;提升空间：RV32I 占用 32bit 指令编码空间不到 1/8，预留指令编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_1"&gt;RV32I 寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于编程：RISC-V = 32 个 GPR + 1 PC；ARM-32 = 16 个 GPR（包含 PC）&lt;/li&gt;
&lt;li&gt;简洁：实现相同功能，设置 x0 为常 0 可以简化操作，额外设置 PC 可以简化分支预测复杂度，且少占用一个 GPR&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_2"&gt;RV32I 整数计算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：imm 总是符号位扩展，所以无需 imm 版本的 sub 指令&lt;/li&gt;
&lt;li&gt;简洁：虽然 branch 支持 2 个 GPR 之间的所有运算关系，还是提供 slt 方便处理更复杂的条件表达式&lt;/li&gt;
&lt;li&gt;易于编程：lui 搭配后续一条指令，可以构造出 32bit 的 imm；auipc 搭配 jal/jalr 可以实现相对于 PC 的任意偏移跳转和数据访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_3"&gt;RV32I 取数和存数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32I 只支持一种标准寻址模式： &lt;strong&gt;偏移寻址&lt;/strong&gt; ，即跳转地址 = 寄存器 + imm[11:0]&lt;/li&gt;
&lt;li&gt;简洁：没有栈指令，ABI 中指定 x2 为 sp 就能使得标准寻址模式具有 push/pop 的优点，无需增加 ISA 复杂度&lt;/li&gt;
&lt;li&gt;易于编程：ARM-32 和 MIPS-32 要求数据按其长度对齐，RISC-V 无此要求&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;因为一条 32bit 指令无法容纳 32bit 地址，所以 linker 通常要把每个符号调整成 2 条 RV32I 指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于数据地址，需要调整为 lui 和 addi&lt;/li&gt;
&lt;li&gt;对于代码地址，需要调整为 auipc 和 jalr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多时候跳转距离没那么大，此时并不需要两条，linker 会多趟扫描代码，尽可能优化成一条 jal 指令（包含 imm[19:0]，可以寻址前后 1MB），这个过程叫做 linker relaxation。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="rv32i_4"&gt;RV32I 条件分支&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RISC-V 没有 MIPS-32 的延迟分支，也没有 ARM-32 和 x86-32 的条件码&lt;/li&gt;
&lt;li&gt;简洁：auipc 的 imm 为 0 就可以得到当前 PC，x86-32 需要先调用函数把 PC push，然后读出 PC，最后再 pop&lt;/li&gt;
&lt;li&gt;简洁：大部分程序都忽略整数的算术溢出，所以 RISC-V 让软件检测溢出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rv32i_5"&gt;RV32I 无条件跳转&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32I 不支持复杂的过程调用指令，如 x86-32 的 enter/leave，Tensilica 的 register windows&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;p class="admonition-title"&gt;Info&lt;/p&gt;
&lt;p&gt;register windows：通过远多于 32 个 GPR 来加速函数调用。在函数调用时，为其分配新的一组 32 个寄存器（也称为窗口），为了支持传参，两个函数的窗口会重叠，即有些寄存器同时属于两个相邻的窗口。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="rv32i_6"&gt;其他 RV32I 指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RISC-V 通过 memory-map IO 来访问设备，没有 x86-32 的专用 I/O 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;那些遗忘过去的人注定要重蹈覆辙。&lt;/p&gt;
&lt;p&gt;—— 乔治 · 桑塔亚那（George Santayana），1905&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;得益于起步时间比过去的 ISA 晚 20∼30 年，RISC-V 架构师可以实践 Santayana 的建议，借鉴包括 RISC-I 在内不同 ISA 的设计，取其精华，去其糟粕。此外，RISC-V 国际基金会将以可选扩展的方式缓慢地演进指令集，以规避给过去的成功 ISA 造成麻烦的野蛮生长现象。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;图 2.7 按照 7 个评价指标汇总了 ARM-32、MIPS-32、x86-32 和 RV32I 的对比&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="risc-v_1"&gt;RISC-V 汇编语言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给看似困难的问题找到简单的解法往往令人满足，而最好的解法通常是简单的。&lt;/p&gt;
&lt;p&gt;—— 伊凡 · 苏泽兰（Ivan Sutherland）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_3"&gt;函数调用过程&lt;/h3&gt;
&lt;p&gt;通常分为 6 个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;caller 将参数放到 callee 可访问的位置&lt;/li&gt;
&lt;li&gt;调换到 callee 的入口（使用 jal）&lt;/li&gt;
&lt;li&gt;获取函数所需的局部存储资源，按需保存 GPR&lt;/li&gt;
&lt;li&gt;执行函数功能&lt;/li&gt;
&lt;li&gt;将返回值放到 caller 可访问的位置，恢复 GPR，释放局部存储资源&lt;/li&gt;
&lt;li&gt;将控制权返回给 caller（使用 ret）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;保存寄存器由 callee 负责维护，重新解释上述过程如下：&lt;/p&gt;
&lt;p&gt;在 caller 中执行 call 指令跳转进入 callee 后，callee 首先做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配 stack frame，为保存现场准备资源&lt;/li&gt;
&lt;li&gt;将 callee 需要维护的保存寄存器存储到 stack 中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当 callee 完成功能后，执行 ret 指令前做两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 stack 向保存寄存器恢复现场&lt;/li&gt;
&lt;li&gt;恢复保存寄存器 &lt;code&gt;sp&lt;/code&gt; == 释放 stack frame（局部资源）&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;为了提升性能，应尽量把变量放在 GPR 中而不是内存中，同时要避免因为保存和恢复 GPR 而频繁访问内存。RISC-V 有足够的寄存器兼顾两者：既能把操作数放在 GPR，又能减少保存和恢复它们的次数。关键在于，一些寄存器不保证其值在函数调用前后保持一致，称为临时寄存器；另一些能保证，称为保存寄存器。不再调用其他函数的函数称为叶子函数。当一个叶子函数只有少量参数和局部变量时，可将其分配到寄存器，无需分配到内存。大部分函数调用均如此，此时程序无需将寄存器保存到内存。&lt;/p&gt;
&lt;p&gt;典型例子 main 函数调用 prinf：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# 编译，将 c 代码转化为 asm 代码，结果如图 3.6&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello.s&lt;span class="w"&gt; &lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;hello.c
&lt;span class="c1"&gt;# 编译，将 asm 代码转化为 .o 文件，.o 文件无法直接查看，需要先 dump，结果如图 3.7&lt;/span&gt;
&lt;span class="c1"&gt;# 其中一些指令的地址字段是 0，需要 linker 填充&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello.o&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;hello.s
objdump&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;hello.o&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;hello.o.dump
&lt;span class="c1"&gt;# 链接，将 .o 文件转化为 elf 文件，elf 文件无法直接查看，需要先 dump，结果如图 3.8&lt;/span&gt;
&lt;span class="c1"&gt;# 地址字段已替换&lt;/span&gt;
gcc&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;hello&lt;span class="w"&gt; &lt;/span&gt;hello.c
objdump&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;hello&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;hello.dump
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_4"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;保持简洁，直接。&lt;/p&gt;
&lt;p&gt;—— 凯利 · 约翰逊（Kelly Johnson），提出 “KISS 原则 ” 的航空工程师，1960&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;汇编器向简洁的 RISC-V ISA 增加了 60 条伪指令，在不增加硬件开销的同时令 RISC-V 代码更易于读写。RISC-V 提供一系列简单有效的机制，可降低成本、提高性能、易于编程。&lt;/p&gt;
&lt;h2 id="rv32m"&gt;RV32M：乘法和除法指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;若无必要，勿增实体。&lt;/p&gt;
&lt;p&gt;—— 奥卡姆的威廉（William of Occam），约 1320&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在几乎任何处理器上，执行速度：移位 &amp;gt; 乘法 &amp;gt;&amp;gt; 除法。&lt;/li&gt;
&lt;li&gt;除以常数，可以转化成乘以一个近似的倒数，再校正积的高位部分&lt;/li&gt;
&lt;li&gt;ARM-32 在 2005 之后才添加了除法指令；MISP-32 使用特殊的寄存器作为乘除法的 rd，所以需要额外的传送指令，会降低性能，增加体系结构的状态，降低切换任务的速度&lt;/li&gt;
&lt;li&gt;mulh 和 mulhu 可以检查乘法溢出&lt;/li&gt;
&lt;li&gt;除数为 0 不会产生 trap，所以可以只在需要时通过 beqz 检查除数是否为 0&lt;/li&gt;
&lt;li&gt;mulhsu 对 multi-word singed 乘法很有用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_5"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;最便宜、最快且最可靠的组件是那些不存在的组件。&lt;/p&gt;
&lt;p&gt;—— 切斯特 · 戈登 · 贝尔（C. Gordon Bell），著名小型计算机架构师&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv32f-rv32d"&gt;RV32F 和 RV32D：单精度和双精度浮点数&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;达成完美之时并非无所可增，而是无所可减。&lt;/p&gt;
&lt;p&gt;—— 安托万 · 德 · 圣埃克絮佩里（Antoine de Saint-Exupéry），《人的大地》，1939&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_6"&gt;浮点寄存器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：4 种指令格式中 rs 和 rd 只有 5bit 刚好表达 32 个 x 寄存器，为了保持指令格式不变，为浮点另外设置一组（32 个）f 寄存器&lt;/li&gt;
&lt;li&gt;如果只支持 RV32F 则 FLEN=32，如果支持 RV32D 则 FLEN=64&lt;/li&gt;
&lt;li&gt;fcsr 用于存放 round mode 和精确异常 flag&lt;/li&gt;
&lt;li&gt;ARM-32 和 MIPS-32 有 32 个 float 寄存器，但是只有 16 个 double 寄存器（把两个 float 拼接成一个 double 使用）&lt;/li&gt;
&lt;li&gt;x86-32 浮点运算早期使用 stack 而不是寄存器，后续版本增加了 8 个 64bit 浮点寄存器&lt;/li&gt;
&lt;li&gt;ARM-32 和 x86-32 不支持 x 和 f 寄存器之间直接传送数据的指令，要实现该功能，必须先写内存，再读内存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_7"&gt;浮点取数、存数和算术运算&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：许多浮点运算（矩阵乘法）在乘法后立即执行一次加法 / 减法，所以 RISC-V 提供了 fmadd、fmsub、fnmadd、fnmsub 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_8"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;少即是多。&lt;/p&gt;
&lt;p&gt;—— 罗伯特 · 勃朗宁（Robert Browning），1855。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv32a"&gt;RV32A：原子指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一切事物都应该尽量简单，但不能过分简单。&lt;/p&gt;
&lt;p&gt;—— 阿尔伯特 · 爱因斯坦（Albert Einstein），1933&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RV32A 用于同步的原子操作有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子内存操作（atomic memory operation，AMO）&lt;/li&gt;
&lt;li&gt;预订取数 / 条件存数（load reserved / store conditional）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为何 RV32A 要提供两种原子操作？答案是对应两种区别很大的使用场景。&lt;/p&gt;
&lt;p&gt;场景一：编程语言开发者假定顶层的 ISA 提供原子的 compare-and-swap 操作：比较某寄存器和另一寄存器寻址的内存值，若相等，则将第 3 个寄存器的值与内存值交换。这是一种通用的同步原语，基于它可以实现其他任意 word 同步操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 用 lr/sc 对内存 M[a0] 进行 compare-and-swap
# 期望的旧值在 a1 中；期望的新值在 a2 中
0: lr.w a3, (a0)  # 取出旧值
4: bne a3, a1, 80  # 旧值是否等于 a1？
8: sc.w a3, a2, (a0)  # 如果相等，则换入新值
c: bnez a3, 0  # 如果失败，重试
... compare-and-swap 成功后的代码 ...
...
80:  # compare-and-swap 失败
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;场景二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# 用 AMO 实现 test-and-set 自旋锁，用于保护临界区
0: li t0, 1 # 初始化锁值
4: amoswap.w.aq t1, t0, (a0) # 尝试获取锁
8: bnez t1, 4 # 若失败则重试
... 临界区代码 ..
20: amoswap.w.rl x0, x0, (a) # 释放锁
```
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_9"&gt;结语&lt;/h3&gt;
&lt;p&gt;RV32A 是可选的，一个不支持它的 RISC-V 处理器会更简单。然而，正如爱因 斯坦所言，一切事物都应该尽量简单，但不能过分简单。RV32A 正是如此，许多场景 都离不开它。&lt;/p&gt;
&lt;h2 id="rv32c"&gt;RV32C：压缩指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;小即是美。&lt;/p&gt;
&lt;p&gt;—— 恩斯特 · 弗里德里希 · 舒马赫（E. F. Schumacher），1973&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码大小：以前的 ISA 为缩减代码大小而添加很多指令和指令格式，ARM 和 MIPS 分别对 ISA 重新设计了两遍：ARM 设计了 ARM Thumb 和 Thumb2，MIPS 则设计了 MIPS16 和 microMIPS。这些新 ISA 给处理器和编译器带来额外的设计开销，同时还增加汇编语言程序员的认知负担。&lt;/li&gt;
&lt;li&gt;简洁：RV32C 采用一种新方法：每条短指令都必须对应一条标准的 32 位 RISC-V 指 令。此外，16 位指令仅对汇编器和链接器可见，并由它们决定是否将标准指令替换为相应的短指令。编译器开发者和汇编语言程序员无需关心 RV32C 指令及其格式，他 们只需知道最终得到的程序比大部分情况下更小。&lt;/li&gt;
&lt;li&gt;成本：尽管处理器设计者不能忽略 RV32C 指令，但能通过以下技巧降低实现开销：在执 行指令前通过一个译码器将所有 16 位指令翻译成相应的 32 位指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么有些架构师会跳过 RV32C：16bit 的 RV32C 和 32bit 的 RV32I 混合在一起会恶化 decoder 的时序，而在高性能处理器中，dec 本身就是时序瓶颈，所以很难处理这种情况。典型例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superscalar 一个 cycle 内 decode 多条指令&lt;/li&gt;
&lt;li&gt;宏融合 macrofusion：decoder 把多条指令组合成更复杂的指令来执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_10"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;我本能写出更短的信，但我没有时间。&lt;/p&gt;
&lt;p&gt;—— 布莱兹 · 帕斯卡（Blaise Pascal），1656。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RV32C 让 RISC-V 编译出当今几乎最短的代码。您几乎能将其视为硬件辅助的伪指令。但这里汇编器将其隐藏起来，汇编语言程序员和编译器开发者无需感知。&lt;/p&gt;
&lt;h2 id="rv32v"&gt;RV32V：向量&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我追求简洁，无法理解复杂的事物。&lt;/p&gt;
&lt;p&gt;—— 西摩 · 克雷（Seymour Cray）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;性能：注数据级并行，该技术用于可在大量数据上并发计算的目标应用程序。最著名的数据级并行架构是 SIMD（Single Instruction Multiple Data，单指令多数据）。&lt;/li&gt;
&lt;li&gt;架构和实现分离：将向量长度和每个时钟周期的最大操作次数与指令编码分离，是向量架构的关键。向量微架构师可灵活设计数据并行硬件单元，不会影响程序员，而程序员无需重写代码即可享受更长向量的好处。&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：向量架构的指令数量比 SIMD 架构少得多。而且，与 SIMD 不同，向量架构的编译技术十分完善。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_11"&gt;向量计算指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RV32IMAFD 每一条整数和浮点计算指令基本都有对应的向量版本&lt;/li&gt;
&lt;li&gt;每条向量指令根据操作数的类型，有多个版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_12"&gt;向量寄存器和动态类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;32 个名称以 v 开头的向量寄存器，但每个向量寄存器的元素数量并不固定，取决于操作的位宽和向量寄存器堆大小，后者由处理器设计者决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VLEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每个 VRF 的位宽，单位为 bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mvl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单条指令能正确运行的最大向量元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;待处理的向量元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;易于编程 / 编译 / 链接：RV32V 采取将数据类型和位宽与向量寄存器关联的新方法，而不是与指令操作码关联。程序在执行向量计算指令前，先在向量寄存器中设置数据类型和位宽。使用动态寄存器类型可大幅减少向量指令数量。动态类型向量架构能降低汇编语言程序员的认知负担和编译器中代码生成器的复杂度。&lt;/li&gt;
&lt;li&gt;向量架构不如 SIMD 架构流行的一个原因是，大家担心添加很大的向量寄存器会增加中断时保存和恢复程序（上下文切换）的开销。动态寄存器类型有助于改善此情况。根据 RV32V 约定，软件在不使用向量指令时需要禁用所有向量寄存器，这意味着处理器既具备向量寄存器的性能优势，又仅在向量指令执行过程中发生中断时才引入额外的上下文切换开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_13"&gt;向量取数和存数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;易于编程 / 编译 / 链接：虽然可以设置 stride = 1 使得 stride 兼容 unistride，但是提供 unistride 指令可以缩小代码体积和指令数。（vlds/vsts 需要 2 个 rs，而 vld/vst 只需要 1 个）&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：为了支持稀疏数组，提供 index 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_14"&gt;向量操作的并行度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能：向量元素之间独立，硬件可以并行计算，每个 cycle 计算的元素数量由 VLEN 和 EEW 决定&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接：在 SIMD 架构中，由 ISA 架构师决定每个 cycle 并行操作的最大数量和每个寄存器的元素数量，如果寄存器位宽翻倍，则指令数也翻倍，还需要同步修改编译器。RV32V 则由 implementation 决定，无需修改 ISA 和编译器，同一份 RV32V 程序，无需修改（修改代码和重新编译）就可以同时在最简单或最激进的向量处理器上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_15"&gt;向量操作的条件执行&lt;/h3&gt;
&lt;p&gt;一些向量计算包含 if 语句。向量架构不依赖于条件分支，而是用掩码禁止部分元素的向量操作。&lt;/p&gt;
&lt;h3 id="_16"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;若代码可向量化，最好的架构就是向量架构。&lt;/p&gt;
&lt;p&gt;—— 吉姆 · 史密斯（Jim Smith）于 1994 年在国际计算机体系结构研讨会（ISCA）上的主题演讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rv6464"&gt;RV64：64 位地址指令&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在计算机设计中只有一种错误难以恢复 —— 用于存储器寻址和存储管理的地址位 不足。&lt;/p&gt;
&lt;p&gt;—— 切斯特 · 戈登 · 贝尔，1976&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码大小：RV64 基本上是 RV32 的超集，唯一例外是压缩指令。&lt;/li&gt;
&lt;li&gt;与 RISC-V 不同，ARM 决定采用最大主义方法来设计 ISA。&lt;/li&gt;
&lt;li&gt;成本：程序大小的差异显著，让 RV64 要么能通过较低的指令缓存缺失率提升性能，要么在缺失率尚可接受的前提下，采用更小的指令缓存来降低成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_17"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;成为先驱的一个问题是你总会犯错误，而我永远不想成为先驱。在看到先驱所犯错误后，第二个做这件事才是最好的。&lt;/p&gt;
&lt;p&gt;—— 西摩 · 克雷（Seymour Cray），第一台超级计算机的架构师，1976 年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;64 位架构更能体现 RISC-V 设计的合理性，这对 20 年后才开始设计的我们是更容易实现的，因为我们能借鉴先驱经验，取其精华，去其糟粕。&lt;/p&gt;
&lt;h2 id="rv3264"&gt;RV32/64 特权架构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;简洁是可靠性的前提。&lt;/p&gt;
&lt;p&gt;—— 艾兹赫尔 · 韦伯 · 戴克斯特拉（Edsger W. Dijkstra）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高特权模式通常能访问低特权模式的所有功能，同时还具备若干低特权模式下不可用的额外功能，如中断处理和 I/O 操作。处理器通常在最低特权模式下运行，当发生中断和异常时，则将控制权转移到更高特权的模式。&lt;/p&gt;
&lt;p&gt;RV 的 3 种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;machine mode&lt;/li&gt;
&lt;li&gt;supervisor mode&lt;/li&gt;
&lt;li&gt;user mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特权架构指令很少，但是增加了若干 csr 来实现其新增功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简洁：RV32 和 RV64 特权架构，两者的差异仅体现在整数寄存器的位宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_18"&gt;机器模式&lt;/h3&gt;
&lt;p&gt;机器模式最重要的特性是拦截和处理异常 exception（不寻常的 runtime event）。RISC-V 将 exception 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步异常 synchronous exception：指令执行的结果，比如访问非法地址，指令 opcode 无效&lt;/li&gt;
&lt;li&gt;中断 interrupt：和指令流异步的外部事件，比如鼠标点击。标准中断源有 3 个&lt;ul&gt;
&lt;li&gt;软件 software：通过写入一个内存映射寄存器触发，通常用于一个 hart 通知另一个 hart，此机制在其他架构中称为处理器间中断 interprocessor interrupt&lt;/li&gt;
&lt;li&gt;时钟 timer：mtime &amp;gt;= mtimecmp（内存映射寄存器）时触发&lt;/li&gt;
&lt;li&gt;外部来源 external：由 PLIC（大部分外设都挂载在它上面）产生，PLIC 因平台而异&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC-V 允许不对齐访存，但是仍包含访存地址不对齐异常。原因是考虑到不对齐访存的硬件实现较复杂，且出现频率很低，因此一些硬件实现方案选择不支持不对齐的普通访存操作。这类处理器需要陷入异常处理程序，然后通过一系列较小的对齐访存操作，来在软件中模拟不对齐访存。应用程序代码对此一无所知：不对齐访存操作仍然正确执行，虽然执行得慢，但硬件实现却很简单。此外，高性能处理器亦可在硬件中实现不对齐访存。&lt;/p&gt;
&lt;h3 id="_19"&gt;机器模式的异常处理&lt;/h3&gt;
&lt;p&gt;异常处理必须的 8 个 csr：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;全拼&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mstatus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Status&lt;/td&gt;
&lt;td&gt;维护各种状态，如全局中断使能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Interrupt Pending&lt;/td&gt;
&lt;td&gt;记录当前的中断请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mie&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Interrupt Enable&lt;/td&gt;
&lt;td&gt;维护处理器的中断使能状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mcause&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Exception Cause&lt;/td&gt;
&lt;td&gt;指示发生了何种异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mtvec&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Trap Vector&lt;/td&gt;
&lt;td&gt;存放发生异常时处理器跳转的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mtval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Trap Value&lt;/td&gt;
&lt;td&gt;存放当前自陷相关的额外信息，如地址异常的故障地址、非法指令异常的指令，发生其他异常时其值为 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mepc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Exception PC&lt;/td&gt;
&lt;td&gt;指向发生异常的指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mscratch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Machine Scratch&lt;/td&gt;
&lt;td&gt;向异常处理程序提供一个字的临时存储&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;M-mode 响应 exception 的例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先检查条件 mstatus.MIE = 1，mie 和 mip 的 bit 位，满足条件后原子性地完成以下步骤&lt;/li&gt;
&lt;li&gt;将 exception 指令的 PC 保存到 mepc，然后把 PC 设置为 mtvec&lt;ul&gt;
&lt;li&gt;对于 synchronous exception：mepc 指向触发 exception 的指令&lt;/li&gt;
&lt;li&gt;对于 interrupt：mepc 指向 ISR 后恢复执行的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把 exception 原因写入 mcause，并把故障地址或其他相关信息写入 mtval&lt;/li&gt;
&lt;li&gt;把 MIE 的旧值保存到 MPIE，把 mstatus.MIE 清零以屏蔽 interrupt&lt;/li&gt;
&lt;li&gt;把 exception 发生前的模式保存到 mstatus.MPP，然后把模式更改为 M&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CSR 中没有记录当前的 privilege 等级，只有 MPP、SPP、UPP，所以软件无法查询得知当前处于哪个模式，原因是 ISA 认为软件开发人员应该准确地知道每段代码所处的特权等级，无需查询。
从硬件设计的角度，内部需要有一个寄存器来记录当前状态，否则无法判断当前等级是否有权限执行某些指令。该内部寄存器未开放给软件，所以在 ISA CSR 中也不可见。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;mscratch 的作用：提供一种快速的保存 - 恢复机制，可以直接把某个 XRF 写入到 mscratch，而不是 stack 中。如果需要保存更多的寄存器，一般 mscratch 指向一片空闲的内存，ISR 可以根据需求把想要的任意个寄存器内容写入到该空间：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先用 csrrw 指令交换 mscratch 和 a0 的内容（mscratch 是 csr，普通指令无法直接使用，必须先交换到 XRF 中。因为 ISR 没有参数，所以 a0 是空闲 XRF，可以用来和 mscratch 交换）&lt;/li&gt;
&lt;li&gt;将任意个 XRF 保存到内存中&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;li&gt;处理完后再从内存中恢复数据到 XRF&lt;/li&gt;
&lt;li&gt;用 csrrw 交换 mscratch 和 a0，恢复内容&lt;/li&gt;
&lt;li&gt;用 mret 返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# example：timer 中断的 ISR。&lt;/span&gt;
&lt;span class="c1"&gt;# 假设&lt;/span&gt;
&lt;span class="c1"&gt;# 1. mstatus.MIE=1 已打开全局中断使能&lt;/span&gt;
&lt;span class="c1"&gt;# 2. timer 中断使能 mie[7]=1 已打开&lt;/span&gt;
&lt;span class="c1"&gt;# 3. mtvec 设置为本处理程序的地址&lt;/span&gt;
&lt;span class="c1"&gt;# 4. mscratch 指向一段 16Byte 的临时缓冲区&lt;/span&gt;

&lt;span class="c1"&gt;# step1. 交换 mscratch 和 a0。a0 保持空闲内存供后续普通指令使用，mscratch 保存 a0 旧值，用于后续恢复&lt;/span&gt;
&lt;span class="nf"&gt;csrrw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mscratch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;

&lt;span class="c1"&gt;# step2. 保存 XRF 到空闲内存。因为后续要使用到 a1, a2, a3, a4 这几个 XRF，所以先保存旧值&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# step3. 中断处理&lt;/span&gt;
&lt;span class="c1"&gt;# 解析中断原因&lt;/span&gt;
&lt;span class="nf"&gt;csrr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mcause&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 读出异常原因&lt;/span&gt;
&lt;span class="nf"&gt;bgez&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;exception&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;# 若非中断则跳转，bgez 的 rs 是 signed 类型，中断对应的 MSB = 1 为负数&lt;/span&gt;
&lt;span class="nf"&gt;andi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0x3f&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# 单独取出中断原因&lt;/span&gt;
&lt;span class="nf"&gt;li&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;# a2 = 时钟中断号&lt;/span&gt;
&lt;span class="nf"&gt;bne&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;otherInt&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;# 若非 timer 中断则跳转&lt;/span&gt;
&lt;span class="c1"&gt;# 处理 timer 中断，递增 mtimecmp&lt;/span&gt;
&lt;span class="nf"&gt;la&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mtimecmp&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# mtimecmp 是 memory map csr，读出该地址的到 a1&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 读出 mtimecmp 的低 32bit 到 a2&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 读出 mtimecmp 的高 32bit 到 a3&lt;/span&gt;
&lt;span class="nf"&gt;addi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;# 给 mtimecmp 的低 32bit 加上 1000，求和结果保存到 a4&lt;/span&gt;
&lt;span class="nf"&gt;sltu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 计算进位，如果和 a4 比加数 a2 小，说明有进位，进位保存在 a2 中&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;# 把进位加到 mtimecmp 的高位 a3 上&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 保存递增后的 mtimecmp 高位&lt;/span&gt;
&lt;span class="nf"&gt;sw&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;# 保存递增后的 mtimecmp 低位&lt;/span&gt;

&lt;span class="c1"&gt;# step4. 恢复 XRF, a1, a2, a3, a4&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;lw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# step5. 恢复 a0 和 mscratch 旧值&lt;/span&gt;
&lt;span class="nf"&gt;csrrw&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;mscratch&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;a0&lt;/span&gt;

&lt;span class="c1"&gt;# step6. 从 ISR 返回&lt;/span&gt;
&lt;span class="nf"&gt;mret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_20"&gt;嵌入式系统中的用户模式和进程隔离&lt;/h3&gt;
&lt;p&gt;并非所有代码都是可信任的：底层 OS 代码可行度较高，可以访问所有硬件资源；应用程序代码可行度较低，需要进行限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制 U 模式代码可执行的指令（M 模式指令）和访问的资源（M 模式 CSR）&lt;/li&gt;
&lt;li&gt;限制 U 模式代码只能访问各自的内存，即 PMP（指定哪些内存可以让 U 模式访问）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_21"&gt;现代操作系统的监管模式&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id="_22"&gt;页式虚拟内存&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h3 id="_23"&gt;结语&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一项又一项的研究表明，最优秀的设计师能更轻松地设计出更快、更小、更简洁、更明了的结构。伟大和平凡之间相差近一个数量级。&lt;/p&gt;
&lt;p&gt;—— 弗雷德 · 布鲁克斯（Fred Brooks, Jr.）, 1986.&amp;gt; 一款指令集的 7 个评价标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;成本&lt;/li&gt;
&lt;li&gt;简洁&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;架构和实现分离&lt;/li&gt;
&lt;li&gt;提升空间&lt;/li&gt;
&lt;li&gt;代码大小&lt;/li&gt;
&lt;li&gt;易于编程 / 编译 / 链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;围绕这 7 个评价指标从全系统角度向读者介绍 RISC-V 的精巧设计和众多的取舍考量。&lt;/p&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>GNU Make Manual 笔记</title><link href="https://qian-gu.github.io/posts/tools/gnu-make-manual-note.html" rel="alternate"></link><published>2023-03-26T20:23:00+08:00</published><updated>2023-03-26T20:23:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2023-03-26:/posts/tools/gnu-make-manual-note.html</id><summary type="html">&lt;p&gt;总结 Make 知识点，为中小工程写出专业的符合 GNU Make 惯例的 Makefile。&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#gnu-make-notes"&gt;GNU Make Notes&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#an-introduction-to-makefiles"&gt;An Introduction to Makefiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#writing-makefiles"&gt;Writing Makefiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#writing-rules"&gt;Writing Rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-recipe-in-rules"&gt;Write Recipe in Rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#how-to-use-variables"&gt;How to Use Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conditional-parts-of-makefiles"&gt;Conditional Parts of Makefiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#functions-for-transforming-text"&gt;Functions for Transforming Text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#how-to-run-make"&gt;How to Run make&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-implicit-rules"&gt;Using Implicit Rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#makefile-conventions"&gt;Makefile Conventions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#rules-of-makefiles"&gt;Rules of Makefiles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#makefile-tempalte"&gt;Makefile Tempalte&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reference"&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="gnu-make-notes"&gt;GNU Make Notes&lt;/h2&gt;
&lt;p&gt;按照 GNU Make Manual 的章节顺序记录，一些基本且重要的点，可以覆盖日常使用，支撑中小项目使用，细节查 Manual。&lt;/p&gt;
&lt;h3 id="an-introduction-to-makefiles"&gt;An Introduction to Makefiles&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;rule 的一般格式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt;
        &amp;lt;recipe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;术语：&lt;code&gt;target&lt;/code&gt;, &lt;code&gt;prerequisites&lt;/code&gt;， &lt;code&gt;recipe&lt;/code&gt; 和 &lt;code&gt;rule&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make 的原理是检查 prerequisites 的时间戳是否比 target 的更新，如果是则执行 recipe。所以 Make 不限于编译程序，还可以用来做其他事情。但是 make 为编程特意提供了一些 implicit rules 和 variables，方便使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有指定 target 名称，默认情况下 make 以 Makefile 中第一个（不以 . 开头的）target 作为 &lt;code&gt;default goal&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="writing-makefiles"&gt;Writing Makefiles&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个 Makefile 中包含 5 部分：explicit rules，implicit rules，variable definitions，directives，comments&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认情况下按照 &lt;code&gt;GNUmakefile&lt;/code&gt;，&lt;code&gt;makefile&lt;/code&gt;，&lt;code&gt;Makefile&lt;/code&gt; 的顺序查找 makefile，推荐文件名为 &lt;code&gt;Makefile&lt;/code&gt;，因为更醒目且通用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遇到 &lt;code&gt;include&lt;/code&gt; 时会暂停读取当前文件，转而读取被 include 的文件，在读取 incldue 文件时 make 会尝试自动 rebuild 这个被 include 的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 include 的场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个子程序由各自的 makefile 管理，这些 makefile 共享的规则可以单独放在一个文件里，被 include 使用（比如 systemc 的 examples）。&lt;/li&gt;
&lt;li&gt;自动生成的依赖文件单独存放，由主 makefile 通过 include 使用，这种方式比直接写到 makefile 的方式更整洁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make 程序读取 makefile 的步骤分为两步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段：读取所有 makefile（包括 include），初始化变量，推导 implicit rules，所有的 target 和 prerequisites 建立一个依赖图&lt;/li&gt;
&lt;li&gt;第二阶段：判断哪个 target 是 goal，并判断 goal 是否需要更新，如果是的话，运行 recipe&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variable 和 function 展开有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即（immediate）展开：用 &lt;code&gt;:=&lt;/code&gt; 定义，展开发生在第一阶段&lt;/li&gt;
&lt;li&gt;延后（deferred）展开：用 &lt;code&gt;=&lt;/code&gt; 定义，展开发生在第二阶段&lt;/li&gt;
&lt;li&gt;Conditional Directives 是立即展开的&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有类型的 rule 都按照下面的规则展开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;immediate &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;immediate&lt;/span&gt; ; &lt;span class="n"&gt;deferred&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;deferred
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;即 target 和 prerequisites 是立即展开的，recipe 是延后展开的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="writing-rules"&gt;Writing Rules&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一个 rule 被当作 default goal，所以一般是 build 整个程序 / 多个程序的命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prerequisites 有两类，语法为 &lt;code&gt;target : normal-prerequisites | order-only-prerequisites&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;order-only prerequisites 的目标是满足一种特定场景：在 build target 前必须先 build order-only prerequisites，但是 order-only prerequisites 的更新不触发 target 的更新。典型例子：编译文件放在 build 目录下，但是 build 目录在执行 make 时并不一定存在，同时 build 目录的更新不应该触发 target 的重新 build&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;OBJDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;objdir
&lt;span class="nv"&gt;OBJS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;addprefix&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;OBJDIR&lt;span class="k"&gt;)&lt;/span&gt;/,foo.o&lt;span class="w"&gt; &lt;/span&gt;bar.o&lt;span class="w"&gt; &lt;/span&gt;baz.o&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;$(OBJDIR)/%.o &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;COMPILE.c&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;OUTPUT_OPTION&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$&amp;lt;&lt;/span&gt;

&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;OBJS&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;$(OBJS)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;OBJDIR&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;$(OBJDIR)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;mkdir&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;OBJDIR&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;!!!warning
      Manual 中的这个例子虽然可以工作，但是根据 Smith 的文章可以知道这种方式不是最优的，因为这种写法违反了规则 2：&lt;code&gt;$@&lt;/code&gt; 和 &lt;code&gt;$&amp;lt;&lt;/code&gt; 的 stem 应该完全一致。更推荐的写法是：在 build 目录下工作，并且通过 vpath 查找 src 文件的路径，此时 obj 和 src 的 stem 就可以做到相同。How?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件名可以用通配符 &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; ，文件名的展开时刻取决于出现的位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;target 和 prerequisites 中的通配符由 make 在第一阶段展开&lt;/li&gt;
&lt;li&gt;recipe 中的通配符由 shell 展开&lt;/li&gt;
&lt;li&gt;其他位置（variable 和 function）的通配符必须用 wildcard 函数展开&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VPATH&lt;/code&gt; 和 &lt;code&gt;vpath&lt;/code&gt; 都是为 target 和 prerequisites 搜索设计的，如果在当前目录下找不到 target/prerequisites 文件时，会从 VPATH/vpath 指定的目录中去寻找&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;vpath 只能对 make 的 target/prerequisites 起作用，无法传递给 makefile 中的 variables 或 functions。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;srcs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;wildcard&lt;span class="w"&gt; &lt;/span&gt;*.c&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;vpath %.c src/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;只能查找当前路径下的 c 文件，无法匹配到 src/ 目录下的 c 文件。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 VPATH/vpath 找到的文件是带完整路径的，因为写 recipe 时并不能确定搜索结果，所以必须使用自动变量 &lt;code&gt;$^&lt;/code&gt; 或 &lt;code&gt;$&amp;lt;&lt;/code&gt; 来表示搜索结果&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;VPATH&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;src:../headers

&lt;span class="nf"&gt;foo.o &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;.&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;defs&lt;/span&gt;.&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="n"&gt;hack&lt;/span&gt;.&lt;span class="n"&gt;h&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;cc&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CLFAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强制 target（没有 prerequisites 且没有 recipe 的 target）作用和伪目标相同，推荐使用伪目标的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;empty target&lt;/code&gt;（target 文件确实存在，但是内容为空）是 phony target 的变种，主要目的是用 target 的时间戳记录上次执行 recipe 的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 prerequisites 可以对应多个 target 文件（用空格分开），表示他们有相同的 prerequisites。如果想根据 prerequisites 根据 target 变化，则应该使用 static pattern rules。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 target 也可以出现在多个 rule 中，对应多个 prerequisites。这种情况下所有 prerequisites 会被合并到一起，但是只能有一个 rule 提供 recipe，如果有多个，则使用最后一个 recipe 且打印错误信息。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;自动产生依赖时，makefile 中给出了 .d 文件的 recipe，同时生成的 .d 文件自身只给出 targt 和 prerequisites，但是没有 recipe，所以这种情况下，相当于给 .d 和 .o 文件添加了一些额外的 prerequisites，并不会引起错误。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;static pattern rule&lt;/code&gt; 可构造 prerequisites 相似，但不相同的 rules，所以比 multiple target rule 更通用（“targets 必须具有相同的 prerequisites" 这个约束放松为 "targets 和 prerequisites 具有相同的 stem"）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;foo.o&lt;span class="w"&gt; &lt;/span&gt;bar.o

&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objects&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;$(objects)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;o&lt;/span&gt;: %.&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CC&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;static pattern rule + filter 在大工程中很有用，可以对 target 中某一类型文件的 recipe 进行定义。比如 object 列表包含了所有目标文件，格式可能包含 .o 和 .elc，那么可以用静态模式 + filter 实现两类目标文件 recipe 的定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;objs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;foo.elc&lt;span class="w"&gt; &lt;/span&gt;bar.o&lt;span class="w"&gt; &lt;/span&gt;lose.o

&lt;span class="nf"&gt;$(filter %.o, $(objs))&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;d&lt;/span&gt;: %.&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;cc&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;

&lt;span class="nf"&gt;$(filter %.elc, $(objs))&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;elc&lt;/span&gt;: %.&lt;span class="n"&gt;el&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;emacs&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;batch-byte-compile&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;实现对 .elc 和 .o 文件 recipe 的定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;implicit rule&lt;/code&gt; 也可以实现和 static pattern rule 类似的功能，但是两者还是有区别的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;static pattern rule 的作用范围是显式指定的，implicit rule 的作用范围是符合 rule 的所有 target&lt;/li&gt;
&lt;li&gt;static pattern rule 更优的两种场景&lt;ul&gt;
&lt;li&gt;想对某些文件重载默认的 implicit rule&lt;/li&gt;
&lt;li&gt;不确定目录下是否存在某些文件满足隐含模式，从而产生不确定的影响，此时采用 static pattern rule 可以消除这种不确定性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;规则模式要求 target 和 prerequisites 的 stem 同名，所以如果编译结果放到 build 目录下，那么规则模式不适用，因为 target 的 stem 为 &lt;code&gt;xxx/foo.o&lt;/code&gt; ，搜索不到对应的 prerequisite &lt;code&gt;xxx/build/foo.cpp&lt;/code&gt;（源文件为 &lt;code&gt;xxx/src/foo.cpp&lt;/code&gt;）&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;double colon rules&lt;/code&gt;（允许 target 出现在多个 rule 中，且每个 rule 有不同的 recipe）可以提供一种根据不同 prerequisite 执行不同 recipe 更新同一个 target 的机制，一般很少用到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Manual 中给出了一种利用 include 自动 rebuild 的特性&lt;a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Prerequisites"&gt;自动维护依赖关系的方法&lt;/a&gt;，但是这个方法有 3 个缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;效率问题：如果某个 .c 文件被修改了，因为 prerequisite(.c 文件 ) 时间戳更新且 rules 存在，所以对应的 .d 文件在 include 时每次都会 rebuild，但是 rebuild 这个 .d  文件并不是必须的，因为无论是否更新 .d 文件，.c 文件的修改都意味着 .o 文件必然要被更新&lt;/li&gt;
&lt;li&gt;烦人的 warning：如果新增了一个文件 or 第一次 build，因为不存在对应的 .d 文件，所以会报 warning&lt;/li&gt;
&lt;li&gt;如果重命名 / 删除了某个 prerequisite 文件（比如程序员在重命名 / 删除某个 .h 文件时忘记同步更新相关的 .c 文件），这个机制会出错。因为 .d 文件里面还记录着这个无效的依赖关系，此时只能手动删除所有相关的 .d 文件（这个错误应该是在更新 .o  文件时由 compiler 报错 , 而不是由 make 报错）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以需要一个&lt;a href="https://make.mad-scientist.net/papers/advanced-auto-dependency-generation/"&gt;更加健壮的自动生成 dependency 的方法&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决第一个问题：.d 文件的更新实际上是为下次 make 准备的，只需要保证下次 make 时 dependency list 是最新的即可，所以 .o 和 .d 文件可以在同一个 rule 下更新&lt;/li&gt;
&lt;li&gt;解决第二个问题：用 wildcard 来匹配所有 .d 文件，避免不存在的文件 include 报错&lt;/li&gt;
&lt;li&gt;解决第三个问题：利用 make 处理 &lt;code&gt;rules without recipes or prerequisite&lt;/code&gt; 的机制，修改 .d 文件的内容，把每个 prerequisite 文件都列为 target 即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方法依然有问题：如果用户在没有修改任何 .c 文件的前提下不小心删除了某个 .d 文件，那么修改 .h 文件并不会触发更新 .o 文件。解决方法：把 .d 作为 .o 的 prerequisites 的一部分，并且为其提供一个 empty rule 避免 rebuild。最终版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nv"&gt;OBJDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;obj

&lt;span class="nv"&gt;DEPDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;OBJDIR&lt;span class="k"&gt;)&lt;/span&gt;/.deps
&lt;span class="nv"&gt;DEPFLAGS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-MT&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-MMD&lt;span class="w"&gt; &lt;/span&gt;-MP&lt;span class="w"&gt; &lt;/span&gt;-MF&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;DEPDIR&lt;span class="k"&gt;)&lt;/span&gt;/&lt;span class="nv"&gt;$*&lt;/span&gt;.d

&lt;span class="nv"&gt;COMPILE.c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CC&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;DEPFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CPPFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;TARGET_ARCH&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-c

&lt;span class="nf"&gt;$(OBJDIR)/%.o &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;DEPDIR&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;/%.&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;DEPDIR&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;COMPILE.c&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;OUTPUT_OPTION&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;

&lt;span class="nf"&gt;$(DEPDIR)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;; @&lt;span class="n"&gt;mkdir&lt;/span&gt; -&lt;span class="n"&gt;p&lt;/span&gt; $@

&lt;span class="nv"&gt;DEPFILES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;SRCS:%.c&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;DEPDIR&lt;span class="k"&gt;)&lt;/span&gt;/%.d&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;$(DEPFILES)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;include $(wildcard $(DEPFILES))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="write-recipe-in-rules"&gt;Write Recipe in Rules&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;recipe 用 &lt;code&gt;@&lt;/code&gt; 开头可以取消 echoing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;recipe 的每一行都由一个新的 shell 子进程执行，同一行包含多个命令时，用分号 &lt;code&gt;;&lt;/code&gt; 隔开组成一个完整的 shell 命令；如果想把完整的 shell 命令分成多行写，在行尾加反斜杠 &lt;code&gt;\&lt;/code&gt; 进行连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make 使用 &lt;code&gt;/bin/sh&lt;/code&gt; 作为默认 shell，不会继承环境变量设置的 shell，可以在 makefile 中通过变量 &lt;code&gt;SHELL&lt;/code&gt; 进行指定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;recipe 用减号开头，忽略此命令返回的失败值，比如 &lt;code&gt;-rm *.o&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归调用时，用 &lt;code&gt;$(MAKE)&lt;/code&gt; 代替 &lt;code&gt;make&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上层 makefile 可以通过 &lt;code&gt;export VARIABLE = value&lt;/code&gt; 的方式把变量传递给子 makefile&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="how-to-use-variables"&gt;How to Use Variables&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;除了 recipe 和用 &lt;code&gt;=&lt;/code&gt; 或 &lt;code&gt;define&lt;/code&gt; 定义的，其他形式的 variables 和 functions 都是在 makefile 被读取时（即第一阶段）展开的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传统做法是 variable 大写，但是 GNU make manual 推荐 makefile 内部使用的变量小写，只有控制 implicit rule 或用户可以通过命令行重载的变量大写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量引用是一个严格的字符替换过程，shell 中的变量引用可以是 &lt;code&gt;$foo&lt;/code&gt; 的形式，但是 makefile 必须是 &lt;code&gt;$(foo)&lt;/code&gt; 或者 &lt;code&gt;${foo}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量赋值有两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归展开式变量：用 &lt;code&gt;=&lt;/code&gt; 赋值，变量只有在被引用时才会递归展开。优点是可以先使用，后定义；缺点是展开时可能存在无限循环导致错误，另外一个缺点是如果变量中包含函数（如 wildcard）会在变量每次展开时都触发函数，导致执行速度变慢&lt;/li&gt;
&lt;li&gt;简单展开式变量：用 &lt;code&gt;:=&lt;/code&gt; 或 &lt;code&gt;::=&lt;/code&gt; 定义，变量在定义时被展开，即变量被定义后就是一个字符串，不包含其他任何变量的引用 . 优点是简化程序因为其行为和大部分编程语言中的变量类似。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量替换：&lt;code&gt;$(VAR:.A=.B)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用未定义的变量时，会被当做空字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以通过命令行对变量进行重载，使用 override 关键字可以让你修改用户通过命令行传进来的变量的值。应用场景例子：不管用户是否在命令行中有无指定，在 makefile 中确保包含 &lt;code&gt;-g&lt;/code&gt; 选项 &lt;code&gt;override CFLAGS += -g&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;target specific variables&lt;/code&gt; 是只对特定 target 起作用的变量，语法 &lt;code&gt;&amp;lt;target&amp;gt;: &amp;lt;variable-assignment&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pattern specific variables&lt;/code&gt; 是只对特定 pattern 起作用的变量，语法 &lt;code&gt;&amp;lt;pattern&amp;gt;: &amp;lt;variable-assignment&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="conditional-parts-of-makefiles"&gt;Conditional Parts of Makefiles&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;语法 &lt;code&gt;ifeq&lt;/code&gt;, &lt;code&gt;ifneq&lt;/code&gt;, &lt;code&gt;ifdef&lt;/code&gt;, &lt;code&gt;ifndef&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;endif&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="functions-for-transforming-text"&gt;Functions for Transforming Text&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;语法 &lt;code&gt;$(FUNCTION ARGUMENTS)&lt;/code&gt; 只能调用 make built-in 函数，用户自定义函数只能通过 &lt;code&gt;call&lt;/code&gt; 调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符替换相关函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(subst from, to, text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(patsubst pattern, replacement, text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(strip string)&lt;/code&gt; 去掉头尾空白符，合并中间空白符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(findstring find, in)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(filter pattern..., text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(filter-out pattern..., text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(sort list)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(word n, text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(wordlist s, e, text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(words text)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(firstword names...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(lastword names...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件名相关函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(dir names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(notdir names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(suffix names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(basename names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(addsuffix suffix,names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(addprefix prefix,names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(join list1,list2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(wildcard pattern)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(realpath names…)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(abspath names…)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="how-to-run-make"&gt;How to Run make&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一些 GNU 的典型 PHONY target 名字：&lt;code&gt;all&lt;/code&gt;, &lt;code&gt;clean&lt;/code&gt;, &lt;code&gt;mostlyclean&lt;/code&gt;, &lt;code&gt;distclean&lt;/code&gt;, &lt;code&gt;realclean&lt;/code&gt;, &lt;code&gt;clobber&lt;/code&gt;, &lt;code&gt;install&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;shar&lt;/code&gt;, &lt;code&gt;dist&lt;/code&gt;, &lt;code&gt;TAGS&lt;/code&gt;, &lt;code&gt;check&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; 参数：只打印但不执行 recipe&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-W&lt;/code&gt; 参数配合 &lt;code&gt;-n&lt;/code&gt;，查看修改某个文件带来的影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;make -k&lt;/code&gt; 忽略错误，继续编译，让一次编译过程多抛出一些错误&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="using-implicit-rules"&gt;Using Implicit Rules&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;implicit rules&lt;/code&gt; 的方法：rules 不包含 recipe，或者甚至不写 rules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 implicit rule 包含一个 target pattern 和 prerequisite pattern&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个 implicit rule 可能拥有相同的 target pattern，比如 .o 文件可以由 .c 或者是 .s 编译得到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般来说，make 会为没有 recipe 的 target 和 double-colon rule 自动搜索 implicit rule。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为 prerequisite 的文件会被当做没有 recipe 的 target 来对待&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;明确给出 prerequisite 并不会影响到 implicit rule 的搜索，比如 &lt;code&gt;foo.o: foo.p&lt;/code&gt; 如果目录下存在 &lt;code&gt;foo.c&lt;/code&gt; 那么会使用 foo.c 而非 foo.p 来编译出 foo.o，因为 .c 对应的 implicit rule 排在搜索结果的更前面。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不想对某个 target 使用 implicit rule，那么使用空命令（recipe 是一个分号）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$(LD)&lt;/code&gt; 使用的 flag 有两种：&lt;code&gt;$(LDFLAGS)&lt;/code&gt; 指向 &lt;code&gt;-L&lt;/code&gt; 参数；&lt;code&gt;$(LDLIBS)&lt;/code&gt; 指向 &lt;code&gt;-l&lt;/code&gt; 参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pattern rule&lt;/code&gt; 和普通 rule 类似，但是 target 中包含 % 符号，用来匹配文件名模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pattern rule 中 target 和 prerequisite 的 stem 必须相同，但是 prerequisite 并不是必须包含 stem，比如 &lt;code&gt;%.o: define.h&lt;/code&gt; 说明所有 .o 文件都依赖 define.h 这个头文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pattern rule 也可以有多个 target pattern（即这些 target 的 stem 相同，文件后缀名不同），这些 targets 会被当做整体来对待，一旦某个 target 被更新，其他 target 也被当做最新（即不更新），比如 &lt;code&gt;%.o, %.x: %.c&lt;/code&gt; 用 make foo.o foo.x 执行后，只生成 foo.o 不生成 foo.x 而且提示 foo.x 已经是最新了（实际上 foo.x 不存在）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;implicit rule 就是 make 内置的 pattern rule，比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;%.o &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CC&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CPPFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;所以用户可以用 pattern rule 的方式自定义一个 implicit rule。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载 implicit rule 的方法：使用 implicit rule 相同的 target 和 prerequisite，但是不同的 recipe；如果留空 recipe 就是屏蔽这个 implicit rule。&lt;/p&gt;
&lt;p&gt;注意下面两个的区别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;# using implicit rule by omitting recipe in common rule&lt;/span&gt;
&lt;span class="nf"&gt;foo.o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;.&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="c"&gt;# cancel implicit rule by omitting recipe in pattern rule&lt;/span&gt;
&lt;span class="nf"&gt;%.o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pattern rule 因为要对文件名进行匹配，所以 recipe 中就不能写具体的文件名，而需要一个特殊的变量来表示，也就是 automatic variables，比如 &lt;code&gt;$@&lt;/code&gt; &lt;code&gt;$^&lt;/code&gt; &lt;code&gt;$&amp;lt;&lt;/code&gt; &lt;code&gt;$?&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="makefile-conventions"&gt;Makefile Conventions&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用 automake 可以帮助你写出符合 GNU makefile 规范的 makefile。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 makefile 都要包含一行 &lt;code&gt;SHELL = /bin/sh&lt;/code&gt;，避免从环境变量继承来的 SHELL 为其他值（对于 GNU make 来说不存在这个问题，GNU make 中的 SHELL 不会从环境变量继承）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;明确指定你想要的 suffixs，避免不同 make 程序的 suffix 和 implicit rule 不兼容的问题&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;.SUFFIXES&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="nf"&gt;.SUFFIXES&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;.&lt;span class="n"&gt;c&lt;/span&gt; .&lt;span class="n"&gt;o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心处理 recipe 中的路径。当需要处理指定目录的文件时，要明确给出路径，因为 &lt;code&gt;./&lt;/code&gt; 指向的是 build 目录（GNU 惯例）而非 src 或其他目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;configure 和 makefile 脚本中使用给定的工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dist target 中可以用 gzip。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个工具尽量用它的通用选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量不要在 recipe 中创建软连接，因为有些操作系统不支持软连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用内置变量调用编译器等工具，比如 &lt;code&gt;$(CC)&lt;/code&gt; 表示 cc。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果确定只是用于某种特殊 OS，那么就可以使用其他工具，上述为了通用性做的约束可以放松。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令应该用变量来表示，比如 &lt;code&gt;$(CC)&lt;/code&gt; ，这样可以方便用户修改相应变量就可以替换工具 / 选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一般性工具，比如 ln，rm，mv 等则不需要为其定义变量，因为用户也没有替换为其他工具的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数也应该用变量表示，变量的命名方式就是 &lt;code&gt;PROGRAM-NAME + FLAGS&lt;/code&gt;，比如 &lt;code&gt;$(CFLAGS)&lt;/code&gt;，&lt;code&gt;$(LDFLAGS)&lt;/code&gt; 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 &lt;code&gt;$(CFLAGS)&lt;/code&gt; 放在命令行的最后，以确保设置的 &lt;code&gt;$(CFLAGS)&lt;/code&gt; 不会被其他变量重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;凡是调用 &lt;code&gt;$(CC)&lt;/code&gt; 的地方都需要加上 &lt;code&gt;$(CFLAGS)&lt;/code&gt;，包括编译和链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 makefile 都要定义一个 &lt;code&gt;INSTALL&lt;/code&gt; 变量，表示安装命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 makefile 要定义两个变量 &lt;code&gt;INSTALL_PROGRAM&lt;/code&gt;（默认值为 INSTALL）和 &lt;code&gt;INSTALL_DATA = $(INSTALL) -m 644&lt;/code&gt; 作为程序和数据的安装命令，比如 &lt;code&gt;$(INSTALL_PROGRAM) foo $(bindir)/foo&lt;/code&gt; 把 foo 安装到 &lt;code&gt;$(bindir)/foo&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装目录也最好用一个变量 DESTDIR 定义，方便修改安装路径。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# makefile recipe&lt;/span&gt;
&lt;span class="k"&gt;$(&lt;/span&gt;INSTALL_PROGRAM&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;foo&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;DESTDIR&lt;span class="k"&gt;)&lt;/span&gt;/&lt;span class="k"&gt;$(&lt;/span&gt;bindir&lt;span class="k"&gt;)&lt;/span&gt;/foo

&lt;span class="c1"&gt;# shell command&lt;/span&gt;
make&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;DESTDIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/tmp/stage&lt;span class="w"&gt; &lt;/span&gt;install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DESTDIR&lt;/code&gt; 应该只用在 &lt;code&gt;install*&lt;/code&gt; 和 &lt;code&gt;uninstalll*&lt;/code&gt; target 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不应该在 Makefile 中定义 &lt;code&gt;DESTDIR&lt;/code&gt;，这样就可以安装到默认目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DESTDIR 在 package creation 中很常用，可以让用户指定安装目录（比如可能没有权限安装到默认目录），所以强烈推荐使用（但不强制）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GNU 为安装定义了一系列标准 variable 和标准 target。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="rules-of-makefiles"&gt;Rules of Makefiles&lt;/h2&gt;
&lt;p&gt;GNU Make 目前的维护者 Paul Smith 的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 GNU make&lt;/p&gt;
&lt;p&gt;不要为写可移植的 makefile 而苦恼，而是使用可移植的 make 程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个非伪目标的 recipe 必须更新和 target 完全同名的文件&lt;/p&gt;
&lt;p&gt;也就是说每个 recipe 更新的文件是 &lt;code&gt;$@&lt;/code&gt;，而不是 &lt;code&gt;../$@&lt;/code&gt; 或 &lt;code&gt;$(notdir $@)&lt;/code&gt; 等形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 CWD 下 build target 是最容易的方式&lt;/p&gt;
&lt;p&gt;VPATH 的用途是在 build 目录下定位 src 文件，而不是反过来在 src 目录下定位 object 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遵循 Least Repetition 原则&lt;/p&gt;
&lt;p&gt;用 variable，pattern rules，automatic variables 和 GNU make function 等技术避免重复写文件名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个以 tab 开头的非连续行都是 recipe 的一部分，反之亦然&lt;/p&gt;
&lt;p&gt;每个不以 tab 开头的非连续行，都会按照 makefile 的语法解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录不应该作为 normal prerequisites 的一部分&lt;/p&gt;
&lt;p&gt;因为 GNU make 会把目录当成普通文件一样对待，所以如果目录新增 / 删除了文件就会产生不期望的
rebuild，正确做法是把目录作为 order-only prerequisite。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="makefile-tempalte"&gt;Makefile Tempalte&lt;/h2&gt;
&lt;div class="admonition info"&gt;
&lt;p class="admonition-title"&gt;Info&lt;/p&gt;
&lt;p&gt;大项目使用 GNU autotool，本模板适用于中小项目。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一份通用模板，可以快速适配到不同（中小）项目中&lt;/li&gt;
&lt;li&gt;自动提取所有源文件和依赖&lt;/li&gt;
&lt;li&gt;自动化编译&lt;/li&gt;
&lt;li&gt;任何源文件被修改，自动编译&lt;/li&gt;
&lt;li&gt;任何头文件被修改，自动编译包含该头文件的源文件&lt;/li&gt;
&lt;li&gt;自动链接更新后的目标文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;############################### Customise #####################################&lt;/span&gt;
&lt;span class="nv"&gt;CURDIR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;shell&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;src_dir&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CURDIR&lt;span class="k"&gt;)&lt;/span&gt;/src
&lt;span class="nv"&gt;inc_dir&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CURDIR&lt;span class="k"&gt;)&lt;/span&gt;/include
&lt;span class="nv"&gt;build_dir&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CURDIR&lt;span class="k"&gt;)&lt;/span&gt;/build
&lt;span class="nv"&gt;target&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;out

&lt;span class="c"&gt;############################### Variables #####################################&lt;/span&gt;

&lt;span class="nv"&gt;CXX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;g++
&lt;span class="nv"&gt;CXXFLAGS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-g&lt;span class="w"&gt; &lt;/span&gt;-Wall&lt;span class="w"&gt; &lt;/span&gt;-O3&lt;span class="w"&gt; &lt;/span&gt;-I&lt;span class="k"&gt;$(&lt;/span&gt;inc_dir&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nv"&gt;LDFLAGS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?=&lt;/span&gt;
&lt;span class="nv"&gt;LDLIBS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?=&lt;/span&gt;

&lt;span class="nv"&gt;depdir&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;build_dir&lt;span class="k"&gt;)&lt;/span&gt;/.deps
&lt;span class="nv"&gt;DEPFLAGS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-MT&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-MMD&lt;span class="w"&gt; &lt;/span&gt;-MP&lt;span class="w"&gt; &lt;/span&gt;-MF&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;depdir&lt;span class="k"&gt;)&lt;/span&gt;/&lt;span class="nv"&gt;$*&lt;/span&gt;.d

&lt;span class="nv"&gt;COMPILE.c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CXX&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;DEPFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CXXFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CPPFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;TARGET_ARCH&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-c

&lt;span class="nv"&gt;srcs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;foreach&lt;span class="w"&gt; &lt;/span&gt;dir,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;src_dir&lt;span class="k"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;wildcard&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;dir&lt;span class="k"&gt;)&lt;/span&gt;/*.cpp&lt;span class="k"&gt;))&lt;/span&gt;
&lt;span class="nv"&gt;objs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;addprefix&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;build_dir&lt;span class="k"&gt;)&lt;/span&gt;/,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;addsuffix&lt;span class="w"&gt; &lt;/span&gt;.o,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;notdir&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;basename&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;srcs&lt;span class="k"&gt;)))))&lt;/span&gt;

&lt;span class="cp"&gt;vpath %.cpp $(src_dir)&lt;/span&gt;
&lt;span class="cp"&gt;vpath %.h $(inc_dir)&lt;/span&gt;

&lt;span class="c"&gt;############################### Rules #########################################&lt;/span&gt;

&lt;span class="nf"&gt;.PHONY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;all&lt;/span&gt; &lt;span class="n"&gt;rebuild&lt;/span&gt; &lt;span class="n"&gt;clean&lt;/span&gt;

&lt;span class="nf"&gt;all&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;build_dir&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;/&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;target&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="nf"&gt;rebuild&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt;

&lt;span class="nf"&gt;$(build_dir)/$(target)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;objs&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CXX&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;CXXFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;LDFLAGS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;LDLIBS&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;$^&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;

&lt;span class="nf"&gt;$(build_dir)/%.o&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;%.&lt;span class="n"&gt;cpp&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;depdir&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;/%.&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;depdir&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;COMPILE.c&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;OUTPUT_OPTION&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;$&amp;lt;

&lt;span class="nf"&gt;$(depdir)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;; @&lt;span class="n"&gt;mkdir&lt;/span&gt; -&lt;span class="n"&gt;p&lt;/span&gt; $@

&lt;span class="nv"&gt;DEPFILES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;addprefix&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;depdir&lt;span class="k"&gt;)&lt;/span&gt;/,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;addsuffix&lt;span class="w"&gt; &lt;/span&gt;.d,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;notdir&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;basename&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;srcs&lt;span class="k"&gt;)))))&lt;/span&gt;
&lt;span class="nf"&gt;$(DEPFILES)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="cp"&gt;include $(wildcard $(DEPFILES))&lt;/span&gt;

&lt;span class="nf"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;-rf&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;build_dir&lt;span class="k"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模板说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用小写定义简单展开式变量，指定项目的路径（根目录，src 目录列表，include 目录列表）&lt;/li&gt;
&lt;li&gt;使用 vpath 指定头文件和源文件的搜索目录&lt;/li&gt;
&lt;li&gt;使用 order-only prerequisite 自动创建 build 目录，保持项目目录整洁&lt;/li&gt;
&lt;li&gt;因为 .o 和 .cpp 分别在 build 和 src 子目录下，无法使用 implicit rule（要求两者的 stem 必须一样），所以明确写 pattern rule&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;最重要的、最全面的、最权威的自然是&lt;a href="https://www.gnu.org/software/make/manual/html_node/index.html"&gt;官方手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GNU Make 当前维护者 Paul Smith 的&lt;a href="https://make.mad-scientist.net/papers/"&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;陈浩大神写的教程&lt;a href="https://seisman.github.io/how-to-write-makefile/"&gt;跟我学 Makefile&lt;/a&gt;，大概就是 manual 的中文简化版&lt;/li&gt;
&lt;li&gt;一份比较全面的 &lt;a href="https://clarkgrubb.com/makefile-style-guide"&gt;Makefile Coding Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><category term="Tools"></category><category term="Makefile"></category><category term="GNU Make"></category></entry><entry><title>开源 IC 工具/库 —— iverilog、verilator 和 gtkwave</title><link href="https://qian-gu.github.io/posts/tools/iverilog-verilator-and-gtkwave.html" rel="alternate"></link><published>2022-04-16T10:43:00+08:00</published><updated>2022-04-16T10:43:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2022-04-16:/posts/tools/iverilog-verilator-and-gtkwave.html</id><summary type="html">&lt;p&gt;总结 iverilog、verilator 和 gtkwave 的常用使用方法&lt;/p&gt;</summary><content type="html">&lt;h2 id="iverilog"&gt;Iverilog&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/steveicarus/iverilog"&gt;iverilog&lt;/a&gt; 是 vcs 的平替，可以做一些基本的仿真，优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装包非常小巧&lt;/li&gt;
&lt;li&gt;支持全平台&lt;/li&gt;
&lt;li&gt;代码开源&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;一般的项目可以为其写 fusesoc 的 core 文件，每次写的时候复制以前的 core 文件相关内容即可。下面内容全是来自 &lt;a href="https://steveicarus.github.io/iverilog/"&gt;iverilog user guide&lt;/a&gt; 和 iverilog 的 man 和 help，主要目的是备忘，为一些临时实验性质的不值得写 core 文件的项目，提供快速查阅。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;方式一：直接用 apt 安装，好处是省心，但是可能获取的不是最新稳定版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;iverilog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方式二：从源码编译，好处是可以获得最新的稳定版本，缺点就是稍微麻烦一点。首先下载源码，安装编译所依赖的工具 &lt;code&gt;bison&lt;/code&gt;，&lt;code&gt;flex&lt;/code&gt;，&lt;code&gt;g++&lt;/code&gt;，&lt;code&gt;gcc&lt;/code&gt;，然后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# download source&lt;/span&gt;
git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;git@github.com:steveicarus:iverilog.git
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;iverilog
&lt;span class="c1"&gt;# build configure file&lt;/span&gt;
sh&lt;span class="w"&gt; &lt;/span&gt;autoconf.sh
&lt;span class="c1"&gt;# comiple and install&lt;/span&gt;
./configure
make
sudo&lt;span class="w"&gt; &lt;/span&gt;make&lt;span class="w"&gt; &lt;/span&gt;install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;iverilog 主要包含两个工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iverilog&lt;/code&gt;：编译器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vvp&lt;/code&gt;：仿真运行引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设有一个 counter.sv 模块和 tb_counter.sv，那么&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;iverilog&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;my_design&lt;span class="w"&gt; &lt;/span&gt;counter.sv&lt;span class="w"&gt; &lt;/span&gt;tb_counter.sv
vvp&lt;span class="w"&gt; &lt;/span&gt;my_design
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后就可以用 gtkwave 打开波形文件了。&lt;/p&gt;
&lt;p&gt;iverilog 的常用参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c file&lt;/code&gt; 指定 filelist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s top&lt;/code&gt; 指定 top module&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I includedir&lt;/code&gt; 指定 include 目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o filename&lt;/code&gt; 指定编译结果的文件名&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;iverilog 对 sv 语法的支持比较弱，很多 sv 的新语法都不支持。相比之下 verilator 的支持力度更好。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="verilator"&gt;Verilator&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.veripool.org/verilator/"&gt;verilator&lt;/a&gt; 号称是 the fastest verilog/systemverilog simulator。是仿真器 4 巨头之一，其他 3 个分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vcs&lt;/li&gt;
&lt;li&gt;modelsim&lt;/li&gt;
&lt;li&gt;nc-sim&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这 3 个因为是闭源的，通常被叫做 3 巨头。&lt;/p&gt;
&lt;p&gt;verilator 文档和手册中说大部分 simulator 都必须兼容 IEEE-1364 和 IEEE-1800 标准，所以必须采用事件驱动的方式，因此无法对 blocks 进行重排序，也无法进行网表的优化。而这些正好是 verilator 速度更快的原因。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;实际使用中，影响 verilator 速度的因素非常多，最主要的有优化掉所有 &lt;code&gt;UNOPTFLAT&lt;/code&gt; 这个 warning 以及使用多线程。其中多线程要确保 CPU core 的数量一定比线程数大，否则仿真速度会严重恶化。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="installation_1"&gt;Installation&lt;/h3&gt;
&lt;p&gt;方式一：直接用 apt 安装，好处是省心，但是缺点是可能获取的不是最新稳定版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;verilator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方式二：从源码编译，好处是可以获得最新的稳定版本，缺点就是稍微麻烦一点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;autoconf
./configure
make
sudo&lt;span class="w"&gt; &lt;/span&gt;make&lt;span class="w"&gt; &lt;/span&gt;install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般用 apt 或者默认的编译安装，则不需要再手动设置任何环境变量，如果安装时选择了自定义目录，那么就要设置相应的环境变量了。&lt;/p&gt;
&lt;h3 id="usage_1"&gt;Usage&lt;/h3&gt;
&lt;p&gt;一个简单的 dut 例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;Vcounter.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;verilated_vcd_c.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;verilated.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Verilated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;commandArgs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// dump wave&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Verilated&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;traceEverOn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;VerilatedVcdC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tfp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;VerilatedVcdC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Vcounter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Vcounter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tfp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;tfp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wave.vcd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// set simulation time&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;vluint64_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;tfp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;time = &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;, cnt = &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;final&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;tfp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Simulation Finished!&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xxx&lt;/code&gt; 模块会被编译成 &lt;code&gt;Vxxx&lt;/code&gt;，所以要 &lt;code&gt;include "Vxxx.h"&lt;/code&gt;，使用时也是通过 &lt;code&gt;new Vxxx&lt;/code&gt; 来动态申请一个对象&lt;/li&gt;
&lt;li&gt;wrapper 必须调用 &lt;code&gt;eval()&lt;/code&gt;，每次 eval 被调用一次，就会执行一次 &lt;code&gt;always @(posedge clk)&lt;/code&gt;，计算相应的组合逻辑，更新寄存器的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后使用下面的命令编译：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;verilator&lt;span class="w"&gt; &lt;/span&gt;main.cpp&lt;span class="w"&gt; &lt;/span&gt;counter.sv&lt;span class="w"&gt; &lt;/span&gt;-Wall&lt;span class="w"&gt; &lt;/span&gt;-top-module&lt;span class="w"&gt; &lt;/span&gt;counter&lt;span class="w"&gt; &lt;/span&gt;--cc&lt;span class="w"&gt; &lt;/span&gt;--trace&lt;span class="w"&gt; &lt;/span&gt;--exe&lt;span class="w"&gt; &lt;/span&gt;--build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一些常见的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Wall&lt;/code&gt; 打开所有 warning&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Wno-fatal&lt;/code&gt; 避免因为 warning 导致 fatal 退出仿真&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--top-module&lt;/code&gt; 指定 top module&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--cc&lt;/code&gt; 生成 c++ 模型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--trace&lt;/code&gt; 生成 trace 波形&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--exe&lt;/code&gt; 在 Makefile 中生成可执行文件的 target&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--build&lt;/code&gt; 在 verilation 后自动生成可执行文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行 &lt;code&gt;obj_dir&lt;/code&gt; 下面的可执行文件，进行仿真并生成波形。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/qian-gu/dic_template"&gt;完整的 example&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="dive-into-verilator"&gt;Dive into Verilator&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;verilator 本质上是一个 compiler，把 tb 和 dut（.v 和 .sv 文件）编译成 .h 和 .cpp，并提供一个 runtime lib，这个库默认安装在 &lt;code&gt;/usr/local/share/verilator/include&lt;/code&gt; 下面。编译过程叫做 &lt;code&gt;verilating&lt;/code&gt;，输出的模型叫做 &lt;code&gt;verilated model&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要用户提供一个包含 &lt;code&gt;main()&lt;/code&gt; 函数的 C++ wrapper 来例化 verilated model&lt;/li&gt;
&lt;li&gt;经过 verilation 后调用 C++ 编译器将 verilated model 编译为可执行文件，运行可执行文件，完成仿真&lt;/li&gt;
&lt;li&gt;verilating 时会生成两个 makefile，分别是 &lt;code&gt;V{top}.mk&lt;/code&gt; 和 &lt;code&gt;V{top}_classes.mk&lt;/code&gt;。其中 &lt;code&gt;V{top}_classes.mk&lt;/code&gt; 会根据命令行参数给一些 verilator 预定义的变量赋值。&lt;code&gt;V{top}.mk&lt;/code&gt; 作为顶层 makefile 会自动 include 生成的 &lt;code&gt;V{top}_classes.mk&lt;/code&gt; 和 &lt;code&gt;$VERILATOR_ROOT/include/verilated.mk&lt;/code&gt; 文件。举个例子，如果命令行加了 &lt;code&gt;--trace&lt;/code&gt; 选项，那么 &lt;code&gt;V{top}_classes.mk&lt;/code&gt; 中会包含一行 &lt;code&gt;VM_TRACE = 1&lt;/code&gt;，然后通过 &lt;code&gt;verilated.mk&lt;/code&gt; 和 &lt;code&gt;V{top}.mk&lt;/code&gt; 最终传递给 g++ 参数 &lt;code&gt;-DVM_TRACE=1&lt;/code&gt;，所以我们就可以直接在 wrapper 中使用 &lt;code&gt;#if VM_TRACE&lt;/code&gt; 来开启 trace 功能了&lt;/li&gt;
&lt;li&gt;如果在调用 verilator 时加上 &lt;code&gt;--exe&lt;/code&gt;，那么 verilator 会在 &lt;code&gt;V{top}.mk&lt;/code&gt; 中加入 link target，方便用户后续手动 build。否则 &lt;code&gt;V{top}.mk&lt;/code&gt; 中不包含 link target&lt;/li&gt;
&lt;li&gt;如果在调用 verilator 时加上 &lt;code&gt;--exe&lt;/code&gt; 和 &lt;code&gt;--build&lt;/code&gt;，那么 verilator 会自动 build，无需用户再手动执行 makefile&lt;/li&gt;
&lt;li&gt;verilator 支持很多命令行参数，详细说明见手册&lt;/li&gt;
&lt;li&gt;大型设计会消耗大量的时间（10+ mins）和内存空间（100+ GB），为了解决这个问题，支持分 hierarchy 做 verilating。比如从一个多核的大型 SoC 中把 core 剥离出来单独做 verilating，然后再整合到一起。具体用法见文档&lt;/li&gt;
&lt;li&gt;verilator 支持多线程仿真&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;dump 波形的功能既可以在 &lt;code&gt;sim_main.cpp&lt;/code&gt; 中用 verilator 提供的 dump 功能，也可以在 &lt;code&gt;tb_top.sv&lt;/code&gt; 中使用 sv 语法 &lt;code&gt;$dumpfile&lt;/code&gt; 和 &lt;code&gt;$dumpvars&lt;/code&gt;。后者会更好一些，因为即使切换成 vcs 等其他仿真器，dump 功能也是可以正常工作的。无论哪种方式，都必须在命令行中加上 &lt;code&gt;--trace&lt;/code&gt; 选项。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="coverage"&gt;Coverage&lt;/h3&gt;
&lt;p&gt;verilator 提供了 coverage 工具，支持 line/function/toggle，需要 &lt;code&gt;sim_main.cpp&lt;/code&gt; 和命令行参数配合使用，具体见 &lt;a href="https://github.com/qian-gu/dic_template"&gt;dic_template&lt;/a&gt;和 &lt;code&gt;&amp;lt;verilator-src&amp;gt;/examples/make_trace_c&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;sim_main.cpp&lt;/code&gt; 中加入收集覆盖率的代码（见 dic_template/tb/sim_main.cpp），&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;verilator&lt;/code&gt; 编译、运行仿真，覆盖率收集结果在 &lt;code&gt;coverage.dat&lt;/code&gt; 文件中&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;verilator_coverage&lt;/code&gt; 配合命令行参数分析 &lt;code&gt;coverage.dat&lt;/code&gt; 文件（见 dic_template/Makefile），分析结果输出到 &lt;code&gt;coverage.info&lt;/code&gt; 文件中，info 文件可以被 &lt;code&gt;lcov&lt;/code&gt; 读取并使用 &lt;code&gt;genhtml&lt;/code&gt; 生成 HTML 报告，然后这些报告可以导入到 codecov.io 网站上&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="code-profiling"&gt;Code Profiling&lt;/h3&gt;
&lt;p&gt;因为 verilator 输出的是 C++ 文件，所以可以支持用 GNU gprof 做性能分析，同时 verilator 提供了 prof 工具，可以将 C++ 的分析结果反标到 verilog/sv。（具体使用方式见 &lt;a href="https://github.com/qian-gu/dic_template"&gt;dic_template&lt;/a&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给 &lt;code&gt;verilator&lt;/code&gt; 命令行加上 &lt;code&gt;--prof-cfunc&lt;/code&gt; 选项&lt;/li&gt;
&lt;li&gt;编译、运行仿真后会输出 &lt;code&gt;gmont.out&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;gprof&lt;/code&gt; 分析 &lt;code&gt;gmont.out&lt;/code&gt; 和 &lt;code&gt;Vtb_top&lt;/code&gt;，结果输出到 &lt;code&gt;grpof.out&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;verilator_profcfunc&lt;/code&gt; 分析 &lt;code&gt;gprof.out&lt;/code&gt;，将性能分析结果反标到 Verilog/sv 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="execution-profiling"&gt;Execution Profiling&lt;/h3&gt;
&lt;p&gt;统计 verilated model 的运行时间并进行可视化，对于性能优化来说非常有用。verilator 通过下面方式实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给 &lt;code&gt;verilator&lt;/code&gt; 命令行加上 &lt;code&gt;--prof-exec&lt;/code&gt; 选项&lt;/li&gt;
&lt;li&gt;编译、运行仿真后会输出 &lt;code&gt;profile_exec.dat&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;verilator_gantt&lt;/code&gt; 分析 &lt;code&gt;profile_exec.dat&lt;/code&gt;，输出 &lt;code&gt;profile_exec.vcd&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;用 gtkwave 分析波形&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="gtkwave"&gt;Gtkwave&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/gtkwave/gtkwave"&gt;gtkwave&lt;/a&gt; 是 verdi 的平替，安装和使用都非常简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;gtkwave
gtkwave&lt;span class="w"&gt; &lt;/span&gt;wave.vcd&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><category term="Tools"></category><category term="IC-tools"></category><category term="iverilog"></category><category term="verilator"></category><category term="gtkwave"></category></entry><entry><title>Computer Architecture 笔记 —— Cache</title><link href="https://qian-gu.github.io/posts/ic/ca-cache.html" rel="alternate"></link><published>2021-11-20T19:21:00+08:00</published><updated>2021-11-20T19:21:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-11-20:/posts/ic/ca-cache.html</id><summary type="html">&lt;p&gt;总结 Cache 的设计细节&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#cache"&gt;为什么需要 Cache？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;面临的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#cache_1"&gt;如何确定 Cache 规格？&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;容量选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#block"&gt;Block 大小选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;映射方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;替换策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;写回策略&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#write-throughwt-write-allocate"&gt;Write-Through(WT) + write allocate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-backwb-write-allocate"&gt;Write-Back(WB) + write allocate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-aroundwa"&gt;Write-Around(WA)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-invalidwi"&gt;Write-Invalid(WI)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-onlywo"&gt;Write-Only(WO)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pass-throughpt"&gt;Pass-Through(PT)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary"&gt;Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#arm-m-cache"&gt;实例：Arm M 系列 cache 规格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#arm-a-cache"&gt;实例：Arm A 系列 cache 规格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#t-head-c906"&gt;实例：T-head C906&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#cache_2"&gt;Cache 的性能指标&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#amat"&gt;AMAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;其他指标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#cache_3"&gt;Cache 的性能分析模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cache_4"&gt;Cache 性能优化方法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#small-and-simple-l1-cache"&gt;Small and Simple L1 Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#way-prediction"&gt;Way Prediction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vitural-indexphysical-tag"&gt;Vitural Index/Physical Tag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#serial"&gt;Serial 访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cache-size"&gt;Cache Size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#block-size"&gt;Block Size&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#set-associativity"&gt;Set Associativity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#prefetch"&gt;Prefetch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#software-optimize"&gt;Software Optimize&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vicitm-cache"&gt;Vicitm Cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-buffer"&gt;Write Buffer( 读优先 )&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#write-merging"&gt;Write Merging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#multiple-level"&gt;Multiple Level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#critical-word-first"&gt;Critical Word First&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#early-restart"&gt;Early Restart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pipeline"&gt;Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#multibank"&gt;Multibank&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#non-blocking"&gt;Non-blocking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Cache 是一个非常广泛、有深度的话题，无数的大牛在此道沉浸数十载，创造出了各种各样的优化技巧和实现技术，一篇短短的博文显然无法做到面面俱到，作为学习笔记，只争取说明白最基础的 Cache 知识。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="cache"&gt;为什么需要 Cache？&lt;/h2&gt;
&lt;h3 id="_1"&gt;面临的问题&lt;/h3&gt;
&lt;p&gt;众所周知，处理器的集成度一直在按照摩尔定律逐渐提高，在 20 世纪的后 20 年内，core 的时钟频率也基本按照每 18 个月翻一番的速度增长，但是 DRAM 的时钟频率增长速度却每年只有 7%，所以两者的速度之间就形成了一个 &lt;code&gt;剪刀差&lt;/code&gt;：随着时间的推移，这个差距会越来越大。即使在现在这个多核时代，core 的频率不再怎么提升了，这个差距仍然在扩大，因为核数量增加对内存的带宽需求也会相应增加。&lt;/p&gt;
&lt;p&gt;这个问题是码农和硅农之间的矛盾：码农希望存储器的容量尽可能大的同时速度足够快，而实际上硅农受限于半导体技术，速度快的 SRAM 容量无法做得很大，成本太高；而容量大的 DRAM 速度无法做得很快。举个例子，假设一个 core 的频率为 2 GHz 的 4-way 超标量处理器，它直接访问 latency = 100ns 的 DRAM，那么访问一次 DRAM 的时间内处理器可以执行多少条指令呢？&lt;/p&gt;
&lt;div class="math"&gt;$$4*100*10^{-9}*2*10^9 = 800$$&lt;/div&gt;
&lt;p&gt;这显然是不可接受的。&lt;/p&gt;
&lt;h3 id="_2"&gt;解决方案&lt;/h3&gt;
&lt;p&gt;按照传统的冯 · 诺依曼结构，指令和数据都在内存中，CPU 只负责处理，内存和 CPU 关系就像是仓库和工厂，工厂加工的原料和生产出来的产品都要放在仓库中。但是摩尔定律和 “ 剪刀差 ” 导致工厂和仓库之间的运输能力成为整个系统的瓶颈，最简单直观的解决办法就是在工厂里面做一个小仓库，对应在处理器中就是存储器层次 &lt;code&gt;Memory Hierarchy&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;存储层次&lt;/th&gt;
&lt;th&gt;大小&lt;/th&gt;
&lt;th&gt;访问 latency&lt;/th&gt;
&lt;th&gt;数据调度&lt;/th&gt;
&lt;th&gt;调度单位&lt;/th&gt;
&lt;th&gt;实现技术&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;register file&lt;/td&gt;
&lt;td&gt;&amp;lt; 1 KB&lt;/td&gt;
&lt;td&gt;0.25 ~ 0.5 ns&lt;/td&gt;
&lt;td&gt;编译器&lt;/td&gt;
&lt;td&gt;Word&lt;/td&gt;
&lt;td&gt;CMOS 寄存器堆&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cache&lt;/td&gt;
&lt;td&gt;&amp;lt; 16 MB&lt;/td&gt;
&lt;td&gt;0.5 ~ 25 ns&lt;/td&gt;
&lt;td&gt;硬件&lt;/td&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;CMOS SRAM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory&lt;/td&gt;
&lt;td&gt;&amp;lt; 16 GB&lt;/td&gt;
&lt;td&gt;80 ~ 250 ns&lt;/td&gt;
&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;CMOS DRAM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O device&lt;/td&gt;
&lt;td&gt;&amp;gt; 100 GB&lt;/td&gt;
&lt;td&gt;5ms&lt;/td&gt;
&lt;td&gt;人工&lt;/td&gt;
&lt;td&gt;file&lt;/td&gt;
&lt;td&gt;disk&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;cache 能缓解问题的原因在于程序具有&lt;strong&gt;局部性原理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;时间局部性&lt;/code&gt;：一个数据被访问之后，短期内很大概率会被再次访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;空间局部性&lt;/code&gt;：一个数据被访问之后，短期内很大概率会访问相邻数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;算法局部性&lt;/code&gt;：程序时空间隔都很大地重复访问数据，常见于图像处理等算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中常规的 prefetch 算法无法识别并利用算法局部性，只能靠程序员观察数据访问规律，并重写算法，依靠 programmer/ccompiler 插入 software prefetch 指令。&lt;/p&gt;
&lt;p&gt;Cache 的出现可以说是一种无奈的妥协。如果 DRAM 的速度足够快，或者 SRAM 的容量可以做到足够大，我们的烦恼不复存在了，cache 也没有存在的必要了。但是在未来一段时间内，当今硅工艺不发生革命性变化的前提下，这是很难实现的一件事情，所以 cache 是有必要的。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;冯诺依曼结构中有个永恒的主题：如何喂饱饥饿的 CPU，即如何提供稳定的指令流和数据流：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令流：分支预测&lt;/li&gt;
&lt;li&gt;数据流：cache&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过多年发展，大概能达到半饱的程度：4 发射的结构，IPC = 2 就已经很不错了。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="cache_1"&gt;如何确定 Cache 规格？&lt;/h2&gt;
&lt;p&gt;cache 的规格可以总结为下面几个问题。&lt;/p&gt;
&lt;h3 id="_3"&gt;容量选择&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Q：Cache 的总容量应该设置为多少合适？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A：没有标准答案，应该根据 &lt;code&gt;应用需求&lt;/code&gt; 和 &lt;code&gt;微架构&lt;/code&gt; 设计特点做出选择。&lt;/p&gt;
&lt;p&gt;首先，cache 容量对 area 有最直接的影响，一般 cache 占用处理器 60% ~ 80% 的晶体管和 30% 以上的总面积，在某些处理器中甚至达到了 80% 的面积。所以确定 cache 容量时，首先要考虑的就是面积约束（即 area 和 money）。&lt;/p&gt;
&lt;p&gt;其次，在满足面积约束的前提下，显然希望 cache 性能越高越好。根据 3C 模型，可以知道&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加容量的优点：可以降低 capacity miss，从而降低整体的 miss rate&lt;/li&gt;
&lt;li&gt;增加容量的缺点：导致时序变差，导致 hit time 和 miss penality 变大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 cache 容量是一把双刃剑，并不是越大性能就越高。&lt;/p&gt;
&lt;p&gt;目前的主流方案是多级 cache，不同级别的 cache 设计目标不同，所以容量规格也不同。因为其他级 cache 的出现，每一级 cache 的最佳规格、设计思路与单级 cache 方案完全不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L1 离 core 最近，其目标是跟上 core 的速度，所以会选择小容量、低相联度的结构，牺牲一些 hit rate，尽量减小 latency，换取高 throughput 和低 hit time。它的容量和 block size 相比于单级 cache 来说都要小很多，以减小 miss penality&lt;/li&gt;
&lt;li&gt;L2 离 core 远一些，其目标则是低 miss rate，所以会选择大容量、高相联度的结构，牺牲一些频率、throughput 和 latency，换取更低的 miss rate。它的容量和 block size 都要比单级 cache 要大很多&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="block"&gt;Block 大小选择&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Q：每个 block 的大小应该设置为多少？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A：应该根据 &lt;code&gt;cache size&lt;/code&gt; 做出选择 , 一般为 4～8 Word，常见的组合有 cache size = 4KB，block size = 32B; cache size &amp;gt; 64KB, block size = 64B。&lt;/p&gt;
&lt;p&gt;较大的 block 可以更好地利用空间局部性，所以可以降低 miss rate，但是当 block 占 cache 容量的比例大到一定程度时，因为 block 的数量变得很少，此时会有大量的冲突，数据在被再次访问前就已经被替换出去了，而且太大的 block 内部数据的空间局部性也会降低，所以会导致 miss rate 反而上升。&lt;/p&gt;
&lt;p&gt;随着 block 的增大，miss rate 的改善逐渐降低，但是在不改变 memory 系统的前提下，miss penalty 会随着 block 的增大而增大，所以当 miss penalty 超过了 miss rate 的收益，cache 的性能就会变低。&lt;/p&gt;
&lt;p&gt;block 的大小还依赖于下一级存储器的 latency 和 throughput：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;latency 和 throughput 越大，越应该使用大 block：因为每次 miss 可以取得更多的数据，但是 miss penality 增长很小（因为此时 miss penality 的主要成分是 latency，所以增大 block 额外传输数据的时间占比很小）&lt;/li&gt;
&lt;li&gt;latency 和 throughput 越小，越应该使用小 block：因为这种情况下增大 block 并不会节省多少时间（比如小块的 penlaty*2 和一个两倍大小 block 的 penalty 相同，此时显然选小 block 更好，还能减小 conflict miss）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;较大 block 会导致较长的传输时间，虽然这部分时间很难优化，但是我们可以隐藏一些数据传输的时间，从而降低 miss penalty。实现这个效果的最简单的技术叫做 &lt;code&gt;early restart&lt;/code&gt;：一旦接收到需要的 word 就立即就开始重启流水线，而不是等到整个 block 都返回后才重启。许多处理器都在 I-cache 上使用这个技术，效果甚佳，这是因为大部分指令访问都具有连续性。这个技术对于 D-cache 来说效果就没那么好了，因为数据访问的预测性没那么好，在传输结束前请求另外一个 block 中 word 的概率很高，而此时前一次请求的数据传输还没有结束，所以仍然会导致处理器 stall。&lt;/p&gt;
&lt;p&gt;还有一种更加复杂的机制叫做 &lt;code&gt;requested word first&lt;/code&gt; 或者是 &lt;code&gt;critical word first&lt;/code&gt;，这种方案会重新组织 memory 的结构，使得被请求的 word 优先返回，然后按照顺序返回后续数据，最后反卷到 block 的开头部分。这种方法比 early restart 稍微快一点，但是会受到相同的限制。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="_4"&gt;映射方式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Q：应该如何组织 cache 的存储结构？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A：根据 &lt;code&gt;cache size&lt;/code&gt; 三选一，有个一般性的规律：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2:1 cache rule of thumb&lt;/strong&gt;：容量为 N、直接映射的 miss rate = 容量为 N/2、相联度为 2-way 的 miss rate。&lt;/p&gt;
&lt;p&gt;cache 的工作方式和停车场非常类似，如果停车场（cache）中有可用的空车位（cache line），那么汽车（data）就可以停在该车位中；如果停车场已经没有空车位，那么就要先把某个车开出来（数据替换出去），然后才能把新来的车停进去。而在停车场找车时，如果停车场很大，而且所有的车都随机停，那么找车（查找数据）的速度就会很慢。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;类比&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接映射&lt;/td&gt;
&lt;td&gt;固定车位&lt;/td&gt;
&lt;td&gt;硬件简单、成本低，查找速度快&lt;/td&gt;
&lt;td&gt;不灵活、易冲突、利用率低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全相联&lt;/td&gt;
&lt;td&gt;随机车位&lt;/td&gt;
&lt;td&gt;冲突小、利用率高&lt;/td&gt;
&lt;td&gt;硬件复杂，查找速度慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组相联&lt;/td&gt;
&lt;td&gt;区域内随机车位&lt;/td&gt;
&lt;td&gt;折中&lt;/td&gt;
&lt;td&gt;折中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;组相联是另外两种方式的折中：组之间是直接映射、组内是全相联。直接映射可以看作是组数 set = full 的特例，全相联可以看作是 set = 1 的特例。&lt;/p&gt;
&lt;h3 id="_5"&gt;替换策略&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Q：如果一个 set 中没有可用的 way 时，应该把哪个 way 替换出去？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A：根据 &lt;code&gt;associative&lt;/code&gt; 和实现复杂度三选一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LRU&lt;/code&gt; (Least Recently Used)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;random&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIFO&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据理论分析，应该把最不活跃的数据替换出去，因为它再次被用的概率最小，即 LRU 策略。但是 LRU 的实现代价比较高，一般超过 8 way 就不可接受了，所以常用方法是 pseudo-LRU，用较小的代价实现近似 LRU 的效果。另外两种则很直观。根据《量化分析》的统计结果，在小容量时 LRU 的效果最好，当容量变大后，LRU 和 random 的效果差不多，FIFO 的效果则取决于具体程序。&lt;/p&gt;
&lt;h3 id="_6"&gt;写回策略&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Q：cache 应该如何处理写回数据？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A： 实际需求和数据访问模式，还有其他约束条件共同决定&lt;/p&gt;
&lt;p&gt;常见的组合方式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;hit&lt;/th&gt;
&lt;th&gt;miss&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;方式一&lt;/td&gt;
&lt;td&gt;write back&lt;/td&gt;
&lt;td&gt;write allocate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;方式二&lt;/td&gt;
&lt;td&gt;write through&lt;/td&gt;
&lt;td&gt;write non-allocate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;hit 下两种不同处理方式的对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;策略&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;应用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;write through&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;硬件简单、flush 代价小&lt;/td&gt;
&lt;td&gt;性能差&lt;/td&gt;
&lt;td&gt;L1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;write back&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;hit 效率高、带宽利用率高&lt;/td&gt;
&lt;td&gt;硬件复杂、flush 代价高&lt;/td&gt;
&lt;td&gt;L2 之后&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面分类讨论不同策略的含义和优缺点。&lt;/p&gt;
&lt;h4 id="write-throughwt-write-allocate"&gt;Write-Through(WT) + write allocate&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; hit 时同时写入 cache memory 和 lower memory；miss 时 allocate，先读回后写入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 兼顾了 fast retrieval 和 data lost risk，维护一致性简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 只加速 read；write latency 差&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt; write once，retrieval frequently 的场景（偶尔个别 write latency 可忍受）&lt;/p&gt;
&lt;h4 id="write-backwb-write-allocate"&gt;Write-Back(WB) + write allocate&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; hit 时写入 cache memory，不写入 lower memory；miss 时 allocate，先读回后写入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 同时加速 read/write；兼顾了 fast retrieval 和 write latency&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 有 data lost risk，维护一致性困难&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt; read-write 混合场景&lt;/p&gt;
&lt;h4 id="write-aroundwa"&gt;Write-Around(WA)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; write through + write non-allocate&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 避免 pollution（一次性数据不会 flood），无 data lost risk，维护一致性简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 只加速 read；write latency 差&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt; 不频繁 retrieval write data；stream 应用&lt;/p&gt;
&lt;h4 id="write-invalidwi"&gt;Write-Invalid(WI)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 只写入 lower memory，write hit 时 invalid 命中行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 确保 read 性能，无 data lost risk，维护一致性简单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 只加速 read；write latency 差&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt; read intensive 应用&lt;/p&gt;
&lt;h4 id="write-onlywo"&gt;Write-Only(WO)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; write 同 write back，read 不会存储到 cache memory&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 确保 write 性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 只加速 write；有 data lost risk，维护一致性困难&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt; write intensive 应用&lt;/p&gt;
&lt;h4 id="pass-throughpt"&gt;Pass-Through(PT)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; bypass 所有请求到 lower memory&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; N/A&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; N/A&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt; debug&lt;/p&gt;
&lt;h4 id="summary"&gt;Summary&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;policy&lt;/th&gt;
&lt;th&gt;speedup&lt;/th&gt;
&lt;th&gt;retrieval&lt;/th&gt;
&lt;th&gt;write latency&lt;/th&gt;
&lt;th&gt;consistency&lt;/th&gt;
&lt;th&gt;data lost risk&lt;/th&gt;
&lt;th&gt;speical&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;WT + WA&lt;/td&gt;
&lt;td&gt;RO&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WB + WA&lt;/td&gt;
&lt;td&gt;RW&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;RW mix&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WA&lt;/td&gt;
&lt;td&gt;RO&lt;/td&gt;
&lt;td&gt;+(RO)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;Stream&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WI&lt;/td&gt;
&lt;td&gt;RO&lt;/td&gt;
&lt;td&gt;+(RO)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;Read intensive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WO&lt;/td&gt;
&lt;td&gt;WO&lt;/td&gt;
&lt;td&gt;+(WO)&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Write intensive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PT&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;debug&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="arm-m-cache"&gt;实例：Arm M 系列 cache 规格&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/ARM-Cortex-M"&gt;ARM M 系列配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结可以得到下面规律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cortex-M 系列定位为 MCU，主要应用于嵌入式领域&lt;/li&gt;
&lt;li&gt;中低端 core 内部没有集成任何类型的 cache（M0, M0+, M3, M4）&lt;/li&gt;
&lt;li&gt;在系统层次，可以为 core 配置系统级别的 cache/TCM&lt;/li&gt;
&lt;li&gt;高端 core 内部可能同时集成了 cache 和 TCM（M7）&lt;/li&gt;
&lt;li&gt;STM32F7 中集成的 M7 是一款双发射、6-stage 的超标量嵌入式处理器，core 内部同时配置了 cache 和 TCM&lt;/li&gt;
&lt;li&gt;I-cache 容量为 0~64KB，cache block 大小为 32B，2-way&lt;/li&gt;
&lt;li&gt;D-cache 容量为 0~64KB，cache block 大小为 32B，4-way&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="arm-a-cache"&gt;实例：Arm A 系列 cache 规格&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/List-of-ARM-microarchitectures#Designed-by-ARM"&gt;ARM A 系列配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结可以得到下面规律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cortex-A 系列定位移动端和用户级应用&lt;/li&gt;
&lt;li&gt;A 系列要支持 OS，所以全系配置了不同大小的 cache，舍弃了 TCM&lt;/li&gt;
&lt;li&gt;低性能 core 只集成了 L1 cache，高性能 core 还集成了 L2 cache，甚至是 L3&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="t-head-c906"&gt;实例：T-head C906&lt;/h3&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="cache_2"&gt;Cache 的性能指标&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Q：如何评价一个 cache 的性能？&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="amat"&gt;AMAT&lt;/h3&gt;
&lt;p&gt;Cache 最常用的性能指标是： &lt;code&gt;AMAT&lt;/code&gt;(Average memory aceess time) ，显然 Cache 系统设计越合理，对 core 表现出来的性能越好，AMAT 就越小。根据定义可以知道 AMAT 的计算公式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(AMAT = Time\ for\ a\ hit + Miss\ rate * Miss\ penalty\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于多级 Cache 系统，AMAT 公式如下（以两级 Cache 为例）：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(T_{avg}=H_1*C_1 + (1-H_1)*(H_2*(C_1 + C_2) + (1-H_2)*(C_1 + C_2 + M)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个符号的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(H_1\)&lt;/span&gt; 表示 L1 cache 的命中率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(H_2\)&lt;/span&gt; 表示 L2 cache 的命中率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_1\)&lt;/span&gt; 表示 L1 cache 命中访问时间&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_2\)&lt;/span&gt; 表示 L2 cache 命中访问时间（即 L1 miss 但是 L2 hit 的 penalty）&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(M\)&lt;/span&gt; 表示 DDR 的访问时间（即 L2 miss 的 penalty）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以换一种算法：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(T_{avg}= C_1 + (1-H_1)*C_2 + (1-H_1)*(1-H_2)*M\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以证明两种方式是等价的。&lt;/p&gt;
&lt;h3 id="_7"&gt;其他指标&lt;/h3&gt;
&lt;p&gt;AMAT 是 dcache 对外表现出来的综合性指标，如果想评估深入评估 dcache 微架构，那么应该用更多的细分指标来衡量。&lt;/p&gt;
&lt;p&gt;最基本的指标是所有硬件都适用的 &lt;code&gt;throughput&lt;/code&gt; 和 &lt;code&gt;latency&lt;/code&gt;，描述 cache 响应命令的吞吐率和时延。&lt;/p&gt;
&lt;p&gt;Cache 特有的最简单的指标是命中率 &lt;code&gt;hit ratio&lt;/code&gt;，描述 cache 规格 / 微架构是否合理，合理的设计命中率都比较高，95% 以上。&lt;/p&gt;
&lt;p&gt;另外如果想衡量 prefetch 的性能，主要有两个指标 &lt;code&gt;coverage&lt;/code&gt; 和 &lt;code&gt;accuracy&lt;/code&gt;，&lt;/p&gt;
&lt;div class="math"&gt;$$coverage=\frac{miss\ eliminated\ by\ prefetch}{total\ miss\ without\ prefetch}$$&lt;/div&gt;
&lt;div class="math"&gt;$$accuracy=\frac{miss\ eliminated\ by\ prefetch}{total\ prefetch}$$&lt;/div&gt;
&lt;p&gt;coverage 描述了漏警性能，accuracy 描述了虚警性能，一般这两者很难兼得。同理，victim cache 也可以用类似的指标来衡量。&lt;/p&gt;
&lt;h2 id="cache_3"&gt;Cache 的性能分析模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3C 模型&lt;/strong&gt;，也就是分析清楚 cache 的 miss 可以分为几类，每一类的产生原因是什么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compulsory miss&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;capacity miss&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conflict miss&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦知道了 miss 产生的原因，也就可以针对性地采用各种方法来降低。虽然按照 3C 模型来分析时，优化某个因素的行为可能会导致另外一个因素的恶化，但是总体上它仍然是个很有用的工具，可以帮助我们在做设计时对 cache 性能进行建模（而且目前我们也没有更好的模型）。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;当系统中有多个 cache 时，会额外再增加一个 C &lt;code&gt;coherency miss&lt;/code&gt;，即为了保持一致性导致 cache 进行 flush，产生 miss。此时就是 4C 模型。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="cache_4"&gt;Cache 性能优化方法&lt;/h2&gt;
&lt;p&gt;有了 cache 模型，就可以根据模型来优化性能，针对性能公式中的每个因子，优化思路可以分为下面几类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;优化思路&lt;/th&gt;
&lt;th&gt;优化方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;减小 hit time&lt;/td&gt;
&lt;td&gt;小而简单的 L1 cache、路预测、Vitural Index/Physical Tag、serial 访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;减小 miss rate&lt;/td&gt;
&lt;td&gt;增大容量、增大 block size、增加关联度、预取、软件优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;减小 miss penalty&lt;/td&gt;
&lt;td&gt;victim cache、write buffer、多级 cache、关键字优先、写合并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提高 throughput&lt;/td&gt;
&lt;td&gt;pipeline、multibank( 多端口 )、非阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;miss penality 本质是就是一块数据的搬运耗时，可以借用 “ 火车过山洞 ” 模型：&lt;/p&gt;
&lt;p&gt;假设火车长度为 l，火车的时速为 v，火车头进入山洞的时刻为 t1，火车头出山洞的时间为 t2，火车尾出山洞的时刻为 t3，那么可以将火车过山洞的过程和数据搬运过程对应起来&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;火车过山洞&lt;/th&gt;
&lt;th&gt;搬运数据&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t2-t1&lt;/td&gt;
&lt;td&gt;latency&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;throughput&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;data-amount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t3-t2 = l/v&lt;/td&gt;
&lt;td&gt;transfer-time = data-amount/throughput&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;火车过山洞的总时间 = t3 - t1 = (t3-t2) + (t2-t1)&lt;/p&gt;
&lt;p&gt;数据传输的总时间 = transfer-time + latency&lt;/p&gt;
&lt;p&gt;所以优化 miss penality 的方法主要就是下面这 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减小 latency，这个取决于 hierarchy 中的下一级， cache 很难改变&lt;/li&gt;
&lt;li&gt;减小 data-amout，每次 miss 时少取一些数据&lt;/li&gt;
&lt;li&gt;增加 throughput，提高 cache 和 hierarchy 下一级之间的传输带宽&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="small-and-simple-l1-cache"&gt;Small and Simple L1 Cache&lt;/h3&gt;
&lt;p&gt;面临的问题：复杂 L1 的速度很难跟上 core 的时钟频率。&lt;/p&gt;
&lt;p&gt;解决思路：思路 1（减小 hit time），简化硬件设计、减小 size 和 associativity，从而减小 hit time。&lt;/p&gt;
&lt;p&gt;付出的代价：miss rate 增加，需要下级 cache 作为补充。&lt;/p&gt;
&lt;h3 id="way-prediction"&gt;Way Prediction&lt;/h3&gt;
&lt;p&gt;面临的问题：对于并行访问 tag 和 data 的组相联 cache，必须经过下面 3 个步骤，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读 tag memory&lt;/li&gt;
&lt;li&gt;比较 tag 内容&lt;/li&gt;
&lt;li&gt;根据读 tag 的结果选中 &amp;amp; 操作 data memory（mux + 写 data memory）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个过程组合逻辑很长，hit time 较长，所以时钟频率无法做到很高。&lt;/p&gt;
&lt;p&gt;解决思路：思路 1（减小 hit time），采用 prediction bits，把组相联的 cache 当初直接相联来用，那么第二步的比较 tag 就只有 1 个 way 做比较，如果命中则相当于直接相联 cache 结构；否则在下个周期检查剩余 way 的 tag。因为这种方式第二步的组合逻辑变少，hit time 就变短了。&lt;/p&gt;
&lt;p&gt;付出的代价：使得 pipeline 难以实现。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;还有一种更进一步的做法叫做 &lt;code&gt;way selection&lt;/code&gt;，即第一步也只读 1 个 way 的 tag，如果 miss 则需要重新读剩余 tag、作比较、操作 data memory。这种方法显然可以更省功耗，但是缺点就是一旦 miss，付出的代价很大，因为要完成重新执行一遍步骤 123。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="vitural-indexphysical-tag"&gt;Vitural Index/Physical Tag&lt;/h3&gt;
&lt;p&gt;面临的问题：全部使用虚拟地址时，必须经过一道查询 TLB 的过程，增加了整体的访问 latency。&lt;/p&gt;
&lt;p&gt;解决思路：思路 1（减小 hit time），采用 page offset 作为 cache tag，省去查询 TLB 的过程。&lt;/p&gt;
&lt;p&gt;付出的代价：实现复杂度增加，功耗增加。&lt;/p&gt;
&lt;h3 id="serial"&gt;Serial 访问&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;parrel：tag array 和 data array 并行访问，根据 tag array 的读结果产生 mux 信号，从 data array 的结果中选出目标 way&lt;/li&gt;
&lt;li&gt;serial：先访问 tag array，根据结果产生 data array 的片选信号，直接读出目标 way&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面临的问题：parrel 方式 critial path 较长，频率低&lt;/p&gt;
&lt;p&gt;解决思路：思路 1（减小 hit time），采用 serial 方式优化 critical path，同时因为省去了不必要的读 data array，所以功耗也更低。&lt;/p&gt;
&lt;h3 id="cache-size"&gt;Cache Size&lt;/h3&gt;
&lt;p&gt;面临的问题：cache 容量不够，数据频繁被替换。&lt;/p&gt;
&lt;p&gt;解决思路：思路 2（降低 miss rate），降低 capacity miss&lt;/p&gt;
&lt;p&gt;付出的代价：导致 hit time 变大，同时成本和功耗也会变高。&lt;/p&gt;
&lt;h3 id="block-size"&gt;Block Size&lt;/h3&gt;
&lt;p&gt;面临的问题：block 太小，对空间局部性的利用不充分。&lt;/p&gt;
&lt;p&gt;解决思路：思路 2（降低 miss rate），可以充分利用空间局部性，降低 compulsory miss。而且扩大 block size 会导致 tag 位宽变小，相应地可以减小一点功耗。&lt;/p&gt;
&lt;p&gt;付出的代价：导致 miss penality 变大；而且过大的 blocksize 会适得其反。&lt;/p&gt;
&lt;h3 id="set-associativity"&gt;Set Associativity&lt;/h3&gt;
&lt;p&gt;面临的问题：关联度太小，一个 set 内频繁竞争。&lt;/p&gt;
&lt;p&gt;解决思路：思路 2（降低 miss rate），降低 conflict miss。&lt;/p&gt;
&lt;p&gt;付出的代价：导致 hit time 变大，同时成本的功耗也会变高。&lt;/p&gt;
&lt;h3 id="prefetch"&gt;Prefetch&lt;/h3&gt;
&lt;p&gt;面临的问题：如果每次发生 miss 时只取回当前 cache line，那么 cache 向 DDR 发送的 burst len 和 outstanding 都很小，效率很低。频繁发生 compulsory miss。&lt;/p&gt;
&lt;p&gt;解决思路：思路 2（降低 miss rate）。在取回当前 cache line 的同时以大 burst len 和 outstanding 高效地多取一些相邻数据，这样访问这些预取数据时就不会发生 miss。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件预取：有些 ISA 定义了预取指令，程序员可以通过软件进行预取&lt;ul&gt;
&lt;li&gt;register prefetch：把数据预取到 register 中&lt;/li&gt;
&lt;li&gt;cache prefetch：把数据预取到 cache 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;硬件预取：cache 自主可以观测 unit-stride 和 stride 的规律，自动预取数据&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OBL&lt;/code&gt; (one block look-ahead)&lt;/td&gt;
&lt;td&gt;每次多预取一个 cache block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stream buffer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多预取的数据存储在 stream buffer 中，miss 时再写入 cache line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SPT&lt;/code&gt; (stride predict table)&lt;/td&gt;
&lt;td&gt;硬件检测 load 是否存在 stride 模式，取回数据直接写入 cache line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stream cache&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;结合 steam buffer 和 SPT，把预取回来的数据放在一个小 cache 中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;预取数据不直接存到 cache 中的原因是避免 “cache 污染 ”，但是 stream buffer 不灵活，所以改进方案是把预取数据放到一个 stream cache 中。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件复杂度增加，消耗更多资源。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;prefetch 有效的前提是有剩余带宽未被利用。如果 prefetch 干扰了正常 miss 的读取，那么反而会降低性能。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="software-optimize"&gt;Software Optimize&lt;/h3&gt;
&lt;p&gt;纯软件，不需要改任何硬件。&lt;/p&gt;
&lt;p&gt;同样也可以分为两类：改善 miss rate 或者是改善 miss penality。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;loop interchange：交换嵌套 loop 的顺序&lt;/li&gt;
&lt;li&gt;bloking：对数据分块处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vicitm-cache"&gt;Vicitm Cache&lt;/h3&gt;
&lt;p&gt;面临的问题：conflict miss 导致频繁的读写下一级 memory，导致整体性能降低。增加相联度代价太大，其他 set 没有这个需求。&lt;/p&gt;
&lt;p&gt;解决思路：思路 2（降低 miss rate），另外增加一个小容量（通常 4~16 个数据）、全相联的 cache，缓存被替换出来的数据。一般和 main cache 为 exclusive 关系。&lt;/p&gt;
&lt;p&gt;和 Victim Cache 相对应的还有一种 Filter Cache，即在数据进入 main cache 前，先写入 Filter cache，等数据再次被使用时才写入 main cache，用来过滤偶然数据，提高整体利用率。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件复杂度增加。维护 victim cache 和 main cache 之间的一致性。&lt;/p&gt;
&lt;h3 id="write-buffer"&gt;Write Buffer( 读优先 )&lt;/h3&gt;
&lt;p&gt;面临的问题：如果发生 miss 时被替换的 block 为 dirty，则必须先将其写回下级 memory 后才能把目标 block 读进来，整个过程是串行的。当写下级的代价很高时，会导致 miss penality 很大。&lt;/p&gt;
&lt;p&gt;解决思路：思路 3（减小 miss penality），先将 dirty block 写入一本本地的 write buffer，为目标 block 尽早腾出空间。等下级 memory 空闲时，再将 dirty block 写入其中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 write-back 的 cache，就是把 dirty cache line 整条都写入 write buffer&lt;/li&gt;
&lt;li&gt;对于 write-through 的 cahe，就是把 dirty data 写入 write buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L1 D-cache 通常采用 write-through 方案，配合 write buffer 提高性能。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件复杂度增加。cache 发生 miss 时首先要查询 write buffer（需要 CAM）&lt;/p&gt;
&lt;h3 id="write-merging"&gt;Write Merging&lt;/h3&gt;
&lt;p&gt;面临的问题：如果 core 每次只写一个 word，那么普通 write buffer 的每个 entry 的大部分空间都会被浪费掉，write buffer 很容易达到 full。&lt;/p&gt;
&lt;p&gt;解决思路：思路 3（减小 miss penality），每次把数据写入 write buffer 时，检查是否可以合并到已有 entry 中。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件复杂度增加。&lt;/p&gt;
&lt;h3 id="multiple-level"&gt;Multiple Level&lt;/h3&gt;
&lt;p&gt;面临的问题：单级 cache 无法同时满足 fast hit 和 few miss 的需求。&lt;/p&gt;
&lt;p&gt;解决思路：思路 3（减小 miss penality），存储器层次结构 L1 + L2 + L3。一般 L1/L2 为每个 core 私有，L2/L3 共享。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L1： 小容量、低关联度、write-through&lt;/li&gt;
&lt;li&gt;L2/L3: 大容量、高关联度、write-back&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;付出的代价：面积变大、解决一致性问题、硬件复杂度增加。&lt;/p&gt;
&lt;h3 id="critical-word-first"&gt;Critical Word First&lt;/h3&gt;
&lt;p&gt;面临的问题：core 每次访问实际上只需要一个 word，但是 cache miss 时取要取回整个 block，耗时较长。&lt;/p&gt;
&lt;p&gt;解决思路：思路 3（减小 miss penality），采用 “ 不耐心 ” 的做法，优先向下级 memory 请求 miss 的 word，一旦读回来立即返回给 core。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件控制复杂化。&lt;/p&gt;
&lt;h3 id="early-restart"&gt;Early Restart&lt;/h3&gt;
&lt;p&gt;面临的问题：同 Critical word first&lt;/p&gt;
&lt;p&gt;解决思路：思路 3（减小 miss penality），另外一种 “ 不耐心 ” 的做法，按照正常顺序请求数据，但是取回数据后立即把 word 发给 core。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件控制复杂化。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;critical word first 和 early restart 只有在 block size 很大时收益才比较明显。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="pipeline"&gt;Pipeline&lt;/h3&gt;
&lt;p&gt;面临的问题：读 D-cache 时 tag memory 和 data memory 可以并行同时读；但是对于写 D-cache，必须经过 way prediction 小节中提到的 3 个过程。整个过程串行操作时钟频率会很低，一般的做法是分为两个 cycle，第一拍读 tag 作比较，第二拍写 data memory。此时 throughput 为 0.5 instr/cycle。&lt;/p&gt;
&lt;p&gt;解决思路：思路 4（提高 throughput），将整个过程 pipeline 化，达到 1 instr/cycle 的 throughput。&lt;/p&gt;
&lt;p&gt;付出的代价：硬件复杂度增加。后续指令要额外检查 pipeline 上的数据，增加 forward 通路。显然 pipeline 越深，mispredict 时 flush 的代价就越大，同时 load-to-use 的 latency 也越大。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;pipeline 主要应用在 L1 上，因为它的访问带宽会限制 instruction throughput。目前大多数 core 的 L1 都采用 3~4 级 pipeline 的方式。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="multibank"&gt;Multibank&lt;/h3&gt;
&lt;p&gt;面临的问题：单 bank 的最高 throughput = 1 instr/cycle，无法满足超标量处理器的需求&lt;/p&gt;
&lt;p&gt;解决思路：思路 4（提高 throughput）。多 bank（多端口）有几种常见方案：&lt;/p&gt;
&lt;p&gt;一般多端口的实现方案有以下几张：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实现方案&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;true multiple port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真正的多端口，memory 有相应数量的读写端口&lt;/td&gt;
&lt;td&gt;实现代价太大，不可接受&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;virtual multiple port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;memory 仍然是单端口，cache 频率是 core 的倍数&lt;/td&gt;
&lt;td&gt;可扩展性差，现在不可接受&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;copy multiple port&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;memory 仍然是单端口，但是复制多份，保持 copy 之间的同步&lt;/td&gt;
&lt;td&gt;浪费资源，同步控制复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;multiple bank&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;memory 仍然是单端口，按照地址分 bank 交织&lt;/td&gt;
&lt;td&gt;折中方案，普遍应用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;分 bank 按照地址交织，也有一些缺点，比如要依靠编译器降低冲突概率；发生冲突时性能变差；内部 crossbar 对 PR 不友好，但是相比于其他几个方案，代价最小，应用最广泛。&lt;/p&gt;
&lt;p&gt;付出的代价：增加硬件复杂度，消耗更多资源。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;multibank 应用在 L1 时主要为了提供高 throughput，应用于 L2, L3 时更主要的目标是做功耗控制。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="non-blocking"&gt;Non-blocking&lt;/h3&gt;
&lt;p&gt;面临的问题：miss 会阻塞 core 的流水线，效率低。&lt;/p&gt;
&lt;p&gt;解决思路：思路 4（提高 throughput），cache 在处理当前 miss 的同时处理后续的请求。&lt;/p&gt;
&lt;p&gt;付出的代价：增加硬件复杂度，消耗更多资源（MSHR）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in-cache MSHR&lt;/code&gt;：给 tag array 新增额外的 1bit transient 信号，如果某 entry 处于 transient mode，tag array 保存 base address，data array 保存所有的 MSHR 信息，具体形式既可以是 implicit 也可以是 explicit。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;MSHR 实现方式&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;implicitly&lt;/td&gt;
&lt;td&gt;消耗资源少（不需要记录 offset）&lt;/td&gt;
&lt;td&gt;一个 word 只能 miss 一次、深度固定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;explicitly&lt;/td&gt;
&lt;td&gt;同一个 word 可以 miss 多次、深度灵活可配&lt;/td&gt;
&lt;td&gt;消耗资源多（需要额外记录 offset）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in-cache&lt;/td&gt;
&lt;td&gt;不需要任何额外资源保存 MSHR&lt;/td&gt;
&lt;td&gt;处理步骤增多，latency 变大&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_8"&gt;参考资料&lt;/h2&gt;
&lt;p&gt;Computer Organization and Design RISC-V Edition. David A. Patterson, John L. Hennessy&lt;/p&gt;
&lt;p&gt;Computer Architecture: A Quantitative Approach. John L. Hennessy, David A. Patterson&lt;/p&gt;
&lt;p&gt;Processor Microarchitecture: An Implementation Perspective. Antonio Gonzalez&lt;/p&gt;
&lt;p&gt;《计算机体系结构》 胡伟武&lt;/p&gt;
&lt;p&gt;《超标量处理器》 姚永斌&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Computer Architecture"></category><category term="Cache"></category></entry><entry><title>Fusesoc 小结</title><link href="https://qian-gu.github.io/posts/tools/fusesoc-summary.html" rel="alternate"></link><published>2021-10-30T16:25:00+08:00</published><updated>2021-10-30T16:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-10-30:/posts/tools/fusesoc-summary.html</id><summary type="html">&lt;p&gt;记录 fusesoc 用法&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近看到很多开源项目都在用 fusesoc 来管理，花了半天时间学习了一下，简单记录一下笔记。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;下面的内容作为学习笔记，主要节选翻译自 Fusesoc 的官方文档，最新的完整内容见官网。&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="what-is-fusesoc"&gt;What is Fusesoc&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/olofk/fusesoc"&gt;Fusesoc&lt;/a&gt; 是一个用 python 写的 HDL 管理工具，用一句话解释就是：&lt;strong&gt;HDL 版的 pip + make&lt;/strong&gt;，它主要解决 IP core 重用时复杂繁琐的常规性工作，更轻松地实现下面目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重用已有的 IP core&lt;/li&gt;
&lt;li&gt;为 compile-time 和 run-time 生成配置文件&lt;/li&gt;
&lt;li&gt;在多个 simulator 上跑回归&lt;/li&gt;
&lt;li&gt;在不同平台间移植设计&lt;/li&gt;
&lt;li&gt;让别人复用你的设计&lt;/li&gt;
&lt;li&gt;配置 CI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个设计中包含多个 core，而且可能会有不同的 target，比如仿真、lint、综合等，而且每个 target 也会有多种工具可用，fusesoc 的目标就是把这些 dirty job 管理起来，使得支持 fusesoc 的 IP 相互之间可以轻松地复用。&lt;/p&gt;
&lt;p&gt;Fusesoc 还有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;非入侵&lt;/strong&gt;：因为 fusesoc 本质上是用特定的描述文件来描述 IP core，这个描述文件不会影响到 IP 本身&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模块化&lt;/strong&gt;：可以为你的工程创建一个 end-to-end 的 flow&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展&lt;/strong&gt;：想支持任何一种新的 EDA 工具时，只需要增加 100 行左右的内容来描述它的用法即可（命令 + 参数）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;兼容标准&lt;/strong&gt;：兼容其他工具的标准格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源丰富&lt;/strong&gt;：标准库目前包含 100 多个 IP（包括 CPU，peripheral, interconnect, SoC 和 util），还可以添加自定义库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开源免费&lt;/strong&gt;：既可以管理开源项目，也可以用到公司内部项目&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实战验证&lt;/strong&gt;：许多开源项目实际使用验证过&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 fusesoc 本身是一个 python package，所以我们可以直接用 pip 来安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pip3&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;fusesoc
fusesoc&lt;span class="w"&gt; &lt;/span&gt;--version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h1 id="how-to-use"&gt;How to use&lt;/h1&gt;
&lt;h2 id="concept"&gt;Concept&lt;/h2&gt;
&lt;p&gt;要使用 fusesoc 首先就要理解它定义的几个概念，然后就可以用 &lt;code&gt;fusesoc -h&lt;/code&gt; 来看具体的命令行选项和用法了。&lt;/p&gt;
&lt;h3 id="core"&gt;&lt;code&gt;core&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;工程管理的第一个问题就是解决依赖。&lt;/p&gt;
&lt;p&gt;就像 pip 管理 package 一样，fusesoc 以 &lt;code&gt;core&lt;/code&gt; 作为基本单元。core 指的就是 IP core 设计本身，比如一个 FIFO。每个 core 都有一个 &lt;code&gt;.core&lt;/code&gt; 文件来描述它，fusesoc 就是通过这个文件来查找、确定某个 core。&lt;/p&gt;
&lt;p&gt;一个 core 可以依赖于另外一个 core，比如一个 FIFO core 依赖于一个 SRAM core。SoC 中有很多 IP core，我们只需要指定顶层 core 即可，剩下的依赖分析都交给 fusesoc 来完成即可。一般 core 有两种组织方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core 代码和 .core 文件保存在一个 repo 下&lt;/li&gt;
&lt;li&gt;core 代码和 .core 文件分两个 repo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;fusesoc standard library 就是按照第二种方式管理的，标准库只是 .core 文件的集合，每个 .core 文件内描述了 core 代码在服务器上的路径。&lt;/p&gt;
&lt;h3 id="core-library"&gt;&lt;code&gt;core library&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;当我们指定顶层 core 后，它依赖的底层 core 代码甚至是底层 .core 文件都不在本地，fusesoc 是如何解决依赖的呢？答案就是 &lt;code&gt;core library&lt;/code&gt;。与软件类似，fusesoc 根据配置文件 &lt;code&gt;fusesoc.conf&lt;/code&gt; 中的 core library 信息来查找所有的 core，所以我们使用某个 core 的第一步就是 “ 安装 ” 包含这个 core 的 library。以 fusesoc 标准库为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fusesoc&lt;span class="w"&gt; &lt;/span&gt;library&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;fusesoc-cores&lt;span class="w"&gt; &lt;/span&gt;https://github.com/fusesoc/fusesoc-cores
&lt;span class="c1"&gt;# show all libraries&lt;/span&gt;
fusesoc&lt;span class="w"&gt; &lt;/span&gt;library&lt;span class="w"&gt; &lt;/span&gt;list
&lt;span class="c1"&gt;# show all cores&lt;/span&gt;
fusesoc&lt;span class="w"&gt; &lt;/span&gt;core&lt;span class="w"&gt; &lt;/span&gt;list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果这个 library 是远程库（如标准库），这个命令会将其 clone 到当前目录下；如果这个 library 是本地库，则会将其路径添加到配置文件中。&lt;/p&gt;
&lt;p&gt;如前面所述，有些 library 可能采用和标准库类似的组织方式，library repo 并不包含 core 代码，而仅仅是 .core 文件集合。所以 &lt;code&gt;fusesoc library add&lt;/code&gt; 命令只是 clone 了 .core 文件，对应的 core 代码并没有下载下来，我们可以看到 &lt;code&gt;fusesoc core list&lt;/code&gt; 显示 core 状态是 empty。在 build 过程中 fusesoc 会根据 .core 文件中 &lt;code&gt;provider&lt;/code&gt; 字段的地址将 core 代码 clone 到 &lt;code&gt;~/.cache/&lt;/code&gt; 目录下面。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;如后面 custom 部分所述，我们可以修改配置文件，指定 clone 和 build 的路径。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="fusesocconf"&gt;&lt;code&gt;fusesoc.conf&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;fusesoc 查找 fusesoc.conf 文件的顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先在当前目录找&lt;/li&gt;
&lt;li&gt;然后在 &lt;code&gt;$XDG_CONFIG_HOME/fusesoc&lt;/code&gt; 下找&lt;/li&gt;
&lt;li&gt;最后在 &lt;code&gt;/etc/fusesoc&lt;/code&gt; 下找&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以直接通过命令行选项 &lt;code&gt;--config&lt;/code&gt; 指定使用某个 fusesoc.conf 文件。&lt;/p&gt;
&lt;p&gt;fusesoc 查找 core 的顺序：&lt;/p&gt;
&lt;p&gt;当 fusesoc 查找到 fusesoc.conf 后，根据文件中 &lt;code&gt;[main]&lt;/code&gt; 的 &lt;code&gt;cores-root&lt;/code&gt; 字段来搜索所有的合法 core 文件，并将其加入内存数据库中。&lt;code&gt;cores-root&lt;/code&gt; 字段可以添加多个目录，用空格隔开。也可以通过命令行参数 &lt;code&gt;--cores-root&lt;/code&gt; 指定搜索目录。fusesoc 查找 core 时按照目录列表顺序搜索，且命令行指定目录位于目录列表的最后。当遇到同名（相同 VLNV，Vender-Library-Name-Version） core 时，后解析到的会覆盖之前的。可以利用这个机制来实现同名 core 的重载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;cores-root&lt;/code&gt; 字段内容顺序来指定某个 lib 重载另外一个 lib 的同名 core&lt;/li&gt;
&lt;li&gt;用命令行参数 &lt;code&gt;--cores-root&lt;/code&gt; 来指定 lib 路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="build-system"&gt;&lt;code&gt;build system&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;解决依赖后，工程管理的第二个问题就是调用 EDA 工具。&lt;/p&gt;
&lt;p&gt;fusesoc 内部的 &lt;code&gt;build system&lt;/code&gt; 从顶层 core 文件开始分析，解决所有依赖后整理出完整的 filelist，然后将后续工作交给真正的 EDA 工具来完成。毕竟，fusesoc 只是一个工程管理工具。显然不同的 EDA 工具用法是不一样的，如何将整理好的 filelist 根据目标调用不同的 EDA 工具，传递该工具的特定参数，这个过程是和 EDA 工具强绑定的。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想调用 verilator 跑仿真：build system 会创建一个 makefile，然后调用 verilator&lt;/li&gt;
&lt;li&gt;如果想生成基于 Xilinx FPGA 的 bit：build system 会创建一个 vivado 工程文件，然后调用 vivado 完成综合 - 布局布线 - 生成 bit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些 dirty job 都由 fusesoc 帮我们做了，而且 fusesoc 本身是可扩展的，可以轻松支持新的 EDA 工具。&lt;code&gt;build system&lt;/code&gt; 包含 3 个概念：&lt;code&gt;tool flow&lt;/code&gt;， &lt;code&gt;target&lt;/code&gt;，&lt;code&gt;build stage&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="tool-flow"&gt;&lt;code&gt;tool flow&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tool flow&lt;/code&gt; 就是某个特定的 EDA 工具分析运行的过程。verilator、vcs 和 vivado 都是一种 tool，显然不同 tool 需要不同的命令来调用，fusesoc 的目标就是对用户隐藏这些工具之间的差异，尽量简化调用过程。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;实际上是将 IP core 用户的工作量转嫁给了 IP core 的提供者，因为一个 IP 要想让别人复用自己的设计，就要提供对应的 .core 文件，提供者在这个文件里描述每一种 target 下每种 tool 使用哪些文件，传入什么样的参数等等。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="target"&gt;&lt;code&gt;target&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;对于同一个 IP，我们可以做不同的任务，比如仿真、综合、lint 等，这些任务对应的 filelist 和参数传递等也不相同，fusesoc 把这些相关配置叫做 &lt;code&gt;target&lt;/code&gt;，一般来说常规的任务有 &lt;code&gt;sim&lt;/code&gt;， &lt;code&gt;synth&lt;/code&gt;，&lt;code&gt;lint&lt;/code&gt; 等。&lt;/p&gt;
&lt;h3 id="build-stage"&gt;&lt;code&gt;build stage&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;fusesco 把 build 过程分为 3 个 stage:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;setup&lt;/code&gt;：把所有 IP 攒到一起，解决所有依赖问题&lt;ul&gt;
&lt;li&gt;从顶层 core 开始生成一棵依赖树&lt;/li&gt;
&lt;li&gt;把调用 &lt;code&gt;generator&lt;/code&gt; 生成的 core 添加到依赖树中&lt;/li&gt;
&lt;li&gt;解析依赖树，生成一个 flattened 描述，将其写入一个 EDAM 文件&lt;/li&gt;
&lt;li&gt;调用某个特定的 tool flow&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bulid&lt;/code&gt;：运行 tool flow 直到输出期望的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;run&lt;/code&gt;：执行 build 阶段的输出，对于 sim 来说就是运行仿真，对于 lint 来说就是调用 lint 工具，对于 FPGA flow 来说就是用生成 bitstream 对 FPGA 进行编程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="building"&gt;Building&lt;/h2&gt;
&lt;p&gt;Build 过程就是 fusesoc 调用 tool flow 产生一些输出，然后执行这些输出文件。所以 target 和 tool flow 不同时，fusesoc 执行的任务也不同。fusesoc 执行 build 分为两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为 IP 写 &lt;code&gt;.core&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;fusesoc run&lt;/code&gt; 命令来调用 fusesoc&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面记录两个实验。&lt;/p&gt;
&lt;h1 id="example-1"&gt;Example 1&lt;/h1&gt;
&lt;p&gt;参考官方的 &lt;code&gt;tests/userguide/blinky&lt;/code&gt;，写了一个 counter 的实验例子。&lt;/p&gt;
&lt;p&gt;首先新建一个目录 &lt;code&gt;~/workspace/mycores/counter&lt;/code&gt;，在下面完成 counter 的 rtl 和 tb，以及 &lt;code&gt;.core&lt;/code&gt; 文件，目录结构如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~/workspace/mycores/counter
├── counter.core
├── rtl
│   └── counter.sv
└── tb
    └── tb_counter.sv

2 directories, 3 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 counter.sv 和 tb_counter.sv 内容很简单&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// counter.sv&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;&amp;#39;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// tb_counter.sv&lt;/span&gt;
&lt;span class="no"&gt;`timescale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;ns&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tb_counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1_000_000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1_000_000_000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;HALF_PERIOD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;U_COUNTER&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="n"&gt;HALF_PERIOD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;initial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;dumpfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sim.vcd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;dumpvars&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Testbench finshed OK&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;counter.core 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;CAPI=2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;qian:examples:counter:1.0.0&lt;/span&gt;
&lt;span class="nt"&gt;description&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Counter, a example core&lt;/span&gt;

&lt;span class="nt"&gt;filesets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;rtl&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;files&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;rtl/counter.sv&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;file_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;systemVerilogSource&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;tb&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;files&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tb/tb_counter.sv&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;file_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;systemVerilogSource&lt;/span&gt;

&lt;span class="nt"&gt;targets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;&amp;amp;default&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filesets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;rtl&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;toplevel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;counter&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;DW&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;sim&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;*default&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;description&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Simulate the design&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;default_tool&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;icarus&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filesets_append&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tb&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;toplevel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tb_counter&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;tools&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;icarus&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;iverilog_options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;-g2012&lt;/span&gt;

&lt;span class="nt"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;datatype    &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;int&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;description &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;counter width&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;paramtype   &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;vlogparam&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;core 文件的语法是 YAML，fuesesoc 的 user guide 里面提供了一个快速入门的教程：&lt;a href="https://learnxinyminutes.com/docs/yaml/"&gt;Learn X in Y minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;core 文件内容需要遵守 user guide 中的 &lt;code&gt;CAPI2&lt;/code&gt; 的语法规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;~/workspace&lt;/code&gt; 目录下面使用执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fusesoc&lt;span class="w"&gt; &lt;/span&gt;--cores-root&lt;span class="o"&gt;=&lt;/span&gt;mycores&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;--target&lt;span class="o"&gt;=&lt;/span&gt;sim&lt;span class="w"&gt; &lt;/span&gt;--setup&lt;span class="w"&gt; &lt;/span&gt;--build&lt;span class="w"&gt; &lt;/span&gt;--run&lt;span class="w"&gt; &lt;/span&gt;qian:examples:counter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们用 &lt;code&gt;--cores-root&lt;/code&gt; 指定 core 的搜索目录，用 &lt;code&gt;--target=sim&lt;/code&gt; 指定执行 sim flow，&lt;code&gt;--setup --build --run&lt;/code&gt; 指定执行完整的 build 3 个步骤，最后的 &lt;code&gt;qian:examples:counter&lt;/code&gt; 是我们在 .core 文件中为 counter 起的名字。&lt;/p&gt;
&lt;p&gt;fusesoc 执行完成后会产生一个 build 目录，在 &lt;code&gt;build/qian-examples-counter-1.0.0/sim-icarus&lt;/code&gt; 下就可以看到结果了，用 &lt;code&gt;gtkwave sim.vcd&lt;/code&gt; 可以看波形。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fusesoc 读取 core 文件后，解析生成 build 下的 makefile， 使用它来调用 EDA 工具&lt;/li&gt;
&lt;li&gt;因为 iverilog 对 sv 的支持不完整，所以如果设计使用的 sv，先确认 iverilog 的版本及对 sv 的支持程度（使用源码本地编译可以得到最新的 iverilog）&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h1 id="example-2"&gt;Example 2&lt;/h1&gt;
&lt;p&gt;一种更常见的场景是我们想复用别人的设计，比如说我们想设计一个 counter_blinky 的 core，它依赖于我们刚才写 counter 和 fusesoc 官方 library 中的 blinky 模块。&lt;/p&gt;
&lt;p&gt;要使用 fusesoc 的官方 library，所以第一步就是添加这个 library：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fusesoc&lt;span class="w"&gt; &lt;/span&gt;library&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;fusesoc-cores&lt;span class="w"&gt; &lt;/span&gt;https://github.com/fusesoc/fusesoc-cores
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个命令会 clone 指定的 library 到当前目录下，并产生一个 &lt;code&gt;fusesoc.conf&lt;/code&gt; 文件，里面保存了这个 library 的配置信息。完成下载后，使用 &lt;code&gt;fusesoc core list&lt;/code&gt; 就可以查看该 library 中包含了哪些 core，并且可以看到对应 core 的状态为 empty 还是 downloaded，empty 表示还没下载该 core 的设计文件。如果设计需要用到某个 core，则 fusesoc 在 build 过程中会自动下载，我们也可以手动下载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!bash&lt;/span&gt;
fusesoc&lt;span class="w"&gt; &lt;/span&gt;fetch&lt;span class="w"&gt; &lt;/span&gt;fusesoc:utils:blinky:0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下载好要用的 blinky core 后我们就可以开始写自己的 counter_blinky 了，在 counter 平级新建一个 counter_blinky 的目录如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;~/workspace/mycores/counter_blinky
├── counter_blinky.core
├── rtl
│   └── counter_blinky.sv
└── tb
    └── tb_counter_blinky.sv

2 directories, 3 files
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 counter_blinky.sv 和 tb_counter_blinky.sv 的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// counter_blinky.sv&lt;/span&gt;
&lt;span class="n"&gt;counter_blinky&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk_freq_hz&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1_0000_000&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;U_COUNTER&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;blinky&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk_freq_hz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk_freq_hz&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;U_BLINKY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// tb_counter_blinky.sv&lt;/span&gt;
&lt;span class="no"&gt;`timescale&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;ns&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;ns&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tb_counter_blinky&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1_000_000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1_000_000_000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FREQ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;HALF_PERIOD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;counter_blinky&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk_freq_hz&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;U_COUNTER_BLINKY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="n"&gt;HALF_PERIOD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;initial&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;dumpfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sim.vcd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;dumpvars&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;PERIOD&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Testbench finshed OK&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;counter_blinky.core 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;CAPI=2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;qian:examples:counter_blinky:1.0.0&lt;/span&gt;
&lt;span class="nt"&gt;description&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Counter_blinky, a example core with dependencies&lt;/span&gt;

&lt;span class="nt"&gt;filesets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;rtl&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;files&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;rtl/counter_blinky.sv&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;file_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;systemVerilogSource&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;depend&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;qian:examples:counter&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;fusesoc:utils:blinky:0&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;tb&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;files&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tb/tb_counter_blinky.sv&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;file_type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;systemVerilogSource&lt;/span&gt;

&lt;span class="nt"&gt;targets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;&amp;amp;default&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filesets&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;rtl&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;toplevel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;counter_blinky&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;DW&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;clk_freq_hz&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;sim&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;*default&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;description&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;Simulate the design&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;default_tool&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;icarus&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;filesets_append&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tb&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;toplevel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;tb_counter_blinky&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;tools&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nt"&gt;icarus&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;iverilog_options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;-g2012&lt;/span&gt;

&lt;span class="nt"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;DW&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;datatype    &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;int&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;description &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;counter width&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;paramtype   &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;vlogparam&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nt"&gt;clk_freq_hz&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;datatype    &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;int&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;description &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;frequency in hz&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;paramtype   &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;vlogparam&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用下面的命令进行 build：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fusesoc&lt;span class="w"&gt; &lt;/span&gt;--cores-root&lt;span class="o"&gt;=&lt;/span&gt;mycores&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;--target&lt;span class="o"&gt;=&lt;/span&gt;sim&lt;span class="w"&gt; &lt;/span&gt;--setup&lt;span class="w"&gt; &lt;/span&gt;--build&lt;span class="w"&gt; &lt;/span&gt;--run&lt;span class="w"&gt; &lt;/span&gt;qian:examples:counter_blinky
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后就可以到 build 下查看波形，进行 debug 了。&lt;/p&gt;
&lt;h1 id="custom"&gt;Custom&lt;/h1&gt;
&lt;p&gt;我们可以通过对 fusesoc.conf 文件的修改，实现自定义配置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[main]&lt;/span&gt;
&lt;span class="na"&gt;cores-root&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;~/workspace/mycores&lt;/span&gt;
&lt;span class="na"&gt;build-root&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;~/workspace/build&lt;/span&gt;
&lt;span class="na"&gt;cache-root&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;~/workspace/remote&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;conf 文件里面加入这些配置后，因为 &lt;code&gt;cores-root&lt;/code&gt; 已经包含了本地目录，所以我们下面的命令中就不需要手动指定了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!bash&lt;/span&gt;
fusesoc&lt;span class="w"&gt; &lt;/span&gt;--config&lt;span class="w"&gt; &lt;/span&gt;fusesoc.conf&lt;span class="w"&gt; &lt;/span&gt;run&lt;span class="w"&gt; &lt;/span&gt;--target&lt;span class="o"&gt;=&lt;/span&gt;sim&lt;span class="w"&gt; &lt;/span&gt;--setup&lt;span class="w"&gt; &lt;/span&gt;--build&lt;span class="w"&gt; &lt;/span&gt;--run&lt;span class="w"&gt; &lt;/span&gt;qian:examples:counter_blinky
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同时，build 完成后可以看到自动下载的 blinky 保存到了我们指定的 &lt;code&gt;cache-root&lt;/code&gt; 目录下面。&lt;/p&gt;
&lt;p&gt;运行时提示 cores-root 这个选项已经被弃用了，应该使用添加 library 的方式，查看 &lt;code&gt;fusesoc library add -h&lt;/code&gt; 后再实验一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;fusesoc&lt;span class="w"&gt; &lt;/span&gt;library&lt;span class="w"&gt; &lt;/span&gt;add&lt;span class="w"&gt; &lt;/span&gt;mycores&lt;span class="w"&gt; &lt;/span&gt;~/workspace/mycores
fusesoc&lt;span class="w"&gt; &lt;/span&gt;library&lt;span class="w"&gt; &lt;/span&gt;list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到已经成功添加了本地目录 &lt;code&gt;~/workspace/mycores&lt;/code&gt; 为本地 library，打开 &lt;code&gt;fusesoc.conf&lt;/code&gt; 可以看到相关的记录。以后使用这个目录下的 core 就不再需要在命令行手动指定路径了。&lt;/p&gt;
&lt;h1 id="more"&gt;More&lt;/h1&gt;
&lt;p&gt;Fusesoc 的这个想法显然是从 &lt;code&gt;pip&lt;/code&gt;， &lt;code&gt;npm&lt;/code&gt; 借鉴过来的，现在硬件开源领域越来越多地借鉴软件领域的成功经验，比如 RISC-V、 fusesoc、硬件敏捷开发、chisel/spinal HDL、CHIPS Alliance 等等，如果将来硬件开发能像软件一样蓬勃发展，想想都是一件激动人心的事情。&lt;/p&gt;</content><category term="Tools"></category><category term="IC-tools"></category><category term="fusesoc"></category></entry><entry><title>《Verilog and SystemVerilog gotchas》笔记</title><link href="https://qian-gu.github.io/posts/ic/verilog-and-systemverilog-gotchas-notes.html" rel="alternate"></link><published>2021-04-25T22:13:00+08:00</published><updated>2021-04-25T22:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-04-25:/posts/ic/verilog-and-systemverilog-gotchas-notes.html</id><summary type="html">&lt;p&gt;读书笔记，总结常见“语法坑”&lt;/p&gt;</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这本书&lt;a href="https://book.douban.com/subject/2859647/"&gt;《Verilog and SystemVerilog gotchas》&lt;/a&gt;非常老，第一作者 Sutherland 已经去世了。虽然有对应的中文翻译版本，但是翻译和校对的质量很差，语句不同顺，笔误满天飞，可能看英文版理解起来更通顺一些&lt;/li&gt;
&lt;li&gt;只记录了 Design 相关的陷阱，Verfication 相关的陷阱没有记录&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;关于作者&lt;/h2&gt;
&lt;p&gt;Stuart Sutherland 是 Verilog 和 SV 标准的起草者，也是业界培训大佬，写了很多著名的书和培训教程。&lt;/p&gt;
&lt;p&gt;Q：什么是陷阱 &lt;code&gt;Gotcha&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;A：符合语法规则，但是结果并不符合预期，比如常见的 C 语言中 &lt;code&gt;if(a=b)&lt;/code&gt; 把比较写成了赋值。&lt;/p&gt;
&lt;p&gt;Verilog/SV 产生陷阱的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;继承自 C/C++ 的陷阱&lt;/li&gt;
&lt;li&gt;松散的类型操作，即操作符可以执行任意类型的数据&lt;/li&gt;
&lt;li&gt;允许良莠不齐的模型设计（可综合 and 不可综合）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verilog 的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verilog-1995 (&lt;code&gt;IEEE Std 1364-1995&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Verilog-2001 (&lt;code&gt;IEEE Std 1364-2001&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Verilog-2005 (&lt;code&gt;IEEE Std 1364-2005&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SV 的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IEEE Std 1800-2005&lt;/li&gt;
&lt;li&gt;IEEE Std 1800-2009（合并 IEEE 1364-2005 和 IEEE 1800-2005）&lt;/li&gt;
&lt;li&gt;IEEE Std 1800-2012&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;声明以及字符表述类陷阱&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;陷阱&lt;/th&gt;
&lt;th&gt;如何避免&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VHDL 大小写不敏感，而 V/SV 大小写敏感&lt;/td&gt;
&lt;td&gt;良好的 coding style&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;笔误和忘记声明会自动推断出隐式 wire，可能导致功能错误&lt;/td&gt;
&lt;td&gt;高级编辑器 / 使用 &lt;code&gt;.name&lt;/code&gt; 或 &lt;code&gt;.*&lt;/code&gt; 方式连接端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动推断出的内部隐式 wire 只有 1bit，可能导致位宽不匹配&lt;/td&gt;
&lt;td&gt;工具会报端口位宽不匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多个文件使用 $unit 一起综合可能会导致命名冲突&lt;/td&gt;
&lt;td&gt;使用 package 代替 $unit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;var 可以在任何地方声明，但是必须先声明后使用&lt;/td&gt;
&lt;td&gt;coding style 约束所有声明放在最前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;枚举类型 import 并不能导入 label&lt;/td&gt;
&lt;td&gt;明确导入每个 label / 使用 &lt;code&gt;*&lt;/code&gt; 通配符导入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用通配符 &lt;code&gt;*&lt;/code&gt; 导入多个 package 可能出现命名冲突&lt;/td&gt;
&lt;td&gt;使用显式的 import 导入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;case 的数据类型（进制、符号）不匹配时可能产生功能错误&lt;/td&gt;
&lt;td&gt;某些场景下可以使用 unique case&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;带 base 的常数默认是 unsigned，不带 base 的常数默认是 signed&lt;/td&gt;
&lt;td&gt;小心使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定义常数时位宽范围不正确，截断 / 填充规则可能不符合预期&lt;/td&gt;
&lt;td&gt;lint 工具检查 / 写代码时明确匹配位宽和数值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;位宽不匹配的常数赋值语句，截断 / 扩展规则取决于等号右侧常数的类型，可能和预期不符&lt;/td&gt;
&lt;td&gt;小心使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;data = 'b1&lt;/code&gt; 并不能设置 data 为全 1&lt;/td&gt;
&lt;td&gt;使用 SV 语法 &lt;code&gt;data = '1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;笔误可能导致 &lt;code&gt;{}&lt;/code&gt; 和 &lt;code&gt;'{}&lt;/code&gt; 混淆使用，不会有语法问题但是功能不正确&lt;/td&gt;
&lt;td&gt;小心使用 / lint 工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;module 端口位宽不匹配可能导致出错&lt;/td&gt;
&lt;td&gt;注意工具 warning / 使用 &lt;code&gt;.name&lt;/code&gt; 或 &lt;code&gt;.*&lt;/code&gt; 方式连接端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;input/output 端口可以反向使用而且不会报错&lt;/td&gt;
&lt;td&gt;使用 logic 代替所有的 wire/reg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;real 类型无法作为端口传递&lt;/td&gt;
&lt;td&gt;Verilog 必须使用系统函数 / SV 需要特别声明&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="rtl"&gt;RTL 建模中的陷阱&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;陷阱&lt;/th&gt;
&lt;th&gt;如何避免&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;always *&lt;/code&gt; 可能推断不出所调用的 function 用到的所有信号&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;always_comb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;array 如何添加到敏感列表中？&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;always_comb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vector 和 posedge/negedge 配合时，只会处理 LSB&lt;/td&gt;
&lt;td&gt;避免使用，如果一定要用 vector 必须先转化成 1bit 信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;posedge/negedge 只被敏感列表中表达式的结果触发，不受操作数的影响&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;always_comb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不恰当的 begin...end 可能导致时序逻辑功能错误&lt;/td&gt;
&lt;td&gt;&lt;code&gt;always_ff&lt;/code&gt; 不需要 begin...end，只有内部 if...else 需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有些信号可能在 reset 块中会被不小心漏掉，导致功能错误&lt;/td&gt;
&lt;td&gt;lint、coverage 等工具报错&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时序逻辑误用阻塞赋值，组合逻辑误用非阻塞赋值&lt;/td&gt;
&lt;td&gt;lint 工具报错 / &lt;code&gt;always_comb&lt;/code&gt;、&lt;code&gt;always_ff&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组合逻辑块中语句的顺序错误可能导致仿真和实际硬件行为不一致&lt;/td&gt;
&lt;td&gt;写代码时小心&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;parallel_case&lt;/code&gt; 使用不当导致仿真和硬件行为不一致&lt;/td&gt;
&lt;td&gt;增加 default 分支 / &lt;code&gt;unique case&lt;/code&gt;、&lt;code&gt;priority case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;粘贴复制导致的重复条件分支，只会执行第一个分支，导致与设计意图不符&lt;/td&gt;
&lt;td&gt;lint 工具 / &lt;code&gt;unique case&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不恰当使用 &lt;code&gt;unique&lt;/code&gt; 导致功能不正确&lt;/td&gt;
&lt;td&gt;关注 warning&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用 2-state 信号建模可能导致仿真出错&lt;/td&gt;
&lt;td&gt;避免使用 2-state 信号 / 使用 &lt;code&gt;always_comb&lt;/code&gt;, &lt;code&gt;always_ff&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内部 X 态可能并不会传播到端口上，导致错误未被发现&lt;/td&gt;
&lt;td&gt;使用 SVA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Verilog 允许 net 多驱动，可能出现功能错误&lt;/td&gt;
&lt;td&gt;lint 工具 / 使用 SV 的 &lt;code&gt;always_comb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_3"&gt;运算符陷阱&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;陷阱&lt;/th&gt;
&lt;th&gt;如何避免&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SV 不允许在条件语句中包含赋值语句&lt;/td&gt;
&lt;td&gt;小心使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有些操作符是 context-determined，有些操作符是 self-determined&lt;/td&gt;
&lt;td&gt;理解操作符的含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;设计者错误理解赋值语句的 bit 扩展规则&lt;/td&gt;
&lt;td&gt;理解 loosely type，小心使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有符号运算是 context-determined&lt;/td&gt;
&lt;td&gt;使用时确认右边的操作数类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从 signed 部分选择的结果是 unsigned 类型，可能与意图不符&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;$signed()&lt;/code&gt; 或 &lt;code&gt;signed'()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自增 / 自减是阻塞赋值，错误使用&lt;/td&gt;
&lt;td&gt;仅在组合逻辑中使用自增 / 自减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;错误认为前自增 / 后自增相同&lt;/td&gt;
&lt;td&gt;理解含义，谨慎使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仿真中的求值短路可能导致仿真和硬件行为不一致&lt;/td&gt;
&lt;td&gt;避免使用对操作数产生副作用的建模方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;把 &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;!&lt;/code&gt; 的作用视为相同（实际不同）&lt;/td&gt;
&lt;td&gt;逻辑判断中永远不要使用 &lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="IC"></category><category term="Verilog"></category><category term="SystemVerilog"></category></entry><entry><title>《SystemVerilog for Design》笔记</title><link href="https://qian-gu.github.io/posts/ic/systemverilog-for-design-notes.html" rel="alternate"></link><published>2021-04-04T21:01:00+08:00</published><updated>2021-04-04T21:01:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-04-04:/posts/ic/systemverilog-for-design-notes.html</id><summary type="html">&lt;p&gt;读书笔记，总结 SV 新语法&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#chapter-1-introduction-to-systemverilog"&gt;Chapter 1 Introduction to SystemVerilog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-2-systemverilog-declration-spaces"&gt;Chapter 2 SystemVerilog Declration Spaces&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#package"&gt;package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#unit"&gt;$unit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-3-systemverilog-literal-values-and-built-in-data-types"&gt;Chapter 3 SystemVerilog Literal Values and Built-in Data Types&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#literal-assigments"&gt;literal assigments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#variable"&gt;variable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#signed-and-unsigned"&gt;signed and unsigned&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#static-and-automatic-variable"&gt;static and automatic variable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#type-casting"&gt;type casting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-4-systemverilog-user-defined-and-enumerated-types"&gt;Chapter 4 SystemVerilog User-Defined and Enumerated Types&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#user-defined-types"&gt;user-defined types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#enumerated-types"&gt;enumerated types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary_1"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-5-systemverilog-arrays-structures-and-unions"&gt;Chapter 5 Systemverilog Arrays, Structures and Unions&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#struct"&gt;struct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#union"&gt;union&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#array"&gt;array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#foreach"&gt;foreach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#array-system-function"&gt;array system function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dynamic-arrays-associative-arrays-sparse-arrays-strings"&gt;dynamic arrays, associative arrays, sparse arrays, strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary_2"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-6-systemverilog-procedural-blocks-tasks-and-functions"&gt;Chapter 6 Systemverilog Procedural Blocks, Tasks and Functions&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#awalys_comb"&gt;awalys_comb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#always_latch"&gt;always_latch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#always_ff"&gt;always_ff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#taskfunction"&gt;task/function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary_3"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-7-systemverilog-procedural-statements"&gt;Chapter 7 Systemverilog Procedural Statements&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#new-operators"&gt;new operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#for-loops"&gt;for loops&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#dowhile-loop"&gt;do...while loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#foreach_1"&gt;foreach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#jump-statements"&gt;jump statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#block-names"&gt;block names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#statement-label"&gt;statement label&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case-statement"&gt;case statement&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ifelse"&gt;if...else&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary_4"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-8-modeling-finite-state-machine-with-systemverilog"&gt;Chapter 8 Modeling Finite State Machine with Systemverilog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-9-systemverilog-design-hierarchy"&gt;Chapter 9 Systemverilog Design Hierarchy&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#module-prototypes"&gt;module prototypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#named-ending-statements"&gt;named ending statements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nested-module-declarations"&gt;nested module declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#simplified-netlists-of-module-instances"&gt;simplified netlists of module instances&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#net-aliasing"&gt;net aliasing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pass-values-through-module-ports"&gt;pass values through module ports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reference-ports"&gt;reference ports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#enhanced-port-declarations"&gt;enhanced port declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#parameterized-types"&gt;parameterized types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary_5"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-10-systemverilog-interfacees"&gt;Chapter 10 Systemverilog Interfacees&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#concepts"&gt;concepts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#interface-declration"&gt;interface declration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-interface-as-module-ports"&gt;using interface as module ports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#instantiating-and-connecting-interface"&gt;instantiating and connecting interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#referencing-signals-within-an-interface"&gt;referencing signals within an interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#interface-modports"&gt;interface modports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-taskfunction-in-interface"&gt;using task/function in interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-procedural-blocks-in-interface"&gt;using procedural blocks in interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reconfigurable-interface"&gt;reconfigurable interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#summary_6"&gt;summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-11-a-complete-design-modeled-with-systemverilog"&gt;Chapter 11 A Complete Design Modeled with SystemVerilog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#chapter-12-behavioral-and-transaction-level-modeling"&gt;Chapter 12 Behavioral and Transaction Level Modeling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;附录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本书假定读者已经掌握了 Verilog，主要内容是从对比角度介绍 SV 如何让设计者在更高层次对硬件进行建模，如何更高效地进行开发&lt;/li&gt;
&lt;li&gt;笔记只记录了可综合的语法特性，略去了不可综合的部分&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h2 id="chapter-1-introduction-to-systemverilog"&gt;Chapter 1 Introduction to SystemVerilog&lt;/h2&gt;
&lt;p&gt;Verilog 的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verilog-1995 (&lt;code&gt;IEEE Std 1364-1995&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Verilog-2001 (&lt;code&gt;IEEE Std 1364-2001&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Verilog-2005 (&lt;code&gt;IEEE Std 1364-2005&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SV 的标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IEEE Std 1800-2005&lt;/li&gt;
&lt;li&gt;IEEE Std 1800-2009（合并 IEEE 1364-2005 和 IEEE 1800-2005）&lt;/li&gt;
&lt;li&gt;IEEE Std 1800-2012&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chapter-2-systemverilog-declration-spaces"&gt;Chapter 2 SystemVerilog Declration Spaces&lt;/h2&gt;
&lt;p&gt;Verilog 中的 &lt;code&gt;wire&lt;/code&gt;, &lt;code&gt;reg&lt;/code&gt;, &lt;code&gt;task&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt; 只能声明在 &lt;code&gt;module&lt;/code&gt; 内部，这样做的缺点就是：同一个 taks、function 要在多个 module 中进行重复声明，不仅增加工作量，还可能出现多个相同功能的副本不对齐的错误。&lt;/p&gt;
&lt;h3 id="package"&gt;package&lt;/h3&gt;
&lt;p&gt;SV 新增的 &lt;code&gt;package&lt;/code&gt; 可以解决上述问题，在其内部可以声明的有，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parameter&lt;/code&gt;, &lt;code&gt;localparam&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typedef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;taks&lt;/code&gt;（必须是 &lt;code&gt;automatic&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;（必须是 &lt;code&gt;automatic&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要在其他 module 中引用 package 中的声明，可以有 4 种方式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;限制&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用 &lt;code&gt;::&lt;/code&gt; 直接引用&lt;/td&gt;
&lt;td&gt;多次使用时每次都要写完成路径，繁琐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通过 &lt;code&gt;import &amp;lt;name&amp;gt;&lt;/code&gt; 明确导入&lt;/td&gt;
&lt;td&gt;如果要导入多个，依然繁琐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通过 &lt;code&gt;import *&lt;/code&gt; 通配符导入&lt;/td&gt;
&lt;td&gt;实际上是把 package 加入到搜索路径中，优先级最低，端口上依然要通过作用域符号引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;导入到 &lt;code&gt;$unit&lt;/code&gt; 中使用&lt;/td&gt;
&lt;td&gt;可以去掉端口上的作用域符号，缺点见下文&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;task 和 function 必须带上 automatic，而且不能包含静态变量，这是因为例化的每个 task/function 必须都有自己独立完整的一套资源，相互之间不能共享。同理，package 中也不能定义变量（logic/wire/reg），它们是不可综合的。&lt;/p&gt;
&lt;h3 id="unit"&gt;$unit&lt;/h3&gt;
&lt;p&gt;SV 定义了一个 compilaton unit scope 的概念（即在 module、package 之外的区域，类似于 C 语言中的全局变量），可以存放一些独立于 package、module，interface 的声明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;variable&lt;/li&gt;
&lt;li&gt;net&lt;/li&gt;
&lt;li&gt;constant&lt;/li&gt;
&lt;li&gt;typedef, enum, class&lt;/li&gt;
&lt;li&gt;task, function&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;$unit 不是全局的，只对那些与其同时编译的源文件可见。每次编译的时候会产生一个专属于这次编译的特定的 compilation unit scope，如果几个文件分开编译，就可能产生某些信号不可见的情况，这是&lt;strong&gt;非常危险&lt;/strong&gt;的！直接在 $unit 中做声明是非常不好的习惯，会产生混乱的代码，维护、复用、debug 都非常困难。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;SV 标识符的搜索策略： 本地声明 &amp;gt; 通配符导入的声明 &amp;gt; $unit 中的声明 &amp;gt; hierarchy 中的声明，完全向后兼容 Verilog 的搜索策略。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;所有的标识符和类型定义必须先声明后使用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果一个标识符没有定义就使用，那么 Verilog 会自动隐式地将其声明为 net 类型（一般来说就是 &lt;code&gt;wire&lt;/code&gt;），而且编译不会报错，所以可能会导致很微妙的错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// a is a local net&lt;/span&gt;
&lt;span class="n"&gt;endmoule&lt;/span&gt;

&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// sig is previous $unit variable&lt;/span&gt;
&lt;span class="n"&gt;endmoule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;总之，把 package 导入到 $unit 中会遇到很多问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对文件编译顺序有要求&lt;/li&gt;
&lt;li&gt;多个文件分多次编译和同时一次性编译的效果不同&lt;/li&gt;
&lt;li&gt;可以通过条件编译的方式解决，但仍然需要注意很多细节&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="summary"&gt;summary&lt;/h3&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在 $unit 中做任何声明，所有的声明都应该放在有名字的 package 中&lt;/li&gt;
&lt;li&gt;在必要时可以把 package 导入到 $unit 中（比如某些 module/interface 中包含了定义在 package 中的自定义类型）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不推荐使用 $unit，应该用 package 来规避相应风险。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-3-systemverilog-literal-values-and-built-in-data-types"&gt;Chapter 3 SystemVerilog Literal Values and Built-in Data Types&lt;/h2&gt;
&lt;h3 id="literal-assigments"&gt;literal assigments&lt;/h3&gt;
&lt;p&gt;Verilog 中赋值全 1 的方法是不可扩展的（line 8），只能通过一些小技巧来实现（line 9～10）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;&amp;#39;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;32&amp;#39;hFFFF&lt;/span&gt;&lt;span class="n"&gt;_FFFF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;SV 新增语法可以实现可扩展的赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;&amp;#39;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;&amp;#39;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;&amp;#39;z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;&amp;#39;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="variable"&gt;variable&lt;/h3&gt;
&lt;p&gt;SV 中对一个信号的定义包含两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;：一共有两种，定义了信号是 net 还是 varibale&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data type&lt;/code&gt;：一共有两种，定义了信号是 2-state 还是 4-state&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;varible&lt;/td&gt;
&lt;td&gt;&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;reg&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;net&lt;/td&gt;
&lt;td&gt;&lt;code&gt;wire&lt;/code&gt;, &lt;code&gt;wor&lt;/code&gt;, &lt;code&gt;wand&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;data type&lt;/th&gt;
&lt;th&gt;example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2-state&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; ...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-state&lt;/td&gt;
&lt;td&gt;&lt;code&gt;logic&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;logic&lt;/code&gt; 实际上并不是 &lt;code&gt;type&lt;/code&gt;，而是 &lt;code&gt;data type&lt;/code&gt;，表示信号取值是 4-state。只使用 logic 会自动推断出一个 variable，所以它可以和 &lt;code&gt;var&lt;/code&gt; 配合起来，显式地定义。从语法上来说，logic 和 reg 等价，但是它不会像 reg 一样模糊不清。而 net 类型必须是 4-state data type，所以它也可以和 logic 配合显式定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 32-bit varible&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 32-bit net&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;bit&lt;/code&gt; 同 logic 一样，它并不是 &lt;code&gt;type&lt;/code&gt;，而是 &lt;code&gt;data type&lt;/code&gt;，表示信号取值是 2-state。只使用 bit 会自动推断出一个 variable，所以它也可以和 var 配合起来显式定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;基本上 variable 可以替代所有的 reg 和 wire，它可以出现在 &lt;code&gt;always_comb&lt;/code&gt;, &lt;code&gt;always_ff&lt;/code&gt;, &lt;code&gt;assign&lt;/code&gt; 这些地方。但是有一条限制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;variable 不能被多个源驱动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个限制可以帮助我们避免设计中的 bug，因为绝大部分设计中信号都应该只有一个驱动源。&lt;/p&gt;
&lt;h3 id="signed-and-unsigned"&gt;signed and unsigned&lt;/h3&gt;
&lt;p&gt;SV 中的 &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;shortint&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;longint&lt;/code&gt; 默认是 signed 类型，可以通过显式的方式声明为 unsigned 类型，需要注意的是声明时 singed/unsigned 关键字只能放在 type 关键字的后面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s_int&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// signed 32-bit varibale&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u_int&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// unsigned 32-bit variable&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="static-and-automatic-variable"&gt;static and automatic variable&lt;/h3&gt;
&lt;p&gt;Verilog-1995 中所有的 varibale 都是 static 类型的，因为它们都是用来对硬件建模的，所以天然就是 static 类型。到了 Verilog-2001，task 和 function 中的 variable 可以声明成 automatic 类型，意味着这个 variable 的存储空间是由工具自动动态分配的，不再使用时会自动释放空间。automatic 类型主要是用来做验证或者是总线的功能模型。它有个作用是在多次调用的 task 中，使得在前一个 task 没有结束时可以进行下一次调用。&lt;/p&gt;
&lt;h3 id="type-casting"&gt;type casting&lt;/h3&gt;
&lt;p&gt;Verilog 只能在 assign 时进行类型转化，或者是调用系统函数 signed/unsigned。SV 新增的类型转化可以直接在表达式中进行，不需要 assign 语句。SV 的类型转化分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;static(compile time) cast 静态转换是可综合的，发生在编译阶段，而且不会检查转化后取值是否正确，所以一定要小心处理！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// type casting： &amp;lt;type&amp;gt;&amp;#39;(&amp;lt;expression&amp;gt;)&lt;/span&gt;
&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// cas result of (2.0 * 3.0) to int, then add 7&lt;/span&gt;

&lt;span class="c1"&gt;// size casting： &amp;lt;size&amp;gt;&amp;#39;(&amp;lt;expression&amp;gt;)&lt;/span&gt;
&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;(&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// cast literal value 2 to be 16-bits wide&lt;/span&gt;

&lt;span class="c1"&gt;// sign casting： &amp;lt;sign&amp;gt;&amp;#39;(&amp;lt;expression&amp;gt;)&lt;/span&gt;
&lt;span class="kt"&gt;shortint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;({&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// cast concat result to a signed value&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dynamic(run time) cast 动态转化（系统函数 $cast），是不可综合的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明只包含 data type（&lt;code&gt;logic&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt;），没有 type 时，默认推断出 varibale&lt;/li&gt;
&lt;li&gt;关键字 &lt;code&gt;var&lt;/code&gt; 是可选的，并不会影响综合和仿真行为，只是增加代码可读性&lt;/li&gt;
&lt;li&gt;只有 &lt;code&gt;var&lt;/code&gt; 没有 data type 时，默认是 logic 类型&lt;/li&gt;
&lt;li&gt;net 类型（&lt;code&gt;wire&lt;/code&gt;）取值只能是 &lt;code&gt;logic&lt;/code&gt; 类型（声明时 logic 可以选）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; 等虽然是 data type，但是只能和 var 搭配，所以也可以看成是 type&lt;/li&gt;
&lt;li&gt;可综合的设计，只使用 &lt;code&gt;logic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;automatic 主要是仿真用，设计时的 automatic 只有定义在 package 中的 task/function 使用&lt;/li&gt;
&lt;li&gt;小心使用 static cast&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-4-systemverilog-user-defined-and-enumerated-types"&gt;Chapter 4 SystemVerilog User-Defined and Enumerated Types&lt;/h2&gt;
&lt;p&gt;SV 支持用户自定义数据类型，可以在保持准确性和可综合的前提下，让用户可以写出数量更少、可读性更好的语句在更高层次上对硬件进行建模。&lt;/p&gt;
&lt;h3 id="user-defined-types"&gt;user-defined types&lt;/h3&gt;
&lt;p&gt;typedef 可以根据需要定义在 module、package、$unit 中，一般来说，为了提高代码可读性，自定义类型的名称以 &lt;code&gt;_t&lt;/code&gt; 结尾。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// a 32-bit vector made from 8 nibble types&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="enumerated-types"&gt;enumerated types&lt;/h3&gt;
&lt;p&gt;verilog 中没有枚举类型，设计 FSM 时只能通过 parameter 或者是 define 的形式实现。SV 新增的枚举类型可以实现相同功能，代码可读性更好。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RGB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// variable can have the values of red, green, blue&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STORE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NextState&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果 label 很多，而且都很有规律，一个一个写出来非常繁琐，SV 还提供了两种定义 label 序列的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;RESET&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// state = RESET, S0, S1, ...S5, W6, ... W9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;显然，在同一个作用域内 label 必须是独一无二的，否则会发生冲突。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Error&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FSM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;GO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STOP&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm1_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DONE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm2_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="c1"&gt;// Ok&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FSM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm1&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;STOP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Go&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm1_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm2&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DONE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm2_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;enumerate 数据类型默认是 int 类型（32-bit 的 2-state 类型），list 中的第一个 label 的值为 0, 第二个为 1, 依次类推，每个 label 会根据前面的取值自动 +1，所以没必要把每个 label 的取值都显式地写出来。但是不同 label 的取值必须不同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// B=2, C=3, Y=25, Z=26&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;enumerate 的类型也可以用户自定义，如果给 label 赋值则必须位宽匹配，否则会报错；如果 label 的数量超过了类型可以取值的数量也会报错；给 4-state 类型的 label 赋值了 x/z，那么下一个 label 必须显式赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Boolean&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit wide, 2-state&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAITE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 2-bit wide, 4-state&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAITE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b100&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAITE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b100&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Error!&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Error: too many labels for 1-bit size&lt;/span&gt;

&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ERR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mb"&gt;2&amp;#39;bxx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Error!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;enum 和 typedef 配合使用时，叫做 typed enumerated type，用 import 时只会导入 type name，并不会导入 label，所有 label 必须显式导入，或者通过通配符导入。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip_types&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STORE&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endpackage&lt;/span&gt;

&lt;span class="c1"&gt;// Error&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip&lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip_types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// import the typedef name only&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;next_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ERROR: WAIT has not been imported!&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;next_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Ok&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;chip_types::WAIT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// method 1&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;chip_types::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// method 2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;大部分的 Verilog/SV 的 var 都是宽松类型，基本上任何类型的任何值都可以赋值给一个 var，在赋值时会根据规则自动转换成 var 对定的类型。enum 类型则是个 semi-strong type，只能用对应的 label、同类型的另外一个 enum、通过 cast 转换成对应 enum 类型的变量赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;READY&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;next_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;next_state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// legal&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// legal, booth is `int` type&lt;/span&gt;
&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// Error: illegal&lt;/span&gt;
&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// Error: illegal&lt;/span&gt;
&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;// Error: illegal&lt;/span&gt;
&lt;span class="n"&gt;next_state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Error: illegal&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="summary_1"&gt;summary&lt;/h3&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;typedef 可以提高代码可读性，命名使用 &lt;code&gt;_t&lt;/code&gt; 结尾&lt;/li&gt;
&lt;li&gt;enum 是 semi-strong type，可以提高设计的安全，import 时注意 label 的导入&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-5-systemverilog-arrays-structures-and-unions"&gt;Chapter 5 Systemverilog Arrays, Structures and Unions&lt;/h2&gt;
&lt;h3 id="struct"&gt;struct&lt;/h3&gt;
&lt;p&gt;Verilog 中没有机制表示一组相关信号，只能通过信号前缀的方式来表示，SV 新增了类似 C 中的 structure，structure 内可以是任何类型的 variable，包括用户自定义的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 32-bit variable&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;opcode_t&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// user-defined type&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// 24-bit variable&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit 2-state var&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instruction_word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;instruction_word&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;24&amp;#39;hF000001E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;strcut 可以是一组 var 也可以是一组 net，前面可以加上可选的 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;wire&lt;/code&gt;, &lt;code&gt;bit&lt;/code&gt; 等，因为 net 本身要求是 4-state 类型，所以声明 net struct 时内部的所有成员也都必须是 4-state 的类型。虽然 struct 作为整体是可以声明为 net，但是 net 类型本身并不能作为 struct 内部的成员。可以用 &lt;code&gt;interface&lt;/code&gt; 来实现同样的效果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;var&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;instruction_word_var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;instruction_word_net&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;struct 可以和 typedef 配合使用，没有 typedef 的 struct 叫做匿名 struct。struct 可以声明在 module 或 interface 内部使用，也可以定义在 package 中或 $unit 中供多个 module 使用。一般来说 struct 都是和 typedef 一起定义在 package 中，因为大多数情况下我们定一个 struct 的目的是为了在多个地方复用，比如在模块端口之间传递等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// structure definition&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;instruction_word_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;instruction_word_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// structure allocation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;struct 和 array 很类似，它们的不同之处和 C 语言中的类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;array 是一组同类型、同宽度的信号，strcut 内的信号可以是不同类型、不同宽度&lt;/li&gt;
&lt;li&gt;array 中的信号通过下标来引用，strcut 中的信号通过名字来引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;struct 可以用 &lt;code&gt;.&lt;/code&gt; 给每个成员单独赋值，也可以给整个 struct 赋值，但是两种方式不能混用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;instruction_word_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;instruction_word_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;{&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&amp;#39;hFF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="c1"&gt;// legal&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;{&lt;/span&gt;&lt;span class="nl"&gt;address:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;opcode:&lt;/span&gt;&lt;span class="mh"&gt;8&amp;#39;hFF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;a:&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;b:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// legal&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;{&lt;/span&gt;&lt;span class="nl"&gt;address:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&amp;#39;hFF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="c1"&gt;// illegal&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;struct 默认是 unpacked 模式，即内部的成员是相互独立的，标准并不规定工具如何处理这些成员的存储关系；也可以声明成 packed 模式，packed strcut 内部的成员按照声明顺序存储，规则为：第一个元素在 MSB，依次类推。packed strcut 内部的成员可以通过名字来引用，也可以直接通过下标来引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;data_word&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&amp;#39;hF0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;data_word&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&amp;#39;hF0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;上面定义的 data_word 的存储格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+--------------+--------------+
| valid | tag  | data         |
+--------------+--------------+
 40      39  32 31           0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;packed struct 存储时是按照 vector 处理的，所以对它的操作也和 vector 相同，可以对其进行数学运算、逻辑操作等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_word_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;data_word_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;packet_out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;packed struct 还可以声明成 signed/unsigned 类型，主要会影响到其作为一个整体以 vector 类型参与数学运算和比较运算时的行为，但不会影响到内部成员的 signed/unsigned 的类型，每个成员仍然基于成员本身的声明类型。从 packed struct 中截取出的一部分永远是 unsigned 类型，这和 verilog 是一致的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_word_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;data_word_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="c1"&gt;// signed comparison&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;module、interface、task/function 的端口也可以声明为 struct 类型：首先必须用 typedef 将其声明为用户自定义类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;definitions&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ADD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SUB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MULT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DIV&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;opcode_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;opcode_t&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instruction_word_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endpackage&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;definitions&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;instruction_word_t&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;unpacked struct 作为模块端口进行连接时，这两个模块的 strcut 类型必须是同一类型。即使两个模块各自定义了一套完全相同的匿名 struct，它们仍然是不同类型。所以必须用 typedef 将其声明为用户自定义类型才可以。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="union"&gt;union&lt;/h3&gt;
&lt;p&gt;SV 中也新增了类似 C 语言的 union，其声明方法和赋值方法和 struct 类似。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;union 也可以和 struct 一样用 typedef 声明成用户自定义类型，如果没有 typedef 则是匿名 union。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;unpacked union 是不可综合的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;packed union 要求所有成员的 bit 位宽必须一致，所以 &lt;strong&gt;packed union 是可综合的&lt;/strong&gt;。packed union 只能存储整数类型的数据，它可以按照一种类型写入，用另外一种类型读出，硬件模型不需要做任何特殊处理来保存数据是如何存储的，因为所有成员的位宽都相同&lt;/p&gt;
&lt;p&gt;下面这个例子说明了 packed union 的两种表现方式：要么是一个 packed struct 方式的数据包，要么是一个数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;source_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dst_addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_packet_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;data_packet_t&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;packet&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// packed structure&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// packed array&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dreg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这两种方式的存储格式如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+-------------+----------+------+--------+
| source-addr | dst-addr | data | opcode |
+-------------+----------+------+--------+
 63            47         31     7      0

+----------+----------+----------+----------+----------+----------+----------+----------+
| bytes[7] | bytes[6] | bytes[5] | bytes[4] | bytes[3] | bytes[2] | bytes[1] | bytes[0] |
+----------+----------+----------+----------+----------+----------+----------+----------+
 63         55         47         39         31         23         15         7        0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个 struct 和 union 的应用实例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;definitions&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ADD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SUB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MULT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DIV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SR&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;opcode_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;UNSIGNED&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIGNED&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operand_types_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;singed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;opcode_t&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;opc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;operand_types_t&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;op_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data_t&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;op_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data_t&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;op_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instr_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endpackage&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;definitions::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alu&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;instr_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alu_out&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;op_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIGNED&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nl"&gt;ADD:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;op_a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;op_b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;s_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nl"&gt;ADD:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;alu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;u_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;op_a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;u_data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IW&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;op_b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;u_data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;SV 支持设计者自定义数据类型，在设计中某些信号（特别是端口信号）可能在不同模块中的含义是不一样的，所以需要支持数据类型动态变化，这是 union 存在的意义。举例：比如所有的 RV32I 的指令都是 32bit，但是可以分为不同的数据类型，那么可能在 IF 模块中指令信号是通用的 32bit 数据，而在 ID 模块中会变成各种类型的格式，这时候就可以把指令定义为 union 类型。&lt;/p&gt;
&lt;p&gt;Union 只是语言上的小技巧，实现既可以支持自定义类型，又支持类型自动转化的效果，本质是还是一组宽 bit 信号。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="array"&gt;array&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;unpacked array&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Verilog 中的 array 一次只能访问一个元素，或者是一个元素的一个切片，操作多个元素会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;integer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// legal: select 1 element&lt;/span&gt;
&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// illegal: selects 8 elements&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这种 array 在 sv 中叫做 unpacked array，array 中的元素是分开存储的，标准并不会规定工具如何存储。相对于 Verilog，SV 的增强之处在于可以声明任何类型的 array，包括用户自定义的类型，而且可以引用 array 整体或者是一个 slice，从而实现复制 array，需要注意的是，复制时等号两端的 array 维度和类型必须一致。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Mo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;We&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Th&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Sa&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Su&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Week&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Week&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1023&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// legal, copy an entire array&lt;/span&gt;
&lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// legal, copye a slice of an array&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;SV 还支持简化版的 array 定义，就像 C 语言一样，只需要定义 array 的大小即可，但是这种写法不能用在 vector(packed arry) 中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// legal, equal to next line&lt;/span&gt;
&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1023&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// illegal vector declaration&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;packed array&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Verilog 中把位宽范围放在标识符前面的声明叫做 vector，把位宽范围放在标识符后面的声明叫做 array。SV 的叫法稍微不同，而且扩展了 packed array 使其可以声明成多维数组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vector = packed array&lt;/li&gt;
&lt;li&gt;array = unpacked array&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 4-bit packed array&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 64-bit packed array&lt;/span&gt;
&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 2-D packed array: 4 8-bit sub-arrays&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SV 定义了 packed array 的存储方式：像 vector 一样整个 array 必须连续存储，packed array 内部的每个维度都是 vector 的一个字段。上面例子中二维数组存储方式如下所示，这是协议规定的，和仿真器、编译器、操作系统、平台无关。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+--------------+--------------+--------------+--------------+
| data[3][7:0] | data[2][7:0] | data[1][7:0] | data[0][7:0] |
+--------------+--------------+--------------+--------------+
 31          24 23          16 15           8 7            0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;packed array 只能用下面元素组成，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bit-wise 类型：logic、bit、reg&lt;/li&gt;
&lt;li&gt;packed array, packed struct, packed union&lt;/li&gt;
&lt;li&gt;任何 net 类型：wire&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;crc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dataword&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;data_word&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;darray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 1-D packed array of packed structures&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;packed array 可以按照一个元素、一部分 bit、一个 slice 的粒度访问：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 2-D packed array&lt;/span&gt;

&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="c1"&gt;// whole array&lt;/span&gt;

&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;// bit-select&lt;/span&gt;

&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nib&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// part-select&lt;/span&gt;

&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high_byte&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;high_byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;// 8-bit slice&lt;/span&gt;

&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// 2 slices&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;因为 packed array 是按照 vector 存储的，所以所有 Verilog 中对 vector 的操作对 packed array 也是合法的，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bit 选择&lt;/li&gt;
&lt;li&gt;部分选择&lt;/li&gt;
&lt;li&gt;数据拼接&lt;/li&gt;
&lt;li&gt;数学操作&lt;/li&gt;
&lt;li&gt;关系操作&lt;/li&gt;
&lt;li&gt;bit-wise 操作&lt;/li&gt;
&lt;li&gt;逻辑操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果位宽不匹配，packed array 会被自动截断 / 扩展成符号左边的位宽，这个规则和 Verilog 是一致的。&lt;/p&gt;
&lt;p&gt;packed 和 unpacked 都很灵活，那么什么时候应该用什么类型的 array 呢？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;unpacked array&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;元素是 unpacked 类型的 struct，union，以及其他非 bit-wise 的类型&lt;/li&gt;&lt;li&gt;一次访问一整个元素的 array，比如 RAM/ROM&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;packed array&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;多个 1-bit 类型的信号组成的 vector（verilog 的用法）&lt;/li&gt;&lt;li&gt;可能访问 sub-field 的 vector&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于赋值，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;packed array 赋值可以像 verilog 里面的 vector 赋值一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 3-D packed arraay&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;1&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// assign to one bit&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;32&amp;#39;hF1A3C5E7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// assign to full array&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;4&amp;#39;hF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// assign to a part select&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;16&amp;#39;hFACE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// assign to a slice&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mb"&gt;16&amp;#39;bz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;16&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// assign concatenation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unpacked array 可以用 SV 的新语法赋值&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;'{}&lt;/code&gt; 表明内部是一个 list，通过前面的单引号和 Vrilog 的拼接操作符区分，而且 &lt;code&gt;'{}&lt;/code&gt;、&lt;code&gt;'{n{}}&lt;/code&gt; 和 verilog 中的 &lt;code&gt;{}&lt;/code&gt;、&lt;code&gt;{n{}}&lt;/code&gt; 不同，后者内部需要明确每个元素的位宽，前者位宽声明是可选的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&amp;#39;h5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// assign to one element&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;#39;{&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;{&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;}};&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;// assign a list to the full array&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;{&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;hF&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;&amp;#39;hA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;&amp;#39;hC&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;&amp;#39;hE&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// assign a list to slice of array&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 packed 和 unpacked 多维数组嵌套在一起时，数组的下标寻址规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先寻址 unpacked array，从左到右的顺序&lt;/li&gt;
&lt;li&gt;其次寻址 packed array，也是从左到右的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="indexing" src="/images/systemverilog-for-design-notes/indexing.png"&gt;&lt;/p&gt;
&lt;p&gt;用户自定义类型也可以用来组成 array，形成复合数据类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;unit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;127&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// array of user types&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;big_word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// packed array, is equalitent to&lt;/span&gt;
&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;big_word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nibble&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nib_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;nib_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compound_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;// is equalitent to&lt;/span&gt;
&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compound_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;Verilog 只允许 1-D 的 packed array 作为模块端口、task/function 参数，而 SV 允许任何类型的任何 array 作为端口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CPU&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lookup_table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;255&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;LUT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lookup_table&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;255&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;struct 和 union 也可以作为 array 的元素，需要注意的是 packed array 的元素也必须是 packed 类型。同理 array 也可以作为 struct/union 的元素，packed struct/union 的元素也必须是 packed 类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;paced&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;packet_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_array&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// packed array of 24 structures&lt;/span&gt;

&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;real&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;data_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// unpacked array of 24 structures&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="c1"&gt;// packed structure&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// packed array&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_word&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="c1"&gt;// unpacked structure&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_ready&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// unpacked array&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="foreach"&gt;foreach&lt;/h3&gt;
&lt;p&gt;有时候需要迭代处理 array 中的每个元素，一般都是通过 for 循环来处理，但是如果有很多个 for 循环或者是 array 的维度较多，则需要声明很多个 index，为了避免这一繁琐的声明，SV 新增了一种语法 &lt;code&gt;foreach&lt;/code&gt; 来自动迭代，设计者不需要再手动声明每个 index 变量了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gen_crc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gen_crc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gen_crc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;上面这个例子中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i, j 不需要声明，直接使用&lt;/li&gt;
&lt;li&gt;i, j 用逗号隔开，和维度的映射规则和前面说的嵌套 array 寻址相同，所以上例中 i 指向外层循环、j 指向内层循环&lt;/li&gt;
&lt;li&gt;如果想跳过某一维度，可以用两个逗号跳过，如果是在尾部，直接不写出来即可&lt;/li&gt;
&lt;li&gt;这些循环变量是自动生成的、只读、只对循环内部可见&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="array-system-function"&gt;array system function&lt;/h3&gt;
&lt;p&gt;大部分系统函数都是不可综合的，但是下面这些和 array 相关的系统函数是例外，它们是可综合的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$dimensions(array_name)&lt;/td&gt;
&lt;td&gt;返回 array 的维度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$left(array_name, dimension)&lt;/td&gt;
&lt;td&gt;返回 array 特定维度的 msb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$right(array_name, dimension)&lt;/td&gt;
&lt;td&gt;返回 array 特定维度的 lsb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$low(array_name, dimension)&lt;/td&gt;
&lt;td&gt;返回 array 特定维度的最低位索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$high(array_name, dimension)&lt;/td&gt;
&lt;td&gt;返回 array 特定维度的最高位索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$size(array_name, dimension)&lt;/td&gt;
&lt;td&gt;返回 array 特定维度元素总数 $high - $low + 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$increasement(array_name, dimension)&lt;/td&gt;
&lt;td&gt;如果 $left &amp;gt;= $right 返回 1，否则返回 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$bits(expression)&lt;/td&gt;
&lt;td&gt;返回 expression 的总 bit 数（expression 的位宽是静态不变的，所以可综合）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="dynamic-arrays-associative-arrays-sparse-arrays-strings"&gt;dynamic arrays, associative arrays, sparse arrays, strings&lt;/h3&gt;
&lt;p&gt;这些都是不可综合的。&lt;/p&gt;
&lt;h3 id="summary_2"&gt;summary&lt;/h3&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;unpacked/packed struct 都是可综合的&lt;/li&gt;
&lt;li&gt;struct 可以作为端口在 module、interface、task/function 之间连接&lt;/li&gt;
&lt;li&gt;只有 packed union 是可综合的，unpacked union 是不可综合的&lt;/li&gt;
&lt;li&gt;array 及其赋值是可综合的，包括&lt;ul&gt;
&lt;li&gt;array 声明：packed/unpacked 都是可综合的，维度可以是任意数&lt;/li&gt;
&lt;li&gt;array 赋值：给单个元素、部分 bit 位、单个元素的 part-select、array slice、整个 array 赋值，default 关键字也是可综合的&lt;/li&gt;
&lt;li&gt;array 复制：packed-to-packed、相同 layout 的 unpacked-to-unpacked 都是可综合的&lt;/li&gt;
&lt;li&gt;struct/union 中的 array 也是可综合的，其中 union 必须是 packed，所以其内部的 array 也必须是 packed&lt;/li&gt;
&lt;li&gt;struct/union 组成的 array 也是可综合的&lt;/li&gt;
&lt;li&gt;array 作为模块端口是可综合的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-6-systemverilog-procedural-blocks-tasks-and-functions"&gt;Chapter 6 Systemverilog Procedural Blocks, Tasks and Functions&lt;/h2&gt;
&lt;p&gt;Verilog 中的 &lt;code&gt;always&lt;/code&gt; 块的用法很多，既可以对硬件建模写可综合的代码，可以在仿真中建模写不可综合的代码，所以有很多各种各样的规则，这对设计者、工具都提出了很高的要求，SV 通过新增语法解决了这些问题 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;always_comb&lt;/li&gt;
&lt;li&gt;always_ff&lt;/li&gt;
&lt;li&gt;always_latch&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="awalys_comb"&gt;awalys_comb&lt;/h3&gt;
&lt;p&gt;顾名思义，组合逻辑专用。和普通的 always 相比其好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要再写出敏感列表，不会有漏掉信号的 bug&lt;/li&gt;
&lt;li&gt;要求赋值语句的左侧信号不能在其他地方赋值，防止不符合组合逻辑的行为&lt;/li&gt;
&lt;li&gt;工具不需要再推测设计意图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;always_comb&lt;/code&gt; 比 &lt;code&gt;always @*&lt;/code&gt; 更好，因为 &lt;code&gt;always @*&lt;/code&gt; 在有函数调用时推断出来的敏感列表可能不完整&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;// infers @(data)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="c1"&gt;// infers @(data, sel, c, d, e)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;b2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// function with no inputs&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="always_latch"&gt;always_latch&lt;/h3&gt;
&lt;p&gt;和 always_comb 一样也不需要写出敏感列表，只是工具会自动推断出 latch，所以检查规则也略有变化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always_latch&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="always_ff"&gt;always_ff&lt;/h3&gt;
&lt;p&gt;同理，always_ff 用来对触发器进行建模，设计者必须提供敏感列表，而且每个信号前面必须有前缀 posedge 或者是 negedge。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst_n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="taskfunction"&gt;task/function&lt;/h3&gt;
&lt;p&gt;SV 对 task/function 也做了一些增强，主要包括下面几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不再强制要求 &lt;code&gt;begin ... end&lt;/code&gt;，会自动推断出来&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NextState&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;states_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NextState&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;WAITE:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NextState&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LOAD&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;LOAD:&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;NextState&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;STORE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;STORE:&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;NextState&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;WAITE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 中的 function 名字本身就是一个变量，返回值就是对同名变量赋值，最后一次给函数名所赋的值就是返回值。SV 新增了 return 语句，而且 return 语句的优先级高于同名变量，即如果有 return 语句，可以把同名变量当成一个临时变量来用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add_and_inc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add_and_inc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;add_and_inc&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;add_and_inc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新增的 void function 可以不必有返回值，可以像普通语句一样调用，就像 task 一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fill_packet&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;packet_t&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;data_out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;data_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data_in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;data_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;data_in&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;data_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 只运行按位置传参，错误的传参顺序可能导致错误；SV 新增了按名传参，可以减少犯错的机会&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;restult&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;divide&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;denominator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;numerator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 中的 function 只能有 input 参数，唯一的 output 参数就是函数名；SV 为 function 新增了 output 参数。为了保证可综合性，带 output 的 function 不能出现在连续赋值语句中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 要求 function 至少有一个参数，即使内部不会用到这个参数；SV 允许 function 不带参数，前面 always_comb 有个实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 要求每个参数都必须有 input/output 表明方向；SV 简化了语法，参数默认的方向是 input，除非明确声明了方向，后续的参数都是这个方向。同时 SV 默认参数是 logic 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;compare&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mytask&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endtask&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SV 还允许 funciton 参数有默认值，这样调用时如果不涉及，可以不传递这个参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;incrementer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;incrementer&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;incrementer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data_bus&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;struct、union、array 都可以作为 function 的参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="summary_3"&gt;summary&lt;/h3&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;always_comb&lt;/code&gt;, &lt;code&gt;always_latch&lt;/code&gt;, &lt;code&gt;always_ff&lt;/code&gt; 都是可综合的，用它们取代 &lt;code&gt;always&lt;/code&gt; 增强设计&lt;/li&gt;
&lt;li&gt;用 void function 代替 tasks，提高设计的安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-7-systemverilog-procedural-statements"&gt;Chapter 7 Systemverilog Procedural Statements&lt;/h2&gt;
&lt;p&gt;SV 新增了一些新语法和新的操作符，可以让设计者写出更加精简的可综合 RTL 代码。&lt;/p&gt;
&lt;h3 id="new-operators"&gt;new operators&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;自增 / 自减操作符： &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 C 语言，赋值和自增 / 自减有先后之分。因为 SV 中有阻塞 / 非阻塞两种赋值方式，&lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 的行为和阻塞赋值是一样的。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;不要在非阻塞赋值中使用自增 / 自减操作符。也就是说它们只能用来对组合逻辑进行建模，不能用在时序逻辑中。（例外情况：类似 for 循环下标这种用法，不是真正的信号）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mh"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// post-increment&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LIMIT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loop1&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// last value of i will be LIMIT&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// pre-increment&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LIMIT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loop2&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// last value of j will be LIMIT-1&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// act as blocking assignment, following two statements are equivalent&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;赋值操作符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;+=&lt;/code&gt; 为例，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// is equalitent to&lt;/span&gt;
&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;除了加法，&lt;code&gt;=&lt;/code&gt; 还可以和其他操作符结合，所有新增赋值操作汇总如下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所有的赋值操作符的行为也和阻塞赋值一样，所以和自增 / 自减一样，只能用在组合逻辑建模中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带 don't care 的等价操作符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Verilog 中有两种等价操作符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;===&lt;/code&gt;，SV 新增的操作符 &lt;code&gt;==?&lt;/code&gt; ，它们的区别在于对 x/z 的判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt;：只要任何一个操作数带 x/z，返回结果是 1'bx&lt;/li&gt;
&lt;li&gt;&lt;code&gt;===&lt;/code&gt;：bit-wise 比较，要求 1, 0, x, z 精确匹配，完全一样才返回 1‘b1，否则返回 1'b0 |&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==?&lt;/code&gt;：右操作数中的 x/z 当成是通配符，和左操作数对应 bit 的任何值都匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=?&lt;/code&gt;：对 &lt;code&gt;==?&lt;/code&gt; 取反&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果左右位宽不匹配，会在比较前做位宽扩展，扩展规则和逻辑比较 &lt;code&gt;==&lt;/code&gt; 的规则相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==?&lt;/code&gt; 和 &lt;code&gt;!=?&lt;/code&gt; 可综合的前提是右操作数是常数，即不能是可变化的信号值。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;判断是否存在 inside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于 Python 中的 &lt;code&gt;in&lt;/code&gt; 效果。&lt;code&gt;inside&lt;/code&gt; 是可综合的，但是很多综合工具可能并不支持。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inside&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b100&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="c1"&gt;// equalitent&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b001&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b010&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;// the set of values can be an array&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;1023&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inside&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;d_array&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// test if value 13 occurs anywhere in array d_array&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="for-loops"&gt;for loops&lt;/h3&gt;
&lt;p&gt;Verilog 中 for 循环的 index 变量必须声明在循环外部，如果一个模块中有多个 for 循环，而且要保证名字相互之间不同，或者把声明放到 always 块中，这时候才可以重名。&lt;/p&gt;
&lt;p&gt;SV 做了一下增强：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以在 for 循环中定义局部变量，不同 for 循环的局部变量可以重名&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，这种变量是 automatic 类型，而 automatic 类型的变量有以下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;automatic 变量不能在外部访问&lt;/li&gt;
&lt;li&gt;automatic 变量无法 dump 到 VCD 文件中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 for 循环外部是无法访问这个变量的，如果一定要访问，那么就要挪到 for 外部定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一次可以声明多个变量，和 C 语言类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="dowhile-loop"&gt;do...while loop&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;do...while&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; 一样，在某些限制条件（这些条件是要能让综合器可以静态地判断循环次数，和 for 类似）下是可综合的，一般来说 RTL 中不会使用这两种语法，略。&lt;/p&gt;
&lt;h3 id="foreach_1"&gt;foreach&lt;/h3&gt;
&lt;p&gt;见 Chapter 5 中关于 array 部分。&lt;/p&gt;
&lt;h3 id="jump-statements"&gt;jump statements&lt;/h3&gt;
&lt;p&gt;SV 新增的 &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt; 都是可综合的，规则和 &lt;code&gt;disable&lt;/code&gt; 一样。（一般很少用）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// continue example&lt;/span&gt;
&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;255&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;255&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// skip empty elements&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;transform_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// break example&lt;/span&gt;
&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;first_bit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mh"&gt;63&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start_range&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;end_range&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;first_bit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// return example&lt;/span&gt;
&lt;span class="k"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add_up_to_max&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mh"&gt;63&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endtask&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="block-names"&gt;block names&lt;/h3&gt;
&lt;p&gt;当有多层 begin...end 嵌套时，即使有缩进，有时候也很那找到 end 对应的 begin，SV 支持给 end 后面也加上 name，这个特性对综合没有任何影响，只是为了提高代码可读性。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;end 后面的名字必须和匹配的 begin 名字相同，否则会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;block_name&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;block_name&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id="statement-label"&gt;statement label&lt;/h3&gt;
&lt;p&gt;SV 还支持给单个语句加上 label，就和 begin...end 块一样，不过语法是类似 C 语言的风格。给语句加上 label 的好处很多，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高代码可读性&lt;/li&gt;
&lt;li&gt;方便文档 / 其他地方引用具体语句&lt;/li&gt;
&lt;li&gt;帮助 debug 工具和 coverage 工具分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;begin...end 块也是一个 statement，所以也可以给它加上 label。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;begin...end 块不能同时使用 label 和 block name。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// &amp;lt;label&amp;gt; : &amp;lt;statement&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nl"&gt;decoder:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;opcode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// named block&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;block1&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;block1&lt;/span&gt;

&lt;span class="c1"&gt;// labeled block&lt;/span&gt;
&lt;span class="nl"&gt;block2:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id="case-statement"&gt;case statement&lt;/h3&gt;
&lt;p&gt;Verilog 标准特意规定了 case 语句的选择必须是按照顺序来评估，所以暗含着优先级。会得到类似 if-else-if 的效果。如果设计本身没有优先级时，综合工具要做特别的处理，把优先级逻辑优化掉。&lt;/p&gt;
&lt;p&gt;SV 为此特意定义了两个描述符来限定 case 语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unique case&lt;/code&gt; 表示无优先级的 case，它要求表达式和 case item 之间必须是一一映射的关系，表达式必须能且只能匹配一个 item，否则会报错。unique case 和 always_comb 配合使用，这两个特性带来的额外检查可以提高 RTL 的综合结果符合设计意图。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;unique&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;case_expression&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// case items&lt;/span&gt;
&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;priority case&lt;/code&gt; 表示有优先级的 case，它要求表达式至少要匹配一项 item，如果有多项匹配时，选择对一个匹配项。使用这个限定符表示设计者是有意这么做的，有多个匹配项也符合设计意图。有时候即使使用了 priority，如果 case item 本身是不可能同时匹配，那么综合工具也会自动把优先逻辑优化掉。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;priority&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;case_expression&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// case items&lt;/span&gt;
&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verilog 中定义了两个 program 来帮助综合工具，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parallel_case&lt;/code&gt;：告诉综合工具去掉优先级逻辑，所有分支是并行同级关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;full_case&lt;/code&gt;：未使用到的 expression value 是无关紧要的，可优化掉这部分逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以 unique case 实际上就相当于同时使能了 full_case 和 parallel_case，而 priority case 相当于只使能了 full_case。但是使用这两个新语法比 program 更健壮，可以减少风险。&lt;/p&gt;
&lt;h3 id="ifelse"&gt;if...else&lt;/h3&gt;
&lt;p&gt;unique 和 priority 也可以用来限定 if-else 语句。仿真工具会按照我们书写顺序来评估每个条件，综合工具也会产生优先级逻辑来保持和仿真的一致性，但是通常，我们书写顺序并不是真正想要的效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unique if...else&lt;/code&gt; 表明设计者并不关心优先级，综合工具可以把优先级逻辑优化掉。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;unique&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b001&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux_out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b010&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux_out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mb"&gt;3&amp;#39;b100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux_out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;priority if...else&lt;/code&gt; 表明设计者关心优先级，所以工具要保留优先级逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="summary_4"&gt;summary&lt;/h3&gt;
&lt;div class="admonition summary"&gt;
&lt;p class="admonition-title"&gt;Summary&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 都是可综合的，但是工具支持并不好，为了健壮性，避免使用这两个操作符&lt;/li&gt;
&lt;li&gt;新增的赋值操作符是可综合的，有些综合工具对部分操作符有限制，为了健壮性，避免使用这些赋值操作符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==?&lt;/code&gt; 和 &lt;code&gt;!=?&lt;/code&gt; 可综合的前提是右操作数是常数&lt;/li&gt;
&lt;li&gt;增强性 for 循环也是可综合的，和 Verilog 中的 for 规则相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do...while&lt;/code&gt; 在某些条件下是可综合的，避免使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt; 都是可综合的，避免使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique&lt;/code&gt;  和 &lt;code&gt;priority&lt;/code&gt; 都是可综合的，可以提高设计的健壮性&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-8-modeling-finite-state-machine-with-systemverilog"&gt;Chapter 8 Modeling Finite State Machine with Systemverilog&lt;/h2&gt;
&lt;p&gt;使用前面 7 章介绍的新特性，使用 FSM 对一个交通灯控制系统建模的例子。和传统 Verilog 相比，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一使用 &lt;code&gt;logic&lt;/code&gt; 代替 &lt;code&gt;reg&lt;/code&gt;/&lt;code&gt;wire&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;always_comb&lt;/code&gt; 和 &lt;code&gt;always_ff&lt;/code&gt; 代替通用 &lt;code&gt;always&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;begin...end 加了 name&lt;/li&gt;
&lt;li&gt;使用 enum 类型描述所有状态&lt;ul&gt;
&lt;li&gt;明确类型为 &lt;code&gt;logic&lt;/code&gt;（默认是 &lt;code&gt;int&lt;/code&gt;，32-bit 2-state）&lt;/li&gt;
&lt;li&gt;明确给出 label 的取值（方便控制编码类型，比如 one-hot, one-cold, binary 等）&lt;/li&gt;
&lt;li&gt;enum 变量只能用 label 赋值，不要用数字给 enum 变量赋值，也不要给部分 bit 赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;unique case&lt;/code&gt; 代替普通 case&lt;ul&gt;
&lt;li&gt;如果是 one-hot 编码，可以调换 case expression 和 case selection items 的位置，某些综合工具下面积更优&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;traffic_light&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;green_light&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                   &lt;/span&gt;&lt;span class="n"&gt;yellow_light&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                   &lt;/span&gt;&lt;span class="n"&gt;red_light&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;sensor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;green_downcnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                   &lt;/span&gt;&lt;span class="n"&gt;yellow_downcnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;R_BIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;G_BIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;Y_BIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state_bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;RED&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b001&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;R_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// explicit enum definition&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;GREEN&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b001&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;G_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="n"&gt;YELLOW&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b001&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Y_BIT&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;set_next_state&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// the default for each branch below&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// reversed case statement&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;R_BIT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sensor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GREEN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;G_BIT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;green_downcnt&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;YELLOW&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Y_BIT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;yellow_downcnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RED&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;set_next_state&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always_comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;set_outputs&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;red_light&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;green_light&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;yellow_light&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;unique&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// reversed case statement&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;R_BIT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;red_light&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;G_BIT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;green_light&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;Staet&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Y_BIT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;yellow_light&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;set_outputs&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="chapter-9-systemverilog-design-hierarchy"&gt;Chapter 9 Systemverilog Design Hierarchy&lt;/h2&gt;
&lt;h3 id="module-prototypes"&gt;module prototypes&lt;/h3&gt;
&lt;p&gt;大型设计可能会分散定义在几十个文件中，在模块中例化另外一个文件中的模块时，综合工具要做大量工作，包括检查这个文件的模块的定义，包括端口数量、端口位宽、甚至是端口顺序。SV 提供了 &lt;code&gt;external module&lt;/code&gt; 语法在例化该模块的文件中声明模块原型，可以简化综合步骤。&lt;/p&gt;
&lt;p&gt;声明方式有两种：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Verilog-1995 style&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Verilog-2001 style&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;N:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;N:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                           &lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                           &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;声明模块原型可以写在任何地方：在 module/interface 之外的声明实际上定义在 $unit 中，这时模块原型声明对于和这个文件一起综合的其他文件来说都是可见的。&lt;/p&gt;
&lt;p&gt;原型和模块的实际定义必须严格一致：包括端口顺序、端口位宽都必须相同，如果不同会报错。&lt;/p&gt;
&lt;p&gt;如果模块参数、端口非常多，重复写两遍非常麻烦，SV 提供了新语法 &lt;code&gt;.*&lt;/code&gt; 解决这个问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// prototype&lt;/span&gt;
&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;N:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;N:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                           &lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                                           &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// difinition&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always_ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="named-ending-statements"&gt;named ending statements&lt;/h3&gt;
&lt;p&gt;前面介绍了 SV 允许给 begin...end 后面加上名字，以提高代码可读性，实际上很多代码块都可以加上名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;begin...end&lt;/li&gt;
&lt;li&gt;package...endpackage&lt;/li&gt;
&lt;li&gt;interface...endinterface&lt;/li&gt;
&lt;li&gt;task...endtask&lt;/li&gt;
&lt;li&gt;function...endfunction&lt;/li&gt;
&lt;li&gt;module...endmodule&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="nested-module-declarations"&gt;nested module declarations&lt;/h3&gt;
&lt;p&gt;Verilog 中的模块默认是全局的可见的，所以在设计中的任何地方都可以访问这些模块的定义。这个机制简单强大，但是有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块访问是无限制的，但是有时候我们希望隐藏某些模块，防止外部访问&lt;/li&gt;
&lt;li&gt;大型设计中可能产生命名冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verilog 虽然可以通过配置文件的方式解决问题，但是不够优雅。SV 为解决这个问题提供了一种方法：嵌套的模块定义。和 C 语言类似，嵌套的模块定义只能被父模块或者是同一层级结构的模块访问。&lt;/p&gt;
&lt;p&gt;为了可维护性一般都是一个文件放一个模块，且文件名和模块名相同，嵌套模块的方式显然违背了这个原则，所以嵌套模块应该和 `include 配合使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ip_core&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sub1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// sub1 is a nested module&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sub2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// sub2 is a nested module&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="c1"&gt;// stored in file sub1.v&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sub1&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;endmoudle&lt;/span&gt;

&lt;span class="c1"&gt;// stored in file sub2.v&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sub2&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;endmoudle&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="simplified-netlists-of-module-instances"&gt;simplified netlists of module instances&lt;/h3&gt;
&lt;p&gt;Verilog 提供了两种端口连接方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按端口顺序连接：缺点太多，大部分情况都被禁止使用&lt;/li&gt;
&lt;li&gt;按端口名连接：优点是不容易出错，缺点是模块和端口数量较多时非常繁琐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SV 提供了三种新的连接方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.name&lt;/code&gt; 方式：在许多端口连接上，信号名和端口名是一致的，这个时候就可以用这种方式，结合了端口顺序和端口名两种方式的优点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;prom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;prom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program_data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program_address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须声明和端口同名的，用于连接的 var / net 信号&lt;/li&gt;
&lt;li&gt;连线的位宽必须和模块端口保持一致&lt;/li&gt;
&lt;li&gt;两个端口的也必须兼容&lt;/li&gt;
&lt;li&gt;无法使用 .name 方式连接的端口必须用端口名连接&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.*&lt;/code&gt; 方式：比 .name 更进一步，例化模块时连信号名都不需要写，直接用通配符来匹配（条件同 .name）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;prom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;prom&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program_data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;program_address&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;interface 方式：见下一章&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-aliasing"&gt;net aliasing&lt;/h3&gt;
&lt;p&gt;SV 新增了信号别名的语法，给信号起别名的 assign 语句有点像，但是并不完全相同。因为 assign 是单方向的，等号右边的信号的值可以传递给左边，但是左边的值无法传递给右边，而 &lt;code&gt;alias&lt;/code&gt; 是双向的，因为本质上多个名字指向的是同一个资源。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rstN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rstN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;alias&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rstN&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;使用别名有几个约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能给 net 类型起别名&lt;/li&gt;
&lt;li&gt;只能在相同类型的 net 直接使用别名&lt;/li&gt;
&lt;li&gt;别名必须位宽相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;别名也不需要预先显式地声明好才能用，它遵守 Verilg 中模块端口的隐式推断规则可以由工具自动推断出来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alias 两端任何一个未声明的名字都会自动推断出一个 net 类型信号&lt;/li&gt;
&lt;li&gt;默认是 wire 类型&lt;/li&gt;
&lt;li&gt;如果 net 是模块端口信号，则其位宽和端口一致&lt;/li&gt;
&lt;li&gt;如果 net 不是端口信号，则默认是 1-bit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然 &lt;code&gt;.*&lt;/code&gt; 可以减少工作量，但是有个前提条件是：模块端口名必须一样，否则还是得用传统的端口连接方式。而这个问题可以通过 alias 解决：&lt;strong&gt;只需要先用 alias 把不同端口名设置为别名即可，这些模块例化时端口列表只写 &lt;code&gt;.*&lt;/code&gt; 即可&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="pass-values-through-module-ports"&gt;pass values through module ports&lt;/h3&gt;
&lt;p&gt;Verilog 对什么信号可以做作为模块端口有严格的约束，而 SV 基本上把这些限制都去掉了，基本上任何类型都可以作为模块端口，包括任何类型的 packed/unpacked 数组、structure、union、用户自定义类型等。&lt;/p&gt;
&lt;p&gt;但是 SV 还是有两个约束，这两个约束都非常直白，都是为了建模的准确性而设立的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一条是：var 类型只能有一个源驱动。因为 SV 中的 var 只是简单地保存赋值，所以有多个赋值时会保存最后一个赋值，而硬件在多驱动时的硬件行为并不是这样。所以 SV 要求只有 net 类型信号可以有多驱动。&lt;/li&gt;
&lt;li&gt;所有 unpacked 类型的信号（struct、union、array）作为端口连接时，必须一模一样，包括维度的数量、每个维度的大小、每个元素的位宽都必须一样。（隐含条件，struct、union 必须用 typedef 才能作为端口连接）。这个条件对 packed 类型并不其作用，因为 packed 类型是按照 vector 来处理的，SV/Verilog 有相应的规则处理位宽不匹配的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="reference-ports"&gt;reference ports&lt;/h3&gt;
&lt;p&gt;不可综合，略。&lt;/p&gt;
&lt;h3 id="enhanced-port-declarations"&gt;enhanced port declarations&lt;/h3&gt;
&lt;p&gt;Verilog-1995 风格的端口声明已经没有人用了，但是 Verilog-2001 还是有点繁琐，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有端口都必须显式声明方向&lt;/li&gt;
&lt;li&gt;多个端口一起声明时，如果要改数据类型则必须连带方向一起声明（下例中的 a, b 和 ci）&lt;/li&gt;
&lt;li&gt;多个端口一起声明时，如果要改变端口位宽必须连带方向一起声明（下例中的 result 和 co）&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// verilog-2001&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;accum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;inout&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;tril&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="c1"&gt;// SV&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;accm&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tril&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;一般为了代码健壮性、减少错误，大部分 coding style 都规定还要一行一个端口地声明，不会用到这个特性。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="parameterized-types"&gt;parameterized types&lt;/h3&gt;
&lt;p&gt;Verilog 中的 parameter 只能参数化端口位宽，SV 新增了一个可综合的新语法 &lt;code&gt;parameter type&lt;/code&gt;，可以对端口类型进行参数化，进一步提高了模块的多态性。实际上 Verilog 模块端口类型一般只有 wire/reg，而且是固定的，所以也不需要对类型参数化，而 SV 中有很多类型，甚至用户可以自定义类型，所以类型参数化就有必要了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ADDERTYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;shortint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;ADDERTYPE&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// redefinable type&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ADDERTYPE&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// redefinable type&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;carry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;ADDERTYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;big_chip&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;shortint&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;carry1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;carry2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;carry3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 16-bit unsigned adder&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;carry1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 32-bit signed adder&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;#(.&lt;/span&gt;&lt;span class="n"&gt;ADDERTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;carry2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 32-bit unsigned adder&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;adder&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;#(.&lt;/span&gt;&lt;span class="n"&gt;ADDERTYPE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;carry3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;endmoudle&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="summary_5"&gt;summary&lt;/h3&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必要时给 begin...end 后面加上 name，增强可读性&lt;/li&gt;
&lt;li&gt;nested module 和 `include 配合使用&lt;/li&gt;
&lt;li&gt;顶层集成用 &lt;code&gt;.*&lt;/code&gt; 配合 alias 减少工作量&lt;/li&gt;
&lt;li&gt;为了减少错误，避免使用增强型的端口声明语法&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-10-systemverilog-interfacees"&gt;Chapter 10 Systemverilog Interfacees&lt;/h2&gt;
&lt;h3 id="concepts"&gt;concepts&lt;/h3&gt;
&lt;p&gt;Verilog 中是通过模块端口进行连接，这种方式在端口数量非常多的时候很繁琐，比如说多个模块连接到总线上时，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个模块定义处都要声明总线的所有信号&lt;/li&gt;
&lt;li&gt;顶层集成时也要把每个模块的所有端口都写出来&lt;/li&gt;
&lt;li&gt;信号很多时连线可能出错&lt;/li&gt;
&lt;li&gt;如果总线变了，多个地方都要同步修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SV 新增了一个叫 &lt;code&gt;interface&lt;/code&gt; 的语法，可以把一组端口定义成一个端口，这样使用 / 修改起来就非常方便了。interface 并不是简单的把信号组合打包在一起，它里面还可以定义其他功能代码，比如其他离散的信号、接口的协议、检查协议的验证代码等：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type declration&lt;/li&gt;
&lt;li&gt;task/function&lt;/li&gt;
&lt;li&gt;procedural block&lt;/li&gt;
&lt;li&gt;program block&lt;/li&gt;
&lt;li&gt;assertion&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main_bus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;slave_instruction&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;slave_request&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;bus_grant&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;bus_request&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;slave_ready&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;data_ready&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;mem_read&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;mem_write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;endinterface&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;processor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;main_bus&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;15&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;jump_address&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//...);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="interface-declration"&gt;interface declration&lt;/h3&gt;
&lt;p&gt;从语法上来说，interface 的定义和 module 非常像，interface 也可以有端口，这样外部信号就可以被引入 interface  成为信号的一部分。Interface 内部还可以定义任何数据类型，包括 var、net、用户自定义类型等。&lt;/p&gt;
&lt;p&gt;Interface 可以定义在全局，就和普通 module 一样，其他 module 可以直接使用 interface，编译顺序对工具没有影响，所以 interface 可以先使用后编译。Interface 也可以定义在一个 module 内部，仅限内部使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// 上例的 main_bus 可以把 clock 和 reset 也引入到 interface 中&lt;/span&gt;
&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test_mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// signal definition&lt;/span&gt;
&lt;span class="n"&gt;endinterface&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test_mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;main_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// using .* connections&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// method 1&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;processor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;proc1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jump_address&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;jump_address&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;instruction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// method 2&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;processor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;proc1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="using-interface-as-module-ports"&gt;using interface as module ports&lt;/h3&gt;
&lt;p&gt;Interface 可以作为 module 端口的一部分，而且不需要声明 input/output 等方向。一共有两种方式声明 interface 端口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 interface 的名字来声明 module 端口，这种端口只能连接到同名的 interface 端口上，目的是避免端口不匹配（推荐使用）&lt;/li&gt;
&lt;li&gt;直接用 &lt;code&gt;interface&lt;/code&gt; 这个关键字来声明端口，这种是通用的 interface 端口，其他任何类型的 interface 端口都可以连接到这个端口上（避免使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种写法都是可综合的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// method 1&lt;/span&gt;
&lt;span class="c1"&gt;// module &amp;lt;module_name&amp;gt; (&amp;lt;interface_name&amp;gt; &amp;lt;port_name&amp;gt;);&lt;/span&gt;

&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;endinterface&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CACHE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pins&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clcok&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="c1"&gt;// method 2&lt;/span&gt;
&lt;span class="c1"&gt;// module &amp;lt;module_name&amp;gt; (interface &amp;lt;port_name&amp;gt;);&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;RAM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pins&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="instantiating-and-connecting-interface"&gt;instantiating and connecting interface&lt;/h3&gt;
&lt;p&gt;interface 和 module 一样都可以例化，然后连接起来，连接的语法也和 module 一样，可以用 .name，.* 等方式（前面 main_bus 的例子）。interface 还可以嵌套，比如 sub_bus 和 main_bus 都可以定义成 interface，且 sub_bus 是 main_bus 的组成部分。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;一个 module 的 interface 端口必须连接到其他 interface instance 或者是另外一个 module 的 interface 端口上，不能悬空。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="referencing-signals-within-an-interface"&gt;referencing signals within an interface&lt;/h3&gt;
&lt;p&gt;使用 interface 中的信号必须通过下面的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// &amp;lt;port_name&amp;gt;.&amp;lt;internal_interface_signal_name&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;因为这种方式必须把端口名前缀加上，所以为了减少工作量、提高可读性，建议给 port 起个简短的名字。&lt;/p&gt;
&lt;h3 id="interface-modports"&gt;interface modports&lt;/h3&gt;
&lt;p&gt;interface 为模块端口连接提供了一种新方式，但是从不同模块的角度看，端口是不一样的。比如一组总线，从 slave 模块看，interrupt_request 很可能是输出端口，而从 master 模块看，它是一个输入端口。SV 提供了一种新语法来解决这个问题：用 module port 的缩写 &lt;code&gt;modport&lt;/code&gt; 关键字来定义端口。一个 interface 可以有任意多个 modport，每个 modport 描述了每个相关模块角度看到的 interface 端口的方向。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;interrupt_request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;grant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;interrupt_request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;grant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;inout&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;slave&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;interrupt_request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;grant&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;inout&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;endinterface&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如上所示，modport 的定义不需要包含 vector 的位宽及数据类型（这些信息在 interface 中已定义好），只需要定义方向即可。&lt;/p&gt;
&lt;p&gt;定义好之后，具体使用时要声明是从哪个角度看待 interface，即要选择具体是哪个 modport。SV 提供了两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;modport 作为 interface 的一部分在模块&lt;strong&gt;例化时&lt;/strong&gt;确定（避免使用）&lt;/p&gt;
&lt;p&gt;同时例化一个 module 和 interface，然后在连接它们时确定 modport。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// &amp;lt;interface_instance_name&amp;gt;.&amp;lt;modport_name&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;slave&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="k"&gt;endinterface&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;primary&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pins&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// generic interface port&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secondary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pins&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// specific interface port&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;primary&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;secondary&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;slave&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;modport 作为模块端口的一部分在模块&lt;strong&gt;定义时&lt;/strong&gt;确定（推荐使用）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// &amp;lt;interface_name&amp;gt;.&amp;lt;modport_name&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;slave&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="k"&gt;endinterface&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;primary&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pins&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;secondary&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;slave&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pins&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;chip&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;chip_bus&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;primary&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;secondary&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种风格都是可综合的，但是只能选择其中一种，不能同时混用：在定义和例化时都使用 modport 会报错。&lt;/p&gt;
&lt;p&gt;即使 interface 中定义了 modport，但是实际中没有使用时，信号会有默认的方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有的 net 都是双向端口 &lt;code&gt;inout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有的 var 都是 &lt;code&gt;ref&lt;/code&gt; 类型端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际使用过程中，很有可能出现这种情况：interface 定义了一大组信号，但是不同 module 分别只需要看到其中的部分信号。显然把 interface 的所有信号都连到每个 module 上很浪费；而为每个 module 定义各自的 interface 又失去了 interface 的意义。&lt;/p&gt;
&lt;p&gt;使用 modport 可以为每个 module 定义一种不同的 interface view，从而解决这个问题。因为每个 module 只能访问 modport 内的信号，所以可以利用这个特性对某些 module 隐藏 interface 中的特定信号。如果一个 module 没有用 modport 连接 interface，那么 interface 中定义的信号这个 module 都可以访问。&lt;/p&gt;
&lt;h3 id="using-taskfunction-in-interface"&gt;using task/function in interface&lt;/h3&gt;
&lt;p&gt;假设有个 master 和 slave 通过总线交互的场景，在传统的 Verilog 代码中，master 和 slave 必须各自包含一些监控端口和处理握手的逻辑。这些逻辑分散在 master 和 slave 模块的定义中，会导致功能重叠的代码，而且不易维护，一旦总线有任何修改，相应的所有模块都需要修改。&lt;/p&gt;
&lt;p&gt;SV 的 interface 内部可以定义 function/task，从而可以把总线相关的逻辑功能代码都放在 interface 中集中管理，这样相关逻辑代码只需要写一次。这些 function/task 叫做 interface method，它们可以像在 module 中一样，访问 interface 内的任何信号。具体使用时，module 首先连接到 interface，然后通过端口名前缀的方式就可以使用某个 method 了。&lt;/p&gt;
&lt;p&gt;如果 interface 是通过 modport 使用，那么 method 必须通过 &lt;code&gt;import&lt;/code&gt; 导入在 modport 内，有两种方式可用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过 method 名导入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// modport (import &amp;lt;task_function_name&amp;gt;);&lt;/span&gt;

&lt;span class="k"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parity_en&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 method 原型导入&lt;/p&gt;
&lt;p&gt;这种方式要求 import 后面加上 task/function 关键字，method 名字后面还要有包含参数的圆括号。如果 interface 定义在另外一个 package 文件中时，这种方式可以提高代码可读性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// modport (import task &amp;lt;task_name&amp;gt;(&amp;lt;task_formal_arguments));&lt;/span&gt;
&lt;span class="c1"&gt;// modport (import function &amp;lt;function_name&amp;gt;(&amp;lt;formal_args));&lt;/span&gt;

&lt;span class="k"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                             &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parity_gen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 modport 把 function/task 导入之后，module 就可以使用这些逻辑了，使用方式和使用 interface 内的信号一样，加上 interface 端口名前缀即可。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;为了保证可综合，导入的 task/function 必须是 automatic 类型，而且内部不能包含 static 声明。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;math_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b_int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result_int&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IntegerRead&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b_int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// do handshaking to fetch a and b values&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endtask&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;modport&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;int_io&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IntegerRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;result_int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;endinterface&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;logic&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;math_bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;resetN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// instance of interface&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;integer_math_unit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_io&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// connect to interface&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;integer_math_unit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interface&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a_reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b_reg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IntegerRead&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_reg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b_reg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// call method in interface&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id="using-procedural-blocks-in-interface"&gt;using procedural blocks in interface&lt;/h3&gt;
&lt;p&gt;interface 内部还可以定义 &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;always_comb&lt;/code&gt;, &lt;code&gt;always_ff&lt;/code&gt;, &lt;code&gt;always_latch&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;assign&lt;/code&gt; 等语句块，在 Interface 中定义这些语句块的一种应用场景是做验证：在 interface 中定义相关协议的 checker，这样每次通过 interface 传递数据时，内置的 checker 会自动检查是否满足相关约束。&lt;/p&gt;
&lt;h3 id="reconfigurable-interface"&gt;reconfigurable interface&lt;/h3&gt;
&lt;p&gt;interface 可以像 module 一样使用 parameter，也可以使用 generate 语句，所以可以定义参数化的 interface，方便复用。
（example 10-12）&lt;/p&gt;
&lt;h3 id="summary_6"&gt;summary&lt;/h3&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;named interface port 和 generic interface ports 都是可综合的&lt;/li&gt;
&lt;li&gt;modport 的两种使用方式都是可综合的&lt;/li&gt;
&lt;li&gt;module 导入 interface 中的 function/task 是可综合的，综合时会自动在模块中产生一份本地电路，综合后的模块内已经包含了这些逻辑，不再需要去 interface 中查询&lt;/li&gt;
&lt;li&gt;永远不要使用 task，用 void function 代替 task&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="chapter-11-a-complete-design-modeled-with-systemverilog"&gt;Chapter 11 A Complete Design Modeled with SystemVerilog&lt;/h2&gt;
&lt;p&gt;一个用 SV 设计的通信领域的异步传输机制 ATM (Asynchronous Transfer Mode) 原型，用到了以下特性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;动态表示相同长度的两种数据包&lt;/td&gt;
&lt;td&gt;用 packed struct + packed union 封装不同数据类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定义总线&lt;/td&gt;
&lt;td&gt;用 interface(modport + method) 封装总线接口和协议、简化代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定义多种实现方式&lt;/td&gt;
&lt;td&gt;带 parameter 的可重定义 interface&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全局定义&lt;/td&gt;
&lt;td&gt;类似 C 语言的 include 头保护 &lt;code&gt;ifndef&lt;/code&gt;...&lt;code&gt;define&lt;/code&gt;...&lt;code&gt;endif&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定义状态机的状态&lt;/td&gt;
&lt;td&gt;enum 类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;定义状态机跳转&lt;/td&gt;
&lt;td&gt;使用 unique case&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;generate 语句&lt;/td&gt;
&lt;td&gt;index 自增减少代码量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多层 begin...end 嵌套&lt;/td&gt;
&lt;td&gt;加上 label 增强可读性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;封装功能代码&lt;/td&gt;
&lt;td&gt;module 内定义 function&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="chapter-12-behavioral-and-transaction-level-modeling"&gt;Chapter 12 Behavioral and Transaction Level Modeling&lt;/h2&gt;
&lt;p&gt;虽然有些特定的综合工具可以处理特定的 TLM，大部分情况下 Transaction Level Modeling(TLM) 大部分情况下都是不可综合的，略。&lt;/p&gt;
&lt;h2 id="_1"&gt;附录&lt;/h2&gt;
&lt;p&gt;一些 SV 的参考资源：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;资源&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Syntax&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://book.douban.com/subject/1764888/"&gt;SystemVerilog for Design&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.sutherland-hdl.com/books_and_guides.html"&gt;RTL Modeling with SystemVerilog For Simulation and Synthesis&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://book.douban.com/subject/2859647/"&gt;Verilog and SystemVerilog gotchas&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Coding Style&lt;/td&gt;
&lt;td&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md"&gt;lowRISC coding style guide&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="IC"></category><category term="SystemVerilog"></category></entry><entry><title>RISC-V Spec 阅读笔记 #2 —— Privileged ISA</title><link href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-2-privileged.html" rel="alternate"></link><published>2021-03-25T17:29:00+08:00</published><updated>2021-03-25T17:29:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-03-25:/posts/risc-v/risc-v-spec-notes-2-privileged.html</id><summary type="html">&lt;p&gt;Volume II: Privileged ISA 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#introduction"&gt;Introduction&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#software-stack-terminology"&gt;Software Stack Terminology&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#privilege-levels"&gt;Privilege Levels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#debug-mode"&gt;Debug Mode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#control-and-status-registers-csrs"&gt;Control and Status Registers (CSRs)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#address-mapping-conventions"&gt;Address Mapping Conventions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#csr-listing"&gt;CSR Listing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#field-specifications"&gt;Field Specifications&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#wpri"&gt;WPRI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#wlrl"&gt;WLRL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#warl"&gt;WARL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#csr-width-modulation"&gt;CSR Width Modulation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#machine-level-isa"&gt;Machine-Level ISA&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#machine-level-csrs"&gt;Machine-Level CSRs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#machine-mode-privileged-instructions"&gt;Machine-Mode Privileged Instructions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reset"&gt;Reset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nmi"&gt;NMI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pma"&gt;PMA&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#main-memory-io-empty"&gt;Main memory / IO / empty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#supported-access-type"&gt;Supported Access Type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#atomicity"&gt;Atomicity&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#amo"&gt;AMO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#reservability-pma"&gt;Reservability PMA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#alignment"&gt;Alignment&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#memory-ording-pmas"&gt;Memory Ording PMAs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#coherenece-and-cacheability"&gt;Coherenece and Cacheability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#idempotency"&gt;Idempotency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#pmp"&gt;PMP&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pmp-csrs"&gt;PMP CSRs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pmpcfg"&gt;pmpcfg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pmpaddr"&gt;pmpaddr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#address-matching"&gt;address matching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#locking"&gt;locking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#priority-and-matching"&gt;priority and matching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#paging"&gt;Paging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#supervisor-level-isa"&gt;Supervisor-Level ISA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Privileged ISA 文档的版本号 :20190608-Priv-MSU-Ratified&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Unprivileged 的补集，包含了运行操作系统和支持外设所需要的特权指令、额外功能。&lt;/p&gt;
&lt;h3 id="software-stack-terminology"&gt;Software Stack Terminology&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ABI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Application Binary Interface, ABI = user-level ISA + ABI calls to AEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SBI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Supervisor Binary Interface, SBI = user-level + supervisor-level ISA + SBI calls to SEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HBI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hypervisor Binary Interface, HBI = user-level ISA + HBI calls to HEE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;AEE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Application Execution Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HEE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Hypervisor Execution Environment&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;观察 spec 中的示意图，可以发现整个 stack 的结构本质上就是不断套娃的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最简单是 “ 裸机系统 ”&lt;/p&gt;
&lt;p&gt;ABI 作为中间抽象借口，隐藏了底层 AEE 的实现细节，对上面的 Application 提供了一个标准抽象借口，这样上层的 Application 就不需要再关心底层实现，这样 AEE 的实现可以更灵活，可以直接用 RISC-V 硬件实现，也可以是一个运行在其他架构机器上的模拟器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套第一层娃，支持单操作系统&lt;/p&gt;
&lt;p&gt;在 ABI 和 AEE 之间插入一层 OS，Application 和 OS 之间通过 ABI 交互，OS 和 SEE 之间通过 SBI 交互。同理，SEE 的实现也可以是真实的硬件，也可以是 hypervisor 提供的虚拟机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套第二层娃，虚拟机支持多操作系统&lt;/p&gt;
&lt;p&gt;在 OS 和 SEE 之间再插入新的一层 hypervisor，每个 OS 通过 SBI 和 hypervisor 交互，hypervisor 通过 HBI 和底层的 HEE 交互。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个 stack 的核心思想可以总结为：&lt;strong&gt;通过抽象的 Interface 对上层提供统一标准借口，隔离底层细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RISC-V 的硬件不仅要实现 Privileged ISA，还要包含一些其他功能才能完整支持各种执行环境（AEE、SEE、HEE）。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;大部分的 supervisor-level ISA 在定义的时候，都没有把 SBI 从 execution environment 或者是硬件平台中分离出来，这样会导致虚拟化和开发新硬件平台时变得更复杂。&lt;/p&gt;
&lt;p&gt;目前 RISC-V 的 ABI、SBI、HBI 都还在定义中。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="privilege-levels"&gt;Privilege Levels&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;00&lt;/td&gt;
&lt;td&gt;User/Application&lt;/td&gt;
&lt;td&gt;&lt;code&gt;U&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;Supervisor&lt;/td&gt;
&lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;-Reserved-&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;Machine&lt;/td&gt;
&lt;td&gt;&lt;code&gt;M&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一共定义了 3 个特权层次，其中 M 是强制要求所有实现都必须支持的，M 的层次最高，它可以不受限制地访问底层的完整硬件资源，一般最简实现只支持 M 即可。U 模式是为了支持传统的 Application，S 模式则是为了支持 OS。&lt;/p&gt;
&lt;p&gt;每个 level 都会有一组核心 Privileged ISA，再附加一些可选的扩展指令和变种指令。任何一个实现可以根据资源和目标折中选择支持 3 种 level 的组合。这些 level 是通过 CSR 来定义的，任何一个 hart 任何时候必然处于 3 种 level 中的某一种。&lt;/p&gt;
&lt;p&gt;允许的组合：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;级别数量&lt;/th&gt;
&lt;th&gt;支持的模式&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;简单嵌入式系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;M, U&lt;/td&gt;
&lt;td&gt;带安全功能的嵌入式系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;M, S, U&lt;/td&gt;
&lt;td&gt;运行 Unix-like 的操作系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="debug-mode"&gt;Debug Mode&lt;/h3&gt;
&lt;p&gt;Debug 可以看做是一个比 M 模式级别更高的特权模式，可能会有一些专用的 CSR 和地址空间。RISC-V 的 debug 模式定义在另外一个标准文档中。&lt;/p&gt;
&lt;h2 id="control-and-status-registers-csrs"&gt;Control and Status Registers (CSRs)&lt;/h2&gt;
&lt;p&gt;RISC-V 中的 opcode &lt;code&gt;SYSTEM&lt;/code&gt; 用来编码所有的特权指令，这些指令可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zicsr&lt;/code&gt; 子集中定义的 atomically read-modify-write CSR 的指令 ( 即 CSR 指令 )&lt;/li&gt;
&lt;li&gt;其他 privileged 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了 Unprivileged ISA 中描述的 CSR 之外，implementation 还可以包含一些其他 CSR，这些 CSR 在某些特权级别下可以通过 &lt;code&gt;Zicsr&lt;/code&gt; 中的指令进行访问。虽然 CSR 和特权指令都绑定了某个特权等级，但是也可以被更高等级访问。&lt;/p&gt;
&lt;h3 id="address-mapping-conventions"&gt;Address Mapping Conventions&lt;/h3&gt;
&lt;p&gt;CSR 的编址使用独立的 12bit 空间，所以理论上最多可以编码 4096 个 CSR。一般的惯例是，最高的 4bit 用来编码 CSR 的读写属性，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;csr[11:10]&lt;/code&gt; 表示 CSR 的读写属性，00/01/10 = read/write，11=read-only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;csr[9:8]&lt;/code&gt; 表示可以访问该 CSR 的最低特权等级，00 = User，01 = Supervisor，10 = Hypervisor，11 = Machine&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 使用高位 bit 来表示访问的最低权限，这种方法可以简化硬件检错电路，提供更大的 CSR 地址空间。但是这种方法确实会约束 CSR 的地址映射。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;出现下列情况，会抛出一个 illegal instruction exception：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问一个不存在的 CSR&lt;/li&gt;
&lt;li&gt;访问的特权等级不够高&lt;/li&gt;
&lt;li&gt;对一个 RO 类型的 CSR 进行写操作（一个 R/W 类型的 CSR 的某些字段可能是 RO 类型，对这些字段的写操作应该被忽略掉。）&lt;/li&gt;
&lt;li&gt;M 模式下访问 debug CSR 地址段的 CSR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;spec 还对 standard 和 custom CSR 地址做了区间划分，custom 区间作为保留地址段，在未来也不会被重定义。&lt;/p&gt;
&lt;p&gt;M-mode 的 0x7A0~0x7BF 地址段留作 debug 用，其中 0x7A0~0x7AF 可以在 M-mode 下访问，剩余的 0x7B0~0x7BF 只能在 debug mode 下访问。如果在 M-mode 下访问后面这段地址，implementation 应该触发 illegal instruction exception。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;高效虚拟化要求在虚拟环境中尽可能多地以 native 方式执行指令，而特权访问则 trap 到 virtual machine monitor 中。有些 CSR 在低特权等级下为 RO 属性，但是在高特权等级下为 RW 属性，这种 CSR 会被 shadowed 到另外一个新的 CSR 地址。这样就可以在正常 tarp 非法访问的同时， 避免错误 trap 本来运行的低特权访问。目前 counter 类 CSR 是唯一被 shadow 的 CSR。
比如 hpmcounter3~hpmcounter31 的属性分别为 URO 和 MRW，且在 U-level 和 M-level 分别有映射地址。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="csr-listing"&gt;CSR Listing&lt;/h3&gt;
&lt;p&gt;所有的 CSR 可以分类两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user-level standard CSR：包括 timer、counter、FP CSR 和 N 子集添加的 CSR。&lt;/li&gt;
&lt;li&gt;Privileged CSR：剩余的 CSR 都必须在某个更高的特权等级下才能访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是：并不是所有的 implementation 都要实现所有的 CSR。&lt;/p&gt;
&lt;h3 id="field-specifications"&gt;Field Specifications&lt;/h3&gt;
&lt;h4 id="wpri"&gt;WPRI&lt;/h4&gt;
&lt;p&gt;Reserved Writes Preserve Values, Reads Ignore Values&lt;/p&gt;
&lt;p&gt;某些 R/W field 留作未来使用。对于这些 field，软件应该忽略读到的值，向这个 CSR 的其他 field 写入值时，硬件应该保持 reserved field 的原值。为了前向兼容，未实现这些 reserved field 的 implementation 应该直接 tie0。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;为了简化软件模型，reserved field 在未来进行向后兼容的重新定义时，必须处理好使用一组非原子性 read/modify/write 指令序列来更新其他字段的场景。否则，原始的 CSR 定义必须声明该 field 只能原子性地更新，比如通过两条 set/clear 指令组成的序列。如果修改过程中的中间值不合法，则可能会有潜在的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="wlrl"&gt;WLRL&lt;/h4&gt;
&lt;p&gt;Write/Read Only Legal Values&lt;/p&gt;
&lt;p&gt;某些 R/W filed 只能配置一些 legal value，其他值作为保留不能使用。软件只能向这些 filed 写入 legal value，而且除非该 field 本身就存储着 legal value（比如上次写入 / 复位等），否则软件也读不到 legal value。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;implementation 只需要有足够的 bit 能表示所有的 legal value 即可，但是软件读取时必须返回完整的所有 bit。比如某个字段的 legal value 为 0~8，共需要 4-bit 表示，表示范围内的 9 ~ 15 为 illegal value。软件读取时，即使当前值为 7，只需要 3bit，硬件仍然要返回完整的 4bit。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当写入 illegal value 时，implementation 可以（但不是强制）触发一个 illegal instruction exception。当写入 illegal value 后，软件读取的值由硬件决定，可以是任意一个值，但是必须满足确定性原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确定性原理：旧值和写入的新非法值确定，返回值也必须是确定性的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="warl"&gt;WARL&lt;/h4&gt;
&lt;p&gt;Write Any Values, Reads Legal Values&lt;/p&gt;
&lt;p&gt;某些 R/W field 只支持一组 legal value，但是允许写入任何值。当写入 illegal value 后，软件读回的一定是 legal value。假设写该 field 没有其他副作用，则可以向其中逐个写入配置值后再重新读出，通过这种方法就能知道支持的 legal value 集合。&lt;/p&gt;
&lt;p&gt;当写入 illegal value 时，implementation 不会触发 exception。写入 illegal value 后，软件会读到一个任意 legal value。同理，该 legal value 必须满足确定性原理。&lt;/p&gt;
&lt;h3 id="csr-width-modulation"&gt;CSR Width Modulation&lt;/h3&gt;
&lt;p&gt;当 CSR 的位宽发生变化时（比如修改 MXLEN 或 UXLEN），CSR 的新位宽和 writable field 的值由以下算法决定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;previous-width CSR 的 value 被复制到一个相同位宽的临时寄存器中。&lt;/li&gt;
&lt;li&gt;对于 previous-width CSR 的 RO bit，临时寄存器的对应 bit 设置为 0。&lt;/li&gt;
&lt;li&gt;将临时寄存器的位宽修改为 new width。&lt;ul&gt;
&lt;li&gt;如果 new-width &lt;span class="math"&gt;\(W\)&lt;/span&gt; &amp;lt; previous-width，则只保留临时寄存器的低 W bit。&lt;/li&gt;
&lt;li&gt;如果 new-width &lt;span class="math"&gt;\(W\)&lt;/span&gt; &amp;gt; previous-width，则将临时寄存器 0 扩展到 W bit。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;new-width CSR 的每个 writable field 等于临时寄存器的对应 bit 的 value。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改 CSR 位宽不属于 read/write CSR，所以不会产生任何 side effect。&lt;/p&gt;
&lt;h2 id="machine-level-isa"&gt;Machine-Level ISA&lt;/h2&gt;
&lt;p&gt;TODO: here&lt;/p&gt;
&lt;p&gt;M-mode 的特权等级最高，而且是唯一强制要求实现模式，它用于访问底层硬件，是上电复位后进入的第一个模式。M-mode 包含一个可扩展的核心 ISA，具体实现可以根据支持的特权等级和自身的硬件特性来扩展它。&lt;/p&gt;
&lt;h3 id="machine-level-csrs"&gt;Machine-Level CSRs&lt;/h3&gt;
&lt;p&gt;略。&lt;/p&gt;
&lt;h3 id="machine-mode-privileged-instructions"&gt;Machine-Mode Privileged Instructions&lt;/h3&gt;
&lt;p&gt;一共 6 条，可以分成 3 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统调用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ECALL&lt;/code&gt;, &lt;code&gt;EBREAK&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Trap 返回&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MRET&lt;/code&gt;, &lt;code&gt;SRET&lt;/code&gt;, &lt;code&gt;URET&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WFI&lt;/td&gt;
&lt;td&gt;&lt;code&gt;WFI&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="reset"&gt;Reset&lt;/h3&gt;
&lt;p&gt;一旦复位，要满足下面要求，除此之外的状态不做要求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hart 必须处于 M-mode，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus&lt;/code&gt; 的 &lt;code&gt;MIE&lt;/code&gt; 和 &lt;code&gt;MPRV&lt;/code&gt; 字段要复位成 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;misa&lt;/code&gt; 字段要复位到支持的最大子集和最宽的 &lt;code&gt;MXLEN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pc&lt;/code&gt; 要复位到实现预先定义好的 reset vector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mcause&lt;/code&gt; 要保存导致复位的原因&lt;/li&gt;
&lt;li&gt;PMP 的 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;L&lt;/code&gt; 字段设置为 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="nmi"&gt;NMI&lt;/h3&gt;
&lt;p&gt;Non-Maskable Interrupts 的作用是发生硬件错误时，不管中断使能是否打开，直接跳转到预先定义好的 NMI vector，在 M-mode 下运行。&lt;code&gt;mepc&lt;/code&gt; 保存发生 NMI 的下一条指令；&lt;code&gt;mcause&lt;/code&gt; 保存导致 NMI 的原因，具体值由实现自定义，但是 0 表示 unknown，所以如果实现不关心 NMI 的原因，那么直接保存 0 即可。&lt;/p&gt;
&lt;h3 id="pma"&gt;PMA&lt;/h3&gt;
&lt;p&gt;一个完整系统中的地址空间包含了各种各样的 address region，有些是 memory，有些是 memory-mapped 的 CSR，还有些是空洞 hole；有些 memory region 不支持读 / 写 / 执行，有些不支持 subword/sublock 粒度的访问；有些不支持原子性操作；有些不支持 cache coherence 或拥有不同的 memory model。同理，memory mapped 的 CSR 在访问位宽、原子操作、read/write 访问是否有副作用等方面也各不相同。在 RISC-V 系统中，物理地址 region 的这些属性有一个专门的术语 &lt;code&gt;Physical Memory Attributes (PMAs)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PMA 是硬件的固有属性，在系统运行时几乎不会变化。&lt;/strong&gt; 和 PMP 不同，PMA 不会随着运行程序的上下文发生变化。有些 memory region 的 PMA 属性在 chip design 时就已经确定了，比如片上 ROM。另外一些在 board design 时确定，比如片外总线上挂载的是什么芯片。片外总线上可以挂载一些支持冷 / 热拔插的设备。某些设备可以在运行时支持重配置 PMA 以支持不同的用途，比如一个片上 RAM 在某个应用在中被缓存到私有 cache 中，也可以在另外一个应用中被配置为共享的 uncacheable 空间。&lt;/p&gt;
&lt;p&gt;大部分系统都要求硬件在一旦确定物理地址之后，在后续 pipeline stage 中做一些必要的 PMA 检查，因为有些特定操作并不是所有 region 都支持，或者有些操作需要获取 PMA 当前的配置值。虽然某些架构是在 virtual page 中声明 PMA，然后通过 TLB 来告诉 pipeline 这些信息，但是这个方法会将一些 platform 信息注入到 virtual layer，而且一旦某个 page table 中某个 memory region 没有被正确初始化，就会导致系统错误。另外，可用的 page size 对于设置 PMA 来说可能并不是最优选择，这会导致地址空间碎片以及浪费宝贵的 TLB entry。&lt;/p&gt;
&lt;p&gt;RISC-V 则把 PMA 分离出来，并且用一个独立的硬件 PMA checker 进行检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分情况下，每个 region 的 PMA 是在系统设计时就已经确定了的，所以可以直接在 PMA checker 中以硬连线的方式实现。&lt;/li&gt;
&lt;li&gt;对于 runtime 可配置的 PMA，则可以通过一些 memory mapped CSR 对每个 region 以合适的粒度进行配置（比如片上 SRAM 可以灵活地划分为 cacheable 和 uncacheable 区域）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;包括虚实地址转化引起的隐式访问在内，任何访问物理地址的行为都会触发 PMA 检查。为了帮助系统 debug，规范强烈建议：&lt;strong&gt;尽可能精确地捕获导致 PMA 检查失败的物理地址访问。&lt;/strong&gt; 精确的 PMA 违例包括 instruction/load/store access-fault exception 以及虚拟内存的 page fault。实际中并不能一直捕获到精确异常，比如探测某些以访问失败作为发现机制的一部分的 legacy bus 时，从 slave device 返回的 error response 是非精确异常。&lt;/p&gt;
&lt;p&gt;为了正确地访问设备或者是控制其他硬件单元（比如 DMA）去访问 memory，PMA 对软件来说必须是可读的。因为 PMA 和硬件平台的设计紧密相关，很多 PMA 来自平台规格，所以软件可以通过访问平台信息的方式来获取 PMA 信息。某些 device，特别是 legacy bus，不支持通过探索尝试的方式获取 PMA，如果对其发起一个不支持的访问，则会返回 error response 或 timeout。通常，平台相关的 machine code 会提取这些 PMA 信息并通过某种标准表示方式将其转发给上层特权等级更低的软件。 &lt;/p&gt;
&lt;p&gt;对于 platform 支持的可配置 PMA，应该提供一个接口，通过该接口向运行在 machine mode 的 driver 发送配置请求，由 driver 进行正确的配置。比如，切换某些 memory region 的 cacheability 可能会涉及到一些 platform 相关的操作，比如只能在 machine mode 下进行的 cache flush。&lt;/p&gt;
&lt;p&gt;常见的 PMA 大概包含下面几方面。&lt;/p&gt;
&lt;h4 id="main-memory-io-empty"&gt;Main memory / IO / empty&lt;/h4&gt;
&lt;p&gt;对于一个 memory region 来说，最重要的属性就是它映射的是常规 main memory 还是 I/O 设备或空洞。main memory 拥有一些后文描述的属性，而 I/O 设备的属性会更广泛一些。非 main memory 的 memory，比如 device scratchpad RAM，被归类为 I/O 段。空地址段会被归类不支持任何访问的 I/O 空间。&lt;/p&gt;
&lt;h4 id="supported-access-type"&gt;Supported Access Type&lt;/h4&gt;
&lt;p&gt;描述 region 支持从 8bit Byte 到 long multi-word burst 之间的哪些访问位宽，以及每种访问位宽是否支持非对齐访问。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;虽然运行在 RISC-V hart 上的软件不能直接生成对 memory 的 burst 访问，但是软件可以对 DMA 进行编程来访问 I/O 设备，所以需要知道支持哪些位宽访问。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;main memory 永远都支持所有 device 要求的所有 width 下的 read/write 操作，同时可以声明是否支持 instruction fetch。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;某些平台可能会强制要求所有 main memory 都支持 instruction fetch，而某些平台可能会禁止在某些 main memory region 进行 instruction fetch。&lt;/li&gt;
&lt;li&gt;在某些 case 中，processor/device 可能支持一些其他访问位宽，但是必须兼容 main memory 支持的访问类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;I/O region 可以指定每种位宽支持的 R/W/X 组合。&lt;/p&gt;
&lt;p&gt;对于基于 page 的 virtual memory，I/O 和 memory region 可以指定支持哪些 hardware page table read/write 组合。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;类 unix 系统通常要求所有 cacheable main memory 都支持 page table walk。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="atomicity"&gt;Atomicity&lt;/h4&gt;
&lt;p&gt;Atomicity PMA 描述 region 支持哪些原子指令，原子指令可以分为 LR/SC 和 AMO 两类。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;某些平台可能强制要求 cacheable main memory 必须支持系统中所有 processor 的所有原子指令。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="amo"&gt;AMO&lt;/h5&gt;
&lt;p&gt;AMO 的支持可以分为&lt;code&gt;AMONone&lt;/code&gt;，&lt;code&gt;AMOSwap&lt;/code&gt;，&lt;code&gt;AMOLogical&lt;/code&gt;，&lt;code&gt;AMOArithmetic&lt;/code&gt; 共 4 个等级，main memory 和 I/O 可能支持部分子集或完全不支持 AMO 操作。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;spec 推荐 I/O region 尽可能支持 AMOLogical。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="reservability-pma"&gt;Reservability PMA&lt;/h5&gt;
&lt;p&gt;对 LR/SC 访问的支持可以分为 &lt;code&gt;RsrvNone&lt;/code&gt;，&lt;code&gt;RsrvNonEventual&lt;/code&gt;，&lt;code&gt;RsrvEventual&lt;/code&gt; 共 3 个等级。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spec 推荐 main memory region 尽可能支持 &lt;code&gt;RsrvEventual&lt;/code&gt;。大部分 I/O region 不支持 LR/SC 访问，因为这些访问最方便建构在 cache-coherence 方案之上，但是有些可能支持 &lt;code&gt;RsrvEventual&lt;/code&gt; 或 &lt;code&gt;RsrvNonEventual&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;当 LR/SC 访问 &lt;code&gt;RsrvNonEventual&lt;/code&gt; 的 memory region 时，当软件检测到无法访问时，软件应该提供备选的 fall-back 机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h5 id="alignment"&gt;Alignment&lt;/h5&gt;
&lt;p&gt;支持 aligned LR/SC 和 aligned AMO 访问的 memory region 可能还支持 misaligned LR/SC 和 misaligned AMO 以某些位宽访问某些地址。如果 misaligned LR/SC 或 AMO 以某种位宽访问某个地址时触发了 address-misaligned exception，那么所有以该位宽访问该地址的 load，store，LR/SC 和 AMO 访问都应该触发 address-misaligned exception。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;A 子集不支持非对齐的 LR/SC 和 AMO 访问。非对齐 AMO 访问由 &lt;code&gt;Zam&lt;/code&gt; 子集提供，非对齐的 LR/SC 访问目前还没有标准化，所以非对齐的 LR/SC 访问必须触发 exception。&lt;/p&gt;
&lt;p&gt;当非对齐的 AMO 触发 address-misaligned exception 时，强制要求非对齐的 load，store 也触发 address-misaligned exception，这样就可以模拟 M-mode trap handler 中的 misaligned AMO 访问。该 handler 使用 global mutex，在 critical section 模拟该访问，以这样的方式保证原子性。当非对齐 load/store 的 handler 使用同一个 mutex 时，以该位宽访问该地址的所有访问都是 mutually atomic。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于某些非对齐访问，implementation 可以通过触发 access-fault exception 的方式表明不应该在 trap handler 中模拟该行为。当以某种位宽访问某个地址时，如果所有 misaligned AMO 和 LR/SC 都触发了 access-fault exception，那么以该位宽访问该地址的所有常规非对齐 load/store 则不要求原子性执行。&lt;/p&gt;
&lt;h4 id="memory-ording-pmas"&gt;Memory Ording PMAs&lt;/h4&gt;
&lt;p&gt;为了实现 FENCE 指令和原子指令 order bit 提供的 order 功能，地址空间被分为 main memory 和 I/O 两类。&lt;/p&gt;
&lt;p&gt;一个 hart 对 main memory region 的访问不仅能被其他 hart 观测到，也会被其他能对 main memory 发起访问的 device（比如 DMA）观测到。coherent main memory 的 memory model 要么是 RVWMO 要么是 RVTSO，incoherent main memory region 的 memory model 由 implementation 决定。&lt;/p&gt;
&lt;p&gt;一个 hart 对 I/O region 的访问不仅能被其他 hart 和 bus master device 观测到，也会被目标 I/O slave
device 观测到。I/O region 的访问要么是 relax order 要么是 strong order：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 relax order 访问 I/O region，其他 hart 和 master device 观测到的行为和以 RVWMO 访问 main memory region 类似。&lt;/li&gt;
&lt;li&gt;以 strong order 访问 I/O region，其他 hart 和 master device 观测到的为 program order。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="coherenece-and-cacheability"&gt;Coherenece and Cacheability&lt;/h4&gt;
&lt;p&gt;coherenece 是针对单个物理地址而言的属性，表示某个 agent 对该地址的 write 对系统中的其他 agent 都可见。注意，不要把 coherence 和 memory consistency model 混淆，内存一致性模型规定给定某个地址的历史读写信息后，读该地址的返回值应该是什么。RISC-V 中不鼓励使用 hardware incoherent region，因为它会导致软件复杂化，性能和功耗恶化。&lt;/p&gt;
&lt;p&gt;一个地址段的 cacheability 属性不会改变软件对该地址段的 view，这些 view 不包括其他 PMA 中规定的属性（比如 main memory 和 I/O 空间的划分、访问顺序、支持的访问类型、支持的原子操作、coherence 等）。因此，cacheability 在指令集中被视为 M-mode 软件管理的 platform level setting。&lt;/p&gt;
&lt;p&gt;当一个 platform 支持对某个 memory region 配置 cacheability 时，一个和 platform 相关的 M-mode routine 负责修改配置，并在必要时 flush cache。因此，只有在 cacheability 的变换的这段时间内系统为 incoherent，这种中间的变化状态不应该对 S/U mode 可见。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;指令集将 cache 分为了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master private：每个 master 私有&lt;/li&gt;
&lt;li&gt;master shared：位于 master 和 slave 之间，可能有多级&lt;/li&gt;
&lt;li&gt;slave private：由 slave 私有，对 coherence 无影响&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于不支持 cache 的 share memory region 来说，coherence 很直观，PMA 只需要表明该 region 不支持被 private 或 shared cache。&lt;/p&gt;
&lt;p&gt;对于 read-only 的 memory region 来说，coherence 也很直观，无需 coherence 机制就可以被多个 agent 安全地多次 cache。PMA 只需要表明该 region 只支持 read，不支持 write 即可。&lt;/p&gt;
&lt;p&gt;有些 read-write memory region 可能只支持一个 agent 访问，这种场景下无需 coherence 机制就可以被 master private cache。PMA 会表明该 region 可以被 cache，而且可以被 cache 在一个 shared cache 中，因为其他 agent 不会访问该 region。&lt;/p&gt;
&lt;p&gt;如果一个 agent 可以 cache 一个 read-write region，且该 region 也可以被其他 agent 访问（无论是否为 cache 或 no cache），都需要一套 cache-coherence 机制。如果没有 hardware cache coherence，则必须提供 software cohere scheme，但是通常软件实现都比较困难且存在严重的性能问题。hardware coherence scheme 通常需要更复杂的硬件，也会影响到性能，但是对软件是不可见的。&lt;/p&gt;
&lt;p&gt;对于每个支持 hardware coherence 的 region 来说，PMA 应该表明该 region 支持 coherence 且当系统中 coherence controller 有多个时，PMA 要指明该 region 使用哪个 controller。对于某些系统来说，controller 是下一级 cache，而该级 cache 的 coherence 又依赖于下下级 cache。&lt;/p&gt;
&lt;p&gt;platform 中的大部分 memory region 对软件来说都是 coherent 的，因为这些 region 的 PMA 属性都是固定的，要么 uncached，要么 read-only，要么 hardware cache-coherent，要么只能由一个 agent 访问。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果 PMA 表明该 region 不支持 cache，则对该 memory region 的访问必须由 memory 自身来满足，不能依靠任何 cache。&lt;/p&gt;
&lt;h4 id="idempotency"&gt;Idempotency&lt;/h4&gt;
&lt;p&gt;幂等性 idempotency：执行多次和一次的效果一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;main memory region 是 idempotent。&lt;/li&gt;
&lt;li&gt;I/O region 的 read/write idempotent 是分开的：read 具有幂等性，而 write 不具有。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果访问不具有幂等性，也就是说会产生潜在的副作用，那么必须避免 speculative 或 redundant 访问（因为他们都可能会导致多次访问）。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;虽然 hardware 会对 non-idempotent region 避免 speculative 或 redundant 访问，但是还是有必要确保软件或编译优化不会对 non-idempotent region 生成投机访问。&lt;/p&gt;
&lt;p&gt;non-idempotent region 可能不支持非对齐访问。非对齐访问应该触发 access-fault exception 而不是 address-misaligned exception，以此来表明软件不应该通过拆分成多次小颗粒的访问来模拟非对齐访问，因为这种行为会引起预期之外的副作用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于 non-idempotent region 来说，不允许 implementat 提前或投机地进行 implicit
read/write，除非是以下特例。&lt;/p&gt;
&lt;p&gt;当进行非投机的 implicit read 时，允许 implementation 额外从包含本次 implicit read 地址的 NAPOT region 中读取任意长度的数据量。而且如果是 instruction fetcch，允许 implementat 额外从下一个 NAPOT region 中读取任意 byte 数据量。这些额外的读数据可以作为后续的提前或投机访问的结果。这些 NAPOT region 的大小由 implementation 决定，但是必须不超过支持的最小 page size。&lt;/p&gt;
&lt;h3 id="pmp"&gt;PMP&lt;/h3&gt;
&lt;p&gt;为了安全运行以及故障隔离，需要限制 hart 上运行的软件可以访问的物理地址，这个需求可以通过一个可选的 &lt;code&gt;Physical Memory Protection (PMP)&lt;/code&gt; 单元实现，它可以为每个 hart 提供每个 memory region 的访问属性控制寄存器。PMP 和 PMA 是并列关系，同步进行检查。&lt;/p&gt;
&lt;p&gt;虽然 PMP 的访问粒度是和平台相关的，但是标准的 PMP 编码支持的最小 region 大小为 4 Byte。某些 region 的特权属性可以直接用 hardwire 实现，比如某些 region 只有 M-mode 下可访问。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;不同平台对 PMP 的需求不同，有些平台还会额外提供其他的 PMP 指令来增强 / 代替本小节描述的方案。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;当 core 运行在 S/U-mode 时，PMP checker 会检查所有的访问，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S/U-mode 下的取指&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus.MPRV = 0&lt;/code&gt; 时 S/U-mode 下的数据访存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mstatus.MPRV = 1&lt;/code&gt; 且 &lt;code&gt;mstatus.MPP&lt;/code&gt; 包含 S/U 时任何 mode 下的数据访存&lt;/li&gt;
&lt;li&gt;S-mode 下的虚拟地址翻译时对 page table 的访问&lt;/li&gt;
&lt;li&gt;( 可选地 ) M-mode 下且 locked region 的访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，PMP 设置 S/U-mode 下的访问权限（默认无权限），在 M-mode 默认有所有地址的权限。&lt;/p&gt;
&lt;p&gt;违反 PMP 的访问会被 core 捕获，触发精确异常。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;PMP 主要检查的是 S-mode 和 U-mode，因为用户程序运行在这两个级别中。而 M-mode 下 core 必须拥有全部的访问权限，所以 M-mode 不是 PMP 的主要应用场景。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="pmp-csrs"&gt;PMP CSRs&lt;/h4&gt;
&lt;p&gt;spec 规定最多支持 16 个 PMP region，每个 region 由一个 8-bit 配置寄存器 &lt;code&gt;pmpxcfg&lt;/code&gt; + 一个 MXLEN-bit 的地址寄存器 &lt;code&gt;pmpaddrx&lt;/code&gt; 共同描述。所有 PMP CSR 均为 WARL，且只能在 M-mode 下访问。&lt;/p&gt;
&lt;h5 id="pmpcfg"&gt;pmpcfg&lt;/h5&gt;
&lt;p&gt;为了最小化上下文切换的代价，&lt;code&gt;pmpxcfg&lt;/code&gt; 是按照小端模式密集存储在一起的。所以可以算出来&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32 需要 4 个 CSR (&lt;code&gt;pmpcfg0&lt;/code&gt; ~ &lt;code&gt;pmpcfg3&lt;/code&gt;) 来存储 &lt;code&gt;pmp0cfg&lt;/code&gt; ~ &lt;code&gt;pmp15cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RV64 需要 2 个偶数下标 CSR &lt;code&gt;pmpcfg0&lt;/code&gt;, &lt;code&gt;pmpcfg2&lt;/code&gt; 来存储 &lt;code&gt;pmp0cfg&lt;/code&gt; ~ &lt;code&gt;pmp15cfg&lt;/code&gt;，奇数下标 &lt;code&gt;pmpcfg1&lt;/code&gt;, &lt;code&gt;pmpcfg3&lt;/code&gt; 是非法的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;RV64 不使用奇数下标 pmpcfg 的原因：减小支持多种 MXLEN 的代价。比如，无论是 RV32 还是 RV64，PMP entry 8~11 都在 pmpcfg2 中。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;每个 8bit 的 &lt;code&gt;pmpxcfg&lt;/code&gt; 规定了对应 region 的 L/A/X/W/R 五个属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 W/R/X 被置 1 时，表示该 region 允许 write/read/instruction execution。当无权限时，触发对应的 store/load/instruction access fault。&lt;/li&gt;
&lt;li&gt;A 字段表示 &lt;code&gt;pmpaddrx&lt;/code&gt; 的地址匹配模式，支持 OFF/TOR/NA4/NAPOT 共 4 种模式。&lt;/li&gt;
&lt;li&gt;L 字段表示该 region 被 lock，无法向 &lt;code&gt;pmpxcfg&lt;/code&gt; 和 &lt;code&gt;pmpaddrx&lt;/code&gt; 写入新值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 MXLEN 发生变化时，&lt;code&gt;pmpxcfg&lt;/code&gt; 的值保留不变，但是出现在对应的 &lt;code&gt;pmpcfgy&lt;/code&gt; 的对应 bit 中。比如当 MXLEN 从 64 变化到 32 时，&lt;code&gt;pmp4cfg&lt;/code&gt; 从 &lt;code&gt;pmpcfg0[39:32]&lt;/code&gt; 移动到 &lt;code&gt;pmpcfg1[7:0]&lt;/code&gt;。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;implementation 可以实现 &lt;code&gt;pmpxcfg&lt;/code&gt; 寄存器，然后根据 MXLEN 用多个 &lt;code&gt;pmpxcfg&lt;/code&gt; 组合得到 &lt;code&gt;pmpcfgy&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="pmpaddr"&gt;pmpaddr&lt;/h5&gt;
&lt;p&gt;PMP 地址寄存器为 CSR &lt;code&gt;pmpaddr0&lt;/code&gt; ~ &lt;code&gt;pmpaddr63&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32：每个 pmpaddr 保存 addr[33:2]，即 34bit 地址&lt;/li&gt;
&lt;li&gt;RV64：每个 pmpaddr 保存 addr[55:2]，即 56bit 地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 PMP region 颗粒度可能大于 4 Byte，所以并不是 pmpaddr 的每个 bit 都会被实现，所以 pmpaddr 为 WARL。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;因为 Sv32 page-based 虚拟地址方案支持 34bit 地址空间，所以 RV32 PMP 要支持比 XLEN 更大的地址区间。同理，Sv39 和 Sv48 page-based 虚拟地址方案支持 56bit 地址空间，所以 RV64 PMP 需要覆盖相同地址范围。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虽然 PMP region 的最小粒度为 4 Byte，但是 platform 可以定义更粗的颗粒度。一般来说，PMP region 的颗粒度必须保持一致，为 &lt;span class="math"&gt;\(2^{G+2}\)&lt;/span&gt; Byte。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;span class="math"&gt;\(G \geq 1\)&lt;/span&gt; 时，NA4 模式不可用&lt;/li&gt;
&lt;li&gt;当 &lt;span class="math"&gt;\(G \geq 2\)&lt;/span&gt; 且 pmpcfg.A[1] = 1 时，为 NAPOT 模式，读出的 pmpaddr[G-2:0] 为全 1。&lt;/li&gt;
&lt;li&gt;当 &lt;span class="math"&gt;\(G \geq 1\)&lt;/span&gt; 且 pmpcfg.A[1] = 0 时，为 OFF/TOR 模式，读出的 pmpaddr[G-1:0] 为全 0。pmpaddr[G-1:0] 并不会影响到 TOR 下的地址匹配逻辑。（从这条规则可以推理出下面软件检测 PMP region 粒度的方法）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;颗粒度 != 容量，所有 region 的颗粒度必须相同，但是大小可以不同。&lt;/li&gt;
&lt;li&gt;最小颗粒度决定了 G，也决定了 pmpaddr[G-2:0] 的值，所以硬件可以 hardwire 实现，不需要使用寄存器。&lt;/li&gt;
&lt;li&gt;虽然修改 pmpxcfg.A 会影响到 pmpaddrx 的读出结果，但实际上并不会改变底层 pmpaddrx 存储的 bit。特别是，当 pmpxcfg.A 从 NAPOT 改到 TOR，又从 TOR 该回 NAPOT，pmpaddrx[G-1] 都会保持原值不变。&lt;/li&gt;
&lt;li&gt;从分类讨论描述可以推断出来，NAPOT 模式下 PMP region 地址和容量对齐；TOR 模式下地址和容量无对齐约束。比如最小粒度为 4KB，region size = 32 KB，则 NAPOT 模式下地址必须为 32 KB 的整数倍，如 32 KB，64 KB，96 KB 等；而 TOR 模式下地址只需要是 4KB 的整数倍即可，如 4KB，8KB，12KB 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;软件可以通过以下方式得到 PMP region 的粒度：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向 pmp0cfg 写入全 0，将地址匹配设置为 OFF&lt;/li&gt;
&lt;li&gt;向 pmpaddr0 写入全 1&lt;/li&gt;
&lt;li&gt;读回 pmpaddr0，如果 LSB 1 为 bit[G]，则粒度为 &lt;span class="math"&gt;\(2^{G+2}\)&lt;/span&gt; Byte&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;这个方法的原理：根据前面的规则，OFF 模式下读到的 pmpaddr[G-1:0] 为全 0，pmpaddr[MXLEN-1 : G] 为全 1。所以 LSB 1 的下标就是 G，从而可以根据公式算出粒度。&lt;/p&gt;
&lt;/div&gt;
&lt;h5 id="address-matching"&gt;address matching&lt;/h5&gt;
&lt;p&gt;pmpxcfg.A 决定了如何翻译和使用 pmpaddrx 的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAPOT 模式利用 region 容量和起始地址对齐的约束，只靠 pmpadddr 一个寄存器就可以同时表示 region 容量和 region 起始地址。因为对于 2 的幂次对齐的地址，其实低位是冗余的，可以用这些低位来表示容量。&lt;/li&gt;
&lt;li&gt;TOR 模式下，第 i 个 entry 的地址区间为 [&lt;span class="math"&gt;\(pmpaddr_{i-1}\)&lt;/span&gt;, &lt;span class="math"&gt;\(pmpaddr_i\)&lt;/span&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="locking"&gt;locking&lt;/h5&gt;
&lt;p&gt;pmpxcfg.L = 1 表示该 entry 被 lock，当 pmpxcfg.L = 1 时，会忽略对 pmpxcfg 和 pmpaddrx 的写操作。如果 pmpxcfg.L = 1 且 pmpxcfg.A = TOR，则对 &lt;span class="math"&gt;\(pmpaddr_{x-1}\)&lt;/span&gt; 的写操作也会被忽略掉。&lt;/p&gt;
&lt;p&gt;L 和 A 无关，即使 pmpxcfg.A = OFF，置位 L 也会 lock 该 entry。一旦 entry 被 lock，就只能通过复位来释放。&lt;/p&gt;
&lt;p&gt;L 字段除了 lock 功能外，还会表示是否在 M-mode 下进行 R/W/X 权限检查：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 L = 1，强制 M/S/U mode 都会检查权限&lt;/li&gt;
&lt;li&gt;当 L = 0，不检查 M-mode 下访问的权限（所有访问都 success），只检查 S/U mode 下的 R/W/X 权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="priority-and-matching"&gt;priority and matching&lt;/h5&gt;
&lt;p&gt;地址匹配逻辑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAuoAAAFlCAMAAACKtz0EAAABJlBMVEUAAAAICAcLCwsREQ8WFhYaGhcYGBgjIx4iIiIoKCMvLykzMywwMDA4ODE8PDxAQDdHRz5GRkZISD5MTEJLS0tSUkdVVUpSUlJbW09cXFBfX19jY1ZnZ1lhYWFra11vb2BpaWlvcGNwcGF2dnZ9fWx8fHx/gG+Cg3KFhYWIiXeLjHuMjIOJiYmPkH2QkX6TlICVlZWXmISam4aen4qampqio42kpKSnqJKrrJWur5iurqOurq6vsJmwsZm0tam0tLS6u6K8vLy/wKbAwafGx6zGxsbHyK3Iya7Oz7PIyMjP0LTQ0bXW17rX19fX2Lva277c3cDZ2sva2tLY2Njf4MLi48Xm58jl5d7k5OTu78/v7+/v8ND299bx8fH3+Nf+/93+/+f///9cJ5UTAAAAKnRFWHRjb3B5bGVmdABHZW5lcmF0ZWQgYnkgaHR0cHM6Ly9wbGFudHVtbC5jb212zsofAAABaWlUWHRwbGFudHVtbAABAAAAeJyFUU1PwkAQvc+vmJNpDwiiECwxIYKaII0ERL0uZQob29lmPyD8e6dU0ZuXzXy993bmjZxX1oeygFMASal8tsN5Okdib49DYOMJrd7ufIKFOZDzyKFck20G8ATQvEXFR1wfZdjkEqPKMnIO3EHXhFHDa8mFwseQKUcY5aEoGnwMOscomuHdHXZivMCosvs6SeMY/Y4YoyO5GBIXTrRDoKJmYCO1bEfZJy7a7+0PqfNG59/8lWyk1VkiyZUuht89Nn+Vz2r/ijUcjYq8zXpyPFPBSPL6kjAvFPtVOsM9WacN49Vlt9PtXd5GqSRLqrAzwKte0usn1wNcvY6xbscQPc1n6EywGeFGO2/1OnjBxzBVe4WLwF6XlOBLRTydPP8U8IH32houxRCYvqW/A/2b1r32omjlJ/iWwoRyJQYIIjMbMS0R9cfWAGaKt0FthZsYxibUzkpvCV/cQK+wm1w07QAAKcxJREFUeNrtnflz29a59x9zlaiNtmSJsqnFjEotthw7jiov8bgeJ82kzW3SxL29efNm7vQvy9wfkpmkaRLfpvGkjes4qmwrrJdK3iSrjGTRkWTLFiVLlLj6YiUBEiBBAsQBiOczEgEcHBw8eM6XhwfbeXb8ARDECthIG4Ag+oBSRywCSh2xCCh1xCKg1BGLgFJHLAJKHbEIKHXEIqDUEYvgIG2AcUmFHz5N2Zxt/l7SliBasAMfDJBh5l8pbq5xxEfaGEQ99sOkLTAo309n+NnEHHSQNgdRDXZgpLm4JFy6ZdtP2iBELXhaKsnUknh5cqmychDjgFKXInUvP+U6aZMQtaDUpbibyk9Zw2bd7KDUpVhQlISYCpS6FM8Kk56StglRCUpdglSmMG2LtFGISlDqiEVAqUvgkPBKPWmjEJWg1KVoKkzaRdomRCUodSm6FCUhpgKlLsVgwfMSLfjEl9lBqUvhGMhPeYm0SYhaUOqSDOc14gexUTc9KHVpTu8VLh3ABxvNDz6vLkOP+zF/I6nxxAukrUHUg8+ryxEM4At3NQVKXRZHMAgfvU/aCkQrsK+OWASUOmIRUOqIRUCpIxYBpY5YBJQ6YhFQ6ohFQKnLEZeYQ0wMSl2O2Qg3E5klbQqiBSh1OfrGbzDTyFgfaVMQLUCpy+Fuv3OFmkQutbhJm4JoAT4DI8vgT2Fa6XCQtCGIJqDUZfHVQRjGwOEnbQiiCdiBkSdYD5CBAGkzEG1AqcsTXKN/87D/UiOg1OVx+5oAduJJaY2AUi/C4BY26rUDSr0IPsCT0toBpV6MIJ6U1g4Wuti4NbtR7iZpiF8pez/NARzK1IhYRuozj1p6PGVvtae7/D1F7232YrfHeFgkRO/STLBNx92FHx21TBtiGqwx5NFU7KXyW3QV7OyYaHeSPmhEjCUan6kmvTsUztGJ45KuDT0n7QwrsHxGomWzgtRnGvTvOttHrr4iueJl0t6wAuM//LxQ6xa42Bh/UsG5pWqc7RH1hSCV4TrxQ6wg0QJSnzxEZLeBOdIHbmHsElq3gNSB0AliA8Z/JIeE1mtf6uFOQjvuCpM+dCtTqPXal/oTUgEvvOukD93SFGi99qWunGhav319fU9Bppgig/48o3SnysoryJrdgSKjS1gna0P620/PlV98EfK1boWLjUWZeiF7Wer86dwPwIUNqO8csl/Y+BXV0x97eqKNSyheQgnWl9b42a2kgvxfDxxQkGs7pfRYlZVXkDW7g11NSjeXt07Whsno6xo/O2Q/MS685mj5Vv2OdDcj2nGk69Z1iMZuUQ1RZD3FJygvQcz6TCgUWmx/+Ygodfkx9ZFOUP90+0P/Lz9kWr3o/DJA4vlWLMHkS6RTEXrt1nMuWyKdWKCmTx4yd6QS85tceczW1Mr5hDiB2Zwtj1mbYNZzLayosM2FJ5DbdXSBaRjZvcNLvqwlkH64BtlGk90oux9h4Zx1fBpfMHecOS8knjQ57VKlidKyFnETobuykyzidt1arfrlwL2t/p7Qqu8wwHQk0XLIM5WavL/Pn76zCJ3DkBjb6B3ksrb4Ye0nAP/cYZjuXMgl0Ewt2vv9dGn3qfxsCdT8Vl+c2jgcH8zbKdOWN3f8jBaS6F7p8t8dzzOvts1PvAeXw2+2Pvzu/dW/7nBsHQvA+dWGpPOt0Pa/572v0jnP7Xrs3Dx4CL440QOxP77ngnM7Vxybxx6sphzv2GFh0rU5MALAb31u5yPXcD8IEtjN2fKYtenJ/wJY+ct7jLiEhX27Ur/l+I2LzRr9NunZHH0BFieZvcOfg8O8JfNjdZnWCGUJDbcRv59ZYeGcdXwaWzBvmMALE8vwdd8hidJEe+As4iZid/ETmhDnYvvFX2fdbS2pzy8PJa5M+/pDdYOwvs/14Pzbu227Wxrhu41hB9UgXBtov96Qu9+0TdVV+9JKW/jEQi6B4sLWwc3xUz6qNDo/W8L84pDbMxG0ww3h77Osyhku+U/Cxe/O9oxFvcv1D1rndsFF/wkIX+lZXfl/dkjDicXsj/3q7+zTPwjvD0R/Z786MfDq80/uHoDVd1yRC8EWfms7PD3LSjCbwG7OlUevfX5jvgem2l0FhR2nfvG/Dp1gs35Lf9FS4r1z81f6R+CvvDHcRvzKQVHhrHV8Gltw1rCcF05ezJyRLE2UxlnETcTuWmEnNCNZP4VyLrNYB2aof7il/nCgh2qeR3oag6lVn60z4I0uvRboptwzNNjv5+9xzl298HCImnbNLIFPmADRpTe6BwO3gcvPlEDPB3x1sxBJCcYC++MV+8tHjvysWfq5l9WtUapPsBmzNy0ktg88hOXOtWc9y8sNmUeeTCgKotOCF+ywLxMTJ+zNvAw7dq0C9LrA3/Aj8FsD7GNVlksQbU6v3dF9B9KRocLCPPM3rmZW2OTo5nFgGkPh5uz8k/hLAC/yxmQ3YleKC2etE6XlDMt5IXdoeaUJ0ziLuEmeuwq9JsZarTq0ALiofzclkMsLdfYU68indR5+rXM7m7f9Rfq534FvEt2iBHia+RIymYa8/Dup/777/dNdAmf/bm3pBypXu1fSlg2gNNcI656OiMvbdz31rPcZXKPSmzOeX0zedx7uF+R1U7/FkPCIEmy2HdQH1YzRptRtAr81m0CRSxBtzqw9+GVixtVTWNhX23vrnHHeQE/h3tn5LRt1mHW8MdmNuIyiwjnrhGk5wwReALnSBGmcRdwkz12FXhNjMannWJk/64RP2HlXonA932n3Njz8rSgBXK53ZcocurW09GthQgv1ZYC1pfuSem+CmAei0Azd39ftcbknXF4nvMbWeE8P3LjaV9hC2dN0BedDnxbHuqkv22viS0EFCULLdt2MSLxMuPbk/9thfIPffrNBZvOdGcZ2iY0KCuesE6YJDct6AeRKE6RxFmUnYnfJeY3DYh2YHNvUoU8n6J9BgE7bFEBMJuPRk3l66QQqdzqaXXZkryDa/ZdaClvwlv7R0dHOx6FQaCYqTPc2XAH4ockDXZlIN/jCu6HBe4nS8jxsUvnaqRx1q3lFNYUBCq8CzcdgZrsvu3WWggRhefvvP3uxoCRwwipE57isDS3U9mlJv1BFJzav5W8kWThnHZ/GFCwwLOsFkC0tl8ZZxE/E7uK9JodlW3W/9zMX3W8Zunn9wPCJK/dsjrekMxa8vWQ/NX7PkRjKapopgZ0dnJN7tCzbvufOmOD03z8CN32FpXmjDfaG9wC89vePXcm6nuhFuz3xoh0Oj/9P0zvCUn7+148h8Ci/7M5zO5L0qyfc1rkV+QnC8gITPlehmZ7AeXem+xGX9Zd/o7Y/2QMS/PLCJ66h63bxRlmEhfPWcWlMwULDsl7IN0HKLM4ibiJ2F+81OWr/hbuQ3HtWUZeguY4lvIpK43M3Sbr0wZWzgvTQMQlrRBfWYzvy75qko020INaeS+8AolLpz5967cKtC4qTIP3xacmn+BMxoSMSm83y2pm+/p7kRnmFc9aJdyg0LN8L+aWJ0jiLuInYXRJeC41mZy3bqlM/ncIFT1kv5EnnTk+Gg/ZyioHCYuytzKRFkdE8O1rFWxcUV8j8PY/0+youl/ySgPCT1rU7QzLZxIWz1uXtUGhYvhekdppN42a4idhdsl5jsLDUtSc+NKi+EH247XpV1fYtD6ddx+QGyZEqXO0O1VP7HZiwi9CjjdHl/YWJ4g4MUm0EHZjavwITWCS04wUcGcxQ1L7UAZQ8RFgFNnGQL0NhAakfvElkt+Fe0geOiLCA1N2tDwjsNfkIB7MzFla4AhOciuguu3TouPSKf5L2hrXYIZit+SswNFOg81XAZGgEe+oGwxpjNnY8n6zTc9DG8OwxjCtjNKzQgaHw+WZmKxl0uhKiC5u9r6gvBtEYi0id6rAHKwglAOEKro03D2DfxYhYRuoA9cPlbxM+Vv42iDGxwMVGBKFBqSMWAaWOWASUOmIRUOqIRUCpIxYBpS5HXGIOMTEodTlm+XG+IrOkTUG0AKUuR984q/XIeJ/KkhBDgFKXw91+idZ6ZKwJn9yqCVDqsgzCWIRq0zNdpA1BNAGlLouvLjMG426o4NEZxICg1OUJujLQtNmmviDECKDU5QnSo+gDPttYI6DU5XH7KO+4mtUXhBgBlHoRBinvDJA2AtEIlHoRfA7Ak9KaAaVejCDgSWnNYKEX7gpIhUodfQoaQiVLGbGyD02EhaspdXnEWSpPR3fJYpKXj1vYiSbCuh0YJUqH0koH58hlxZHPEYJYVuqKlK4I1Lo5sKrUtVM6at0kWFTqWiodtW4OrCl1bZWOWjcFlpS61kpHrZsBK0pdmdLvls6Rzs2j1g2PBaVeVOlfZeVbesz/fwqzo9aNjvWkLlR6GmJJgCij11iMTlil0iAdZSKFxZLCXGkuGzVJM4nZ7CyodYNjuRt9ojb946612KG5ROykH85Rq854J+AreHP2ZkP8cAC+W9sOMoEWPt6z3nt4erJ+60gg+ZXNnv7VZ+9B+uMPqDVMdj4ANaV1vG9qYIjXzUd67/B1Ye+l8xfh8dd8U3f8tGJvTJ08/u837bHrb3jpxrrzF9HzbEyRPWcgdvM/PNFvesJ1b0A6k92czp4rzDn0CTE3KuZ90gYQg7jU9fZ9fELYU++DXQ4f7JwFmA1vZ9ihARaavAB2ep03k2aUHKQS4RpAZrXj5l+7ZMfKSN45a/jBBXRvWYwDeanrjHtUqHU7f7ayMvmaNzwlymkXzbn2Aexrcb4Tjtz6NbWYKSw5GRo1vNKtjPVOS92jIYnw1OsuL/xITR1x6Hq2ApDOW9+1Xef3dziTzv4zmUQmCmE22ZEb5A6VbnAs16rnt+scPf/6Ahqo6b6/2N5+6QJzWirC89KFugz8NjxZH2/zBr+pa2GT6exs649KNzrE45Z+ROA8KS6hdYg2ZXss6WcNElfeoy4PvyqZzA+WZxalk3C3QbBeBwZk+jBeQd/cK3WPyevJrnKaVelWxpJSl+mvVw4q3QRYU+oaax2VbgYsKnVNtY5KNwVWlbqGWkelmwPLSl0zraPSTYIFr6vzUFq3l8oTDpQsJo1KNwcWljq4XymZJYzj8NYM1u3AIBYDpY5YBJQ6YhFQ6ohFQKkjFgGljlgEI0h97jY3c5v5K4WCLIg21JSrDSD176fWuVElfkjRf5L8OTf7A2mDQaiBGvxu5nxtBFdrhgGk/njkmMSNrK049c/oPr5FfaxwqWwK0QFXaCVMZpdM8t0UwHlvK5uQ52rO10ZwtaaQv1t6cWOs+dEHAB8K34f6sGst9tL8Vuy0H76k/P2ba/AneMsxc60+eSQAF59uDx3Wz8AtJ+2keKaeWYozSnhPkMJns7mFWVdEG9vJ+5njw17Ge1O36rdO+5iEPFfX/4P2dZiIq6sK+So4/ceTOz8tSA0Ewpfe8E1N+uFNB9y4evr+u5RsJt5igojuPb1+Ti//f5SwZcDmgATtKxvQS/AhOFIfOFhd8PmM9N0sDuO9rZtn62cu/V7S1a9Qvibh6mpDXurSBKCTHqBlBiA8nUix77ctNLHhcoPQnFFTdhm8Dx++NBz/9J36FKWC6Gn48OX99M8PPZoKq4ucwQb5bpaE8d6Ctx6C4ymHgVxddQwhdfoBw8I+IX0akYGVa79uDk8WrEzpZvgguL2LAV4F/dn0nC4YTCWYfGcbxNXVxQCnpfT3bYsfWKWAdVcz3GcHXOl6tk7KwpVrp94dSYOgacim5OAFU7CCxlind13RLZjx5GmYczU7Fg4xV1cNY3xjBz6v2yWzqvvan6ARoO9z27v1o39uoLu++jK9Px7tXORUQOOI0w+orwtSRGS/m27omlhv1tlahdQf+rxh63ReIudqxtdEXF1dDDIOTBzk32/YElzoYC9o6MmHXRubQ4dTX9igcett5jLRlTlbIvUB8CkfMBZRK7Y+fx8iV37HZaVyveuYCdGCoTf6n/eN0ajkxoHZqi9cS9bVVcYgUjcuH/6BvVIoUgZjtJRWGIwsGKO7u4oYqyIMCft7U6hrOaWLVshmQvTGEKelRuYUaQMQjUCpl6C2Ts2sDEodsQgodcQikJR6XGLO8JjSaJNbrg0kpT4b4WYis6TdUONGm9xybSAp9b5x1vmR8T6VJaHRNW25NpCUurv1Eu38yCWviYaCM6XRrOWeMdbydrNZrg1ET0sPAOX8yBi8SNoLNW80w3CGatcjl2CQtCFkICp1nyszBmMZh4+0Fyow2mUqoxl6bZlxuAR15rNcE8hebBywZSBDR8A1E6zRZuzvdmUyAHUmc7dmkJU66/Uh0k6wgNEMI3Rk4QRKnQTu3dRHm8nOkkxpNGt5A4DLZ0bLtYDw3dID1P5Nd35HGW0zndEMhwAyFj0pJS51nwPMdVJqWqMZem1mtVwDSD8DM2C2k1LWaDOelNJ0mdHdGqH+1YxUSE0ZKdgOqdl8RMd3S8JPCo1uNeBDvkVqxA4bcu7W1ZUkUH14qcsjTjXbd3Sr2Tp5+bhOFRSfhM7sWC45o5euOA4a7DyvaI3Iu1s/VxJC7bulapWulmRInwqaeXJI5jiTN1sN1SmouEb0ciUpyuurs0NabuVGtiStdHCOXBaOsFIw9KZGTDlkj9M54pgid/wa1ohOriSGklY9tHEa4p++55i51rgxGkh94YT0u+wa4koHUWNUMPSmVkw1+Yutjjwb1vmguSoJa1sjeriSHEp+sg5+mnJc9zviobPurc8DDxp+xa8wgtLpxihbQQVDb2rDEhRVOvjvLuksB7ZK0hrXiA6uJIiSDoy7/S7MDcNDmPg+lFnvXP3mNvvbZgili354c0NvxrQcOG621G2XQb1fdmCrRPMaqb4rCaKor75/Zs7VBilXIBA47an//b7IH+mjz/l1KQqQLlFGeoXKkc6NzBiNZWfpzcsgzewqnStM3MnUvmJmektm6Z3RfK/FYapEvkbKgHcnQ7VdSRJFUvenQgMAXdvNfv9uR9wRfD0TE/o1Pd4A8OlS0SIin41/FgH7NPfSV/KLi+evgmDzMvj0M6pepj6+kS0sr4Ikh95Uw5PSvRPfI+12pwimSmRrpBx4d7JLVXYlSZQdxtDNfoD60b/UpzO/m7/WuN3RLPTrnfbSHp441D8d8kP/FNvrDTvfhKRg87Q95rYDPXHa6CGo0/YiZbkedsNsI2QLE3cypYfeVMFWo4JMLVs6j+NFV4lsjQj8CR6l7mSpqiuJokzqG346XzBIB0EJBmLU91zo13DpYfKj233Q98+ot+dKktmsZTPpdAo2/3jPxnbwMDVZ740nT0Ls3Nki357ee90rQP0S8IUBX0H01aT/Bhge1lR34R4FmXrC+zXcpQKYKpGrEYE/6xqVulMHVxJFidTjl396h51jDtvRnPdbudEmzH2O7YT/p10wBxsuO9hdG167Z5G5XbcGX73pTLLzzObtZ2Ln+j2w5wxEz6ft0+zvRLYAQUkU+2aTM32LAHxhNKLGSNuREmMeBZk8MQWZtCNbJdI1IvCncnfq4EqiKJG6fd9R9oA/yqW9nvNrOiO6M/6WxFwOJ3NLInb9jTtfvbkw253dfAA83oV++mEkr2e2PzwiLiCvpL33Hr69mC2MK3jok9xC1YabTT9r4A882mSn/rJr9D2F46tEukZA4M8y3Mmjjyt1R4nUHb0Fxy1sQ+y2jLAr+NdNZvIbu2AOGhNpezpBdQiTTA2t1HmPj33t6i/YnJ4Lhlsy3eKiBCXRBP/Wyuw9KWhyknd+nz0WgQC0JTLuGuAvPH5zykf9VWtPJchWiWSN5LCX404eXVypPxWeXTuOCzwr6EdQvJJgJnbhHHjrZvtnPV5IxzrppLbYku/4/0Z7cpvPDsaiXWwBwZu3u/KKEpTEbH6AfhGIL4xBnwc4pgMj2fkTrdXfXxmIakToT8Xu5KnVZ2EqPSihZ/0RWuoXqX/67MeT7dp6BJ3c0fE7iRMAD1uYjTwvX6pL7Ibzb9j5zX/69+YAl93e/tN/5BXgyesus/fhucJo9KmeqadbY0c805FEyyEPRBq91d9jGYi1nvOnYndy1KrSK3+IV+DZQ/+btjNBa4vgP/uM7tjeO8gu9vc9y/Zzmc3PJIEq7QMm4Uzxotg9/TJXmG7Vs3u2Za8T1ve5Hpx/2z7fq8Mey0GkdYE/lbqTpWaVruItJMfxEHdl3DnyrHR2u5e+ztvZLVwUbu4s++5HrjC9qsdX5w04YaSnMZha1WN/ZZKrEajEnwy1q3Q1r2bkWhHFb1fYJZ8ApDY/UcH+s4XpXD2XF+rsKX2vLSokVyOV+JOmhpWu6t1SUSuiDjWvrelcPSvz77z1pkH1kK2RCv1Zy0pX9xq1hlqvHL2rZ5vy2XSC9FHLoK5GalrpKkcMMIDWda8ev/ezL8JKbqASQU2N1LbSFffV4+7COSi4mqs/+dUjY6dGvMF8RF200n/P/JFD8xrR15X6o7RVlwu5QLhdL2iI9AgN4ZVq03VvD7WuESKu1BOlNdT35QnmidnI+Nt5BRy/aldYRhVI5//kytpZcxSpkYpG1ql5VyqVutt76ZSfDrnQkf9j5niF9DGI7Gzn7Nyp2Y+uJ6rgtmhU9967/JE6jlV5B+ZE8Wnpi1ywiAOkLS7BIFxi7DyoviiOvgUFmRb0H9pO+yMt2MFYdXegL4qlbpZgEb46YCJx+NUXxeHeVJBpU/+WT/sjzd8BF9SkajvQF+UXG/sgAxnbAGmDSxJ00EEttBxKsS9cMkuYxHil9JGWcau6fAY0dyVJlEudCRORMdSYbZIE6frX9EfX96TUJY2kgjetq3OkGXipujvQ1pUkUS51N/1eXIfxz1DcPuqYtD2TGrlWfOiP9LURhSVpf6TNVawRN/0FrpGT0rLulr5oA5vRT0ppBm1at0SOI0UvVSdDR8jcZaSPtPQr7Gp24KidRr0cqZslWARtp8ZnUvVHb8r318M3jxJ617gKR5q3A1uVd6An5TwD0wfGPymlCWp/JuU41nx1SmoQsujU1eZjxJ4cCVbzpJRmoGZOSmVuIWXDQ4hJyYVc0C10ROrBEyW5IKXkfmFrdzkS9fnisz/yCzPZs3PPkC5dWdkaAZkaKevYCsvl/SxwpRHjg5RF4aDT8clUl0w/5YFMG7K0oEvoiPXbjq42JRkfKGrrVhZS+5srs+QjXYeMqKBGVByb2M+5HehUydWjQOry4SGKoUfoiFBdUOOnbdJ3UpVdOtFV6pXVSHpmu7JjS91wDEn72WjxQcokv68+BRU9AuocgSqHjoh/3z+o9XNl9uH+7w0fFaJIwI6ixzbY/328gu22LvcPy/iZbHwQ1eRJfaqp0h5ZoKmqboiHRqvxQJVnNGRwrU81VXrmSR1b+VrfKurn7upWcnURS71UeIhi+GGp4m1LMzFSnUeF7aNqYklWHzU1Yh+ZKHeTVGi0qJ+rW8nVRSz1GTVRuQerOJx+6FC1Hoq3HzK01ksG7ND22G6U8rPu8UG0QyT12+quJwWqpvX1uuo9Du5xrFetbNUoCNhR9Njqyju2dUdJP+seH0QzRFJfVXcztHqhI25X88x/6HYVC1fJI5W3p4PlHdvtoZJZdI8PohlCqa+3qCyspUqneClHNd/pszsMG/NnS22NlHdsivxcrUquOkKpzysJD1GMnip15B50VdUHXQ+qWrwKFAXs0O7YFPm5p/TT+8ZEKPUNtR1iz0Z1jHyi6B5pxbQpedqACIoCdmh3bIr8rHN8EO1QN+QROaJppYlmhmTPKh3lH1ym3Cr0rGG7eyUwq9TPPy6eeOHcufM36PpJnp+6TC8zH2F6OflVhKrIC2b9HdaJyGcX+e7oN4/pP9NTqyOXRff6N2/GjwLM2hvuUAJ/RH2nkz+9SC8790502q9HVXeDaxtBgBCDxQepFBmpP7ifqD/kHTvqhGlnANJ3FqFzmP0EmFq09/u5HPxEP3grEmMbvYO8MdlUSIf2sDfSW/ywSseyWujqGl9pW/BuUx+ONnoZDj+YCM6cIThQUyVI1Qg/4ZzAZtGmRpgAIQvGjA9SIdIdmOi4f7h1G+ao3tqjJYDvwn0D29wnXJgf2DO+xOXgJjrCWQHX2gI3H3DG5FKTXyVzj4xs1lHSf9LnbFyEh7426qOVWQY49ePFF8zwPpUAyRrhJpwT2Cwa1chuR8te5/q+YTifhnldK7hqSLfq646AM/fsRXTptx7oZj+phf+yw8btn7E5xBl1gLMCYKgfHkWaWWN8fGpsPMC/a3lvbjtzCuBhkxM6FodXfrY2P7zSxy6Dt2XtCCmHV4hUjWQrhnUCm+WBNjVCBwiBkfSz4MJqdS9/6Ye01Pfu+rSx+yD/E/+UuS3PfsLTzJeQyTRwOcQZdeAp/4hAC4BzmzMmm3qlO/tWcdveR/RLQ+G9VLWFktu+5pvJjU52GcKbjaHjentaHVI1wlcM5wQ2i5Y1Ytz4IJUgLXX7meTCjfhRW8IDiXpwMQPns5/gcr3LTNkcXEb97HWJBvHnjeFTX5qc7udWtQUCyatvwvIhgK7xW17wOG7RXXV6ORka2fWXbnO9HixVI3zFcE7gsmhXIyvzZ53wifpyDIJ0Xz2WdAbat6FuEWKPADptU1QS+wmd9DsY6SiXg5voB2cFv8Qak03deebm3Vzeo2sPlhzUGZWzcYYSeesM1VVnli+2BbxDE+a6Bi9VI3zFcE5gs2hYI4aOD1I+0q360kQdUD3dA/+8Y6OkYT9x5Z7N8Rb7aT81fs+RGGpgc3AZ9YOzhV9ijfFmU9te/9t2tg/j3HdjN91fgY5/d1EfC1z/ZfrJWaCvwpiqCyNZI9yEcwKbRcMa8Xs/c1XxkVK9Eb5beiX3MmL6GXiZCRddNJbwZj+pCZWazQGCK1EhbYY7zickGteHsyK7xJooTuX50wlf0WWWG+W+hanXu6UlayRbMXQqm0VcI2UdWyh//CQ2Pkh+rupUctWRua5u9wonfPxiLooxM8nPoR/iWMr8kkey+TnjLb5sHqRrRFQx7Dota8S03pLCrA8GKMRbYtngGPJetiGNUoBQ6s3RiothiVY89EhxWleq6oMlw9749qitkfKOrVXJi6P6xwfRCKHUFYWHKEa1QkcE1BpWnEXDjlulukbKO7bAooJMBOKDaINQ6orCQxSjeqEjqhlFj3Tk1SKorpFyj01BfgLxQbRB1FfvVfdga7i3WlYevFVFF9w08LDKCgJ2FOVWecd28GbJLETig2iCSOr+R2pauOSjqt2AdLdU7524B60GbqZKB+wofmwt5R2bu7WUn8nEB9EE8RWYo6HK7yGmr1Xx+YDgZkR9IZJENg09DmGpgB0aH1spPxOKD6IJYqk7RiqOLV3l0BHDz+6qL0SCu8+Gq2i1ekoE7ND82Ir7mVh8EC2wi2+QOfeEEjsrKSc8e7S6/YCO55Pa36Remex6oZLtpvTr3jv3XI9XVCMVHlsxP4d/HDVwZ68UheOrR+Yausq80xJd2OzToQs386SxR0O1x+bX2ivsvOg7vvrSbNk1ouLYKD8/apHws06VXD0KpQ4Qn5V5RnlGxnuePp2+7FthRU9PzyiqZU+g4hBG+kq9khqp/Nhocn4WxAfRq5KrhVTXy71fJvMM6XOS+v2KshG3U2v0rpGcn2vIlTX+DAyC8KDUEYuAUkcsAkodsQikpZ763qxDAJoSK7ubsNRTl4cuW9f5umNpd5OVeuryiHfEus7XG2u7m6jUKdc7wWld5+uMxd1NUuqM68HCztcXq7uboNQ511vY+bpieXeTk3rW9dZ1vp6gu3WTevy2OAq4wPUSzs/PjZQJursA3aTubvnyW8HYCyLX5zt/6dvPy3xTDMnD3fL5RcXu/uZLK7hbv5dK/CcuLbsGgqxP81zPOP84a0t85l4CTplrnFwD4j82/lNdUIG778ykrOFuHd+f8p8aS9ya7Djgk3B91vlLtx5DxnbSCq6vMr0wvn3nlm+wuLv/tUL9slvD3Xq+Kug/OZaB5ceOgb5QgesZ54/M3ktlLOP6akNpPQVLjxxBWXffm8lYyN3lSf0jDfaYSUxOHnJKrHC2fs7luETaK+ahVI1kMil0N0tZUlf7mllkjG5EHH0DoaSE85NP3sFWvUyK1kiE1rCN/hGVcfetMHVyarOdsIa77YfVl6EURultR0c7nXsnfAXRepKh4+6O/btjm7bMws4qjXOqFTqOGFA5lNJtO9pHRztk3b33QHt0+zlEvAZ3tzboKPXIpeeu/lP9jdSsrdD5lOvpX5jGQL99NTW/y9jON4PUKaW7hl4JlnD3z/pT0ZThmxZN0E/qkfFdx0Y7uQ5TgfM511M4Ova3x+4a2/kmkHpkrP3oaIcCd1NN+/p9K7Trul2Bia+9LbxN4TguugCWcz2Nzxef3W2BmxpVJL72DrpbjH53S/eLnek4LhihTex6idxImaC7CyD3uJfA+QWuRzQH3U3wId6s8y3qep2xvLtJvprBOd+qrtcbq7ub6At3jPMt63rdsbi7yb5GTTk/alnX64+13U14cAzH8W8s63oCWNrdpIc8cpg24qspsbK7SUsdQXQCpY5YBJQ6YhGs23VThBbvoiDGAKVeHJ2DHiHVAzswiEVAqcsRl5hDTAxKXY5ZPgR5ZJa0KYgWoNTl6BufY6aR8T7SpiBagFKXw93OaD0y5rHAawtWAK/AyDL40zjdpmeUhQVGjA626rL46mzjMJ6xBUgbgmgCSl2eoIv6yOwlbQaiDSh1eYIJgBSMkjYD0QaUujxuXx1AA56U1ggo9SIMZgCMP7gRogyUehF8NsCT0poBpV6MIOBJac2AUi9GHxwibQKiFSj1IqRCh25aMexhbYJ3S+WhQwglL1v3FfsaA1t1WZhgWRYNZ1uLoNTl4MLCodZrBZS6DNkAiKj1GgGlLo0g1CdqvTZAqTPEb4vfqhMFtS3Qen5uxAyg1BncLV9+s5RbzAvfLNb60sXPW/DBGPOBV9JY/CfGLjiCQ6yECwKVc2HKKeIzM9twzBqBPmsMlDqH/+R46s6dthd9EkrPan3p7pIjAcfwuRgzglLn8Z8Yz2RWqKZ9IDRSGLyZ0vrI7Ewqk0GlmxXyUjfYWHFU035IIkw5OFs/5+auXCFtI1IJxKVunJHiIuNAnXw6AgdCSQmtJ5+8M3svlaHmTvSSthSphB1/IG2BUYhQ/RfYedAv2VfnQggt3XpsS6HWzYl+gdcNTmQsbe87PUgHIC8IU54NC9cYCNpW0wvNXtLWIuWDrTpLZNy7P3cJMb9dF4WFo5r2k3i10Xyg1Bnis32iu0JirecHQMzPjZgBlLo0Qq1bN9RnTYEPBkiTDVOOSq8VUOoyZLWOSq8RUOpycFpHpdcKKHVZGK2j0msGlLo8lNajqPSaAaVeBMfxb0ZR6bUCSr0YDsDr5zUDSh2xCCh1xCKg1BGLgFJHLAJKHbEIKHXEIqDU5YhLzCEmBqUux2yEm4nMkjYF0QKUuhx9TNx1+v2kPtKmIFqAUpfD3c5oPTLmwTumNQE+4iHL4E/jzDgC+0kbgmgCtuqy+Ops4zCewXCONQJKXZ6gi/rIYDjHGgGlLk8wAZCCUdJmINqAUpfH7asDaMCT0hoBpV6EwQzAQdJGIBqBUi+CzwZ4UlozoNSLEQQ8Ka0Z8Lq6LEs/rm7B8tc79/lIW4JoAUpdhsgN8P+8YbljcyEEh3E00hoAx2yU5sryoV5+fu5mxzHS9iCqwfHVJfk2+ctd2QVv3/0wnp2aHjwtleIKvCrs2TleBYx/ZHqwry5BZPlNerJ0dyXl2HmAPiv9xVcR7K+bHOzASHDpRbr38o/bG2nIxOZW9lE/fnX/6idtFaIO7MAUsgS91Oc/Vph4dtTit9RHLyypKRIhD0q9kB/pvsrS8ha//HiO+vD/SNosRB0o9UJWOqmPu4IYd1PUf+cKabMQdeBpaSGJndTH00QuYYP635motDjEGGCrXkiKfm43X9nuFGmzEHWg1Atx0AO/uPIS4/j7Z3JQ6oW4VqmPXfW5BHp21VVpcYgxQKkX0rZIfQwmcwmHqP/FNtJmIepAqReyjx7Xy9eZbcZ39VIfkX2kzULUgVIvxAdz1OcrHQ7WObtfpz7mAJ9aNzn4YIAEDdf7KJV3t25tZ2w7X6a7L6nvjzSTtgpRB15XkMC/8N2r1MSXa8i/68CnvcwOdmCkOAbfCi+jp74FfDfD9GAHRpLA8o06L78w9/3OU6QNQlSDL9zJQL9b2tVQv7W5EMF3S2sClLos9IgBCVc9jhhQI+BpqSw+lHhNgaeliEVAqSMWAaWOWASUOmIRUOqIRUCpIxYBpY5YBJQ6YhH+D11lSU4xPj8FAAAAAElFTkSuQmCC" class="uml" alt="uml diagram" title="PMP &amp;#22320;&amp;#22336;&amp;#21305;&amp;#37197;&amp;#36923;&amp;#36753;" /&gt;&lt;/p&gt;
&lt;p&gt;failed 的访问会触发对应 exception。单条指令可能会拆分出多个非原子访问序列（比如非对齐访问，访问虚地址 etc），一旦序列中某个访问 failed，即使其他访问 success 且产生了副作用，仍然会触发 exception。&lt;/p&gt;
&lt;h4 id="paging"&gt;Paging&lt;/h4&gt;
&lt;p&gt;PMP 机制支持基于 page 技术的 Virtual-Memory 系统。当启用 page 时，访问虚拟地址的指令可能会产生多次物理地址访问，包括隐式的查询 page table，PMP 会检查所有的这些物理地址访问。隐式查询 page table 时为 S-mode。&lt;/p&gt;
&lt;p&gt;spec 允许支持虚拟地址的 implementation 在实际物理地址访问前投机地进行地址翻译，而且允许把翻译结果缓存起来。从地址翻译到发起物理地址访问，PMP 检查可以发生在这段时间内的任何时候，所以当 PMP CSR 被修改后，M-mode 的软件必须把最新的配置同步到虚拟地址系统已经任何 PMP 翻译缓存中。具体方法：修改 PMP CSR 后使用 rs1 = x0 和 rs2 = x0 的 &lt;code&gt;SFENCE.VMA&lt;/code&gt; 指令。&lt;/p&gt;
&lt;p&gt;如果不支持虚拟系统，则不需要 &lt;code&gt;SFENCE.VMA&lt;/code&gt; 指令。&lt;/p&gt;
&lt;h2 id="supervisor-level-isa"&gt;Supervisor-Level ISA&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>Patterson and Hennessy 学习笔记 #6 —— Chapter 6 Parallel processors from Client to Cloud</title><link href="https://qian-gu.github.io/posts/ic/learning-patterson-and-hennessy-notes-6-chapter-6.html" rel="alternate"></link><published>2021-03-13T16:17:00+08:00</published><updated>2021-03-13T16:17:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-03-13:/posts/ic/learning-patterson-and-hennessy-notes-6-chapter-6.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，第六章&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;I swing big, with everything I've got. I hit big r I miss big. I like to live as big as I can.&lt;/p&gt;
&lt;p&gt;-- Bebe Ruth&lt;/p&gt;
&lt;p&gt;-American baseball player-&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;计算机设计者一直追寻的 “ 黄金之城 ”：只需要将现有的多个小计算机简单地连接在一起来构成功能强大的计算机，这就是多处理器 &lt;code&gt;multiprocessor&lt;/code&gt;。几个概念：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;multiprocessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;至少包含 2 个 processor 的计算机系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;task-level parallelism&lt;/code&gt; / &lt;code&gt;process-level parallelism&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在多个 processor 上同时运行相互独立的程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;paralle processing program&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在多个 processor 上运行的单个程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cluster&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通过局域网连接的一组计算机形成的大型 multiprocessor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;multicore microprocessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在单芯片上包含多个 core 的 microprocessor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMP&lt;/code&gt;(shared memory processor)&lt;/td&gt;
&lt;td&gt;共享同一物理地址空间的并行处理器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如第一章所述，因为功耗墙的原因，现在的发展趋势是多核，而非提高主频或者是改进 CPI，这也意味着关心性能的程序员必须成为并行程序员，因为串行等于速度慢。所以业界现在面临的主要问题是：&lt;strong&gt;设计出一套软硬件，使得程序员可以轻松地写出能随着并行度变化的高效运行的程序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现这个目标的难点不在于硬件，而是基本上没有什么重要软件被重新编写，以便在 multiprocessor 上高效运行。事实上在 multiprocessor 上写程序很困难，而且难度会随着 core 数量增长。为什么并行程序更加难开发呢？原因有几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写并行程序的前提一定是有收益（性能 or 能效 更高），否则还不如写顺序程序，因为顺序程序写起来更加简单&lt;/li&gt;
&lt;li&gt;单处理器技术（超标量、乱序执行 etc）可以在不改变程序的前提下充分利用 &lt;code&gt;ILP&lt;/code&gt;(instruction-level parallelism)，获得高性能&lt;/li&gt;
&lt;li&gt;并行程序有额外开销（掉队、分割任务、负载均衡、同步和通信）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Amdahl&lt;/code&gt; 定律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Amdahl 定律：&lt;/p&gt;
&lt;div class="math"&gt;$$T_{after} = \frac{T_{affected}}{Amout\ of\ improve} + T_{unaffected}$$&lt;/div&gt;
&lt;p&gt;也可以改写成：&lt;/p&gt;
&lt;div class="math"&gt;$$speed\_up = \frac{T_{before}}{(T_{before}-T_{affected})+\frac{T_{affected}}{n}}$$&lt;/div&gt;
&lt;div class="math"&gt;$$speed\_up = \frac{1}{(1-Frac_{affected}) + \frac{Frac_{affected}}{n}}$$&lt;/div&gt;
&lt;p&gt;从书里面的两个例子可以看到，有时候必须增加问题的规模才能保持高加速比，而且负载不均衡对加速效果影响很大。&lt;/p&gt;
&lt;p&gt;1960 年代提出的一种基于指令流和数据流的数量进行分类的方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;signle data&lt;/th&gt;
&lt;th&gt;multiple data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;signle instruction&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SISD&lt;/code&gt; (Intel Pentium 4)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SIMD&lt;/code&gt; (SSE instruction of x86)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;multiple instruction&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MISD&lt;/code&gt; (Nop)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;MIMD&lt;/code&gt; (Intel Core i7)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;SIMD 有两种重要表现形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MMX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vector 和 scalar 相比的好处有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条 vector 顶很多条 scalar，所以指令 fetch 和 decode 的带宽大幅降低&lt;/li&gt;
&lt;li&gt;硬件不需要检查 vector 中 element 之间的数据相关性&lt;/li&gt;
&lt;li&gt;比 MIMD 编程简单&lt;/li&gt;
&lt;li&gt;两条 vector 指令之间只需要检查一次相关性（scalar 需要对每个 element 都进行检查），功耗更低&lt;/li&gt;
&lt;li&gt;vector 一次从 DDR 搬运一整块数据时开销只有一次，scalar 是多次&lt;/li&gt;
&lt;li&gt;loop 引起的 contrl hazard 在 vector 不存在&lt;/li&gt;
&lt;li&gt;指令带宽更低、不需要 hazard 检查、DDR 带宽利用率高，所以 vector 的能效比更高&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vector 和 MMX 的对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MMX 是 &lt;code&gt;LVS&lt;/code&gt; (vector length specific)，vector 是 &lt;code&gt;VLA&lt;/code&gt; (vector length agnostic)&lt;/li&gt;
&lt;li&gt;MMX 的 load/store 必须地址连续，而 vector 支持 index/stride 模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="hardware-multithreading"&gt;Hardware Multithreading&lt;/h2&gt;
&lt;p&gt;相关的几个术语：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;概念&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hardware multithreading&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在一个 thread 发生 stall 时硬件可以切换到另外一个 thread&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含了 PC + register file + stack，共享同一片虚拟地址空间，切换不涉及 OS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;process&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含了 1 个或多个 thread、虚拟地址空间、OS 状态，切换涉及到 OS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SMT&lt;/code&gt; Simultaneous multithreading&lt;/td&gt;
&lt;td&gt;利用多发射、动态调度使用资源，从而降低 thread 切换成本的技术&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;MIMD 是通过 process 和 thread 使得多个 core 一直保持 busy，从而提高性能和利用率，而 &lt;code&gt;hardware multithreading&lt;/code&gt; 则可以让多个 thread 共享单一 core 的功能单元 FU (functional unit)，从而提高硬件的利用率。举个例子：比如某个 thread 发生了 stall，如果没有硬件多线程，那么 FU 就会处于 IDLE 状态，利用率下降；而如果有硬件多线程，那么可以切换执行另外一个线程，让 FU 一直保持 busy 状态，利用率不会下降。&lt;/p&gt;
&lt;p&gt;显然每个 thread 都有自己的状态（比如 register file 和 PC），所以硬件要复制这些状态才能支持 hardware multithread，而且硬件切换 thread 的速度必须很快才行，否则还没等切换好 stall 已经解决了，那么硬件多线程就毫无意义了。一般 thread 的切换基本可以做到实时（1-2 cycle），而 process 的切换则需要花费成百数千的 cycle。&lt;/p&gt;
&lt;p&gt;硬件多线程可以分为两类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;切换时间&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fine-grained multithreading&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每条指令执行后都发生切换 ，一般用 RR 轮询 threads&lt;/td&gt;
&lt;td&gt;1 cycle&lt;/td&gt;
&lt;td&gt;可以隐藏各种长短 stall 导致的 throughput 损失&lt;/td&gt;
&lt;td&gt;某个 thread 可能会被其他 thread 阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;coarse-grained multithreading&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只有在重大事件（如 last-evel cache miss）发生后才发生切换&lt;/td&gt;
&lt;td&gt;多个 cycle&lt;/td&gt;
&lt;td&gt;对切换速度要求低&lt;/td&gt;
&lt;td&gt;无法隐藏（如 shorter stall 导致的） throughput 的损失&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;SMT&lt;/code&gt; 是另外一种多线程技术，可以利用多发射、动态调度等技术使用硬件资源，在 ILP 的基础上还充分利用了 TLP。SMT 的主要思想是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多发射处理器内通常有多个 FU 可以并行使用，所以配合寄存器重命名和动态调度策略，就可以不检查多个 thread 之间的相关性，直接发射多条指令，相关性的检查和维护留给动态调度机制来解决。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 superscalar 不支持 hardware multithreading，那么会受限于有限的 ILP，发生 stall 时甚至会使整个 core 处于 IDLE 状态，最终导致利用率不高。&lt;/p&gt;
&lt;h2 id="multicore-and-other-shared-memory-multiprocessors"&gt;Multicore and Other Shared Memory Multiprocessors&lt;/h2&gt;
&lt;p&gt;前面已经描述了并行编程的困难之处，所以有个自然的问题：计算机设计者可以在这个问题上做些什么？答案之一是：为所有处理器提供一个共享的单一物理地址空间，这样程序就不需要关心自己的数据在哪里，从而降低并行程序的编写难度。这种处理器就叫做 &lt;code&gt;SMP&lt;/code&gt; (shared memory multiprocessor)。还有一种方案是每个 core 都有自己的地址空间，然后显式地共享数据（即 cluster）。&lt;/p&gt;
&lt;p&gt;SMP 可以分成两类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UMA&lt;/code&gt; uniform memory access&lt;/td&gt;
&lt;td&gt;DDR 中每个 word 对任何一个 core 的 latency 是一样的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;NUMA&lt;/code&gt; nonuniform memory access&lt;/td&gt;
&lt;td&gt;DDR 中某些 word 对某些 core 的访问速度要更快一些&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为多个 core 可能会同时操作共享数据，所以 core 之间一定要做同步机制，否则就可能发生错误，其中一种同步方式就是锁 &lt;code&gt;lock&lt;/code&gt;，保证任何时候只有一个 core 操作数据，别的 core 必须等待直到锁被释放。RISC-V 中相应的是 A 子集中的相关指令。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;除了提供共享的单一物理地址空间之外，还有另外一种选择：物理地址空间是分散的，但是虚拟地址空间是统一的，由操作系统负责处理通信。这种方案已经被尝试过了，但是开销太大了。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction-to-gpu"&gt;Introduction to GPU&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id="cluster-warehouse-scale-computer-and-other-message-passing-multiprocessor"&gt;Cluster, Warehouse Scale Computer, and Other Message-Passing Multiprocessor&lt;/h2&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;h2 id="multiprocessor-benchmarks-and-performance-models"&gt;Multiprocessor Benchmarks and Performance Models&lt;/h2&gt;
&lt;h3 id="benchmark"&gt;Benchmark&lt;/h3&gt;
&lt;p&gt;benchmark 不仅仅是一个单纯的指标，它关系到销售量、设计者的声誉，所以要保证无法通过小 trick 获得好的虚假结果，也要能实实在在地体现出真实应用场景中的性能。为了避免各种小 tricks，一个重要规则就是：不能修改 benchmark，代码和数据结构都是固定的，只有一个正确结果。违背了这个规则结果就是无效的。&lt;/p&gt;
&lt;p&gt;几个常见的 benchmark：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Linpack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPECrate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPLASH&lt;/code&gt; / &lt;code&gt;SPLASH2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NAS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PARSEC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着技术的发展，以前的旧 benchmark 显得有些过时，不断有新的 benchmark 被提出来。&lt;/p&gt;
&lt;h3 id="performance-models"&gt;Performance Models&lt;/h3&gt;
&lt;p&gt;和 benchmark 相关的另外一个话题就是性能模型，因为有各种新的体系结构不断被提出，所以如果有一个简单的模型可以比较不同体系结构的性能，将是非常有益的。这个模型不需要非常精确，只要能说明一些问题即可。&lt;/p&gt;
&lt;p&gt;cache 中的 3C 模型就是一个很好的例子，它忽略了很多重要因素，比如 block 大小、block 放置策略、block 替换策略等等。而且它还有些含糊不清，比如 miss 的原因在不同的设计中是不一样的。即使如此，这个模型仍然流行了 25 年，原因就是它提供了一个深刻理解程序行为的途径，可以说明一些设计中的问题，帮助体系结构的设计者和程序员改进自己的设计。&lt;/p&gt;
&lt;p&gt;而对于多核系统来说，我们也需要一个这样的模型。首先，我们可以将一个程序 / 系统分成两部分：计算 + 存储。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算：显然最高性能由总的计算资源决定，当资源利用率是 100% 时就达到了最高性能，不可能比这个值再高，这个值就是硬件系统的峰值性能&lt;/li&gt;
&lt;li&gt;存储：最常见的指标就是带宽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据下面这个量纲公式，&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{Operation/Sec}{Operation/Byte} = Byte/Sec$$&lt;/div&gt;
&lt;p&gt;可以知道，分母表述了一个算子自身的性质，算子对计算量和数据量需求的比例。这个指标叫做计算密度 &lt;code&gt;arithmetic intensity&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;将这几个概念组合在一起就得到了大名鼎鼎的 &lt;code&gt;Roofline Model&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;横坐标是 算子的 arithmetic intensity，单位是 OPs/Byte&lt;/li&gt;
&lt;li&gt;纵坐标是可以 算子在该系统上可以获得的性能，单位是 GOPs/Sec&lt;/li&gt;
&lt;li&gt;屋顶是硬件系统的峰值性能&lt;/li&gt;
&lt;li&gt;屋檐是硬件系统的存储带宽性能&lt;/li&gt;
&lt;li&gt;任何一个算子肯定是落在 Roofline 的下面&lt;/li&gt;
&lt;li&gt;一旦硬件系统确定了，Roofline 就不会改变，变化只是算子可以获得的性能&lt;/li&gt;
&lt;li&gt;算子落在斜线屋檐下面，表示它是带宽受限&lt;/li&gt;
&lt;li&gt;算子落在屋顶下面，表示它是计算受限&lt;/li&gt;
&lt;li&gt;屋顶的 “ 脊点 ”，是计算机系统的重要指标&lt;ul&gt;
&lt;li&gt;过于靠右，表示只有 intensity 很大的程序才能充分利用资源，达到最大性能&lt;/li&gt;
&lt;li&gt;过于靠左，表示几乎任何程序都可以达到最大性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们的程序的结果远远低于模型上界，即离 Roofline 很远，应该做哪些优化呢？&lt;/p&gt;
&lt;p&gt;还是分类讨论，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是计算受限&lt;ul&gt;
&lt;li&gt;平衡操作：避免因为其他因素成为瓶颈。比如算子中一般浮点运算和浮点加法、浮点乘法的数量一样多，如果浮点加法 / 乘法资源太少、或者加法 / 乘法指令太少，则会导致浮点性能达不到最高&lt;/li&gt;
&lt;li&gt;提高 ILP 且使用 SIMD：避免指令瓶颈导致硬件资源 IDLE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果是带宽受限&lt;ul&gt;
&lt;li&gt;软件预取：提前取数，减少 memory 等待时间&lt;/li&gt;
&lt;li&gt;内存关联：从不同 memory 分散取数会导致性能下降，分配数据时尽量让 thread 和 data 都分配到同一个 processor 上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="fallacies-and-pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;谬论：Amdahl 定律不适用于并行计算机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 weak scaling 问题上得出的错误结论，Amdahl 定律仍然适用于并行计算机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：峰值性能可以代表实际性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先单核系统就很难达到峰值性能，其次多核并行处理时 Amdahl 定律也告诉我们想获得完美的峰值性能几乎不可能。更实际的做法是用 Roofline 模型来分析系统实际可以达到的整体性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：开发软件时不针对多核系统做优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件针对硬件专门设计，充分利用硬件资源，才能达到最高性能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：不用提升带宽就可以获得很高的 vector 性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 Roofline 模型可以看到，带宽对系统的性能有很大的影响。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单纯地把多个 processor 连接到一起并不能很轻易就获得高性能（并行软件很那写 + Amdahl 定律）&lt;/li&gt;
&lt;li&gt;计算机行业的未来已经绑定在并行化上了&lt;/li&gt;
&lt;li&gt;SIMD 和 vector 比 MIMD 的能效高&lt;/li&gt;
&lt;li&gt;想要达到高性能，程序员必须将自己的串行程序并行化，或者直接重写全新的并行程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>Patterson and Hennessy 学习笔记 #5 —— Chapter 5 Large and Fast:Exploiting Memory Hierarchy</title><link href="https://qian-gu.github.io/posts/ic/learning-patterson-and-hennessy-notes-5-chapter-5.html" rel="alternate"></link><published>2021-02-21T22:28:00+08:00</published><updated>2021-02-21T22:28:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2021-02-21:/posts/ic/learning-patterson-and-hennessy-notes-5-chapter-5.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，第五章&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;Ideally one would desire an indefinitely large memory capacity such that any particular ... word would be immediately available. ... We are ... forced to recognize the possibility of constructing a hierarchy of memories, each of which has greater capacity than the preceding but which is less quickly accessible.&lt;/p&gt;
&lt;p&gt;-- A. W. Burks, H. H. Goldstine, and J. von Neumann&lt;/p&gt;
&lt;p&gt;-Preliminary Discussion of the Logical Design of an Electronic Computing Instrument-, 1946&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;如前所述，码农和硅农之间有一个矛盾：码农希望内存无限大的同时访问速度足够快，而硅农手上的存储器容量大的速度不够快、速度快的容量不够大。实际上程序访问数据并不是完全随机的，&lt;strong&gt;局部性原理&lt;/strong&gt; 告诉我们，在任何时候程序大概率都是只访问地址空间中相对较小的一部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间局部性：如果某个数据被访问了，那么近期很可能会被再次访问&lt;/li&gt;
&lt;li&gt;空间局部性：如果某个数据被访问了，那么和它相邻的数据也很可能被访问&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;程序的局部性源自于它的结构：大部分程序都包含循环，所以有很高的时间局部性；程序顺序存储，所以有很高的空间局部性，而且顺序访问数据（数组）时，数据也有很高的空间局部性。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;所以解决前面矛盾的方式就是：利用局部性原理，构建存储器层级结构 &lt;code&gt;Memory Hierarchy&lt;/code&gt;，用最低的成本向用户提供尽可能大的存储容量的同时，使得速度和最快的存储器相当。&lt;/p&gt;
&lt;p&gt;Memory Hierarchy 的几个概念：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;概念&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;块 &lt;code&gt;block&lt;/code&gt;/ 行 &lt;code&gt;line&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对于任一相邻的两层来说，高层和底层之间交换数据的最小单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命中 &lt;code&gt;hit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;处理器需要的数据存储在高层存储器中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺失 &lt;code&gt;miss&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;处理器需要的数据没有存储在高层存储器中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命中率 &lt;code&gt;hit rate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在高层存储器中找到数据的访问比例，被当作 Memory Hierarchy 的性能指标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺失率 &lt;code&gt;miss rate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1 - hit rate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;命中时间 &lt;code&gt;hit time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;访问某层的时间，包含了判断 hit/miss 逻辑在内的的总时间开销&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;缺失惩罚 &lt;code&gt;miss penalty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从低层向高层搬运一个 block 的时间开销，包含了访问块、逐层传输、插入数据等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;Memory Hierarchy 对计算机的性能至关重要，硅农们为此设计了大量复杂精巧的设计，本章做了大量简化和抽象，只讨论最基本的知识。&lt;/p&gt;
&lt;p&gt;在大部分真实的计算机系统中，Memory Hierarchy 就是一个真实的层次结构，高低层之间是包含关系，这意味着一个数据除非出现在 i+1 层，否则它不可能出现在第 i 层。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="memory-technologies"&gt;Memory Technologies&lt;/h2&gt;
&lt;p&gt;主要有 4 种：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;种类&lt;/th&gt;
&lt;th&gt;价格&lt;/th&gt;
&lt;th&gt;速度&lt;/th&gt;
&lt;th&gt;应用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SRAM&lt;/td&gt;
&lt;td&gt;最贵&lt;/td&gt;
&lt;td&gt;最快&lt;/td&gt;
&lt;td&gt;cache/TCM&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRAM&lt;/td&gt;
&lt;td&gt;贵&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;DDR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Flash&lt;/td&gt;
&lt;td&gt;便宜&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;二级存储&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Magnetic disk&lt;/td&gt;
&lt;td&gt;最便宜&lt;/td&gt;
&lt;td&gt;最慢&lt;/td&gt;
&lt;td&gt;硬盘&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="caches"&gt;Caches&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;Cache 大概是 prediction 思想最重要的例子。依赖于局部性原理，Cache 可以靠自身的一套机制在预测错误时取回正确数据，现代计算机中的 Cache 的命中率通常保持在 95% 以上。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Cache 的形式就是一张 table，大概可以分成 3 个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valid 指示本 entry 是否有效&lt;/li&gt;
&lt;li&gt;tag 指示本 entry 保存的是 DDR 的哪个地址的数&lt;/li&gt;
&lt;li&gt;data 保存具体数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用地址索引 cache 时，地址会相应地被分成 3 部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;offset：索引 block 内部的 byte&lt;/li&gt;
&lt;li&gt;index：索引 block&lt;/li&gt;
&lt;li&gt;tag：和 cache 中的 tag 做比较&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;假设在 64bit 系统中有个直接映射的 cache，一共有 &lt;span class="math"&gt;\(2^n\)&lt;/span&gt; 个 block，每个 block 的大小为 &lt;span class="math"&gt;\(2^m\)&lt;/span&gt; 个 word，&lt;/p&gt;
&lt;p&gt;那么 offset 的位宽为 &lt;span class="math"&gt;\(m+2\)&lt;/span&gt; bit，index 的位宽为 &lt;span class="math"&gt;\(n\)&lt;/span&gt; bit，tag 的位宽为 &lt;span class="math"&gt;\(64-(m+2)-(n)\)&lt;/span&gt; bit，所以 cache 占用的总 bit 为，&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(2^n*(block\ size + tag\ size + valid\ size) = 2^n*(2^m*32 + (64-n-m-2) + 1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是一般说 cache 容量的时候都只指 data 部分的容量。所以 n = 10, m = 1 时，这个 cache 的容量是 4 KiB。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="mapping"&gt;Mapping&lt;/h3&gt;
&lt;p&gt;Cache 的组织方式可以分为 3 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;类比&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接相联 &lt;code&gt;directly associative&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;固定车位&lt;/td&gt;
&lt;td&gt;硬件简单&lt;/td&gt;
&lt;td&gt;冲突概率高，利用率低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全相联 &lt;code&gt;fully associative&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;随机车位&lt;/td&gt;
&lt;td&gt;冲突概率低、利用率高&lt;/td&gt;
&lt;td&gt;硬件实现复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组相联 &lt;code&gt;set associative&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;区域内随机&lt;/td&gt;
&lt;td&gt;折中&lt;/td&gt;
&lt;td&gt;折中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;直接相联和全相联可以看成是组相联的特例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接相联 = 1-way 组相联&lt;/li&gt;
&lt;li&gt;全相联 = 只有 1 个 set 的组相联&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般来说，在容量一定的前提下，混合 cache 的 miss rate 要比分离 cache 低一些。但是分离 cache 的带宽更高，这个优点的收益超过了 miss rate 的增加。&lt;/li&gt;
&lt;li&gt;多级 cache 的设计和最优化单级 cache 的设计理念是不一样的。和单级 cache 相比，多级 cache 中的第一级容量一般都更小，block 也更小，所以 miss penalty 也更小。而第二级一般比单级 cache 容量更大，因为第二级的访问时间的重要性没有那么高，容量更大的同时 block 也更大，为了降低 miss reate 一般第二级使用更高的相联度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="writing"&gt;Writing&lt;/h3&gt;
&lt;p&gt;如果是 hit 情况，可以有两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write through&lt;/code&gt;：把数据同时写入 cache 和 DDR&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write back&lt;/code&gt;：只把数据写入 cache，替换时再把该 block 全部写入 DDR&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;write through 的优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即使需要配合 write buffer，实现依然要比 write back 简单&lt;/li&gt;
&lt;li&gt;处理 miss 比较简单，因为不需要把 block 写入低层系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;write through 的缺点：&lt;/p&gt;
&lt;p&gt;性能很差。假设一个系统中有 10% 的 store 指令，直接写入 DDR 需要花费 100 个 cycle，而没有 cache miss 时的 CPI 为 1, 那么整个系统的 CPI 为 &lt;span class="math"&gt;\(1 + 100 * 10\% = 11\)&lt;/span&gt;，性能大概降低了 10 倍。&lt;/p&gt;
&lt;p&gt;write back 的优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速度快，可以以 cache 的速度接收单个 word&lt;/li&gt;
&lt;li&gt;同一个 word 的多次操作可以合并成一次低层操作&lt;/li&gt;
&lt;li&gt;一整块写回低层时，可以充分利用高带宽传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是 miss 情况，也可以有两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write non-allocate&lt;/code&gt;：直接把 block 写入 DDR&lt;/li&gt;
&lt;li&gt;&lt;code&gt;write allocate&lt;/code&gt;：把该 block 从 DDR 中读到 cache 中，分配空间保存，然后再替换成新数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;产生 write non-allocate 的主要原因是有些程序会写整个 block，比如操作系统可能会把 memory 中的某一个 page 全部填 0。在这种情况下，取回数据就没有必要了。&lt;/p&gt;
&lt;p&gt;一般 write through 和 write non-allocate 搭配，write back 和 write allocate 搭配。如果 write back 中某个被修改过的 block 发生了 miss，那么就必须先把该 block 写回到 DDR 然后再把新数据写入该 block。简单地直接用新数据覆盖该 block 会丢失之前的修改数据，因为这些数据没有在低层中进行备份。所以要完成这个过程要么花费两个 cycle（第一个 cycle 检查是否 hit，第二个周期执行写操作），要么使用 write buffer（只花费一个 cycle，先把修改的数据写入 DDR，在下一个周期把新数据从 buffer 写入 cache）。&lt;/p&gt;
&lt;h3 id="replacing"&gt;Replacing&lt;/h3&gt;
&lt;p&gt;常见的替换策略有 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机替换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FIFO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LRU&lt;/code&gt; (least recently used)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说，在相联度不低（2-way 或 4-way）的时候 LRU 的实现代价非常高，因为要追踪记录使用信息的代价很高。即使是 4-way 也是用近似的方法来实现：4-way 分成两组，先用 1bit 记录那一组是 LRU，再在组内使用 1bit 记录哪个 block 是 LRU。&lt;/p&gt;
&lt;h3 id="measuring-cache-performance"&gt;Measuring Cache Performance&lt;/h3&gt;
&lt;p&gt;CPU time 可以分成两部分：CPU 的执行时间 + 由于 memory 系统导致的 stall 时间。一般来说，cache hit 的开销时间算在执行时间内，所以有下面的公式：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(CPU\ time = (CPU\ execution\ clock\ cycles + Memory\ stall\ clock\ cycles) * Clock\ cycle\ time\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们假设 Memory stall 的时间开销主要来自于 cache miss，并且使用简化的 memory 模型。实际处理器中，读写产生的 stall 非常复杂，精确的性能预测通常需要对处理器和存储系统进行非常详细的仿真。所以我们可以定义下面的公式：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Memory\ stall\ clock\ cycles = (Read\ stall\ cycles + Write\ stall\ cycles)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中读的 cycle 数可以用每个程序中读指令的数量、读操作的 miss penalty、读 miss rate 三个因素来定义：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Read\ stall\ cycles = \frac{Reads}{Program} * Read\ miss\ rate * Read\ miss\ penalty\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;写的情况要复杂一些，对于 write through 的 cache 而言，分为两部分：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Write\ stall\ cycles = (\frac{Writes}{Program} * Write\ miss\ rate * Write\ miss\ penalty) + Write\ buffer\ stall\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为 write buffer 不仅和写指令的频率有关，还和写操作的执行时机有关，不能用简单公式来计算。幸运的是，如果系统设置合理，wirte buffer 的阻塞时间可以变得很小，近似忽略。如果系统设计不合理，则设计人员应该用更深的 write buffer 或者是使用 write back 机制。&lt;/p&gt;
&lt;p&gt;在大部分 write through 方案中，读写的 penalty 是一样的（都是从 DDR 中读回数据），假设 write buffer 部分可以忽略不计，则上面的公式可以简化为：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Memory\ stall\ clock\ cycles = \frac{Memory\ access}{Program} * Miss\ rate * Miss\ penalty\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或者是：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Memory\ stall\ clock\ cycles = \frac{Instrcutions}{Program} * \frac{Misses}{Instrcution} * Miss\ penalty\)&lt;/span&gt;&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;上面最后计算 memory stall clock cycles 的两个公式中，&lt;code&gt;miss rate&lt;/code&gt; 和 &lt;code&gt;miss/instruction&lt;/code&gt; 的含义并不一样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;miss rate&lt;/code&gt; 是标准定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;miss/instrcution&lt;/code&gt; 是把 miss 次数平摊到了包括计算指令的每一条指令中&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;也可以采用另外一种测量方式对 Cache 性能进行建模：每次访存的平均时间 &lt;code&gt;AMAT&lt;/code&gt;(Average memory aceess time)。显然，Cache 系统设计越合理，对 Core 表现出来的性能越好，AMAT 就越小。根据定义可以知道 AMAT 的计算公式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(AMAT = Time\ for\ a\ hit + Miss\ rate * Miss\ penalty\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于多级 Cache 系统，AMAT 公式如下（以两级 Cache 为例）：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(T_{avg}=H_1*C_1 + (1-H_1)*(H_2*(C_1 + C_2) + (1-H_2)*(C_1 + C_2 + M)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个符号的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(H_1\)&lt;/span&gt; 表示 L1 cache 的命中率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(H_2\)&lt;/span&gt; 表示 L2 cache 的命中率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_1\)&lt;/span&gt; 表示 L1 cache 命中访问时间&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_2\)&lt;/span&gt; 表示 L2 cache 命中访问时间（即 L1 miss 但是 L2 hit 的 penalty）&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(M\)&lt;/span&gt; 表示 DDR 的访问时间（即 L2 miss 的 penalty）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以换一种算法：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(T_{avg}= C_1 + (1-H_1)*C_2 + (1-H_1)*(1-H_2)*M\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以证明两种方式是等价的。&lt;/p&gt;
&lt;h3 id="the-three-cs"&gt;The Three Cs&lt;/h3&gt;
&lt;p&gt;所有的 miss 可以被分为 3 类（&lt;code&gt;3C&lt;/code&gt; 模型）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Compulsory Miss&lt;/code&gt; 强制失效 / &lt;code&gt;Cold Miss&lt;/code&gt; 冷启动失效&lt;/td&gt;
&lt;td&gt;对 Cache 中没有出现的数据第一次访问引起的失效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Capacity Miss&lt;/code&gt; 容量失效&lt;/td&gt;
&lt;td&gt;即使是全相联，因为容量有限，block 被替换后再次访问的失效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Conflict Miss&lt;/code&gt; 冲突失效 / &lt;code&gt;Collision Miss&lt;/code&gt; 碰撞失效&lt;/td&gt;
&lt;td&gt;多个 block 竞争同一个 set 时导致的冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这几种失效相互之间是关联的，改变设计中的某一方面会直接影响到其中某几种失效。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设计修改&lt;/th&gt;
&lt;th&gt;对 miss rate 的影响&lt;/th&gt;
&lt;th&gt;可能对性能产生的负面影响&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cache size ↑&lt;/td&gt;
&lt;td&gt;capacity miss ↓&lt;/td&gt;
&lt;td&gt;access latency ↑, hit time ↑, miss penality ↑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;block size ↑&lt;/td&gt;
&lt;td&gt;compulsory rate ↓&lt;/td&gt;
&lt;td&gt;miss penalty ↑, miss rate ↑ when very large block&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;associativity ↑&lt;/td&gt;
&lt;td&gt;conflict miss ↓&lt;/td&gt;
&lt;td&gt;access latency ↑, hit time ↑, miss penality ↑&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="controller"&gt;Controller&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式 Cache：基于 FSM 的控制器，必须要等到 Cache 处理完前一个请求后处理器才能继续执行&lt;/li&gt;
&lt;li&gt;非阻塞 Cache：性能更高&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="coherence"&gt;Coherence&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;coherence&lt;/code&gt;：定义了 read 操作返回什么数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;consistency&lt;/code&gt;：定义了 write 值什么时候才能被 read 操作返回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问题产生的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享数据在多个 cache 都有备份，多个备份之间会出现一致性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多核系统一般通过一种硬件协议来维护 cache 之间的一致性，这个协议叫做 &lt;code&gt;cache coherence protocals&lt;/code&gt; Cache 一致性协议。显然问题由共享数据引起，所以一致性协议的关键就在于追踪所有共享 block 的状态。&lt;/p&gt;
&lt;p&gt;最流行的一致性协议叫做 &lt;code&gt;snooping&lt;/code&gt; 窥探协议：每个 cache 不仅从 memory 中复制了 block 数据，同时还复制了 block 的状态，按照分布式的方式管理这些状态。每个 cache 都可以通过广播媒介（总线 / 网络）访问，而且每个 cache 控制器都会监听媒介，判断自己是否包含了当前总线上访问的数据。snooping 的实现比较简单，但是它的可扩展性比较低（因为不同所有 core 之间都要交互，复杂度和通信量成指数增长）。&lt;/p&gt;
&lt;p&gt;有种保证一致性的方法：确保每个 core 在写数据时是互斥访问，因为这种协议在写一个数据时会设置其他 cache 中的备份无效，所以叫做 &lt;code&gt;write invalidate protocal&lt;/code&gt;。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一般来说 cache 之间是以 block 为单位进行数据交换和更新，所以 block 大小对一致性的影响很大，增加 block 会导致 cache 之间的带宽需求上升。&lt;/p&gt;
&lt;p&gt;较大的 block 还会导致 &lt;code&gt;false sharing&lt;/code&gt; 的问题：2 个不相关的数据落到了同一个 block 中时，尽管两个 core 访问的是不同的数据，但是还是会发生数据交换。所以程序员和编译器要谨慎放置数据以避免发生假共享。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果一个存储系统满足了下面 3 个条件，就可以认为该存储系统是一致的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;处理器 P 对位置 X 的 write 后面紧跟着 P 对 X 的 read 操作，并且 write 和 read 之间没有其他处理器对 X 进行操作，那么 read 返回的一定是 write 的值&lt;/li&gt;
&lt;li&gt;在其他处理器对 X 完成 write 之后，P 对 X 进行 read 操作，这两个操作之间要有足够的时间间隔，并且没有其他处理器对 X 进行写操作，这是 P 的 read 返回的一定是 write 的数据&lt;/li&gt;
&lt;li&gt;对同一个地址的操作是串行执行的，即任何两个处理器对同一个地址的操作在所有处理器看来都是相同的顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;虽然上面的 3 个条件可以保证一致性，但是一个写数据什么时候对其他 core 可见也是一个重要问题。假设 core1 刚写了一个数据，core2 马上读相同地址，那么 core2 就不一定能读回最新值，因为可能写数据都还没离开 core1。这个写数据什么时候被其他 core 可以看到的问题叫做 &lt;code&gt;memory consistency model&lt;/code&gt; 内存一致性模型。&lt;/p&gt;
&lt;p&gt;我们做了两个假设：1. 一个 write 操作只有等所有 core 都可以看到写效果才能算是完成；2. 处理器不能修改访问 memory 的顺序。这两个限制可以允许 core 对 read 操作进行重拍序，但是强制要求 write 操作必须是程序顺序。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;因为系统的 input 可能会绕过 cache 直接改变 memory 的内容；output 可能也会用到 write-back cache 中的最新数据，所以单核系统中，就像多核之间的 cache 一样，I/O 和 cache 之间也有一致性问题。虽然这两种一致性问题的原因很相似，但是它们的特点不一样，所以解决方法也不一样。具体来说，I/O 包含多个数据备份的情况很少出现，而且要尽可能地避免这种情况；而多核系统中不同 cache 备份同一个数据则很常见。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;除了 snooping 这种分布式的监听协议外，基于目录的 cache 一致性协议（&lt;code&gt;directory-based cache coherence protocal&lt;/code&gt;）将物理存储器的共享块的状态集中存储在一个地点，叫做目录。虽然基于目录的协议要比监听方式的实现代价要高一些，但是这种方法可以减少 cache 之间的通信，所以可以扩展更多的处理器。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="dependable-memory-hierarchy"&gt;Dependable Memory Hierarchy&lt;/h2&gt;
&lt;p&gt;如果 memory hierarchy 只是单纯的追求速度，无法保证可靠性，那么它将毫无吸引力。如第一章介绍，dependability 的重要方法就是冗余。所以我们首先讨论如何定义和测量可靠性，然后再看看如何通过冗余设计出可靠的存储器。&lt;/p&gt;
&lt;h3 id="defining-failure"&gt;Defining Failure&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;概念&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;service accomplishment&lt;/td&gt;
&lt;td&gt;交付的服务与预期相符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;service interruption&lt;/td&gt;
&lt;td&gt;交付服务与预期不符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;failure&lt;/td&gt;
&lt;td&gt;从 accomplishment 到 interruption 的跳变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;restoration&lt;/td&gt;
&lt;td&gt;从 interruption 到 accomplishment 的跳变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reliability&lt;/td&gt;
&lt;td&gt;持续提供 accomplishment 能力的度量，从开始到 failure 的时间间隔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MTTF&lt;/code&gt;, mean time to failure&lt;/td&gt;
&lt;td&gt;reliability 的度量方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;AFR&lt;/code&gt;, annual failure rate&lt;/td&gt;
&lt;td&gt;给定 MTTF 时，设备在一年中出现 fail 的比例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MTTR&lt;/code&gt;, mean time to repair&lt;/td&gt;
&lt;td&gt;service interruption 的度量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;MTBF&lt;/code&gt;, mean time between failures&lt;/td&gt;
&lt;td&gt;= MTTF + MTTR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;availability&lt;/td&gt;
&lt;td&gt;连续两次 interruption 之间 accomplishment 能力的度量，计算公式如下&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Availability = \frac{MTTF}{MTTF + MTTR}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们希望系统有很高的可用性 availability，一种简单表示方法是 “ 可用性 9 的数量 ”，类似于黄金纯度一样，9 的数量越多表示可用性越好。增加 MTTF 或者是减少 MTTR 都可以提高可用性。&lt;/p&gt;
&lt;p&gt;为了提高 MTTF，可以提高元件的质量或者是设计一个不受元件故障的系统。因为元件故障不一定和导致系统 failure，所以专门定义一个词 fault 来表示元件的故障。有 3 种方法提高 MTTF：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fault avoidance&lt;/code&gt;：合理构建系统避免发生 fault&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fault tolerance&lt;/code&gt;：采用冗余措施，发生 fault 时系统仍然正常工作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fault forecasting&lt;/code&gt;：预测故障，在发生之前替换失效元件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了减小 MTTR，可以采用检测、诊断、修复工具来处理 failure。&lt;/p&gt;
&lt;h3 id="hamming-secded"&gt;Hamming SEC/DED&lt;/h3&gt;
&lt;p&gt;Richard Hamming 因为发明这个编码于 1968 年获得图灵奖。如果一种编码可以检测出是否发生 1 bit 错误，我们将其称为 1 bit 错误检测编码 error detection code。&lt;/p&gt;
&lt;p&gt;Hamming 编码采用 “ 奇偶校验 ” 码来检测是否发生错误：统计码字中 1 的数量，然后根据统计结果设置校验位（奇数为 1, 偶数为 0）。所以 N+1 的总 bit 中 1 的个数永远是偶数个，如果从 memory 中读出的数据包含奇数个 1, 那么就说明发生了错误。&lt;/p&gt;
&lt;p&gt;显然，这个方案只能检测到奇数个错误的情况，而且同时发生 3 个错误的概率非常小，所以一般用来检查 1 bit 错误。&lt;/p&gt;
&lt;p&gt;Hamming 为了实现纠正错误的目的，设计一种将数据映射到距离为 3 的码字的方式，为了表达敬意，我们称为 Hamming Error Correction Code, &lt;code&gt;ECC&lt;/code&gt;。因为这种编码可以纠正 1bit 错误，检测 2bit 的错误，所以叫做 Single Error Correcting/Double Error Detecting (SEC/DED)，它广泛地应用于服务器的内存中。一般 8 byte 的数据正好需要 1byte 的额外开销，所以许多双列直插式存储模块 DIMM 的宽度是 72 bit。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一般 SEC/DED 一般在存储器中属于典型情况，而在网络传输中，发生突然错误情况比较典型，这个时候采用的是循环冗余校验 Cyclic Redundancy Check, &lt;code&gt;CRC&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="virtual-memory"&gt;Virtual Memory&lt;/h2&gt;
&lt;p&gt;DDR 也可以充当 disk 的 “cache”，这种技术叫做虚拟存储器 &lt;code&gt;virtual memory&lt;/code&gt;，就像 cache 一样，局部性原理也适用于 VM。&lt;/p&gt;
&lt;p&gt;相似点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;cache&lt;/th&gt;
&lt;th&gt;virtual memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;block&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;page&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cache miss&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;page fault&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;index&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;virutal page number&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;page offset&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;cache&lt;/th&gt;
&lt;th&gt;page table&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;存储在 SRAM 中&lt;/td&gt;
&lt;td&gt;存储在 DDR 中，需要 TLB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;penalty 小（几百个 cycle）&lt;/td&gt;
&lt;td&gt;penalty 巨大（几百万个 cycle）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无地址转换&lt;/td&gt;
&lt;td&gt;有地址转换，&lt;code&gt;virtual page number&lt;/code&gt; --&amp;gt; &lt;code&gt;physical page number&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多种组织方式&lt;/td&gt;
&lt;td&gt;全相联 only&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬件替换算法&lt;/td&gt;
&lt;td&gt;软件替换算法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多种 write 策略&lt;/td&gt;
&lt;td&gt;只能是 write-back&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可能需要 tag 位域&lt;/td&gt;
&lt;td&gt;全相联不需要 tag 位域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;需要 data 位域&lt;/td&gt;
&lt;td&gt;地址映射表，不需要 data 位域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;block&lt;/code&gt; 容量小，32/64B&lt;/td&gt;
&lt;td&gt;&lt;code&gt;page&lt;/code&gt; 容量大，4KiB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为每个程序都有自己的地址空间，所以 VM 要实现从程序地址空间到物理地址之间的转换，这个转换操作加强了一个程序的地址空间和其他 VM 之间的保护。virutal page number 比 physical page number 多得多是描述一个无限容量的虚拟存储器假象的基础。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;virtual address&lt;/code&gt; = {&lt;code&gt;virtual page number&lt;/code&gt;, &lt;code&gt;page offset&lt;/code&gt;} ==&amp;gt; &lt;code&gt;pyhsical address&lt;/code&gt; = {&lt;code&gt;physical page number&lt;/code&gt;, &lt;code&gt;page offset&lt;/code&gt;}&lt;/p&gt;
&lt;p&gt;page fault 的代价非常高，每次都要花费几百万个 cycle 才能完成处理（DDR 的速度大概是 disk 的 100,000 倍）。所以 VM 系统的很多设计决策都受 page fault 的影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;page 必须要足够大，以缓解很长的访问时间。典型 page 的大小为 4～16 KB&lt;/li&gt;
&lt;li&gt;采用全相联的结构来降低 page fault&lt;/li&gt;
&lt;li&gt;通过软件处理，软件相比于 disk 的开销非常小，而且可以采用聪明的替换算法，至少能稍微降低一点 miss rate，算法的开销就值了&lt;/li&gt;
&lt;li&gt;不可能使用 write through，只能用 write-back&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mapping-replacing"&gt;Mapping &amp;amp; Replacing&lt;/h3&gt;
&lt;p&gt;如上所述，因为 page faut 的代价太高了，所以为了尽可能地降低发生概率，VM 采用全相联的组织方式，允许 virtual page 可以映射到任何一个 physical page 上，这样操作系统就可以在发生 page fault 时用复杂的算法和数据结构跟踪 page 的使用过程，然后选择某个在长时间不会用到的 page 进行替换。&lt;/p&gt;
&lt;p&gt;但是全相联的查询复杂度非常高，基本上不可实现，所以 VM 通过一个存储在 DDR 中的特殊的结构 &lt;code&gt;page table&lt;/code&gt; 来查询：用 virtual page number 查询 physical page number。因为每个程序都有自己的地址空间，所以有自己的 page table，为了找到自己的 page table，会有一个寄存器 &lt;code&gt;page table register&lt;/code&gt; 指向它。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;page table + PC + 其他寄存器，三者就确定了一个 virtual machine 的状态，这个状态就叫做进程 &lt;code&gt;process&lt;/code&gt;。切换进程时，操作系统只是简单地加载 page table register 即可。由操作系统负责分配物理地址空间以及 page table 的更新。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="page-fault"&gt;Page Fault&lt;/h3&gt;
&lt;p&gt;因为 virtual page 可能会映射到 DDR 中，也有可能会映射到 disk 中，所以操作系统一般会在创建每个 process 时开辟一段空间来存储所有的 page，这个空间就叫做 &lt;code&gt;swap space&lt;/code&gt;。所以相应地就需要一个数据结构来记录 virtual page 到底是在 DDR 中还是 disk 中，只需要 1bit 的 valid 即可，从逻辑上讲，virtual page 到 DDR 和 disk 的映射是同一张表，但是一般是按照两张独立的表来实现的。&lt;/p&gt;
&lt;p&gt;发生 page falut 时，操作系统通过软件算法（LRU）选定要被替换的 page，把它存储到 swap 区域。&lt;/p&gt;
&lt;h3 id="wrting-tlb"&gt;Wrting &amp;amp; TLB&lt;/h3&gt;
&lt;p&gt;因为写回的代价太高了，所以只能用 write-back 的方式把一整块 page 都写回。&lt;/p&gt;
&lt;p&gt;程序的每次 memory 访问都需要完成两个步骤：首先查询 page table 得到 physical address，然后根据查询到的地址获取数据。提高访问性能的关键就在于 page table 的访问也有局部性：如果查询了某个 page number，那么很可能会再次查询它，因为它指向的数据具有局部性。&lt;/p&gt;
&lt;p&gt;所以处理器会包含一个特殊的叫作 &lt;code&gt;TLB&lt;/code&gt;(Translation-Lookaside Buffer) 的 cache 用来追踪最近使用过的地址变换。所以 TLB 的读写操作也遵守前面 cache 的讨论，简单的一次读操作的流程如下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;                lookup TLB
read reference -----------&amp;gt; hit ---------------------------&amp;gt; translate
                    |                                            ^
                    |            lookup page table               |
                    |-----&amp;gt; miss -----------------&amp;gt; hit ---&amp;gt; loading into TLB
                                             |
                                             |----&amp;gt; miss --&amp;gt; OS.exception handle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为 TLB 是一个小 cache，所以它的设计考虑因素和规格都符合前面 cache 部分的讨论。下面是一个典型配置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;规格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TLB size&lt;/td&gt;
&lt;td&gt;16 - 512 entries&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;block size&lt;/td&gt;
&lt;td&gt;1-2 page entries (typically 4-8 Byte)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hit time&lt;/td&gt;
&lt;td&gt;0.5 - 1 cycle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;miss penalty&lt;/td&gt;
&lt;td&gt;10 - 100 cycle&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;miss rate&lt;/td&gt;
&lt;td&gt;0.01% - 1%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="fallacies-and-pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;陷阱：写代码或通过 compiler 生成代码时忽略 memory 系统的行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外一个描述是：在写代码时，程序员可以忽略存储器存储结构。显然，这个结论是错误的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：模拟一个 cache 时，忘记说明 byte 地址和 block 大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要区分清楚 byte 地址、block 地址，word 地址。举例说明，假设有个容量为 36 Byte 的 cache，block 大小为 4 Byte，那么内存地址 36 的 block 地址是 9，所以映射到 block1 中（&lt;span class="math"&gt;\(9\ modulo\ 8 = 1\)&lt;/span&gt;）；如果 36 是 word 地址，那么它会映射到 block4 中（&lt;span class="math"&gt;\(36\ modulo\ 8 = 4\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：对于共享 cache，组相联度 &amp;lt; 核的数量 / 共享该 cache 的线程数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 way 数比 core/ 线程数量少时，可能会有严重的性能缺陷。比如，32 个 core 竞争同一个 set 内的 16 个 way，性能很差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：用平均的 memory 访问时间来评估 out-of-order 处理器的存储器层次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果发生 miss 时处理器阻塞，那么就可以用平均时间来评估；如果是乱序执行的处理器，可能在 miss 时会继续执行其他指令，此时要准确评估存储器层次的唯一办法就是模拟乱序执行处理器和存储器层次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬误：disk 实际的故障率和规格书中的一致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际评估的结果表明并不相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬误：操作系统是调度 disk 访问的最佳地方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;磁盘自己知道逻辑地址和映射的物理地址，所以磁盘比操作系统好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：为一个不支持虚拟化的 ISA 实现虚拟机监视器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某些 ISA 要支持 VMM 必须新增一些其他指令。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部性原理让我们可以在保持 memory 低成本的同时获取高性能&lt;/li&gt;
&lt;li&gt;cache 的基本设计包含了组织方式、更新算法、写回策略等&lt;/li&gt;
&lt;li&gt;3C 模型可以用来对 cache 性能的建模&lt;/li&gt;
&lt;li&gt;virtual memory 是 DDR 对 disk 的特殊 &lt;code&gt;cache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多级 cache 的优化更加方便，优化方式也更多&lt;/li&gt;
&lt;li&gt;借助软件，重新组织代码也可以提高局部性&lt;/li&gt;
&lt;li&gt;硬件预取也可以提高性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;图书馆系统和 memory hierarchy 很相似：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;图书馆&lt;/th&gt;
&lt;th&gt;cache / virtual memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;书&lt;/td&gt;
&lt;td&gt;cache block / page&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询书桌的时间&lt;/td&gt;
&lt;td&gt;hit time&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从书架拿书到书桌的时间&lt;/td&gt;
&lt;td&gt;miss penalty&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书桌放满了书，必须放回才能拿回新书&lt;/td&gt;
&lt;td&gt;cache replace&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书桌太大，查询变慢&lt;/td&gt;
&lt;td&gt;cache 容量变大，latency 也变大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书名&lt;/td&gt;
&lt;td&gt;virtual address&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书的索书号&lt;/td&gt;
&lt;td&gt;physical address&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;书名 &amp;lt;-&amp;gt; 索书号查询系统&lt;/td&gt;
&lt;td&gt;page table&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;记录索书号的小纸片&lt;/td&gt;
&lt;td&gt;TLB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以问题也可以类比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;图书馆问题&lt;/th&gt;
&lt;th&gt;图书馆解决方法&lt;/th&gt;
&lt;th&gt;对应的 memory 问题&lt;/th&gt;
&lt;th&gt;memory hierarchy 解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;每次只拿一本，往返换书太慢&lt;/td&gt;
&lt;td&gt;使用书桌一次性放好几本书&lt;/td&gt;
&lt;td&gt;访问 DDR 太慢&lt;/td&gt;
&lt;td&gt;使用 cache&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每次都查询目录太慢&lt;/td&gt;
&lt;td&gt;用小纸条抄写一小段目录&lt;/td&gt;
&lt;td&gt;从 DDR 查询 page table 速度太慢&lt;/td&gt;
&lt;td&gt;TLB 存储部分 page table&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>Patterson and Hennessy 学习笔记 #4 —— Chapter 4 The Processor</title><link href="https://qian-gu.github.io/posts/ic/learning-patterson-and-hennessy-notes-4-chapter-4.html" rel="alternate"></link><published>2020-12-20T22:28:00+08:00</published><updated>2020-12-20T22:28:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-12-20:/posts/ic/learning-patterson-and-hennessy-notes-4-chapter-4.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，第四章&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;In a major matter, no details are small.&lt;/p&gt;
&lt;p&gt;-- French Proverb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;第一章中提到，影响一个计算机性能的因素有 3 个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指令总数&lt;/li&gt;
&lt;li&gt;时钟周期&lt;/li&gt;
&lt;li&gt;每条指令的执行时钟数（CPI）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从第二章可知对于一个特定程序，由编译器和 ISA 共同决定了第一个因素：指令总数。而一个 processor 的实现决定了另外两个因素，所以这章介绍 RISC-V 处理器 &lt;code&gt;control path&lt;/code&gt; 和 &lt;code&gt;data path&lt;/code&gt; 的两种不同实现方案。&lt;/p&gt;
&lt;h2 id="a-simple-implementation-scheme"&gt;A Simple Implementation Scheme&lt;/h2&gt;
&lt;p&gt;从 RISC-V ISA 中挑选出三种具有代表性的指令组成一个小子集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代表和 memory 交互的 &lt;code&gt;ld&lt;/code&gt;, &lt;code&gt;st&lt;/code&gt; 指令&lt;/li&gt;
&lt;li&gt;代表算术 - 逻辑运算的 &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; 指令&lt;/li&gt;
&lt;li&gt;代表分支运算的 &lt;code&gt;beq&lt;/code&gt; 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个小子集非常具有代表性，其他指令的处理基本上都和这几个指令类似，搞懂了这几个指令的处理，其他指令的处理也就大同小异。以实现这个小子集为目标，处理器核设计的经典问题如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取指：如何产生下一个 PC&lt;/li&gt;
&lt;li&gt;译码：如何产生内部控制信号&lt;/li&gt;
&lt;li&gt;读操作数：register file 的设计（包括端口数量、实现方式）&lt;/li&gt;
&lt;li&gt;执行：如何根据控制信号复用 ALU 等单元，完成算术运算、分支判断、访存地址计算 etc&lt;/li&gt;
&lt;li&gt;访存：如何访问 memory&lt;/li&gt;
&lt;li&gt;写回：未涉及&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面几个问题可以分成 &lt;code&gt;control path&lt;/code&gt; 和 &lt;code&gt;data path&lt;/code&gt; 两大类，各个击破。&lt;/p&gt;
&lt;p&gt;架构具体框图略（Figure 4.17）。这个实现方案中一条指令的所有处理都在一个 cycle 内完成，所有组合逻辑都在一起，显然这个方案的主频非常低。虽然 CPI 是 1, 但是时钟周期实在是太长了，所以性能非常差。历史上早期 CPU 的 ISA 非常简单，所以确实曾经用过这种实现方案，但是现在基本是不可接受的。&lt;/p&gt;
&lt;p&gt;因为时钟周期要覆盖最恶劣的组合逻辑路径，所以即使我们尝试使用实现技巧优化大部分常见情况，单周期版本的实现方案的性能不会有任何提升，这和 &lt;strong&gt;common case fast&lt;/strong&gt; 这一伟大思想相违背。&lt;/p&gt;
&lt;h2 id="an-overview-of-pipeling"&gt;An Overview of Pipeling&lt;/h2&gt;
&lt;p&gt;Pipeline 的基本概念，是在一个很长的组合逻辑路径中插入寄存器，切分成多个小段，这样时钟周期只需要 cover 住 latency 最长的小段即可，因此 Pipeline 可以提高时钟频率。需要注意的是插入寄存器后，处理单条指令的总时间（&lt;code&gt;latency&lt;/code&gt;）实际上变长了，因为寄存器翻转也需要时间，但是由于指令可以重叠在一起并行处理，所以 Pipeline 提高系统的吞吐率（&lt;code&gt;throughput&lt;/code&gt;），提高了整体性能（所有指令的总处理时间变小）。&lt;/p&gt;
&lt;p&gt;假设整个组合逻辑被切分成 n 个 latency 相似的 stage，每个 stage 的 latency 为 T₀，则单周期方案需要的总时间为&lt;/p&gt;
&lt;div class="math"&gt;$$T_{nopipe} = n * T_0$$&lt;/div&gt;
&lt;p&gt;而 pipeline 方案，假设指令之间没有冒险，则所有之间直接可以完美重叠，则每条指令的执行时间为&lt;/p&gt;
&lt;div class="math"&gt;$$T_{pipe} = T_0$$&lt;/div&gt;
&lt;p&gt;显然在理想情况下，pipeline 版本的性能近似可以提高 n 倍，流水线切分地越细，每条指令的执行时间 T 就越小，性能越高。一般低端 MCU 大概 2～3 个 stage，而高端 CPU 高达 10 个 stage。&lt;/p&gt;
&lt;p&gt;性能提升 n 倍是非常理想的理论数据，实际上有很多因素导致最终效果稍差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stage 并不是均匀切分&lt;/li&gt;
&lt;li&gt;指令之间有冒险，不能完美重叠&lt;/li&gt;
&lt;li&gt;流水线建立和撤销的开销&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很容易就可以分析得出结论：当指令数量非常多时，近似可以忽略第三个因素。关于第二个因素 &lt;strong&gt;冒险&lt;/strong&gt; 可以分为三类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;结构冒险 &lt;code&gt;structural hazard&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;硬件 busy 无法计算下一条指令&lt;/td&gt;
&lt;td&gt;硬件资源复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据冒险 &lt;code&gt;data hazard&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数据依赖 RAW 等&lt;/td&gt;
&lt;td&gt;&lt;code&gt;forward&lt;/code&gt; / &lt;code&gt;rename&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制冒险 &lt;code&gt;contrl hazard&lt;/code&gt;/ 分支冒险 &lt;code&gt;branch hazard&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;取指不正确导致指令不能在预定时钟周期内执行&lt;/td&gt;
&lt;td&gt;&lt;code&gt;prediction&lt;/code&gt;(&lt;code&gt;BTB&lt;/code&gt;/&lt;code&gt;BTH&lt;/code&gt;) / delay slot&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;基本上每个 stage 都有对应的核心问题需要解决，各种各样的解决方案实现复杂度、消耗的资源和达到的性能都不相同，这些解决方案按照不同的方式组合在一起，就形成了高中低等不同系列的 CPU。关于每个 stage 的问题及解决方案可以扩展出很多内容。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;除了存储系统外，pipeline 的有效运作是决定一个处理器 CPI 的最重要因素。不管实现方案是否简单、性能高低，结构冒险、数据冒险、控制冒险这三种冒险是 pipeline 中非常重要的问题。一般来说，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构冒险通常发生 FPU 中，因为它无法做到完全的 pipeline&lt;/li&gt;
&lt;li&gt;控制冒险通常发生在整数程序中，因为这些程序中 branch 出现概率很高&lt;/li&gt;
&lt;li&gt;数据冒险在整数、浮点中都会出现，一般浮点因为规则的存储和较低概率的条件分支所以更好处理一些，而整数更难处理一些&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有很多基于软硬件的技术通过调度来减少数据之间的依赖。&lt;/p&gt;
&lt;p&gt;Pipeline 是一个非常伟大的思想，基本上计算机体系结构的非常大一部分都是围绕着它做优化设计，虽然它可以提高性能，但是并不是没有代价，其中之一就是电路的复杂化，现代处理器多发射乱序执行的超标量处理器想想就非常复杂。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="a-pipelined-scheme"&gt;A Pipelined Scheme&lt;/h2&gt;
&lt;p&gt;流水线可以按照很多方式划分，其中最典型的是 MIPS 的 &lt;strong&gt;经典 5 级流水线&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IF&lt;/code&gt;：取指&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt;：译码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EX&lt;/code&gt;：执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MEM&lt;/code&gt;：访存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WR&lt;/code&gt;：写回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个 pipeline 里面，大部分数据流都是从左向右流动，只有两条是反向的，而这两条路径会引起两类冒险：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一条是 WR 阶段，执行执行结果写回到 regfile 中 ==&amp;gt; 数据冒险&lt;/li&gt;
&lt;li&gt;第二条是 IF 阶段，选择下一条 PC 的取值 ==&amp;gt; 控制冒险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体框图略（Figure 4.49）&lt;/p&gt;
&lt;h2 id="exceptions"&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;控制通路是处理器设计中最难的部分：正确控制和达到高频率都非常困难。控制必须处理的一个问题是 &lt;code&gt;exception&lt;/code&gt; 和 &lt;code&gt;interrupt&lt;/code&gt;，它们是除 branch 指令之外可以控制程序流的事件，主要用来处理 CPU 内部的 unexpected 事件，比如未定义的指令格式等。&lt;/p&gt;
&lt;p&gt;许多架构中并不区分这两个概念，统称为 interrupt，比如 x86 。RISC-V 对这两种情况做了区分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;exception&lt;/strong&gt;: 无论是内部还是外部原因，导致程序控制流发生变化的 unexpected change&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;interrupt&lt;/strong&gt;：只用来描述外部因素导致控制流发生变化的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件类型&lt;/th&gt;
&lt;th&gt;由何处产生&lt;/th&gt;
&lt;th&gt;RISC-V 术语&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统复位&lt;/td&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;td&gt;Exception&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O 设备请求&lt;/td&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;td&gt;Interrupt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户程序唤醒操作系统&lt;/td&gt;
&lt;td&gt;内部&lt;/td&gt;
&lt;td&gt;Exception&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用未定义指令&lt;/td&gt;
&lt;td&gt;内部&lt;/td&gt;
&lt;td&gt;Exception&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬件故障&lt;/td&gt;
&lt;td&gt;内外均可&lt;/td&gt;
&lt;td&gt;两个术语均可&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RISC-V 处理 Exception 时要做的事情就是：保存异常现场，然后把控制权交给操作系统，由操作系统完成合适的处理，比如执行某些提前定义好的处理、定制运行程序、上报 error 等，然后操作系统根据情况决定是否要中止程序还是继续运行。&lt;/p&gt;
&lt;p&gt;操作系统要完成异常处理，必须要知道异常的原因和导致异常的指令，有两种方法传递这个信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用寄存器保存异常信息（&lt;code&gt;SPEC&lt;/code&gt; / &lt;code&gt;SCAUSE&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;使用向量中断 &lt;code&gt;vectored interrupts&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC-V 中没有使用向量中断，而是使用寄存器作为所有异常的单一入口，所以需要对寄存器内容做一些译码才能知道异常原因。对于 Exception 的处理和 branch 预测失败的处理非常相似，实际上硬件就是把 Exception 当成另外一种形式的 &lt;code&gt;control hazard&lt;/code&gt; 来处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;flush 流水线，然后从一个特定地址（中断处理程序）重新取指&lt;/p&gt;
&lt;p&gt;一般来说，要在 Ex 阶段就要把 Exception 指令 flush 掉，否则错误结果会写入到 dst 寄存器中，导致覆盖原来的有效值。很多时候，发生 Exception 的指令最终还是要正确执行完成的，所以最简单方法就是完成异常处理后重新取指、执行这条指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存 Exception 现场&lt;/p&gt;
&lt;p&gt;RISC-V 中定义了两个寄存器来保存异常现场：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;supervisor exception program counter (&lt;code&gt;SPEC&lt;/code&gt;) 保存异常指令的地址&lt;/li&gt;
&lt;li&gt;supervisor exception cause register (&lt;code&gt;SCAUSE&lt;/code&gt;) 有个特殊字段保存异常原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Exception 处理中，要把 pipeline 中每一个 Exception 和相对应的指令对应起来是非常难的，所以有些设计者会在非关键情况下放松要求，这种叫做非精确中断 / 异常（&lt;code&gt;imprecise interrupt&lt;/code&gt;/&lt;code&gt;imprecise exception&lt;/code&gt;），也就是说引起异常的某一条指令，但是硬件记录的其实是另外一条指令，由操作系统去判断具体是哪一条引起的异常。与其相对的，严格要求的叫做精确中断 / 异常（&lt;code&gt;precise interrupt&lt;/code&gt;/&lt;code&gt;precise exception&lt;/code&gt;）。RISC-V 等一些处理器都支持精确异常，部分原因是非精确异常对操作系统来说很头疼，所以对于 pipeline 很深的设计一般要求要把发生异常时流水线上的所有指令都记录下来，这样做对硬件和软件来说都比较容易（另外一个原因是为了支持虚拟存储器）。&lt;/p&gt;
&lt;h2 id="parallelism-via-instructions"&gt;Parallelism via Instructions&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这部分只是简述，《量化分析》中花费了一整个章节和附录，一共大概 200 多页来展开详细描述。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如前所述，pipeline 可以挖掘指令之间潜在的并行潜力，这种并行性叫做 Instructions Level Parallelism (&lt;code&gt;ILP&lt;/code&gt;)。要想提高 ILP 一共有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增加 pipeline 的深度，让更多的指令可以重叠在一起&lt;/p&gt;
&lt;p&gt;stage 切分地越多，时钟频率也越高，理论性能提升上限就越高（前面分析的 n 倍），实际中有其他因素限制，并不是线性无线增长。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多发射 &lt;code&gt;multiple issue&lt;/code&gt;，复制内部的硬件资源，使得每个周期可以启动更多的指令&lt;/p&gt;
&lt;p&gt;多发射可以让 CPI 的值小于 1，比如一个 5 stage 的 3GHz 4-way 多发射处理器的峰值性能是 1.2 billion instruction/second，最小 CPI 是 0.25，每个 cycle 最多可以并行执行 20 条指令。现在高端处理器一般都是 3～6 发射，一些中端处理器的目标是 IPC = 2。实际上，指令并行多发射的前提条件非常多，比如指令之间有依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现多发射的方式可以大致分为两类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;static multiple issue&lt;/code&gt; 静态多发射&lt;/td&gt;
&lt;td&gt;编译器在编译时就已经做好了指令发射的判断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dynamic multiple issue&lt;/code&gt; 动态多发射&lt;/td&gt;
&lt;td&gt;硬件在执行时做发射的相关判断&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;无论是那种实现方式，都需要解决下面这两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;把指令打包到 &lt;code&gt;issue slot&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;即处理器如何判断在某个 cycle 下应该发射多少条、哪些指令？在静态发射处理器中大部分工作都由编译器负责处理，而在动态发射处理器中，虽然编译器也会做一部分优化工作，比如调整指令顺序，但是大部分工作都是主要由硬件负责完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理 &lt;code&gt;data hazard&lt;/code&gt; 和 &lt;code&gt;control hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在静态处理器中由编译器处理所有的数据冒险和控制冒险，而绝大多数动态发射处理器在运行时通过硬件技术消除冒险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然分成了静态和动态两类，实际上这些方法之间都是相互借鉴的，没有任何一种方法是纯粹独立的。&lt;/p&gt;
&lt;h3 id="the-concept-of-speculation"&gt;The Concept of Speculation&lt;/h3&gt;
&lt;p&gt;发掘 ILP 的一个重要方法是推测 Speculation，基于伟大思想之一的 &lt;strong&gt;prediction&lt;/strong&gt;，speculation 是一种通过猜测指令运行结果，以使得依赖此指令的其他指令可以提前执行的方法。比如可以推测一个 branch 指令的结果，然后就可以提前执行 branch 之后的其他指令；另外一个例子是假设有 store 和 load 两条指令，推测它们指向不同地址，然后就可以把 load 放在 store 之前运行。&lt;/p&gt;
&lt;p&gt;显然肯定会有推测出错的情况，所以任何推测机制都需要有某种方法可以检查推测结果是否正确，如果出错了要能回滚推测状态的指令结果。&lt;/p&gt;
&lt;p&gt;推测可以由软件完成，也可以由硬件完成。这两种方法处理推测错误的方式也非常不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件方式：编译器一般会插入额外的检查推测正确性的指令，如果出错了会提供一个修复例程&lt;/li&gt;
&lt;li&gt;硬件方式：先把推测指令的结果 buffer 起来，等待解除了推测状态后写入到 register file/memory 中，如果推测错了则 flush 流水线，重新取正确的指令执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果处理得当，推测可以提高性能，反之会降低性能。下面详细展开静态 / 动态发射两种方案中的推测技术。&lt;/p&gt;
&lt;h3 id="static-multiple-issue"&gt;Static Multiple Issue&lt;/h3&gt;
&lt;p&gt;所有的静态多发射处理器都会用到编译器来辅助完成指令打包和处理冒险这两个问题。某个时钟周期下同时发射的指令叫做 &lt;code&gt;issue packet&lt;/code&gt;，可以把它们看成是一条更宽、同时操作多个操作数的 “ 大指令 ”，这就是 Very Long Instruction Word （&lt;code&gt;VLIW&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;大部分静态多发射处理器都依赖于编译器来完成一些冒险处理，但是实现方式千差万别：有些实现中编译器负责移除所有的冒险，比如调度指令顺序，插入 nop 指令等，因此硬件完全不需要任何冒险检测和 stall 控制逻辑；有些实现中编译器只保证 packet 内部无冒险，而 packet 之间的冒险需要硬件负责。&lt;/p&gt;
&lt;p&gt;根据上面的讨论，假设我们有一个简单的静态双发射处理器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只允许 ALU/Branch 和 Load/Store 指令打包在一起（嵌入式处理器的常见设计）&lt;/li&gt;
&lt;li&gt;每个 cycle 发射的指令按照 64bit 对齐打包，且 ALU/Branch 在 LSB（通常为了简化译码逻辑，打包指令的格式有严格要求）&lt;/li&gt;
&lt;li&gt;如果不满足打包要求，则使用 Nop 凑数&lt;/li&gt;
&lt;li&gt;编译器负责 packet 内部无冒险，硬件负责处理 packet 之间的冒险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要实现这个规格，我们需要做下面一些改变：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增 packet 之间的冒险检测和 stall 控制逻辑&lt;/li&gt;
&lt;li&gt;register file 新增读写端口&lt;/li&gt;
&lt;li&gt;额外的硬件资源执行指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显然双发射最高可以将性能提高 2 倍，但是实际上因为各种开销和限制因素，很难达到理论效果，而且为了有效地挖掘多发射的潜在性能，对编译器和硬件调度技术要求很高。对于循环来说，有一种非常重要的优化技术就是 loop unrolling，即循环展开，通过循环展开把不同迭代次数的指令重叠在一起，从而挖掘出更高的 ILP。&lt;/p&gt;
&lt;p&gt;书里面有个例子，对下面这段程序重排序，使得其在上述双发射处理器上的性能达到尽可能高。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nl"&gt;Loop:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;ld&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;x31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// x31=array element&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;x31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;x21&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;// add scalar in x21&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nf"&gt;sd&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="no"&gt;x31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// store result&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nf"&gt;addi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-8&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// decrement pointer&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nf"&gt;blt&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;x22&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;x20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;Loop&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// branch if x20 &amp;gt; x22&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;仔细分析代码，就可以知道前 3 条指令之间有依赖，最后两条指之间也有依赖，只有一对指令可以打包到一起，所以需要用 4 个 cycle 完成 5 条指令，IPC = 5/4 = 1.25，离理论最大值 2 差距很大。&lt;/p&gt;
&lt;p&gt;重排序结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;ALU/Branch instr&lt;/th&gt;
&lt;th&gt;Load/Store instr&lt;/th&gt;
&lt;th&gt;clock Cycle&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Loop&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ld x31, 0(x20)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;addi x20, x20, -8&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;add x31, x31, x21&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;blt x22, x20, Loop&lt;/td&gt;
&lt;td&gt;sd x31, 8(x20)&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;按照 4 倍循环展开的结果：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;ALU/Branch instr&lt;/th&gt;
&lt;th&gt;Load/Store instr&lt;/th&gt;
&lt;th&gt;clock Cycle&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Loop&lt;/td&gt;
&lt;td&gt;addi x20, x20, -32&lt;/td&gt;
&lt;td&gt;ld x28, 0(x20)&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ld x29, 24(x20)&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;add x28, x28, x21&lt;/td&gt;
&lt;td&gt;ld x30, 16(x20)&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;add x29, x29, x21&lt;/td&gt;
&lt;td&gt;ld x31,  8(x20)&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;add x30, x30, x21&lt;/td&gt;
&lt;td&gt;sd x28, 32(x20)&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;add x31, x31, x21&lt;/td&gt;
&lt;td&gt;sd x29, 24(x20)&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;sd x30, 16(x20)&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;blt x22, x20, Loop&lt;/td&gt;
&lt;td&gt;sd x31,  8(x20)&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;经过循环展开后，8 个 cyle 可以完成 14 条指令，IPC = 14/8 = 1.75，如果迭代总次数为 4 次，则总时间由原来的 20 个 cycle 变为 8 个 cycle，而付出的代价就是需要使用额外的 4 个寄存器，同时代码体积也变为原来的 2 倍。&lt;/p&gt;
&lt;h3 id="dynamic-multiple-issue"&gt;Dynamic Multiple Issue&lt;/h3&gt;
&lt;p&gt;动态多发射处理器有个非常有名的外号 —— 超标量处理器 &lt;code&gt;superscalar processor&lt;/code&gt;，在最简单的超标量处理器中，指令是顺序发射的，由硬件决定当前时钟周期能否发射多少条并行指令。显然在这种超标量处理器上还是需要编译器配合优化才能达到最高的发射速率，得到最好的性能。&lt;/p&gt;
&lt;p&gt;虽然同样都需要编译器调度，但是 superscalar 和 VLIW 在本质上是不同的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;superscalar 无论有无编译器调度，而且无论发射速率和流水线结构怎么变化，代码都可以正确执行&lt;/li&gt;
&lt;li&gt;VLIW 必须要有编译器调度，而且在不同平台上运行时通常都要重新编译才能正确运行，即使有些处理器正确性可以保证，但是往往因为性能仍然需要重新编译&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;许多 superscalar 把动态发射算法扩展成一整套体系：&lt;code&gt;dynamic pipeline scheduling&lt;/code&gt;，即动态调度算法。最经典的动态调度算法就是 Tomasolu 算法，涉及到的术语有 &lt;code&gt;reservation station&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;reorder buffer&lt;/code&gt;, &lt;code&gt;out-of-order execution&lt;/code&gt;, &lt;code&gt;in-order commit&lt;/code&gt; 等，这里不展开描述。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;目前所有动态调度算法都使用 in-order commit。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;既然编译器也可以做调度，为什么 superscalar 还需要用动态调度算法呢？原因大概有 3 个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器无法预测所有的 stall，特别是 cache miss 等，动态调度可以让处理器隐藏某些 stall&lt;/li&gt;
&lt;li&gt;使用动态分支预测时，如果不搭配动态调度则 ILP 的性能提升非常有限&lt;/li&gt;
&lt;li&gt;静态调度无法适应硬件平台切换，必须重新编译，而动态调度不需要重新编译，对软件不可见，代码复用高&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;现代高性能处理器都可以在每个 cycle 发射多条指令，但是很不幸的是要维持高 issue rate 非常困难。比如，虽然现在处理器都可以达到 4～6 发射的并行度，但几乎没有什么应用可以保持在 2 以上的发射速率，主要原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要性能瓶颈来自于无法避免的 data hazard，虽然基本无法优化真数据依赖 RAW，但是编译器和硬件通常连是否存在依赖都不确定，所以只能保守地认为存在依赖。一般来说，ILP 总是有优化空间的，但是因为太分散（可能存在于上千条指令之间），编译器和硬件往往力不从心。&lt;/li&gt;
&lt;li&gt;memory hierarchy 的损失会导致 pipeline 无法保持满负荷运行，虽然有些 stall 可以掩盖起来，但是有限的 ILP 无法掩盖所有 stall。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h3 id="energy-efficiency"&gt;Energy Efficiency&lt;/h3&gt;
&lt;p&gt;动态调度算法和推测执行虽然可以挖掘 ILP，提高性能，但是代价之一就是更高的功耗。因为现在我们遇到了功耗墙的问题，所以目前的趋势是舍弃超长的 pipeline 和贪婪的推测算法，而是转向多核。&lt;/p&gt;
&lt;h2 id="fallacies-and-pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;谬论：pipeline 非常简单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;呵呵。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：pipeline 的概念和实现工艺无关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然，工艺的实现难度和代价会反过来影响设计的取舍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：没有考虑到 ISA 的设计会反过来影响到 pipeline 的设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多复杂的 ISA 会导致实现的困难，这也是 RISC-V 的设计目标之一：用简单的 ISA 简化硬件设计，以达到更高的主频和性能。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pipeline 可以提高 throughput 但是不能减少 latency&lt;/li&gt;
&lt;li&gt;pipeline 和 multiple issue 都可以提高 ILP&lt;/li&gt;
&lt;li&gt;hazard 限制了可以达到的性能上限&lt;/li&gt;
&lt;li&gt;static multiple issue 依赖编译器发现、解决 hazard&lt;/li&gt;
&lt;li&gt;dynamic multiple issue 依赖硬件发现、解决 hazard&lt;/li&gt;
&lt;li&gt;基于软件 / 硬件实现的 scheduling 和 speculation 是降低 data hazard 负面效果的主要手段&lt;/li&gt;
&lt;li&gt;在功耗墙的背景下，现在的趋势是舍弃以前超深的流水线和复杂的推测算法，转向多核，在更粗粒度上寻求并行性&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>Patterson and Hennessy 学习笔记 #3 —— Chapter 3 Arithmetic For Computers</title><link href="https://qian-gu.github.io/posts/ic/learning-patterson-and-hennessy-notes-3-chapter-3.html" rel="alternate"></link><published>2020-12-13T12:55:00+08:00</published><updated>2020-12-13T12:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-12-13:/posts/ic/learning-patterson-and-hennessy-notes-3-chapter-3.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，第三章&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;Numerical precision is the very soul of science.&lt;/p&gt;
&lt;p&gt;-- Sir D'arcy Wentworth Thompson,On Grwth and Form, 1917&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="integer"&gt;Integer&lt;/h2&gt;
&lt;h3 id="addition-subtraction"&gt;Addition &amp;amp; Subtraction&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;处理 overflow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为寄存器位宽是有限的，所以会产生 overflow，一般计算机都提供了 overflow 检测。对于补码形式的 signed 类型数据检测方法很简单，根据操作数、结果的符号位以及操作类型分类讨论判断即可。而对于 unsigned 类型而言，一般这些数据都是用来计算内存地址，产生的 overflow 都被忽略了。编译器可以用 branch 指令来检测 unsigned 类型数据是否发生了 overflow：加法的结果是否比任何一个加数都小，或者减法的结果是否比任何一个减数都大。&lt;/p&gt;
&lt;p&gt;检测出发生了 overflow 之后应该怎么办呢？C 和 Java 会忽略 integer 的 overflow，但是 Ada 和 Fortran 要求必须通知程序，所以程序猿或者是编程环境要决定发生 overflow 时该如何处理。&lt;/p&gt;
&lt;p&gt;和 overflow 相对的有一种不常见的处理：饱和处理 saturation。这种操作一般都出现在多媒体的相关处理中，比如音量的最大限度等例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加法器的设计是一个非常经典的 IC 话题，它的速度取决于进位链的速度，有很多技术会预测进位 bit，其最坏的结果就是进位时间是 log2(W) 的函数（其中 W 是加法器的位宽）。这些预测信号的逻辑门更少所以速度更快，付出的代价就是消耗了更多的硬件资源来预测进位信号的正确值，最流行的结构就是超前进位加法器 &lt;code&gt;CLA&lt;/code&gt;(carry lookahead adder)。&lt;/p&gt;
&lt;h3 id="multiplication"&gt;Multiplication&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(1010 * 1011 = 0110\_1110\)&lt;/span&gt;，动手算一下就知道将 1010 和 1011 解释成 10 进制数或者是 2 进制等式都是成立的，因为他们的原理都一样：移位相加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最简单直接的思路：模仿人类手工计算过程，相与 -&amp;gt; 移位 -&amp;gt; 相加&lt;/p&gt;
&lt;p&gt;只有一个加法器和移位器，时分复用，具体模块框图见原文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更快速的实现方案：资源换速度，乘法器展开&lt;/p&gt;
&lt;p&gt;前面的方案只有一个硬件通过若干次重复计算后累加出结果，将这个过程展开（unroll）就可以得到一个更快的（latency 更小）方案：给乘数的每一 bit 都和被乘数相与，然后相邻 bit 的结果相加，显然宽度是 W 的乘法只需要 W 个加法器，latency 是 W 个加法器 latency 的总和。显然这个组合逻辑太大了时钟频率很可能上不去。继续优化的思路是：采用并行树的方式。latency 只有 &lt;span class="math"&gt;\(log2(W)\)&lt;/span&gt; 次加法，代价是消耗了更多的硬件资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ALU 中的方案：&lt;/p&gt;
&lt;p&gt;使用前面提到的超前进位加法器 &lt;code&gt;carry save adders&lt;/code&gt; 来构造乘法器，速度更快而且可以做成 pipeline 形式，提高吞吐率。最常见的实现方法是 booth-wallace + CLA 实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Signed 处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Q：如何处理 signed/unsigned？&lt;/p&gt;
&lt;p&gt;A：最简单的方法，先将 signed 转化为 unsigned，符号位单独处理（这个规则也适用于 signed 数据的其他运算）&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;乘法器的设计和优化也是 IC 设计中的一个经典话题，历经几十年的发展，从最原始的阵列乘法器发展到经典的 booth-wallace 乘法器，目前仍然有很多相关研究和论文，其中大部分都是基于 booth 乘法器的结构或追求性能、或追求面积、或追求功耗等。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="division"&gt;Division&lt;/h3&gt;
&lt;p&gt;比乘法的使用频率更底，也更诡异，可能会出现无效运算：除数为 0 的情况。&lt;/p&gt;
&lt;div class="math"&gt;$$Dividend = Quotient * Divisor + Remainder$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最简单直接的思路：与乘法器同理，模仿人类手工计算过程，移位 -&amp;gt; 相减&lt;/p&gt;
&lt;p&gt;具体模块框图见原文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速的除法器：&lt;code&gt;RST division&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无法直接像乘法那样展开成多个加法器来加速，因为除法必须先算出前一次迭代结果的符号位之后才能开始下一次的迭代。加速除法的思路：每次迭代产生商的若干 bit，而不仅仅是 1bit。RST division 技术就是每次迭代的时候，基于 dividend 和 remainder 的高位 bit 来预测 quotient 的若干 bit，如果预测错了后面的步骤需要纠正这个错误。目前一般是每次预测 quotient 的 4bit 结果，这个算法的准确度取决于查找表中的是否有合适的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更快的除法器：&lt;code&gt;non-restoring division&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前面两种都是 restoring 除法，每次迭代相减的结果是负数，需要将 divisor 恢复回去。不恢复的数学原理是：&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$(r+d)*2-d=r*2+d*2-d=r*2+d$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更更快的除法器：&lt;code&gt;non-performing division&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果移位相减的结果是负数，则不保存减法的结果，平均减少 1/3 的算术操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Signed 处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Q：如何处理 signed/unsigned？&lt;/p&gt;
&lt;p&gt;A：需要特别注意 signed 除法必须保证 &lt;span class="math"&gt;\(-(x \div y)=(-x)\div y\)&lt;/span&gt;，也即&lt;strong&gt;保证 dividend 和 remainder 的符号必须相同。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;RISC-V 除法指令会忽略 overflow，所以软件必须自己检测 quotient 是否发生了溢出；对于除 0 运算也是一样，软件必须自己检测。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="float-point"&gt;Float Point&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;科学计数法：小数点左边只有 1 位整数的表示方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;normalized number&lt;/code&gt;：没有 leading 0s&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于二进制浮点数，标准格式是：&lt;/p&gt;
&lt;div class="math"&gt;$$1.xyz\ast2^{abc}$$&lt;/div&gt;
&lt;p&gt;因为 word 的位宽是固定的，所以浮点数必须在 fraction 和 exponent 之间做折中，也就是精度和范围之间的取舍，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 fraction 的 bit 位数可以提高精度但是会减小表示的范围&lt;/li&gt;
&lt;li&gt;增加 exponent 的 bit 位数可以扩大表示范围，但是会降低表示精度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如 chapter 2 所述，&lt;strong&gt;一个好的设计需要有合理的折中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;float 数的表示方法实际上就是 sign-and-magnitude 方式，1bit 符号 + E bit 指数 + F bit 尾数，表示的数据大小为：&lt;/p&gt;
&lt;div class="math"&gt;$$(-1)^S * F * 2^E$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;处理 overflow&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;float 同理也会有 overflow 和 underflow，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;overflow：正的指数太大无法完整保存在 exponent 字段&lt;/li&gt;
&lt;li&gt;underflow：负的指数太大无法完整保存在 exponent 字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决 overflow/underflow 的方法很简单粗暴，增加 bit 即可：即 double 数据类型。&lt;/p&gt;
&lt;p&gt;如果发生了 overflow/underflow 应该怎么通知用户呢？一些计算机会发出 exception 或者是 interrupts，然后由异常 / 中断处理程序来完成后续工作。但是 RISC-V 不会发出 exception 和 interrupt，而是要求软件查询 &lt;code&gt;floating-point control and status register (fcsr)&lt;/code&gt; 这个寄存器来判断是否发生了 overflow/underflow。&lt;/p&gt;
&lt;h3 id="ieee-754-floating-point-standard"&gt;IEEE 754 Floating Point Standard&lt;/h3&gt;
&lt;p&gt;1980 年之后的所有 PC 都遵守这个标准，754 对浮点数做了进一步的规定，对许多特殊数都有定义，比如正负无穷和 NaN 等，具体标准内容略。&lt;/p&gt;
&lt;h3 id="arithmetic"&gt;Arithmetic&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;加法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和人类手工计算过程类似，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先对齐 exponent&lt;/li&gt;
&lt;li&gt;然后计算 fraction&lt;/li&gt;
&lt;li&gt;对结果进行 normalize&lt;/li&gt;
&lt;li&gt;对结果进行 round&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;乘法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指数部分相加&lt;/li&gt;
&lt;li&gt;尾数部分相乘&lt;/li&gt;
&lt;li&gt;normalize 乘积&lt;/li&gt;
&lt;li&gt;round 乘积&lt;/li&gt;
&lt;li&gt;设置符号位&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="subword-parallelism"&gt;Subword Parallelism&lt;/h3&gt;
&lt;p&gt;多媒体处理一般处理的数据要比 word 窄，而且这些数据的操作都是相同的，所以就出现了一种新技术：通过对进位链的分割，实现 word 内部的数据的并行计算，相比于收益来说这种分割的代价是非常小的。&lt;/p&gt;
&lt;p&gt;这种在一个 word 内部进行并行操作的技术叫做 &lt;code&gt;subword parallelism&lt;/code&gt;，有时候也分到更加宏观的类别 &lt;code&gt;data parallelism&lt;/code&gt; 中，这种技术有时候也叫做 &lt;code&gt;vector&lt;/code&gt; 或者是 &lt;code&gt;SIMD&lt;/code&gt;。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;目前 RISC-V 的向量指令还处于 draft 阶段，但是向量指令是现在的发展趋势，在未来必不可少。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="fallacies-and-pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算的错误和谬论一般都是由 “ 计算机的数据是有限位宽的，而自然数是无限的 ” 这一矛盾产生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：就像左移指令可以代替 2 的指数次的乘法，右移指令可以代替除数是 2 的指数的除法运算。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 unsigned 类型来说的确如此，但是对于 signed 类型的数据则显然不对，负数右移后在高位补充符号位，最后会永远是 -1，不会变成 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：结合律不适用于浮点运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于 integer 的运算，即使会发生 overflow 结合律也是适用的。但是对于浮点数，结合律是不适用的，因为计算机内的浮点数是用有限的 bit 来近似真实的数字，无法保存 overflow 的数字。这里有意思的是，对于定点的整数而言即使发生了 overflow 结合律仍然是适用的，找个例子就可以验证下面的等式是成立的，&lt;/p&gt;
&lt;div class="math"&gt;$$-128+127+3 = -128+(127+3) = -128+(-126)=2$$&lt;/div&gt;
&lt;p&gt;原因也很简单：整数运算 overflow 只会影响高位 bit，低位 bit 是不受影响的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：并行执行策略不仅适用于 integer 类型，也适用于 float 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上一条已经证明了结合律不适用于 float 类型，所以并行执行策略不一定适合 float 类型。所以写并行代码并且使用了浮点数的时候，程序猿要自己判断结果是不是可靠的，处理这个问题的领域叫做数值分析，关于这个问题本身就可以写一本书了。这也是 &lt;code&gt;LAPACK&lt;/code&gt; 和 &lt;code&gt;SCALAPAK&lt;/code&gt; 这类数学库流行的原因，它们的顺序执行和并行执行都已经被验证过是有效的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：只有理论数学家才关心 float 数的精度问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个经典故事，Intel 的 Pentium 系列处理器就出现过相关问题，为此付出了 5 亿美元召回有 bug 的芯片。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本算术单元是 ALU 的核心组件&lt;/li&gt;
&lt;li&gt;加法器、乘法器、除法器、integer/float 的处理每个 topic 都是经典问题&lt;/li&gt;
&lt;li&gt;不同定位的处理器的性能差别的一个重要因素就是 ALU 中这些组件的实现方式和性能不同，这是个折中取舍的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>Patterson and Hennessy 学习笔记 #2 —— Chapter 2 Instructions: Language of the Computer</title><link href="https://qian-gu.github.io/posts/ic/learning-patterson-and-hennessy-notes-2-chapter-2.html" rel="alternate"></link><published>2020-11-29T21:49:00+08:00</published><updated>2020-11-29T21:49:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-11-29:/posts/ic/learning-patterson-and-hennessy-notes-2-chapter-2.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，第二章&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;I speak Spanish to God, Italian to women, French to men, and German to my horse.&lt;/p&gt;
&lt;p&gt;-- Charles V, Holy Roman Emperor&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;计算机和人很像，要让它服从指挥，就必须使用它的 “ 语言 ”。计算机语言中基本的单词是指令 &lt;code&gt;instructions&lt;/code&gt;，整个词汇表叫做指令集（合）&lt;code&gt;instruction set&lt;/code&gt;。使用不同指令集的计算机就像是不同地方的人，而且指令集之间的区别像是同一种语言的不同 “ 方言 ”，所以掌握了一个指令集，其他的就很容易掌握了。不同指令集之所以能做到相似，并不是一件偶然事件，而是有其背后的道理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的计算机用到的硬件技术有着相似的底层原则&lt;/li&gt;
&lt;li&gt;所有的计算机都必须提供一组最基本的操作&lt;/li&gt;
&lt;li&gt;计算机设计者有着共同的目标：找到一种语言（ISA），在最大化性能、最小化成本和能耗的前提下，可以轻松地构建硬件和编译器&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;It is easy to see by formal-logical methods that there exist certain [instruction
sets] that are in abstract adequate to control and cause the execution of any
sequence of operations.... The really decisive considerations from the present
point of view, in selecting an [instruction set], are more of a practical nature:
simplicity of the equipment demanded by the [instruction set], and the clarity of
its application to the actually important problems together with the speed of its
handling of those problems.&lt;/p&gt;
&lt;p&gt;-- Burks, Goldstine, and von Neumann, 1947&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Simplicity of the equipment&lt;/strong&gt; 这个设计哲学不仅适用于 1950 年代也适用于现代计算机。本章的内容就是学习一种遵循这个哲学的 ISA —— &lt;code&gt;RISC-V&lt;/code&gt;，主要内容如下，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件中如何体现这一哲学&lt;/li&gt;
&lt;li&gt;高层编程语言和底层原语之间如何映射&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition info"&gt;
&lt;p class="admonition-title"&gt;Info&lt;/p&gt;
&lt;p&gt;如原文所说，每个小节围绕一个指令子集，讲清楚设计原理和高层编程语言的关系，这种 top-down, step-by-step 的方式可以做到真正的深入浅出，让你不仅知其然，还知其所以然，所谓圣经不是浪得虚名。很多资料（特别是国内的教科书）不注重知识背后的原理和方法，采用灌输式的方法，很容易打击学习者的兴趣。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="three-principles-of-hardware-design"&gt;Three Principles of Hardware Design&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Simplicity favors regularity. 简单源于规整&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RISC-V 中的很有算术指令都和加法类似，很自然地有 3 个操作数：两个源操作数，一个目的操作数。显然操作数数量固定要比动态变化更简单，“ 让所有的指令都包含相同数量的操作数 ” 体现了 &lt;strong&gt;keep the hardware simple&lt;/strong&gt; 这一设计哲学。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Smaller is faster. 越小越快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和高层编程语言不同的是，算术指令的操作数必须来自有限个寄存器 &lt;code&gt;register&lt;/code&gt;。寄存器是硬件的基本元素，而且对程序员是可见的，所以可以把它看作是构造计算机这个 “ 建筑 ” 的 “ 砖块 ”。RV64 中的寄存器宽度为 64bit，因为 64bit 非常频繁地出现，所以 RV 架构给它起了一个特别的名字：&lt;code&gt;doubleword&lt;/code&gt;，对应地给 32bit 起名叫 &lt;code&gt;word&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;高层编程语言中的变量和硬件中的寄存器的一个主要区别就是：寄存器数量是有限的，一般为 32 个。把寄存器限制在 32 个原因就是本条设计原则：越小越快。道理很显然，寄存器越多，mux 就越复杂时钟频率也就越低。&lt;/p&gt;
&lt;p&gt;这个原则并不是绝对的，31 个寄存器也不见得就比 32 个寄存器更快（不要钻牛角尖抬杠），但是这个原则依然非常重要。计算机设计者必须平衡好一组矛盾：程序希望寄存器越多越好，而硬件希望寄存器少一些以提高时钟频率。RISC-V 使用 32 个而不是 31 个寄存器的另一个原因是指令格式中的 bit 数（rs 和 rd 使用 5bit 编码）正好可以寻址 32 个寄存器。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;因为寄存器的数量远小于程序中的变量数，所以编译器会将常用的变量放在寄存器中，不常用的变量放在 memory 中，有需要时再从 memory 中读到寄存器中使用。把不常用的变量存回到 memory 的过程叫做寄存器溢出 &lt;code&gt;spilling&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;显然，register 和 memory 相比，访问时间短、吞吐率高、功耗小，所以为了获得更高的性能，节约功耗，ISA 中必须有足够的 register，而且编译器也必须高效使用它们。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;显然，寄存器是硬件的核心元素，有效使用寄存器是提高程序性能的关键。RISC-V 的命名惯例：每个寄存器以 &lt;code&gt;x&lt;/code&gt; 开头，后面加上序号，所以寄存器的名字为 &lt;code&gt;x0&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;, ... &lt;code&gt;x31&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Good design demands good compromises. 优秀的设计需要合适的折中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由前面的设计规则可知，我们既想让所有的指令长度都相等，又想让它们的格式都保持一致，这样硬件实现起来最简单。但是实际上只定义一种指令格式是无法满足需求的，这里产生了矛盾。RISC-V 采用了折中方案：&lt;/p&gt;
&lt;p&gt;保持所有指令长度相同，但是为不同类型的指令设计了不同的指令格式。&lt;/p&gt;
&lt;p&gt;RISC-V 一共定义了 4 种类型的指令：&lt;code&gt;R&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;，其中 &lt;code&gt;S&lt;/code&gt; 类型有一个变种类型 &lt;code&gt;SB&lt;/code&gt; 类型，&lt;code&gt;U&lt;/code&gt; 类型有个变种 &lt;code&gt;UJ&lt;/code&gt; 类型，详细的指令格式参考 RISC-V 的 spec 即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="endian"&gt;Endian&lt;/h2&gt;
&lt;p&gt;一般 memory 都使用的是 byte 地址，当有个数据长度超过一个 byte 时，就会遇到大小端问题：应该以哪个 byte 地址作为这个数据的地址呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用数据最左边的 bit 的地址（即 big end 的 byte）作为数据的寻址地址&lt;/li&gt;
&lt;li&gt;使用数据最右边的 bit 的地址（即 little end 的 byte）作为数据的寻址地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RISC 采用的是 little-endian 类型。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;很多体系结构中，要求 word 的地址必须是 4Byte 对齐，doubleword 的地址必须是 8Byte 对齐。RISC-V 和 x86 没有对齐约束，但是 MIPS 有约束。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;许多程序中都会用到常数，比如地址自增 1 来自动指向数组中的下一个元素。如果每次都从 memory 中用 load 指令来搬运这个常数则显得很低效，解决方法就是把常数放在指令中。常数作为操作数是非常常见的，实际上，&lt;code&gt;addi&lt;/code&gt; 是 RISC-V 中最常见的指令。而常数 0 更加重要，它可以提供各种用法来简化指令集。比如，想得到一个数的相反数，则用 0 减去它即可。所以 RISC-V 用专用的寄存器 &lt;code&gt;x0&lt;/code&gt; 来存储常数 0。（&lt;strong&gt;common case fast&lt;/strong&gt; 哲学的体现）&lt;/p&gt;
&lt;h2 id="signed-and-unsigned-numbers"&gt;Signed and Unsigned Numbers&lt;/h2&gt;
&lt;p&gt;参考以前的一篇总结：&lt;a href="https://qian-gu.github.io/posts/cs/signed-number-representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="addressing-modes"&gt;Addressing Modes&lt;/h2&gt;
&lt;p&gt;RISC-V 一共有 4 种寻址模式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寻址类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Immediate addressing 立即数寻址&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;操作数是常数，保存在指令当中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Register addressing 寄存器寻址&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;操作数保存在寄存器中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Base/displacement addressing 基址寻址&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;操作数保存在 memory 中，其地址为寄存器和指令中常数相加的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;PC-relative addressing PC 相对寻址&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;分支指令中，跳转地址为 PC 和指令中的常数相加的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="fallacies-and-pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;谬论：更强大的指令意味着更高的性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RISC 和 CISC 之争，现在的趋势是大部分都转向 RISC，连 x86 指令也通过内部的微码化来模拟 RISC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：使用汇编语言编程来获取最高性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在很久以前，编译器性能还不够好时，汇编程序员是占优势的。但是通过不断的改进，现在编译器产生的代码与手工编写的汇编代码在性能上的差距在快速缩小。一个汇编程序员想要和编译器竞争，必须对计算机体系结构中的流水线和存储器层次有非常深刻的理解才行。&lt;/p&gt;
&lt;p&gt;即使手工编写的代码速度更快，但是还是不应该选择这种方法，原因如下，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;花费更多的 coding 时间&lt;/li&gt;
&lt;li&gt;可移植性差&lt;/li&gt;
&lt;li&gt;难以维护&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;陷阱：商用计算机二进制向后兼容的重要性意味着成功的指令集不需要改变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;x86 指令的演变用事实说明，在保持向后兼容神圣不可侵犯的同时，也要不断地添加新指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：忘记 byte 寻址的机器中连续的 word/doubleword 地址相差不是 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编代码容易出错的例子：必须程序员自己清楚地计算地址，而用高级语言则不需要考虑这些因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：在 automatic 类型变量的定义域外面使用指针指向该变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是汇编还是高级语言，都要注意这一点，常见的新手易犯的编程错误。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Less is more.&lt;/p&gt;
&lt;p&gt;-- Robert Browning, Andrea del Sarto, 1855&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;stored-program 计算机的两大准则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指令和数据都是数字&lt;/li&gt;
&lt;li&gt;使用可以修改的存储器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这两个概念，一台计算机上就可以运行不同的程序，应用在各个领域。&lt;/p&gt;
&lt;p&gt;为机器选择指令集需要在指令数量、单条指令的运行 cycle 数、时钟频率等因素之间做精妙的平衡。本章提供了 3 条准则来指导指令集的设计者如何做一些 tricky 的折中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Simplicity favors regularity.&lt;/li&gt;
&lt;li&gt;Smaller is faster.&lt;/li&gt;
&lt;li&gt;Good design demands good compromises.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指令集的设计中也应用到了计算机体系结构领域中的 common cast fast 原则，比如 RISC-V 中对于条件分支指令使用 PC 相对寻址，对于大位宽的常数操作数使用立即数寻址。&lt;/p&gt;
&lt;p&gt;RISC-V 中每个类型的指令都有对应的编程语言中的元素，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RISC-V 指令类型&lt;/th&gt;
&lt;th&gt;编程元素&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算术指令&lt;/td&gt;
&lt;td&gt;赋值语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输指令&lt;/td&gt;
&lt;td&gt;处理数组 / 结构体之类的数据结构的语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;条件分支指令&lt;/td&gt;
&lt;td&gt;if/for 等语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无条件分支指令&lt;/td&gt;
&lt;td&gt;函数调用 / 返回，case/switch 语句&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些指令并不是平等的，有一小部分指令出现的频率非常高。指令出现概率的不同在 datapath，control，pipeline 中扮演着非常重要的角色。&lt;/p&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>Patterson and Hennessy 学习笔记 #1 —— Chapter 1 Computer Abstractions and Technology</title><link href="https://qian-gu.github.io/posts/ic/learning-patterson-and-hennessy-notes-1-chapter-1.html" rel="alternate"></link><published>2020-11-22T14:51:00+08:00</published><updated>2020-11-22T14:51:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-11-22:/posts/ic/learning-patterson-and-hennessy-notes-1-chapter-1.html</id><summary type="html">&lt;p&gt;Patterson and Hennessy 读书笔记，前言 + 第一章&lt;/p&gt;</summary><content type="html">&lt;p&gt;写在前面的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Computer-Organization-Design-RISC-V-Architecture/dp/0128122757"&gt;Computer Organization and Design&lt;/a&gt; 俗称 Patterson and Hennessy&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.amazon.com/Computer-Architecture-Quantitative-Approach-Kaufmann/dp/0128119055/"&gt;Computer Architecture: A Quantitative Approach&lt;/a&gt; 俗称 Hennessy and Patterson&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两本书有共同内容但是因为定位不同，所以内容也相互补充。&lt;a href="https://www.amazon.com/Computer-Architecture-Quantitative-Approach-Kaufmann/dp/0128119055/"&gt;Computer Architecture: A Quantitative Approach&lt;/a&gt; 这本书是针对专业人士的，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用坚实的工程基础和量化的 cost/performance 折中分析方法来描述计算机体系结构中的主要原则&lt;/li&gt;
&lt;li&gt;基于商用的实际系统，结合例子和评测数据，总结出一些实际中的设计经验&lt;/li&gt;
&lt;li&gt;证明体系结构可以通过量化而不是描述性的方式学习&lt;/li&gt;
&lt;li&gt;目标读者是严肃的，想仔细理解计算机系统的专家&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而 Patterson &amp;amp; Hennessy 这本书的读者并不都是想成为计算机体系结构的专家。这本书并不是前者的子集，还包括了一些其他知识，比如编译器、操作系统、数据库等等。作者的观点是：&lt;strong&gt;对于下一个十年内的大部分码农来说，如果想写出可以在并行计算机上高效运行的程序，则必须理解软硬件接口。&lt;/strong&gt;这本书的读者包括，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;几乎没有汇编 / 逻辑设计基础，但是需要理解基本的计算机组成原理&lt;/li&gt;
&lt;li&gt;有汇编 / 逻辑设计基础，但是想了解如何设计一个计算机，或者想理解一个系统是如何工作以及为何性能如此&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Civilization advances by extending the number of important operations which we can perform without thinking about them.&lt;/p&gt;
&lt;p&gt;-- Alfred North Whithead, An Introduction to Mathematics, 1911&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="understanding-program-performance"&gt;Understanding Program Performance&lt;/h2&gt;
&lt;p&gt;一个程序的性能取决于很多因素的组合，包括，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序用到的算法的效率&lt;/li&gt;
&lt;li&gt;把程序翻译成机器指令的软件工具&lt;/li&gt;
&lt;li&gt;计算机执行指令的效率（包括 I/O 操作）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下表总结了这些因素是如何影响程序性能的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件 / 硬件&lt;/th&gt;
&lt;th&gt;如何影响到性能&lt;/th&gt;
&lt;th&gt;哪一章会涉及到&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算法&lt;/td&gt;
&lt;td&gt;决定了源码级别的语句数量，I/O 操作的数量&lt;/td&gt;
&lt;td&gt;整本书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编程语言、编译器、架构&lt;/td&gt;
&lt;td&gt;决定了每句源码对应的计算机指令数量&lt;/td&gt;
&lt;td&gt;第 2, 3 章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;处理器、memory 系统&lt;/td&gt;
&lt;td&gt;决定了指令的执行速度&lt;/td&gt;
&lt;td&gt;第 4, 5, 6 章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I/O 系统（硬件 &amp;amp; 操作系统）&lt;/td&gt;
&lt;td&gt;决定了 I/O 操作的速度&lt;/td&gt;
&lt;td&gt;第 4, 5, 6 章&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;书里面以一个实例（矩阵和向量的乘法）来证明这些因素的影响，通过一系列的优化，例子的性能最终提高了大概 200 倍！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 3 章在 &lt;code&gt;data-level parallelism&lt;/code&gt; 层次，使用 C 语言的 intrinsics 可以使性能提高 3.8 倍&lt;/li&gt;
&lt;li&gt;第 4 章在 &lt;code&gt;instruction-level parallelism&lt;/code&gt; 层级，使用 loop unrolling 实现指令的多发射，乱序执行，可以使性能提高 2.3 倍&lt;/li&gt;
&lt;li&gt;第 5 章在 &lt;code&gt;memory hierarchy optimization&lt;/code&gt; 层次，使用 cache blocking 可以使性能提高 2.0 到 2.5 倍&lt;/li&gt;
&lt;li&gt;第 6 章在 &lt;code&gt;thread-level parallelism&lt;/code&gt; 层次，使用 parallel for loops in OpenMP 实现多核计算，可以使性能提高 4 到 14 倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="8-great-ideas-in-computer-architecture"&gt;8 Great Ideas in Computer Architecture&lt;/h2&gt;
&lt;p&gt;设计计算机系统中的 8 个最伟大的思想，从第一台计算机到现在，这些思想仍然被广泛采用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Design for Moore's Law&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;摩尔定律：电路的集成度每 18 ~ 24 个月翻一倍。&lt;/p&gt;
&lt;p&gt;Intel 的创始人之一 Gordon Moore 在 1965 年作出的预测。因为计算机的设计周期长达数年时间，很有可能项目结束时候的工艺和项目开始时相差非常大，所以设计者要预测未来技术的发展，不能对标当下的技术水平，防止做出来的时候 spec 已经落后了。&lt;/p&gt;
&lt;p&gt;从目前的趋势来看，由于物理技术的限制摩尔定律很有可能失效，Intel 也被大家戏称为牙膏厂。为了继续获得性能的提升，大家纷纷转向 ASIC 芯片，比如目前如火如荼的 AI 硬加速芯片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Use Abstraction to Simplify Desing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是硅农还是码农都要发明一些技术来提高自己的效率，否则由于摩尔定律，资源动不动翻倍会导致设计时间变得非常长。其中一个非常重要的技术就是在不同层次进行抽象，把底层的实现细节通过抽象隐藏起来，只提供一个高层的简单接口。&lt;/p&gt;
&lt;p&gt;通过抽象，顶层可以不关心底层的实现细节，只专注于自己的功能，抽象带来的 “ 模块化设计 ” 可以大幅提高效率。这个思想应用非常广泛，典型代表是 OSI 的参考模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Make the Common Case Fast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同领域的共同规律：common case 比 corner case 更重要，而且 common case 也比 corner case 更加容易提升性能。加速 common case 的前提是要知道什么是 common case，而这一点很多时候只有通过仔细的实验和分析才能确定。&lt;/p&gt;
&lt;p&gt;俗话常说 “ 抓住主要矛盾 ”，“ 好钢用在刀刃上 ”，这个思想就是要求我们能分清问题的主次，把大部分的精力投入到主要问题上，获得更高的全局收益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance via Parallelism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显而易见，并行的性能更高。十个人搬转的速度当然比一个人更快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance via Pipelining&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流水线实际上是并行的一种，但是因为它实在是太重要，太基础了，在计算机系统中应用太广泛了，所以单独列出来。&lt;/p&gt;
&lt;p&gt;经典故事 “ 汽车装配流水线 ”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Performance via Prediction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，不一定非要等到完全确定之后再开始做一件事情，提前预测开始做往往获得的性能更高，前提是从错误中恢复的代价不高。&lt;/p&gt;
&lt;p&gt;典型代表：CPU 中的预测技术。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hierarchy of Memories&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码农一般都想要让 memory 尽可能的速度快、容量大、价格便宜，而这是矛盾的，硅农的解决方法是用 memories hierarchy 兼顾各个指标： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;L1 cache &amp;gt;&amp;gt; L2 cache &amp;gt;&amp;gt; L3 cache &amp;gt;&amp;gt; DDR &amp;gt;&amp;gt; Disk&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dependability via Redundancy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机不光要速度快，还要可靠。任何硬件都有可能出错，解决方法就是冗余。&lt;/p&gt;
&lt;p&gt;某些对可靠性要求非常高的应用系统都是通过冗余备份来提高可靠性，比如航天，大型服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="performance"&gt;Performance&lt;/h2&gt;
&lt;h3 id="defining-performance"&gt;Defining Performance&lt;/h3&gt;
&lt;p&gt;套用知乎名言：“ 先问是不是，再问为什么 ”（狗头保命）。性能是一个很宽泛的问题，在仔细展开讨论之前必须先定义清楚一个问题：&lt;/p&gt;
&lt;p&gt;Q：计算机的性能是什么？&lt;/p&gt;
&lt;p&gt;因为计算机自身的类型多种多样（PC，server，embedded），它们使用了各种各样的技术来提升硬件性能；再加上软件的大小和复杂度也有区别，所以要确定计算机的性能是一个复杂的问题。书里面举例了一个 “ 如何比较飞机性能 ” 的问题，实际上下面三个问题是很类似的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定 / 比较 计算机的性能&lt;/li&gt;
&lt;li&gt;确定 / 比较 飞机的性能&lt;/li&gt;
&lt;li&gt;确定 / 比较 汽车的性能（更接地气）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;他们的共性就是评价标准是多维的，飞机 / 汽车有最大巡航里程、最快巡航速度、最大载客量等指标，计算机也有执行时间、典型功耗、体积（芯片的 PPA）等指标。下面我们做第一条约束，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们定义计算机的性能是一个时间的函数，也就是说我们并不关心其他因素（比如价格、体积等）。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;response time&lt;/code&gt; = &lt;code&gt;execution time&lt;/code&gt;：计算机完成一个任务的总时间，包括硬盘访问、内存访问、I/O 操作、操作系统开销、CPU 执行时间等等，一般 PC 和移动设备最关心这个指标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;throughput&lt;/code&gt; = &lt;code&gt;bandwidth&lt;/code&gt;：单位时间内完成的任务量。一般 servers 更关心这个指标&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以很多时候我们要根据类型来区分不同的计算机，对每个类型采用不同的 {performance matrics, applications} 的组合作为 benchmark。&lt;/p&gt;
&lt;p&gt;在接下来的前几章中我们主要关心的是 response time，对于这个指标，性能最大意味着 response time 最小，所以可以这么定义计算机的性能：&lt;/p&gt;
&lt;div class="math"&gt;$$Performance_X = \frac{1}{Execution\ time_X}$$&lt;/div&gt;
&lt;p&gt;在比较两个不同的计算机时，“X 比 Y 快 n 倍 ” = “X 的速度是 Y 的 n 倍 ” 指的是同一个意思，即&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{Performance_X}{Performance_Y} = n$$&lt;/div&gt;
&lt;p&gt;为了简单起见，统一使用 “X 的速度是 Y 的 n 倍 ”（&lt;code&gt;as fast as&lt;/code&gt;）这种方式。因为 performance 和 execution time 是倒数关系，为了避免歧义，约定下面的描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;improve performance = increase performance&lt;/li&gt;
&lt;li&gt;improve execution time = decrease execution time&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="measuring-performance"&gt;Measuring Performance&lt;/h3&gt;
&lt;p&gt;根据前面的讨论，我们把 time 作为 performance 的度量标准：完成等量的任务，花费时间最短的计算机的性能最高。但是即使把性能约束在时间这个维度上，依然不够明确，因为 “ 时间 ” 也有很多种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wall clock time&lt;/code&gt; = &lt;code&gt;response time&lt;/code&gt; = &lt;code&gt;elapsed time&lt;/code&gt;，表示完成任务的总时间，包含了所有因素&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CPU execution time&lt;/code&gt; = &lt;code&gt;CPU time&lt;/code&gt; = &lt;code&gt;user CPU time&lt;/code&gt; + &lt;code&gt;system CPU time&lt;/code&gt;，表示 CPU 在特定任务上花费的计算时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;user CPU time&lt;/code&gt;，表示 CPU 在这个程序本身上花费的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;system CPU time&lt;/code&gt;，表示 CPU 在这个程序相关的操作系统上花费的时间&lt;/li&gt;
&lt;li&gt;要区分这两个时间实际上是很困难的，因为很难明确定义操作系统的哪些活动是对应哪个特定程序的，而且不同的操作系统的功能也不相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保持一致，使用下面的术语，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;system performance&lt;/code&gt; 指的是一个空载系统上的 &lt;code&gt;elapsed time&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPU performance&lt;/code&gt; 指的是 &lt;code&gt;user time&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="the-classic-cpu-performance-equation"&gt;The Classic CPU Performance Equation&lt;/h3&gt;
&lt;p&gt;一个程序的执行时间 = 这个程序包含的 cycle 数 × 每个 cycle 的时长，所以有下面的公式，&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ execution\ time = CPU\ clock\ cycles * clock\ cycle\ time\tag{1}$$&lt;/div&gt;
&lt;p&gt;其中一个程序包含的 cycle 数 = 包含的所有指令数 × 平均每条指令的 cycle 数，即&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ clock\ cycles = Instructions * Average\ clock\ cycles\ per\ Instr\tag{2}$$&lt;/div&gt;
&lt;p&gt;这里涉及到一个非常重要的概念 &lt;code&gt;clock cycles per instruction&lt;/code&gt;，也简称为 &lt;strong&gt;&lt;code&gt;CPI&lt;/code&gt;&lt;/strong&gt;，表示执行一条指令花费的 cycle 数。因为不同的指令完成的任务不同，花费的时间也不同，所以 CPI 指的是所有指令的平均 cycle 数。有了 CPI， 两个使用相同 ISA 的不同计算机之间的比较就很容易了，因为它们的指令条数肯定是一样多的。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CPI 不仅和具体的硬件实现有关，而且和程序也有关系，不同的程序用到的指令类型和数量必然是不相等的，算出来的平均数也不相等。&lt;/p&gt;
&lt;p&gt;CPI 实际上是有可能小于 1 的，所以有些人用 CPI 的倒数作为另外一个指标，&lt;code&gt;instructions per clock cycle&lt;/code&gt;，简称 &lt;code&gt;IPC&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;把公式 2 带入到公式 1 之中，就可以得到经典的 CPU 性能公式：&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ time = Instruction\ count * CPI * Clock\ cycle\ time\tag{3}$$&lt;/div&gt;
&lt;p&gt;也可以写成，&lt;/p&gt;
&lt;div class="math"&gt;$$CPU\ time = \frac{Instruction\ count * CPI}{Clock\ rate}\tag{4}$$&lt;/div&gt;
&lt;p&gt;这个公式其实就是下面公式，只不过给了每个元素一个新的定义，&lt;/p&gt;
&lt;div class="math"&gt;$$Time = \frac{Seconds}{Program} = \frac{Instructions}{Program} * \frac{Clock\ cycles}{Instruction} * \frac{Seconds}{Clock\ cycle}\tag{5}$$&lt;/div&gt;
&lt;p&gt;永远都要记住：&lt;strong&gt;只有 time 是最可靠的指标，其他子指标比如指令条数、CPI 等都不可靠。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表列出了影响一个程序的 performance 的因素，以及具体的影响方式，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;硬件 / 软件&lt;/th&gt;
&lt;th&gt;影响到了什么&lt;/th&gt;
&lt;th&gt;如何影响的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;算法&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI&lt;/td&gt;
&lt;td&gt;算法决定了一共有多少条指令和指令类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编程语言&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI&lt;/td&gt;
&lt;td&gt;不同的编程语言翻译出的指令数量和类型也不相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;编译器&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI&lt;/td&gt;
&lt;td&gt;编译器是算法和底层指令之间的桥梁，必然会影响到具体的指令翻译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISA&lt;/td&gt;
&lt;td&gt;Instrcution count, CPI, clock rate&lt;/td&gt;
&lt;td&gt;ISA 对 3 个因素都有影响&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="the-power-wall"&gt;The Power Wall&lt;/h2&gt;
&lt;p&gt;功耗分为两部分：动态功耗、静态功耗，动态功耗可以通过公式算出来：&lt;/p&gt;
&lt;div class="math"&gt;$$Power \propto \frac{1}{2} * Capacitive\ load * Voltage^2 * Frequency\ switched\tag{6}$$&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;Frequency switched&lt;/code&gt; 是时钟频率的函数，&lt;code&gt;Capacitive load&lt;/code&gt; 是晶体管的 fanout 和工艺的函数。&lt;/p&gt;
&lt;p&gt;从 Intel X86 架构芯片 30 年间 8 代 CPU 的时钟频率和 power 关系图中可以看到，随着时间发展，时钟频率提高了近 1000 倍，但是 power 只提高了大概 30 倍，原因就在于电压的不断降低。&lt;/p&gt;
&lt;p&gt;从前面 performance 的讨论可以知道，我们不能采用降低时钟频率的方式来降功耗，因为这会伤害到性能。那么我们可以无限降低电压吗？答案是不行，现在业界遇到的问题就是电压不能再低了，否则晶体管就像水龙头一样，无法完全关闭。虽然动态功耗是 CMOS 功耗中的大头，但是静态功耗也逐渐占据主角，在服务器中静态功耗能达到 40%，所以人们发明了各种技术来降低静态功耗，但是电压很难再进一步降低了。&lt;/p&gt;
&lt;p&gt;虽然有各种各样的昂贵技术来冷却芯片，但是继续提高功耗对于 PC（甚至是 servers）来说代价太高了，对移动设备就更不用说了，这就是所谓的功耗墙。&lt;/p&gt;
&lt;h2 id="the-switch-from-uniprocessors-to-multiprocessors"&gt;The Switch from Uniprocessors to Multiprocessors&lt;/h2&gt;
&lt;p&gt;遇到了功耗墙怎么办？只能舍弃这 30 年来的老路线（提频），选择另外一条路线：多核。&lt;/p&gt;
&lt;p&gt;在过去，码农不需要改任何一行代码，就可以每 18 个月让自己的程序性能翻倍（摩尔定律），但是现在由于摩尔定律的失效，码农必须重新写他们的程序，以充分利用多个核。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;强制要求码农转换到显式的并行编程是一件高风险的事情（Intel 的安腾系列处理器）。但是，随着多核概念的普及，整个 IT 界已经接受了并行编程，码农们最终会转向显式的并行编程。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为什么并行编程这么难推广呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编程困难，人的大脑更适合线性思维，很难处理并行的事情，编程也是同理&lt;/li&gt;
&lt;li&gt;调度困难，必须要减少核之间的通信和同步开销，防止这些额外的开销抵消并行带来的性能提升&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="fallacies-and-pitfalls"&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fallacies&lt;/code&gt; 谬论：错误概念&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pitfalls&lt;/code&gt; 陷阱：特定条件下成立的规律的错误推广&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;陷阱：期望局部的性能提升和整体性能成比例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;common case fast&lt;/code&gt; 思想对整体性能的提升效果取决于 common case 到底有多 common，典型例子就是 &lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s-law"&gt;Amdahl's Law&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;假设一个程序运行时间是 100s，其中 80s 是乘法运算，那么应该把乘法运算的性能提高到原来的多少倍才能使总计算时间减小到 20s 呢？&lt;/p&gt;
&lt;p&gt;根据 Amdahl 定律，&lt;/p&gt;
&lt;div class="math"&gt;$$T^* = \frac{T_{improved}}{Amout\ of\ improve} + T_{unaffected}\tag{7}$$&lt;/div&gt;
&lt;p&gt;在这个例子里，有&lt;/p&gt;
&lt;div class="math"&gt;$$20 = \frac{80}{n} + 20$$&lt;/div&gt;
&lt;p&gt;可以知道实际上不可能达到 20s 的。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;CPU 性能计算公式和 Amdahl 定律是设计系统时候的常用工具。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;谬论：利用率低的计算机功耗也低&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上 Google 的服务器上 10% 的负载消耗了 33% 的功耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谬论：性能设计和能效设计是不相关的事情&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;能量是功耗在时间上的积分，所以如果通过软硬件优化减少了程序的计算时间，就能同时降低功耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陷阱：把性能公式中的子集作为评价性能的标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面已经描述过，只有把 3 个因素都考虑进去，得到的性能结果才是可靠的，取其中任何一个、两个子指标都会导致不可靠的结果。比如，常用的 &lt;code&gt;MIPS(million instructions per second)&lt;/code&gt; 指标，&lt;/p&gt;
&lt;div class="math"&gt;$$MIPS = \frac{Instrcution\ count}{Execution\ time * 10^6}\tag{8}$$&lt;/div&gt;
&lt;p&gt;MIPS 描述的是指令执行速度，计算机越快相应的 MIPS 指标就越高。MIPS 指标非常容易理解，但是把它作为性能指标是有问题的，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只考虑了指令执行速度，但是没考虑指令的数量，对于不同 ISA 的计算机，不能直接比较它们的 MIPS&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使是同一台计算机，MIPS 值也会随着程序的不同而变化，没有固定值&lt;/p&gt;
&lt;p&gt;实际上，把公式 3 和公式 8 可以得到下面的公式，&lt;/p&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$MIPS = \frac{clock\ rate}{CPI * 10^6}$$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;因为 CPI 是个变化值，所以 MIPS 也是个变化值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个程序的指令数量变多，但是同时每条指令的执行速度变快，那么 MIPS 的值就完全不能反映出实际的真实性能&lt;/p&gt;
&lt;p&gt;比如下面这个例子，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;测量方式&lt;/th&gt;
&lt;th&gt;计算机 A&lt;/th&gt;
&lt;th&gt;计算机 B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;指令数&lt;/td&gt;
&lt;td&gt;10 billion&lt;/td&gt;
&lt;td&gt;8 billion&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时钟频率&lt;/td&gt;
&lt;td&gt;4 GHz&lt;/td&gt;
&lt;td&gt;4 GHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPI&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;1.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以算出来 A 比 B 的 MIPS 指标高，但实际上 A 的性能比 B 差，MIPS 指标和真实情况背道而驰。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8 个伟大思想是计算机体系结构的基本，应用非常广泛&lt;/li&gt;
&lt;li&gt;计算机程序的性能是多个影响因素的共同作用结果&lt;/li&gt;
&lt;li&gt;性能的定义：&lt;code&gt;response time&lt;/code&gt; 和 &lt;code&gt;throughput&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;经典性能公式&lt;/li&gt;
&lt;li&gt;目前的问题：功耗墙&lt;/li&gt;
&lt;li&gt;功耗墙的解决方法：多核 + 并行&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h2 id="road-map-for-this-book"&gt;Road Map for This Book&lt;/h2&gt;
&lt;p&gt;计算机可以划分为经典的 5 部分：&lt;code&gt;datapath&lt;/code&gt;, &lt;code&gt;control&lt;/code&gt;, &lt;code&gt;memroy&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;，分别在后续几章介绍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;datapath&lt;/code&gt;：Chapter 3, Chapter 4, Chapter 6, Appendix B&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control&lt;/code&gt;：Chapter 4, Chapter 6, Appendix B&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Memory&lt;/code&gt;：Chapter 5&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Input&lt;/code&gt;：Chapter 5, Chapter 6&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ouptut&lt;/code&gt;：Chapter 5, Chapter 6&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="IC"></category><category term="Patterson and Hennessy"></category></entry><entry><title>RISC-V Spec 阅读笔记 #1 —— Unprivileged ISA</title><link href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-1-unprivileged.html" rel="alternate"></link><published>2020-11-17T21:55:00+08:00</published><updated>2020-11-17T21:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-11-17:/posts/risc-v/risc-v-spec-notes-1-unprivileged.html</id><summary type="html">&lt;p&gt;Volume I: Unprivileged ISA 读书笔记&lt;/p&gt;</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;Unprivileged ISA 文档的版本号 :20191213&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;RISC-V 的目标可以说非常宏大、也非常务实，可以用这几个关键词来概括：完全 open、可实现、通用、模块化、可扩展。RISC-V 在定义时尽可能地规避了具体的实现细节（虽然 ISA 中有些设计是出于实现考虑的），所以这个 ISA 应该当成各种不同实现方案的统一软件可见接口，而非某种特定微架构实现的专属。整个手册分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Volume I: Unpriviledge ISA&lt;/li&gt;
&lt;li&gt;Volume II: Priviledge ISA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设计这些 ISA 时都遵循了 “ 尽量移除对特定微架构依赖 ” 的原则，这样可以在简化 ISA 同时保证 implementation 最大程度的灵活性。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;ISA 作为软件和硬件之间的接口，其地位非常重要。曾经有很多各种各样的 ISA，其中大部分都随着历史消亡了，只剩下个别占领了市场主流，并不断演进。但是目前大部分 ISA 被商业产权保护，普通人无法使用，而且因为要向后兼容而有历史包袱，在这样的背景下，RISC-V 最早起源于 UC Berkeley 的教学需求，逐渐发展壮大，如今在业界如火如荼。&lt;/p&gt;
&lt;p&gt;定义一个新的 ISA 并不是简单定义指令集就足够的，还需要大量的投入，比如文档、编译器工具链、测试套件、教学材料等等，即使这些都全做出来了别人也不一定会用，做出来简单，要想推动整个生态是件非常难的事情。看看 RISC-V 基金的董事会和赞助商，就会发现全是著名科技公司和大佬，也只有他们才能集整个产业界的力量推动新的 ISA 发展。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;ISA 之所以叫架构，是因为它作为软硬件世界之间的桥梁，不仅仅包含了指令集，还需要包含很多其他内容，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;存储模型&lt;/li&gt;
&lt;li&gt;软件可见的处理器状态 GPR + CSR + PC&lt;/li&gt;
&lt;li&gt;指令集&lt;/li&gt;
&lt;li&gt;系统模型：状态 + 特权级别  + 中断 / 异常&lt;/li&gt;
&lt;li&gt;外部接口： I/O + 管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hardware-platform-terminology"&gt;Hardware Platform Terminology&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hardware platform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RISC-V core + non-RISC-V core + accelerator + memory + I/O + interconnect&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;core&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含独立的 IFU 的模块，一个 core 可能包含多个 &lt;code&gt;hart&lt;/code&gt; 和 &lt;code&gt;coprocessor&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;coprocessor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;附着在 RISC-V core 上，大部分情况下由 RISC-V 指令流控制，但是具有架构状态和有限的自主控制权来运行扩展指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;accelerator&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不可编程的固定函数单元 or 针对特定任务的可以自动运行的 core，如 I/O 加速器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="software-execution-environment-and-harts"&gt;Software Execution Environment and Harts&lt;/h3&gt;
&lt;p&gt;RISC-V 程序的行为依赖于它的执行环境，&lt;code&gt;EEI (Execution Environment Interface)&lt;/code&gt; 定义了下面这些内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的初始状态&lt;/li&gt;
&lt;li&gt;Hart 的数量和类型&lt;/li&gt;
&lt;li&gt;hart 支持的特权模式&lt;/li&gt;
&lt;li&gt;memory/IO 的访问及特性&lt;/li&gt;
&lt;li&gt;每个 hart 支持的合法指令，即 ISA&lt;/li&gt;
&lt;li&gt;中断和异常的处理方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EEI 的典型例子有 Linux &lt;code&gt;ABI (Application Binary Interface)&lt;/code&gt; 和 RISC-V &lt;code&gt;SBI (Supervisor Binary Interface)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;EEI 的实现方式有多种：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实现方式&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bare metal&lt;/td&gt;
&lt;td&gt;由硬件直接实现的 hart，指令可以访问所有的物理地址空间，硬件平台定义上电复位后的执行环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OS&lt;/td&gt;
&lt;td&gt;通过复用 hart 和虚拟地址控制访问 memory ，OS 可以实现多个用户层级的 execution environment（即多个 thread）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hypervisor&lt;/td&gt;
&lt;td&gt;对 guest OS 访问提供多个 supervisor 级别的 execution environment（即多个虚拟机）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;emulator&lt;/td&gt;
&lt;td&gt;在另一个硬件平台（如 x86）上模拟 RISC-V 的 hart，比如 Spike、QEMU、rv8 等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Hardware Thread&lt;/code&gt;：随着处理器技术的发展，现在的处理器已经突破了多核的概念，在单个核心中包含多个硬件线程的技术叫做硬件超线程 &lt;code&gt;Hyper-threading&lt;/code&gt;，每个硬件线程有自己独立的 RF 等上下文资源，但是不同线程共享同一份运算资源，所以面积效率很高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hart&lt;/code&gt;：为了区别多核，RISC-V 定义的术语，取 Hardware Thread 之意，包含自动取指和执行所涉及的硬件资源的统称。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;一般软件的接口都比实际硬件接口更加抽象，因为 EEI 越抽象移植性就越好。通常 EEI 都是一层一层堆叠在一起的，上层的 EEI 依赖于下层的 EEI。&lt;/li&gt;
&lt;li&gt;hart 由 execution environment 提供，所以可能会出现 guest hart 数量比 host hart 数量多的情况，即时分复用。这种情况下，由 execution environment 确保每个 hart 行为正常，尤其是要支持 guest hart 抢占 host hart。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="isa-overview"&gt;ISA Overview&lt;/h3&gt;
&lt;p&gt;RISCV ISA 由必选的 Base Integer ISA 和其他可选 ISA 组成，完整的子集列表直接看 spec 即可。其中必选的 base interger ISA 和以前的 RISC 处理器的 ISA 非常相似，只是去掉了分支延迟槽并支持了可选的变长编码。I 子集是一个精心设计过的针对工具链来说合理的最小化集合，基于它可以实现一个基本的软硬件 “ 骨架 ”，并进一步定制化。I 子集一共有 4 种形式，它们的区别在于 register 的位宽、register 的数量、寻址空间大小： &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;XLEN (register 位宽 )&lt;/th&gt;
&lt;th&gt;registe 数量&lt;/th&gt;
&lt;th&gt;寻址空间范围 (Byte)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{32}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{64}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV32E&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{32}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV128I&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(2^{128}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;4 个 base ISA 被当作完全不同的 ISA 来对待，所以有个常见问题：&lt;/p&gt;
&lt;p&gt;Q：为什么不设计一个统一的 ISA，即让 RV32I 是 RV64I 的严格子集？一些早期 ISA(SPARC, MIPS) 就采用了这样的设计规则，使得可以在 64bit 的硬件上运行 32bit 的程序。&lt;/p&gt;
&lt;p&gt;A：ISA 分开设计的主要优点是可以针对某个子集独立优化，不需要为支持其他子集而消耗资源，主要缺点则是当在一个 ISA 上模拟另外一个 ISA 时的硬件更复杂。实际上寻址模式和捕获非法指令的不同往往意味着即使某两个 ISA 是子集关系仍然需要两套电路以及某种模式切换，而且 RISC-V 的 base ISA 之间的相似性可以降低多版本的开销。虽然理论上可以把 32bit 的 lib 和 64bit 的代码链接在一起，但因为程序调用和系统调用接口的不同实际中并不可行。&lt;/p&gt;
&lt;p&gt;RISC-V 的特权架构中 misa 寄存器有个字段专门用来控制在同一份电路上可模拟的 unprivileged ISA，而且可以看到最新的 SPARC 和 MIPS 也放弃了对在 64bit 系统上直接运行 32bit 程序的支持。&lt;/p&gt;
&lt;p&gt;另外一个相关的问题是：为什么相同的 32bit 加法在 RV32I 和 RV64I 中的 opcode 不同？应该遵守字面意思，W 后缀表示 word（32bit），D 后缀表示 double word（64bibt），按如下方式编码，这样和 LW 的编码方式也能保持统一。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;32-bit add&lt;/th&gt;
&lt;th&gt;64-bit add&lt;/th&gt;
&lt;th&gt;32-bit load&lt;/th&gt;
&lt;th&gt;64-bit load&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;ADDW&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;ADDW&lt;/td&gt;
&lt;td&gt;ADDD&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;LD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;而目前的设计为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ISA&lt;/th&gt;
&lt;th&gt;32-bit add&lt;/th&gt;
&lt;th&gt;64-bit add&lt;/th&gt;
&lt;th&gt;32-bit load&lt;/th&gt;
&lt;th&gt;64-bit load&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RV32I&lt;/td&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RV64I&lt;/td&gt;
&lt;td&gt;ADDW&lt;/td&gt;
&lt;td&gt;ADD&lt;/td&gt;
&lt;td&gt;LW&lt;/td&gt;
&lt;td&gt;LD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;实际上一开始确实是按照提议的方式编码的，但是在后来的演进过程中修改为目前的方式。之所以把 32bit 加法的编码设置成不兼容，目的是为了消除 RV32I 中的不对称性（RV32I 有 ADDW 和 AND 但是没有 ANDW）。从事后复盘看目前的方式是不合理的，主要原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时设计两个 ISA，而不是是一层一层地叠加&lt;/li&gt;
&lt;li&gt;设计 ISA 时的一个理念：RV64I 必须完全包含 RV32I（RV32I 已经使用了 ADD，所以 RV64I 只能修改指令的含义，并新增 ADDW）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 RV32I 和 RV64I 已经 frozen 了，所以无法修改了，目前看这样做几乎没有什么实际问题。以后可以将 W 后缀作为某个 RV32I 变种的扩展集，这样就能在 RV32I 和 RV64I 之间保持一致的编码了。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="memory"&gt;Memory&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;寻址范围是 &lt;span class="math"&gt;\(2^{XLEN}\)&lt;/span&gt; Byte&lt;/li&gt;
&lt;li&gt;1 word = 32bit(4Byte)；1 halfword = 16bit(2Byte)；1 doubleword = 64bit(8Byte)，1 quadword = 128bbit(16Byte)，和 XLEN 无关&lt;/li&gt;
&lt;li&gt;memory 地址是循环的，最大的地址溢出后自动回到 0 地址，硬件计算地址时以 &lt;span class="math"&gt;\(2^{XLEN}\)&lt;/span&gt; 为模会自动忽略溢出即可&lt;/li&gt;
&lt;li&gt;由 execution environment 将硬件资源映射到 hart 的地址空间中，通常地址空间被分成了不同段，如 memory、I/O device 等，每个段有自己的属性&lt;/li&gt;
&lt;li&gt;多个 hart 的 memory 可以完全一样，也可以完全独立或部分重叠&lt;/li&gt;
&lt;li&gt;memory 访问可以分为 implicit 和 explicit 两类&lt;ul&gt;
&lt;li&gt;implicit access：取指操作，没有对应的指令，硬件自动读取。这种类型的访问可以提前进行（比如 I$ 指令预取），当需要和 store 数据同步时必须用 fence 或 cache control 指令显式地同步&lt;/li&gt;
&lt;li&gt;explicit access：load/store 指令的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RISC-V 默认使用 &lt;code&gt;RVWMO(RISC-V Weak Memory Ordering)&lt;/code&gt; 作为内存一致性模型，实现也可以选择约束更强的 TSO(Total Store Ordering) 模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="base-isa-encoding"&gt;Base ISA Encoding&lt;/h3&gt;
&lt;p&gt;RISC-V 指令可以是变长的，但是所有 base ISA 都按照 16bit 对齐，即其指令长度都是 16bit 的倍数。&lt;/p&gt;
&lt;p&gt;使用术语 &lt;code&gt;IALIGN&lt;/code&gt;（单位为 bits）表示指令对齐约束，IALIGN 的取值只能是 16 或 32：base ISA 的 IALIGN 是 32，C 子集和其他扩展 ISA 可以是 16。&lt;/p&gt;
&lt;p&gt;使用术语 &lt;code&gt;ILEN&lt;/code&gt;（单位为 bits）表示实现支持的最大指令长度，它永远是 &lt;code&gt;IALIGN&lt;/code&gt; 的整数倍。&lt;/p&gt;
&lt;p&gt;Base ISA 既可以是大端模式，也可以是小端模式，但是指令存储一定是以 16bit 为单位的数据包的小端模式。&lt;/p&gt;
&lt;h3 id="exceptions-traps-interrupts"&gt;Exceptions, Traps, Interrupts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Exception&lt;/code&gt; 表示指令执行中处理器本身出现异常情况而停止执行当前程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interrupt&lt;/code&gt; 表示外部异步事件导致处理器停止执行当前程序，转而去完成其他事情，完成后再继续之前的程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trap&lt;/code&gt; 表示由 exception 或 interrput 导致的 CPU 控制权向 trap handler 的转移过程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 种不同的 trap：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Contained&lt;/th&gt;
&lt;th&gt;Requested&lt;/th&gt;
&lt;th&gt;Invisible&lt;/th&gt;
&lt;th&gt;Fatal&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Execution terminates ?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Software is oblivious?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Handled by environment?&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="rv32i-base-isa"&gt;RV32I Base ISA&lt;/h2&gt;
&lt;p&gt;一共有 40 条指令，查询 reference card 即可。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一些资料中会描述说 I 指令集包含 47 条指令，这里有点歧义。以前的历史版本中 I 确实有 47 条指令，但是在最新的版本中，有 7 条指令被移了出来，只剩下只包 40 条指令，通常所说的 47 条指令是把另外两个必要的子集也包含在内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Zifencei&lt;/code&gt; 子集：包含 1 条指令 &lt;code&gt;FENCE.I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Zicsr&lt;/code&gt; 子集：包含 6 条 csr 相关的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些实现中，可能会把 ECALL/EBREAK 当成一条永远 trap 的硬件指令来处理，且把 FENCE 指令当成 NOP 来处理，这时 I 子集的指令条数就缩水到了 38 条。&lt;/p&gt;
&lt;p&gt;除了 A 子集需要特殊的硬件来支持原子性操作之外，RV32I 基本上可以模拟任何其他子集。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="programmers-model"&gt;Programmers' Model&lt;/h3&gt;
&lt;p&gt;RV32I 的 Unpriviledged state 分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用寄存器 XRF：一共有 32 个，XLEN=32，其中 x0 为常数 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSR&lt;/code&gt;：内部寄存器，专有的 12bit 地址编码空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有个特殊的 register：&lt;code&gt;pc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;I 子集只涉及通用寄存器，CSR 寄存器在后面的 &lt;code&gt;Zicsr&lt;/code&gt; 部分介绍。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV32I 中没有定义 stack pointer 和 return address 寄存器，而是直接使用某个 XRF。标准的软件调用规范中指定了 x1 作为 return address，x2 保存 sp。遵守这个规范可以生成最小体积的代码。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一个 ISA 中寄存器的个数对代码体积、性能、功耗有巨大的影响。到底应该设计多少个 register 也是有讲究的，有种意见是对于 I 子集只用 16bit 的指令编码配合 16 个 register 就已经足够了，但是如果指令中包含 3 个寄存器地址，则光地址就需要 12bit，只剩了 4bit 来编码 opcode，这基本上是不可能的。而如果指令只包含 2 个地址，那么实现相同功能就需要更多的指令，降低效率。为了简化硬件设计也应该避免 24bit 这种中间长度的指令格式，所以最终选择了 32bit 的指令来编码配合 32 个寄存器。寄存器数量多一些对性能提升也有帮助，比如 loop unrolling, software pipelining, cache tiling 这些技术都对寄存器数量有很大的需求。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="format"&gt;Format&lt;/h3&gt;
&lt;p&gt;主要有 4 种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; (Register)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; (Immediate) &lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; (Store)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&lt;/code&gt; (Upper)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 branch 或 jump 指令跳转的地址没有 4Byte 对齐时，会在 branch/jump 指令处产生 exception。当支持 16bit 指令时 (IALIGN = 16)，对齐约束放宽到 16 的倍数。&lt;/p&gt;
&lt;p&gt;RISC-V 的指令格式是精心设计过的，目的就是为了简化硬件的译码电路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RV32I 的指令长度都是 32bit，按照 4Byte 对齐存储&lt;/li&gt;
&lt;li&gt;所有指令中的 rs1, rs2, rd 都在固定位置&lt;/li&gt;
&lt;li&gt;所有指令中的立即数都是按照有符号的方式扩展（除了 CSR 指令中的 5bit 立即数）&lt;/li&gt;
&lt;li&gt;所有立即数都放在指令可用空间的最左边 bit 位置&lt;/li&gt;
&lt;li&gt;所有立即数的符号位都在指令的固定位置 bit[31]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：和蜂鸟总结的 dec 优势对比，查缺补漏&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;译码模块中 register 标识符的逻辑通常都是关键路径，所以 RISC-V 在设计指令格式的时候，不管是什么格式类型的指令，都把标识符放在固定位置，付出的代价则是指令中立即数的位置会随着指令类型变化。&lt;/p&gt;
&lt;p&gt;实际上，大部分立即数的位宽要么很小，要么就要占满 XLEN bit，RISC-V 选择了一种非对称的方式切分立即数（用两条指令来搬运一个立即数：第一条指令搬运低 12bit，第二条指令搬运剩余的 20bit），这样做的好处是可以增加常规指令可用的 opcode 编码空间。&lt;/p&gt;
&lt;p&gt;所有立即数都是符号为扩展的，因为我们没有发现 MIPS 中按 0 扩展能带来什么好处，这样做同时也能最大限度地保持 ISA 的简洁。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;因为立即数的原因，所以有了另外两个变种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; (Branch) 类型：它和 &lt;code&gt;S&lt;/code&gt; 一样都用 12bit 来编码立即数，唯一区别是 B 中的立即数是 S 中立即数的 2 倍，也就是说 S 中的 12bit 表示 imm[11:0]，而 B 中的 12bit 表示 imm[12:1]，而且这 12bit 在指令中的位置是精心设计过的，并不是简单移位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; (Jump) 类型：它和 &lt;code&gt;U&lt;/code&gt; 的关系也是类似的，唯一区别是 U 和 J 需要 shift 的 bit 位数不一样，同理，立即数的位置是精心设计过的，并不是简单填充&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;立即数的符号位扩展是其关键路径之一，RISC-V 把所有立即数的符号位都放在第 31bit，好处是可以让符号位扩展和译码并行。&lt;/p&gt;
&lt;p&gt;虽然有些复杂的实现会给 branch 和 jump 指令计算分配专有加法器，所以并不会受益于不同指令中的立即数位置固定的设计，但是我们想降低最简实现的硬件成本。通过变换立即数的 bit 位置，而不是使用动态的硬件 mux，指令信号的 fanout 和 mux 数量大概减少为原来的一半。而这种混乱的立即数编码带来的开销可以忽略不计。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下面分类描述 I 子集的 40 条指令，大概可以分成 4 类：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;整数计算指令&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;控制转移指令&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Load/Store 指令&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Memory 顺序指令&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统调用和断点&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="integer-computational-instructions"&gt;Integer Computational Instructions&lt;/h3&gt;
&lt;p&gt;整数计算指令只有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;I-type&lt;/code&gt;：register 和 immediate 相计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R-type&lt;/code&gt;：register 和 register 相计算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两类都会有 rd 寄存器来保存结果，rs 和 rd 都为 XRF，而且都不会产生算术异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;我们并没有设计特殊的指令集来检测 overflow，因为可以用 branch 指令很廉价的实现这个功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无符号数加法的 overflow 检查只需要在 add 指令后面加一条 branch 指令即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add t0, t1, t2
bltu t0, t1, overflw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有符号数加法，如果已知一个操作数的符号（I 类型加法），那么只需要在 add 后面加一条 branch 指令即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;addi t0, t1, +imm
blt t0, t1, overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一般的有符号数 R 类型的加法，需要 3 条指令来检测求和结果是否比任何一个加数都小（除非一个操作数是负数）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;add t0, t1, t2
slti t3, t2, 0
slt t4, t0, t1
bne t3, t4, overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SLTIU&lt;/code&gt; 指令需要先对立即数进行符号位扩展，然后再当成无符号数来比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NOP&lt;/code&gt; 是伪指令，以 &lt;code&gt;ADDI x0, x0, 0&lt;/code&gt; 的方式实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LUI&lt;/code&gt; 和 &lt;code&gt;AUIPC&lt;/code&gt; 都是 U 类型的格式，用来组装一个 32it 数据，区别是 &lt;code&gt;LUI&lt;/code&gt; 只做组装，而 &lt;code&gt;AUIPC&lt;/code&gt; 完成组装后还会有一个额外的加法&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AUIPC&lt;/code&gt; 指令支持以 “ 双指令序列 ” 的方式访问当前 PC 的任意 offset 位置，既可以用来做控制流的转移，也可以用来做数据访问，可以访问相对于当前 PC 值的任意 32-bit 地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制流转移： AUIPC + JALR 组合，AUIPC 先把目标地址的高 20bit 存储到 rd 中，然后这个 rd 作为 JAL 的 rs，叠加上 imm 就可以算出完整的 32bit 目标地址&lt;/li&gt;
&lt;li&gt;数据访问： AUIPC + LOAD/STORD，AUIPC 先把目标地址的高 20bit 存储到 rd 中，然后这个 rd 作为 ld/st 的 rs，叠加上 imm 就可以算出完整的 32bit 目标地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：看蜂鸟，补充实际指令序列的例子&lt;/p&gt;
&lt;p&gt;原理：AUIPC 已经包含了立即数的高 20bit，所以只需要其他指令配合产生立即数的低 12it 即可。&lt;/p&gt;
&lt;p&gt;虽然获取当前 PC 值可以通过把 AUIPC 的立即数设置为 0 来实现，也可以通过 &lt;code&gt;JAL +4&lt;/code&gt; 的方式实现，但是后者的问题在于可能会导致流水线停顿或者是污染 BTB。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;一般 NOP 指令都用来处理地址边界问题以使得指令对齐，或者为指令修改预留空间。虽然 NOP 的实现方式有很多种，我们只定义了一种作为示范，给微架构层面的优化留有空间，同时也可以使得汇编代码的可读性更好。NOP 指令也可以用 HINT 指令来实现。&lt;/p&gt;
&lt;p&gt;选用 ADDI 来实现 NOP 的原因是，这样占用的资源最少（除非是在 decode 阶段把它优化掉了），只需要读一个 register，而且在超标量处理器中加法器是最常见的操作，AGU 可以像计算地址一样直接执行这条指令，其他的 register-register 指令（比如 ADD 或 logical 指令、shift 指令）都需要额外的硬件才能完成。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="control-transfer-instructions"&gt;Control Transfer Instructions&lt;/h3&gt;
&lt;p&gt;控制流相关的指令一共有两类，而且都没有 delay slot（延迟槽），如果跳转地址没有对齐，则会产生一个不对齐异常。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无条件跳转 jump&lt;/li&gt;
&lt;li&gt;有条件分支 branch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 &lt;code&gt;JAL&lt;/code&gt; 指令属于 J-type，所以它包含了 imm[20:1] bit，所以可以跳转的范围是 [-1MB, +1MB] 内。JAL 会把自己后面的指令地址 (pc+4) 存到 rd 中，方便跳回后继续执行。一般标准的软件调用惯例是 rd = x1 作为返回地址，x5 作为 alternate link register。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这个 alternate link register 可以在保留常规的返回地址寄存器 rd 不变前提下支持调用一些 millicode，之所以选择 x5 是因为在标准调用中它是一个临时寄存器，而且和 x1 的编码只有 1bit 不同。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;无条件 jump 指令（JAL 和 JALR）都使用 PC 的相对地址来支持地址不相关的代码。JALR 和 LUI 组合在一起可以访问 32bit 地址空间中的任一位置，首先 LUI 把目标地址的高 20bit 搬运到寄存器中，然后 JALR 把低 12bit 加上去就可以算出完整的 32bit 目标地址。同理，AUIPC 和 JALR 也可以跳转到相对于 PC 的任意 32bit 地址。&lt;/p&gt;
&lt;p&gt;需要注意的是，JALR 不会像 branch 指令一样从 imm[1] 开始编码（2 的倍数），JALR 编码的是 imm[11:0]，这样做的好处是可以避免硬件中立即数格式太多的问题。&lt;/p&gt;
&lt;p&gt;JALR 执行的时候，会把计算出的 target address 的 LSB 清零，这样做的好处是可以稍微简化硬件设计，同时还可以空余出 1bit 空间来存储更多辅助信息。虽然这么会导致错误检查的逻辑变复杂，所以有些轻微的性能损失，因为发生了指令地址错误很快就触发异常，所以问题不大。&lt;/p&gt;
&lt;p&gt;当 rs1=x0 时，JALR 可以用来实现单指令调用子程序，在 [-2KB, 2KB] 范围内跳转，可以实现 small runtime lib 的快速调用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RAS 预测是高性能 IFU 中的常见功能，但是前提是要能准确区分出函数调用和返回，协议规定了 JAL 和 JALR 所使用的寄存器序号可以用来辅助 RAS 预测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 JAL 的 rd=x1 或者是 rd=x5，那么就是函数调用，要把 rd 寄存器的值 push 进 RAS，保存返回地址&lt;/li&gt;
&lt;li&gt;如果 JAL 的 rs=x1 或者是 rs=x5，那么就是函数调用返回，要从 RSA pop 出返回地址，用于 IFU 预测下一个地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;遵守协议的规定，compiler 和 core 配合就可以最大化地提高 RAS 的预测准确度。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;有些 ISA 使用了特别的 bit 位来标识辅助 RAS，我们使用隐式的方式（约定寄存器号）来减少对编码空间的占用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;所有的 branch 指令都是 B-type，所以它编码了 imm[12:1] bit，所以可以跳转的范围是 [-4KB, 4KB] 之间。&lt;/p&gt;
&lt;p&gt;协议规定软件要假设硬件是 BTFN 算法的方式，依次进行优化，这样可以提高低端 CPU 的预测性能。不同于其他 ISA，RISC-V 规定无条件跳转必须使用 JAL(rd=x0)，而不能用条件设置为 true 的 branch 指令。因为 jump 指令要比 branch 的跳转范围大，而且不会污染条件 branch 的预测表。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;条件 branch 指令被设计成包含两个 register 的算数比较的方式（同 PA-RISC、Xtensa、MIPS R6），没有使用以下方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用条件码 condition code（x86、ARM、SPARC、PowerPC）&lt;/li&gt;
&lt;li&gt;只使用一个 register 和 0 做比较（Alpha，MIPS）&lt;/li&gt;
&lt;li&gt;两个寄存器只用于比较是否相等（MIPS）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样设计的主要原因是把比较和分支合并在一起更加适合常规流水线，不需要使用额外的 condition code，也不需要使用寄存器保存中间结果，可以减少代码体积，降低 IFU 的带宽，还可以在 IF 阶段就被提前检测到，即使是和 0 比较这种设计，也会引入不可忽略的 latency。这样设计付出的硬件代价也很小近似可以忽略。另外融合的指令可以在流水线的上游更早地观测到，更早地预测。&lt;/p&gt;
&lt;p&gt;曾经考虑过在指令编码中加入静态分支提示，但最终并没有加，理由是虽然静态分支提示可以缓解动态预测器的压力，但是代价是会占用更多的编码空间，还需要软件做 profiling 才能获得最好的结果，而一旦 profiling 和实际不一致，性能就很差。&lt;/p&gt;
&lt;p&gt;没有包含类似 ARM 条件码的原因是：条件码需要占用指令的额外 bit，需要额外的指令来设置 / 清除，增加了硬件复杂度，而和它一起配合使用的静态预测的效果可能并不好。&lt;/p&gt;
&lt;p&gt;有很多方法可以动态地把不可预测的前向分支转化为可预测的代码，以避免流水线的 flush 代价。其中最简单的就是只 flush IFU 中的指令，而不是整个 pipeline 上的所有代码。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="load-and-store-instructions"&gt;Load and Store Instructions&lt;/h3&gt;
&lt;p&gt;RISC-V 是一个 load-store 体系结构，即只有 load/store 才可以访问 memory，计算指令只能和寄存器打交道，而且 RISC-V 的端序是 byte 地址不变的。&lt;/p&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 load 指令的 rd 是 x0，即使读回来的数据被丢弃了，也必须报一个任意类型的 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在一个端序是 byte 地址不变的系统中，有下列特性：如果某个 1 byte 的数据被 store 在某种端序的 memory 的某个地址中，那么从那个地址中 load 1 byte 数据返回的数据也是那个值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小端系统：一个多 byte 数据，LSB 被存储在 memory 的低位地址，剩余数据的地址按照顺序递增，load 指令会把低位地址的数据搬运到 register 的 LSB 中&lt;/li&gt;
&lt;li&gt;大端系统：一个多 byte 数据，MSB 被存储在 memory 的低位地中，剩余数据的地址按照顺序递减，load 指令会把高位地址的数据搬运到 register 的 LSB 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RV32I 的地址空间是 32bit，按照 byte 地址访问，由 EEI 规定合法的地址段。无论端序如何，如果访问地址是天然对齐的，那么就不会产生任何异常，如果访问地址不是天然对齐的（访问数据量是 32bit，地址按照 4byte 对齐；访问数据量是 16bit，地址按照 2byte 对齐），那么具体行为取决于 EEI。EEI 可以允许非对齐访问，由硬件或者软件处理，也可以不允许非对齐访问，直接抛出异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;非对齐访问在移植旧代码、使用 packed-SIMD 扩展的应用程序、处理外部打包的数据结构时很有用。之所以通过 load/store 来允许 EEI 自主选择非对其访问的处理方式，目的就是想简化硬件设计。&lt;/p&gt;
&lt;p&gt;有一种备选方案：在 base ISA 中不允许非对齐访问，额外再设计一个 ISA 来支持非对齐访问，比如某些特殊指令或者是硬件特殊的寻址模式。这个方案的问题在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特殊指令使用难度大，导致 ISA 复杂化&lt;/li&gt;
&lt;li&gt;要么处理器添加了额外状态（CSR），要么导致现有 CSR 的访问复杂化&lt;/li&gt;
&lt;li&gt;面向 for 循环的 packd-SIMD 程序可能要根据数据对齐模式修改多个版本的代码，使得代码生成复杂化，产生额外开销&lt;/li&gt;
&lt;li&gt;新的硬件寻址模式必然要消耗大量的指令编码空间，而且也要消耗一些硬件资源来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;即使实现了非对齐访问，在某些实现中可能性能很差；而且硬件处理非对齐访问时可能会将其拆分成多个子指令来处理，此时需要额外的同步机制来保证访问的原子性。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;标准中非对齐访问的原子性不是必须的，这样 EEI 就可以自由选择是用不可见的 machine trap 还是软件 handler 来处理非对齐访问。如果硬件支持非对齐访问，那么软件只需要直接用简单的 load/store 即可，发生非对齐访问时，硬件会自动优化。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="memory-ordering-instructions"&gt;Memory Ordering Instructions&lt;/h3&gt;
&lt;p&gt;RISC-V 支持在一个单一的用户地址空间内运行多个 hart，每个 hart 都有自己的 pc 和 register，执行自己的指令流。而由 EEI 来完成 hart 的创建和管理。不同 hart 之间可以通过共享存储器来实现通信和同步，又因为 RISC-V 使用存储器松散一致性模型 &lt;code&gt;RVWMO&lt;/code&gt;，所以需要 FENCE 指令来定义另外一个 hart 观测到本 hart 的指令执行顺序。从原则上讲，另外一个 hart 只能先观测到 FENCE 前的指令行为，然后才能观测到 FENCE 之后的指令行为，即 FENCE 像一道屏障一样，隔断了前后的指令流。&lt;/p&gt;
&lt;p&gt;RISC-V 把数据存储器访问分为了 4 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I：设备读 device-input&lt;/li&gt;
&lt;li&gt;O：设备写 device-output&lt;/li&gt;
&lt;li&gt;R：存储器读 device-read&lt;/li&gt;
&lt;li&gt;W：存储器写 device-write&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配合前后的概念，所以可以实现很多种组合，达到非常精细的控制。&lt;/p&gt;
&lt;p&gt;FENCE 的 fm 字段取值为 1000，predecessor = RW，successor = RW 时，为 FENCE.TSO 指令，效果为 predecessor 的 load 和 successor 所有 memory 操作保序，predecessor 的 store 和 successor 的所有 store 保序，但是并未规定 predecessor 中的 non-AMO store 和 successor 的 non-AMO load 之间保序。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;FENCE.TSO 是 FENCE 的可选扩展，因为 FENCE 的基本定义要求忽略 I/O 和 memory 字段全局实现 fence，所以 FENCE.TSO 和 FENCE 是兼容的。&lt;/p&gt;
&lt;p&gt;FENCE 中没有定义的字段 rs1 和 rd 是为了将来更细精度的扩展而保留的。为了保持前向兼容，硬件应该忽略这些 bit 位，同时软件应该将这些 bit 位设置为全 0。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;我们选择松散一致性模型的目的是让一个简单的微架构能获得高性能的同时也方便未来进行扩展。将 I/O 和 memory 操作分离开来的好处是可以避免不必要的串行化。一个简单的微架构可以忽略 FENCE 中的前序和后序字段，保守地把所有的 FENCE 指令都当成最严格的 FENCE 指令来执行即可。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id="environment-call-and-breakpoints"&gt;Environment Call and Breakpoints&lt;/h3&gt;
&lt;p&gt;系统指令用来访问系统功能，可能会要求特权访问，全部是 I 类型的指令。大概可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性地 read-modify-write CSR 的指令&lt;/li&gt;
&lt;li&gt;其他特权指令&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;系统指令的目的是使得简单实现中可以触发软件 trap handler 实现功能，而一些高端实现可能直接用硬件实现该指令。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;ECALL 和 EBREAK 都向 EEI 会出发一条精确异常来请求复位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ECALL&lt;/code&gt; 用来向 EEI 发送服务请求，请求的参数则一般放在寄存器文件中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EBREAK&lt;/code&gt; 用来把控制权转移给 debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hint-instructions"&gt;HINT Instructions&lt;/h3&gt;
&lt;p&gt;HINT 指令一般用来给微架构传递性能提示。RV32I 给 HINT 预留了大量的编码空间，且全部用 rd = x0 的计算指令来表示。所以 HINT 和 NOP 类似，只会导致 pc 向前移动以及改变性能计数器，除此之外不会改变硬件架构中任何可见的状态。实现中直接把 HINT 忽略也是符合标准的。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;HINT 设计成这样的目的是方便硬件实现。简单实现中既可以把 HINT 当成一条恰好并不会产生任何影响的指令来走完所有 pipeline stage，也可以直接把它丢弃。&lt;/p&gt;
&lt;p&gt;虽然 HINT 编码空间很大，而且划分了 standard 空间和 custom 空间，但是目前还没有定义好 standard HINT。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="zifencei"&gt;Zifencei&lt;/h2&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;先讨论一个问题：假设一个指令流，前面的有条指令向 memory 某个地址 store 了一个新值，后面需要从该地址取指，那么后面的指令一定可以读取到前面的新值吗？&lt;/p&gt;
&lt;p&gt;答案是：不一定。因为 pipeline 是有深度的，假设前面的这两条指令是背靠背的，那么前序指令结果还没写入的时候后续指令已经完成了取指、译码，开始执行了，所以后续取指的是旧值。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，引入了 FENCE.I 指令，用来约束 store 和取值之间的顺序关系。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个子集只包含一条指令 &lt;code&gt;FENCE.I&lt;/code&gt;，它可以实现对同一个 hart 的 instruction memory 的写指令和取指之间的显式的同步控制，目前这是确保 hart 内部 store 对 instruction fetch 可见的唯一标准机制。&lt;/p&gt;
&lt;p&gt;这条指令用来同步一个 hart 的 data 和 instruction 之间的关系，如果没有这条指令，RISC-V 就无法保证后续的取值操作能观测到前序的 store 结果。因为 FENCE.I 只用来处理单个 hart 内部的关系，所以如果有多个 hart，为了保证某个 hart 的 store 结果可以被其他 hart 观测到，应该在 FENCE.I 之前先调用一条 FENCE 指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step1：本 hart 完成 store 指令&lt;/li&gt;
&lt;li&gt;step2：本 hart 执行 fence 指令&lt;/li&gt;
&lt;li&gt;step3：本 hart 请求所有 hart 执行 fence.i 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;为了支持各种不同的实现，FENCE.I 指令做过精心的设计。简单实现可以直接 flush 流水线，清空 I-cache 即可。复杂一些的实现可能会有更高级的操作。&lt;/p&gt;
&lt;p&gt;FENCI.I 之前是 I 子集的一部分，但是因为下面两个原因，从 I 子集中挪了出来，不再是必须实现的指令了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某些系统中，实现 FENCE.I 的代价很大。比如有些设计中 I-cache 和 D-cache 都是 incoherent 形式，一旦遇到 FENCE.I 指令，就必须清空两个 cache。如果在共享 cache / memory 之前有多级独立的 I/D cache，这个问题会更加严重&lt;/li&gt;
&lt;li&gt;在类 Unix 系统中，这条指令并没有强大到足以在 user level 使用。因为 FENCE.I 只能处理 hart 内部的同步，但是 OS 可能会在遇到 FENCE.I 时重新调度 user hart，所以现在 Linux ABI 都是要求产生一个系统调用来保证取指的 coherent&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="rv32e"&gt;RV32E&lt;/h2&gt;
&lt;p&gt;RV32E 是专门为嵌入式 Embedded 设计的 ISA，目前还是 draft 1.9 状态，它和 RV32I 的唯一区别就是把 register 的数量减少到了 16 个。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;实际上一开始是拒绝专门设计一个新的子 ISA 的，但是后来考虑到 32bit MCU 的需求，最终定义了这个子集，将来可能还会有 RV64E。&lt;/p&gt;
&lt;p&gt;我们发现在 RV32I 的小核中，高 16 个 register 大概占了 core 面积的 1/4（除 memory 之外），所以去掉这 16 个 register 可以节省大约 25% 的面积和功耗。&lt;/p&gt;
&lt;p&gt;这个改变也对软件的调用惯例和 ABI 提出了要求。&lt;/p&gt;
&lt;p&gt;RV32E 可以和任何标准 extension 组合使用。曾经考虑过 F、D、Q 和 RV32E 配合时，定义一个新版的只有 16-entry 的 FP register file，但是最终放弃了，计划定义一个 &lt;code&gt;zfinx&lt;/code&gt; 扩展 ，它计算 FP 时直接使用 integer register file，所以省去了 FP register file 和 XRF 之间的搬运操作。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV32E 的 ISA 和 RV32I 完全一样，但是因为 register 只有 16 个，所有指令中 index 的字段可以释放出几 bit，未来的标准指令扩展都不会用到这些字段，所以可以给自定义扩展指令来使用。&lt;/p&gt;
&lt;h2 id="rv64i"&gt;RV64I&lt;/h2&gt;
&lt;p&gt;RV64I 是 RV32I 的扩展。和 RV32I 的区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;XLEN&lt;/code&gt; 变成了 64，即 register 的位宽是 64bit。&lt;/li&gt;
&lt;li&gt;RV64I 的大部分指令的操作数位宽都是 XLEN bit，但是也有一些附加的指令来操作 32bit 的数，这些指令都在 opcode 后面加了 &lt;code&gt;W&lt;/code&gt; 后缀来区分（W = word）。这些 &lt;code&gt;*W&lt;/code&gt; 指令会忽略掉高 32bit 数据，产生的结果也只保留 32bit 结果，然后把它符号位扩展到 64bit 后保存在 register 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rv128i"&gt;RV128I&lt;/h2&gt;
&lt;p&gt;目前还是 draft 1.7 状态，定义这个子 ISA 的目的就是为了支持更大的地址空间。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;目前暂时还不是很清楚我们什么时候需要比 64bit 更大的地址空间，世界上 Top500 的超级计算机拥有超过 1PB 的 DRAM，这需要超过 50bit 的地址线。一些仓储级的计算机已经包含了更大的 DRAM，而且固态硬盘和 interconnect 技术的发展可以能会产生更大地址空间的需求。万亿级别的系统研究需要 100PB 的空间，大概占用 57 根地址线。根据历史增长速度看，大概在 2030 年前就有可能超过 64bit 的范围。&lt;/p&gt;
&lt;p&gt;历史证明，无论何时只要出现地址不够用的情况，architect 设计者们就会重复以前的争论，使用各种技术（如 segmentation，96-bit 地址，软件规避等方法）来扩充寻址范围，但是最终，128bit 的寻址方案将作为最简单、最佳解决方案而被采用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;RV128I 在 RV64I 的基础上定义，就如同 RV64I 在 RV32I 上定义一样，保留了 &lt;code&gt;*W&lt;/code&gt; 指令不变，只不过新增了如何在 128bit 寄存器中操作 64bit 的指令，用 &lt;code&gt;*D&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;为了提升和 RV64I 的兼容性，和 RV64I 兼容 RV32I 的做法相反，可能会把 RV64I ADDI 的指令编码定义为 RV64I ADDD，然后在之前的 opcode &lt;code&gt;OP-64&lt;/code&gt; 新增一个 RV128I ADDQ，同时将 &lt;code&gt;OP-64&lt;/code&gt; 的编码定义为 &lt;code&gt;OP-128&lt;/code&gt;。即目前的编码规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不带后缀的指令操作数位宽为 XLEN&lt;/li&gt;
&lt;li&gt;通过后缀 &lt;code&gt;W&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 指定操作数位宽为 word 或 doubleword&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;未来的编码规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不带后缀的指令从操作数位宽为 word&lt;/li&gt;
&lt;li&gt;指令中带后缀 &lt;code&gt;W&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 指定操作数位宽为 word 或 doubleword&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h2 id="zicsr"&gt;Zicsr&lt;/h2&gt;
&lt;p&gt;RISC-V 专门定义了一组 (control and status register, CSR) 寄存器来记录配置和运行状态，这些寄存器是内部寄存器，使用专有的 12bit 地址编码空间。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 主要是在 Priviledge 架构中使用，但是 Unpriviledge 架构中也会用到一些，比如计数器和计时器，浮点状态等。&lt;/p&gt;
&lt;p&gt;因为计数器和计时器等不再是 base ISA 中的必须强制性实现的了，所以访问这些 CSR 的指令就独立出来自成一章。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;只要程序中有指令会修改或者是行为受 CSR 影响，那么就会发生隐式或是显式的 CSR 访问。比如说，在某些修改或受 CSR 影响的指令执行完之后，后续修改 CSR 或受 CSR 影响的指令执行之前，会产生 CSR 访问。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一条带有 CSR 读的指令，在指令执行之前会先读回 CSR 的状态&lt;/li&gt;
&lt;li&gt;对于一条带有 CSR 写的指令，在指令执行之后会更新 CSR 的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSR 的访问是 weakly ordered，所以其他 hart 观测 CSR 的顺序可能和程序中的顺序不一样，特别是，CSR 和 memory 的访问没有顺序关系，除非 CSR 会修改访问 memory 指令的执行，或者是使用特权指令集中定义的 Memory-Ordering PMAs 做了明确的顺序要求。对于 FENCE 指令来说，CSR 读被当作设备输入 (I)，CSR 写被当作设备输出 (O)。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;CSR 按照第二卷中 Memory-Ordering PMAs 章节定义的 weakly ordered memory-mapped I/O region 模型操作，所以 CSR 的访问顺序和 memory-mapped I/O 访问的约束一致。&lt;/p&gt;
&lt;p&gt;对 CSR 的顺序设置约束的原因是为了支持对主存及 memory-mapped I/O 访问和 time CSR 的排序。除了 &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;cycle&lt;/code&gt;, &lt;code&gt;mycle&lt;/code&gt; 这三类 CSR，两卷标准中定义的其他 CSR 都对其他 hart 不可见，所以这些 CSR 的访问顺序和 FENCE 的顺序可以是任意顺序，都是符合标准的。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="counter"&gt;Counter&lt;/h2&gt;
&lt;p&gt;RISC-V 定义了 32 个 64bit 的 Unpriviledge 只读性能计数器和计时器，其中前 3 个有特定的含义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CSR 名字&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CYCLE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 执行到当前的周期数，使用 RDCYCLE[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TIME&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 的 wall-clock 周期数，使用 RDTIME[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;INSTRET&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;保存了 hart 退休的总指令数量，使用 RDINSTRET[H] 来读取低 / 高 32bit&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以通过一组非特权指令通过 0xC00-0xC1F 地址访问（高 32bit 可以用 0xC80-0xC9F 访问）这些计数器 / 计时器。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;这个子集之前是在 RV32I 中，后来分离出来单独作为一个子集，目前是 draft 2.0 版本，目测以后也不会大改。&lt;/p&gt;
&lt;p&gt;在 V2.2 版本中这 3 个 CSR 指令作为 RV32I 的一部分是强制实现的，但是现在独立后就不是强制性的了，但是还是推荐实现这 3 个 CSR，因为它们对于基本的性能分析、自适应、动态优化来说是必不可少的。而且也应该以较小的代价实现其他计数器，来辅助诊断性能问题。&lt;/p&gt;
&lt;p&gt;这些计数器必须是 64bit，即使是 RV32I 也是如此，否则位宽太少软件很难判断是否发生了 overflow。（简单算一下就知道 64bit 的表示范围非常大，可以覆盖任何性能计数的需求）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;剩余的 29 个 CSR 名称为 &lt;code&gt;hpmcounter3&lt;/code&gt;-&lt;code&gt;hpmcounter31&lt;/code&gt;（hardware performance counter），它们作为可编程的计数器能针对某些事件进行计数，这些计数器可以通过特权指令来配置。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;特权架构中定义了访问和配置这些 hpm 的 privileged CSR，这些 hpm 可以用来对一些硬件指标做统计，比如执行的 F 指令条数，L1 I$ 的 miss 次数等等。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="m-extension"&gt;M Extension&lt;/h2&gt;
&lt;p&gt;把乘除法指令从 I 子集中分离出来，可以简化低端 core 的实现，或者对于那些乘除法不常出现的应用，用另外一个加速器来实现。&lt;/p&gt;
&lt;p&gt;如果同时需要乘法结果的高低两部分，推荐使用下面的顺序，同时保证 rs1 和 rs2 的值和顺序不变，且 rdh != rs1 or rs2：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;MULH&lt;/span&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="no"&gt;S&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdh&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;span class="nf"&gt;MUL&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="no"&gt;rdl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样硬件实现时会把它们融合成一条指令来执行，只进行一次乘法。&lt;/p&gt;
&lt;p&gt;同理，除法也可以按照类似的方法实现，硬件实现时只会进行一次除法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nf"&gt;DIV&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;span class="nf"&gt;REM&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;U&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="no"&gt;rs2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MUL 不需要（没必要）区分 signed/unsigned，MULH 则需要区分 singed/unsigned&lt;/li&gt;
&lt;li&gt;大多数 ISA 中除以 0 都会触发异常，跳转到 trap，但是 RISC-V 做了简化，不会产生异常，可以简化硬件实现&lt;/li&gt;
&lt;li&gt;RISC-V 的所有的计算指令都不会产生 exception&lt;/li&gt;
&lt;li&gt;RISC-V 虽然不会产生 exception，但是对除 0 的结果做了特殊规定：商的所有 bit 设置为全 1&lt;/li&gt;
&lt;li&gt;设置为全 1 是精心设计过的：对于无符号除法来说，全 1 就是最大值，而且也天然符合硬件除法器的输出，无需任何修改；对于有符号除法来说，一般都是先转成无符号来算，所以也没有问题。这样设计可以最大程度地简化硬件设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="a-extension"&gt;A Extension&lt;/h2&gt;
&lt;p&gt;A 子集包含了对 memory 进行原子性的 read-modify-write 操作的指令，目的是同步多个共享同一个 memory 空间的不同 hart。
A 指令支持 unordered, acquire, release, sequentially 等各种内存一致性模型，这些指令可以让 RISC-V 支持 RCsc 存储器一致性模型。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;经过大量辩论后，编程语言社区和体系结构社区最后达成一致：用 release consistency 作为存储器一致性模型，所以围绕着这个模型建立了 A 子集。&lt;/p&gt;
&lt;p&gt;背景知识：3 种最有代表性的内存一致性模型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;访问 memory&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;按序一致性模型 Sequential Consistency Model&lt;/td&gt;
&lt;td&gt;每个 hart 看到的都是 program-order&lt;/td&gt;
&lt;td&gt;原子性、串行化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;松散一致性模型 Relaxed Consistency Model&lt;/td&gt;
&lt;td&gt;每个 hart 可以改变自己的存储器访问顺序&lt;/td&gt;
&lt;td&gt;性能、功能 balance&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;释放一致性模型 Release Consistency Model&lt;/td&gt;
&lt;td&gt;支持 acquire-release 机制&lt;/td&gt;
&lt;td&gt;更加松散&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;已知 base 子集使用的是 relaxed 模型，配合 FENCE 指令可以实现额外的顺序控制。但是为了更加高效地支持 release 模型，每个 A 指令都新增了两 bit：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ac&lt;/code&gt; 字段：表明本指令是 acquire 访问（上锁），屏障了它之后的 memory 操作，即在它之后的 memory 访问必须要等到这条 A 指令结束后才能开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rl&lt;/code&gt; 字段：表明本指令是 release 访问（释放锁），屏蔽了它之前的 memory 操作，即它必须等前面的 memory 访问都结束了才能开始&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果两个字段都是 0, 则这条 A 指令没有任何附加的约束；如果两个字段都是 1，则这条 A 指令是 sequential 模型，只能在前序指令结束、后序指令开始前执行。&lt;/p&gt;
&lt;p&gt;A 子集主要包含两大类指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Atomic Memory Operations, &lt;code&gt;AMO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些指令都是原子性的，也就是说读回数据和写回结果这段时间内这个地址不允许其他任何指令访问，也就是对这个地址 “ 上锁 ”。AMO 指令要求必须是对齐访问（32-bit 数据按照 4-byte 对齐；64-bit 数据要求按照 8-byte 对齐），否则会产生异常。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;设计 AMO 指令的原因是在高度并行系统中它比 LR/SC 指令的伸缩性更好。对于简单实现，可以直接用 LR/SC 来等价实现 AMO；而对于一个复杂实现，可以在 memory 控制器中实现 AMO 指令，而且如果 rd = x0 时可以优化掉读 memory 的操作。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;AMO 可以用来实现 memory 中的 parallel reductions，还可以用来更新 I/O 设备映射出的寄存器（比如 setting, clearing, toggle 比他位）。&lt;/p&gt;
&lt;p&gt;通过设置 ac/rl 字段，AMO 可以用来高效地实现 C11/C++ 11 中的 atmic memory operations。虽然 &lt;code&gt;FENCE R, RW&lt;/code&gt; 可以实现 acquire 效果，&lt;code&gt;FENCE RW, W&lt;/code&gt; 可以实现 release 效果，但是和 AMO 比起来引入了不必要的额外约束，所以 AMO 实现更加高效。&lt;/p&gt;
&lt;p&gt;下面是一个自旋锁的例子，整个流程就是 test-and-test-and-set，先测试锁是否可获取，如果可以就尝试获取，尝试完了测试是否获取成功，获取成功了就开始执行核心代码，核心代码执行完后再释放锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    li          t0, 1   # initialize swap value
again:
    lw            t1, (a0)      # load lock, lock is stored in a0 address
    bnez          t1, again     # check if lock is held
    amoswap.w.aq  t1, t0, (a0)  # attempt to acquire lock
    bnez          t1, again     # check agian
    # ...
    # critical section.
    # ...
    amoswap.w.r1  x0, x0, (a0)  # release lock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Load-Reserved/Store-Conditional, &lt;code&gt;LR&lt;/code&gt;/&lt;code&gt;SC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和 ARM 中的 Load-Exclusive/Store-Exclusive 类似。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rvwmo-model"&gt;RVWMO Model&lt;/h2&gt;
&lt;h2 id="f-extension"&gt;F Extension&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="d-extension"&gt;D Extension&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id="extending-risc-v"&gt;Extending RISC-V&lt;/h2&gt;
&lt;h2 id="isa-extension-naming-conventions"&gt;ISA Extension Naming Conventions&lt;/h2&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="RISC-V"></category><category term="RISC-V"></category><category term="Spec"></category></entry><entry><title>学习 Vim 之《Pratical Vim》读书笔记</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-pratical-vim-notes.html" rel="alternate"></link><published>2020-08-20T20:45:00+08:00</published><updated>2020-08-20T20:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-08-20:/posts/tools/learning-vim-pratical-vim-notes.html</id><summary type="html">&lt;p&gt;《Pratical Vim》读书笔记。&lt;/p&gt;</summary><content type="html">&lt;h2 id="vim"&gt;Vim 解决问题的方式&lt;/h2&gt;
&lt;p&gt;理想的编辑模式：用一次按键移动，用另外一次按键执行。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;从本质上讲，我们的编辑工作是重复性的，不论是修改文档的不同地方，还是在文档内移动，我们都会有很多重复操作。Vim 对重复操作进行了优化，它之所以能高效地重复，是因为它会记录我们最近的操作，让我们用一次按键就能重复上次操作。要想利用这个强大的功能，首先要求我们能够&lt;strong&gt;学会规划按键动作，使得重复时可以完成一项有用的工作&lt;/strong&gt;。这一理念是高效使用 Vim 的关键。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;面对重复性的工作，我们的口诀就是：修改、重复 &lt;code&gt;.&lt;/code&gt;、回退 &lt;code&gt;u&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用好 &lt;code&gt;Esc&lt;/code&gt; 键，把撤销单元切成块，使撤销命令作用于单词、句子、段落。一次思考对应一次插入模式&lt;/li&gt;
&lt;li&gt;构造可重复的修改，最好让一次修改是最小原子性的，方便重复任意次，反例， &lt;code&gt;d2w&lt;/code&gt; 无法删除 3 个单词&lt;/li&gt;
&lt;li&gt;能重复就别用次数，只有在必要时使用次数。因为次数很容易数错，而不小心多按的重复操作用 u 很容易恢复&lt;/li&gt;
&lt;li&gt;操作符 + 动作命令 = 操作&lt;/li&gt;
&lt;li&gt;只要可能，最好用操作符命令，而不是可视命令&lt;/li&gt;
&lt;li&gt;Ex 命令的强大之处在于可以在多行同时执行，而普通模式一般操作当前光标处&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键只有 “ 差一误差 ” 时才使用，平时应该用其他键移动光标更高效&lt;/li&gt;
&lt;li&gt;面向字符串的移动更快，面向单词的移动更细粒度&lt;/li&gt;
&lt;li&gt;像 scrabble 玩家那样思考，查找低频字母更高效&lt;/li&gt;
&lt;li&gt;可以用 &lt;code&gt;{motion}&lt;/code&gt; 的地方都可以用文本对象，文本对象处理代码更高效&lt;/li&gt;
&lt;li&gt;浏览文件前用 &lt;code&gt;m{A-Z}&lt;/code&gt; 可以标记全局位置，方便跳转回原地&lt;/li&gt;
&lt;li&gt;录制宏时确保光标位置是正确的（比如行首），以保证每条命令都可以被重复执行&lt;/li&gt;
&lt;li&gt;替换操作一般分两步实现解耦，第一步写正则表达式匹配，第二步进行替换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_2"&gt;第一部分 模式&lt;/h2&gt;
&lt;h4 id="_3"&gt;普通模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;80&amp;lt;C-a&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数字增加 80&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;80&amp;lt;C-x&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数字减少 80&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;操作符命令列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;修改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;复制到寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;反转大小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gu&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转化为小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gU&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转化为大写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;增加缩进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;减少缩进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自动缩进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用外部程序过滤 {motion} 所跨越的行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_4"&gt;插入模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-h&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除前一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除前一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-u&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删至行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到插入 - 普通模式（普通模式下 = 回跳前一个跳转位置）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;{register}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不离开插入模式，粘贴 register 中的文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用表达式寄存器，进行计算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到替换模式，替换字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_5"&gt;可视模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重选上次高亮选区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;o&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换选区的活动端&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_6"&gt;命令行模式&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同普通模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-u&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同普通模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;{register}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同普通模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[range]delete[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除指定范围到寄存器 [x] 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[range]yank[x]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;复制指定范围到寄存器 [x] 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[range]copy{address}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;复制指定范围到 {address} 行下面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[range]normal{commands}&lt;/code&gt;&lt;/td&gt;
&lt;td commands&gt;对指定范围内执行普通模式命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[range]substitude/{patten}/{string}/[flags]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对指定范围内的 patten 替换为 string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:[range]global/{patten}/[cmd]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对指定范围内匹配 pattern 的行执行 cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:{start},{end}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前文件中的所有行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;'&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;高亮区域的首航&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;'&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;高亮区域的尾行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:copy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简写 &lt;code&gt;:t&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:move&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简写 &lt;code&gt;:m&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重复上次命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:shell&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;启动一个临时 shell 会话，用 exit 退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-z&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;挂起 vim&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fg %[id]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;唤醒作业，移到前台&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_7"&gt;第二部分 文件&lt;/h2&gt;
&lt;h3 id="_8"&gt;管理多个文件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;缓冲区被修改过&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;活动缓冲区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;隐藏缓冲区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;哪个缓冲区在当前窗口可见&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;轮换文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-^&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在当前文件和轮换文件之间快速切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;水平切分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;垂直切分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;等宽等高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大化高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最大化宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[N]&amp;lt;C-w&amp;gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;高度设置为 N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[N]&amp;lt;C-w&amp;gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;宽度设置为 N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-w&amp;gt;T&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移动到新标签页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到下一个标签页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到前一个标签页&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_9"&gt;打开及保存文件&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:pwd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印工作目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:set path+=dir/**&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置 path&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:find filename&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查找打开文件（必须先设置 path）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:e %&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;补全当前文件完整路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;去除文件名，保留路径其他部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:e %:h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;补全当前文件所在目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_10"&gt;第三部分 更快地移动及跳转&lt;/h2&gt;
&lt;h3 id="_11"&gt;文件内跳转&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;光标移动到行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;光标移动到第一个非空白字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;光标移动到行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ge&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;光标移动到上一个单词的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;f{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移动到下一个 char 字符上，&lt;code&gt;;&lt;/code&gt; 跳转到下一个匹配项，&lt;code&gt;,&lt;/code&gt; 跳转到上一个匹配项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;t{char}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;移动到下一个 char 之前的字符上，比如删除特定字符 / 符号前的内容等，非常有用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查找操作是开操作，不包含当前字符，&lt;code&gt;d/th&amp;lt;CR&amp;gt;&lt;/code&gt; 命令会删除当前位置到 th 之前的内容，保留 th 字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m{a-zA-Z}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大写标记全局可见，小写只能本文件可见&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在匹配括号之间跳转，修改成对括号前先执行 %，修改完后用 `` 跳转到对应括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gi:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从普通模式返回到上次修改的地方，并进入插入模式继续编辑&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;文本对象：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含圆括号在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含方括号在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含尖括号在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含单引号在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含双引号在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a`&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含反引号在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;at&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含 XML 标签在内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;圆括号内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方括号内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;尖括号内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单引号内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双引号内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i`&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;反引号内部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;it&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;XML 标签内部&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;自动标记位置：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;``&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前文件上次跳转动作之前位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次修改的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次插入的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`[&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次修改 / 复制的起始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次修改 / 复制的结束位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次高亮选区的起始位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;`&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次高亮选区的结束位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_12"&gt;文件间跳转&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;后退&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前进，插入模式下 = &lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;gf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;跳转到当前光标下的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_13"&gt;寄存器&lt;/h2&gt;
&lt;h3 id="_14"&gt;复制与粘贴&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"{register}y{motion}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定复制到特定寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-r&amp;gt;{register}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在插入模式中使用寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;寄存器：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;黑洞寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无名寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;复制专用寄存器，只有 y{motion} 才会改变它的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a-z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有名寄存器，覆盖原始内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;A-Z&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有名寄存器，追加到寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;系统剪切板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;主剪切板，鼠标中键&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表达式寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;特殊只读寄存器：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;轮换文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次插入的文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;：&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次执行的 Ex 命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上次查找的模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_15"&gt;宏&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;q{register}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开始 / 结束录制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@{register}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用宏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@@&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最近使用的宏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;100@a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重复调用 100 次 a 中的宏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;'&amp;lt;, '&amp;gt;normal @a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;选中区域，并行执行 a 中的宏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;qA&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;追加到寄存器 a 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:put a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把 a 中的宏复制到文本中，方便编辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"ay$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;修改后的宏内容复制到 a 中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_16"&gt;模式（正则表达式）&lt;/h2&gt;
&lt;h3 id="_17"&gt;查找&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;激活 very magic 搜索模式，假定模式中除 -, 大小写字母，0-9 之外的所有字符都有特殊含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\V&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;激活 very nomagic 搜索模式，假定模式中只有 \ 有特殊含义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单词定界符 , example: &lt;code&gt;/\v&amp;lt;the&amp;gt;&amp;lt;CR&amp;gt;&lt;/code&gt; 只会匹配单词 the，忽略 these, they 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正向查找&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;反向查找&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_18"&gt;替换&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;:[range]s/{pattern}/{string}/[flags]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;替换域&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;换行符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;制表符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;反斜杠&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\={vim script}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行 vim script，并把返回结果作为替换 string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/{pattern}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第一步匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:%s//{string}/g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第二步替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:%s//&amp;lt;C-r&amp;gt;0/g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把寄存器 0 中的内容作为 string&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重复上次替换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="global"&gt;global 命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;:[range]g[!]/{pattern}/[cmd]&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:g/re/p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;g 是 global 简写，re 指正则表达式，p 是 print 简写，整个命令即 grep 的含义&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_19"&gt;工具&lt;/h2&gt;
&lt;h3 id="ctags"&gt;ctags&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:! ctags -R&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对当前目录递归生成 tag 文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;跳转到定义处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-t&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;跳转回退&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&amp;lt;C-]&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;弹出标签列表供选择，适用于多个匹配项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="quickfix"&gt;Quickfix&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:make&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;再 Vim 内编译&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cnext&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下一项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cprev&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前一项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cfirst&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第一项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:clast&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;最后一项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:copen&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开 quickfix 窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:cclose&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;关闭 quickfix 窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="grep-vimgrep"&gt;grep, vimgrep&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:grep&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用外部 grep&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:vimgrep&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用内部 grep&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_20"&gt;自动补全&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;普通关键字补全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-l&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;整行补全&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-f&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件名补全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="_21"&gt;拼写检查&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:set sepll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前一个拼写错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;后一个拼写错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;z=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为当前词提供更正建议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把当前词加入到拼写文件中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;zw&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把当前词从拼写文件中删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;C-x&amp;gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在插入模式下触发自动补全，完成拼写更正&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26967597/"&gt;Pratical Vim&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category></entry><entry><title>Python 学习笔记 #10 —— Python 中的 FP</title><link href="https://qian-gu.github.io/posts/cs/python-notes-10-fp-in-python.html" rel="alternate"></link><published>2020-06-21T11:19:00+08:00</published><updated>2020-06-21T11:19:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-06-21:/posts/cs/python-notes-10-fp-in-python.html</id><summary type="html">&lt;p&gt;学习 Python 中的函数式编程&lt;/p&gt;</summary><content type="html">&lt;h2 id="functional-programming"&gt;Functional Programming&lt;/h2&gt;
&lt;p&gt;函数式编程是一种编程范式，和面向过程、面向对象并列。大家都知道世界观和方法论，用中国古话就是道和术。就编程而言解决一个问题的方法有很多，不同方法的具体实现就是术，但是我们可以对这戏方法进行归类，归类的依据就是道，也就是编程范式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向过程：一切问题都可以通过一些数据（变量）和一些操作（函数）进行处理，只需要按照步骤处理数据就可以解决问题，其中数据和操作是相互独立没有关系的，典型例子是 C 语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向对象：数据和操作是有关联的，它们都是一个类（对象）的属性，根据问题建模出若干对象，在对象之间进行交互就能解决问题，典型例子是 C++&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数式编程：源自于数学中的函数，基本上数学中函数有什么特点，编程语言中的函数就有相同特点，比如函数是一等公民，引用透明，没有副作用等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数式编程本身是一个大而广的问题，而且 Python 不是也不大可能成为一种函数式编程语言，但是它有很多函数式编程的特点。函数式编程是一种思想，很多老手都无法准确定义什么是函数式编程，这里只是简单写写学习笔记。&lt;/p&gt;
&lt;h2 id="lambda"&gt;Lambda&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt; 函数的主要用途是定义特殊的函数，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先它必须很小，小到只有一行表达式&lt;/li&gt;
&lt;li&gt;其次它只会别调用一次（实际上因为 lambda 函数是匿名函数，没有函数名自然其他地方也无法调用）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
lambda  [arg1 [, arg2, ... argN]: expression
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;把一个常规函数转换成 lambda 函数的方法很简单：把 def 替换成 lambda，并且省略掉函数名和参数的括号，以及 return 关键字。可以通过下面的变形来理解 lambda 函数，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;

&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="high-order-function"&gt;High-order Function&lt;/h2&gt;
&lt;p&gt;高阶函数在学习 decorator 时已经接触过了，可以接收 function 作为参数，或者返回值的函数就是高阶函数，典型例子就是各种 decorator。&lt;/p&gt;
&lt;p&gt;Python 中的所有函数都是 ” 一等公民 “，一等公民是指具有下面一项或几项特点的对象，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;runtime 时创建&lt;/li&gt;
&lt;li&gt;可以赋值给一个变量或者是数据结构中的一个元素&lt;/li&gt;
&lt;li&gt;可以作为参数进行传递&lt;/li&gt;
&lt;li&gt;可以作为函数的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此 Python 中的所有函数都可以作为高阶函数来使用。&lt;/p&gt;
&lt;h2 id="filter-map-reduce"&gt;Filter, Map, Reduce&lt;/h2&gt;
&lt;p&gt;这几个高阶函数都定义在 functools 模块中。&lt;/p&gt;
&lt;h3 id="filter"&gt;Filter&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt; 函数顾名思义，就像一个过滤器一样，把符合条件的东西（数据）过滤出来，它接收两个参数，第一个参数是过滤函数；第二个参数是 &lt;code&gt;iterable&lt;/code&gt; 对象，也就是待处理的数据对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
filter(function, iterable)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举例说明，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;odd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# [1, 3, 5]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;odd 是个过滤函数，如果数据是奇数则返回 1，偶数返回 0，也就是说会把奇数过滤出来。如果 odd 函数只在这里使用一次的话，可以结合前面的 lambda 函数写出更简洁的代码，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# [1, 3, 5]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;仔细观察一下 filter 函数就会发现它的功能和 list comprehension 非常相似，都是迭代一个 &lt;code&gt;iterable&lt;/code&gt; 对象并筛选出符合条件的数据。所以上面的例子可以用 list comprehension 重写成下面的样子，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;显然 list comprehension 的版本更加简洁，更加 &lt;code&gt;Pythonic&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="map"&gt;Map&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 函数和 filter 函数类似，不同之处在于做映射而不是过滤。它也接收两个参数，第一个参数是映射函数，第二个参数是 &lt;code&gt;iterable&lt;/code&gt; 对象，也就是待处理的数据对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
map(function, iterable)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举例说明，将上面的挑选奇数的例子改成求平方，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# [0, 1, 4, 9, 16, 25]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同理也可以写出 lambda 形式和 list comprehension，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# using lambda&lt;/span&gt;
&lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# [0, 1, 4, 9, 16, 25]&lt;/span&gt;

&lt;span class="c1"&gt;# list comprehension&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="c1"&gt;# [0, 1, 4, 9, 16, 25]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="reduce"&gt;Reduce&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reduce&lt;/code&gt; 函数顾名思义，就是把一个 &lt;code&gt;iterable&lt;/code&gt; 对象归并缩减成一个单一的值。它的语法规则也 filter，map 类似。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
reduce(function, iterable)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举例说明，将前面例子中的函数改为求和。普通模式的代码略，下面是 lambda 方式，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# lambda&lt;/span&gt;
&lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;map 和 reduce 函数非常有名，Google 大牛 Jeff Dean 的著名论文 &lt;a href="https://research.google/pubs/pub62/"&gt;MapReduce: Simplified Data Processing on Large Clusters&lt;/a&gt; 介绍了 map/reduce 的基本思想，而之前非常火的大数据处理框架 Hadoop 底层实现的一个组件就是 map/reduce。大数据处理一般需要很多太计算机分布式计算，而 FP 天然就支持并行处理，不需要锁和同步，所以应用很广泛。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="partial-function-application"&gt;Partial Function Application&lt;/h2&gt;
&lt;p&gt;3 个容易混淆的概念，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数学的偏函数：定义域上部分有定义的函数，也就是说定义域中某些值没有映射值&lt;/li&gt;
&lt;li&gt;柯里化 &lt;code&gt;curring&lt;/code&gt;，它指把一个有多参数的函数分解成一系列单参数的函数的过程&lt;/li&gt;
&lt;li&gt;部分函数应用 partial function application, PFA，函数调用的结果，在调用时只提供了部分参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经典例子，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;exponent&lt;/span&gt;

&lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cube&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 9&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;cube&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 27&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上，partial 接收的参数有 3 个，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;partical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般创建 PFA 固定参数时都是采用关键字的方式，比如上面例子中固化 exponent 参数。在实际调用 square 时，会把位置参数放到 &lt;code&gt;*args&lt;/code&gt;, &lt;code&gt;**kw-args&lt;/code&gt; 的左边（必须符合 Python 的参数定义约束）。所以上面的例子实际上等价于，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;kw1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="n"&gt;exponent&lt;/span&gt;&lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;kw2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;exponent&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;square&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;cube&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是如果下面这个例子中，我们就想固化中间的参数怎么办？显然调用 sum2 时只能通过关键字的方式传参。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num4&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;num1 = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num1&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;num2 = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;num3 = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num3&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;num4 = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num4&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;num1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;num3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;num4&lt;/span&gt;

&lt;span class="n"&gt;sum2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;paritcal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num3&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sum2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# TypeError: sum() got multiple values for keyword argument &amp;#39;num2&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;sum2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num4&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# num1 = 1&lt;/span&gt;
&lt;span class="c1"&gt;# num2 = 2&lt;/span&gt;
&lt;span class="c1"&gt;# num3 = 3&lt;/span&gt;
&lt;span class="c1"&gt;# num4 = 4&lt;/span&gt;
&lt;span class="c1"&gt;# 10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果固化参数时没有用关键字，那么实际上就是按顺序固化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;sum3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sum3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# num1 = 1&lt;/span&gt;
&lt;span class="c1"&gt;# num2 = 3&lt;/span&gt;
&lt;span class="c1"&gt;# num3 = 2&lt;/span&gt;
&lt;span class="c1"&gt;# num4 = 4&lt;/span&gt;
&lt;span class="c1"&gt;# 10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到 PFA 和待默认参数的函数很类似，但是 PFA 更灵活，原始函数不必提供参数默认值，而且可以得到很多偏函数调用，每个都能选择给不同参数默认值。&lt;/p&gt;
&lt;h2 id="practice"&gt;Practice&lt;/h2&gt;
&lt;p&gt;只使用这几个简单函数就可以把所有面向过程的代码都改写成 FP 的形式，但是转换出来的代码新手比较难理解，这很不 Pythonic（具体参考&lt;a href="https://debugtalk.com/post/python-functional-programming-getting-started/"&gt;这篇文章&lt;/a&gt;），我们也不应该这么做。Python 本身没有专门设计成一门函数式编程语言，在可预见的将来可以也不会变成函数式语言，Python 能流行起来很大的原因就是它的语法非常接近自然语言有很高的可读性，一方面 Python 在一直吸取 FP 的要素，比如 list comprehension 等语法，另外一方面虽然 FP 的代码更接近抽象层，但是实际上能习惯看数学表达式的人本来就不多而且 FP 目前也没有大面积推广，显然 Python 类似自然语言的语法可读性更好。如果呆板地为了 FP 而舍弃 Python 自身的精髓显然是一件非常愚蠢的事情。&lt;/p&gt;
&lt;p&gt;那么在 Python 中到底应该怎么运用 FP 呢？这里有两篇博客介绍了一些经验。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kite.com/blog/python/functional-programming/"&gt;Best Practices for Using Functional Programming in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming"&gt;A practical introduction to functional programming&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能地写 pure function&lt;/li&gt;
&lt;li&gt;尽可能地避免使用 mutability 对象&lt;/li&gt;
&lt;li&gt;有限地使用 class，改用 module 来代替 class（待讨论）&lt;/li&gt;
&lt;li&gt;不要滥用 lambda 和 high-order function&lt;/li&gt;
&lt;li&gt;必要时使用 generator&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;函数式编程是美丽而纯粹的，Python 是一门多范式编程语言并且支持 FP。事实上很多大牛 Python 程序猿都非常反感 Python 中的 FP，因为它很不 Pythonic。个人认为到底要不要在 Python 中使用 FP 取决于实际应用，不能削足适履强行套用，也不能无脑抵制。核心思想还是 The Zen of Python，有时候简单地使用 lambda, PFA 可以简化代码，提高可读性；在不影响可读性的情况下尽量将函数写出 pure 形式也可以提高代码的健壮性。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/howto/functional.html"&gt;Functional Programming HOWTO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/3112503/"&gt;Python 核心编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26381341/"&gt;Python Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056"&gt;函数式编程 - 廖雪峰的官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kite.com/blog/python/functional-programming/"&gt;Best Practices for Using Functional Programming in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming"&gt;A practical introduction to functional programming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://hackernoon.com/learn-functional-python-in-10-minutes-to-2d1651dece6f"&gt;Learn Functional Python Syntax in 10 Minutes [Tutorial]&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #9 —— Function Arguments 函数参数</title><link href="https://qian-gu.github.io/posts/cs/python-notes-9-function-arguments.html" rel="alternate"></link><published>2020-06-13T16:24:00+08:00</published><updated>2020-06-13T16:24:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-06-13:/posts/cs/python-notes-9-function-arguments.html</id><summary type="html">&lt;p&gt;函数参数小结&lt;/p&gt;</summary><content type="html">&lt;h2 id="positional-argument"&gt;Positional Argument&lt;/h2&gt;
&lt;p&gt;最普通常见的参数，函数调用时必须按照定义顺序准确传递，而且数量也必须一样，不能多也不能少。位置参数还有一种传参方式：通过关键字。如果在函数调用时给出参数名，这样就不必按照定义顺序传参了，因为解释器可以自己根据参数名进行传递。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="default-argument"&gt;Default Argument&lt;/h2&gt;
&lt;p&gt;如果定义函数时给参数默认值，那么在调用函数时可以传递也可以不传递这个参数，不传递时使用默认值。默认参数的好处是，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;帮助开发者更好的控制用户行为&lt;/li&gt;
&lt;li&gt;帮助用户更轻松的调用函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认参数可以让用户不必再操心每个繁琐的参数，当没有那么多必须操心的参数时，生活也不再那么复杂。而且一般默认值是精心选择过的 “ 最佳值 ”，用户一开始时可以不必面对繁琐的选项，随着时间流逝用户逐渐变成了专家，自然就能在需要时给默认参数传递新的值。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;显然默认参数在调用时不是必需的，有一个规则：所有的&lt;strong&gt;必需参数&lt;/strong&gt;都要在默认参数的前面！原因很简单，如果这两类参数混合在一起，那么解释器就无法确定用哪个值来匹配哪个参数。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;add2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结合关键字参数和默认参数，就可以实现 “ 跳过缺失参数 ” 的效果，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="n"&gt;add3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认参数并没有看上去的那么简单。首先，对默认参数的赋值只会在函数定义的时候绑定一次。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;spam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;
&lt;span class="n"&gt;spam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 1 42&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;
&lt;span class="n"&gt;spam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 1 42&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其次，给默认参数赋的值应该是不可变对象，如果默认值是可变容器的话，应该用 None 作为默认值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]):&lt;/span&gt;
    &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;END&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;

&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;连续调用两次就会发现问题。修改方法也很简单，将默认值改成 &lt;code&gt;None&lt;/code&gt; 即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;END&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;和 C++ 中的 const 一样，使用不变对象的好处有很多，首先它不会有修改数据导致错误的情况，其次多任务时也不必加锁，同时读取也没有关系。由这个例子就可以推出一个规则，如果一个变量可以定义为不变对象，那么尽量设计成不变对象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;有时候函数需要处理的参数数量是可变的，显然最简单的方法就是通过容器（&lt;code&gt;tuple&lt;/code&gt;， &lt;code&gt;list&lt;/code&gt;，&lt;code&gt;dict&lt;/code&gt;）来传递参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;

&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方式的问题在于：调用函数时必须先组装出一个容器对象，而利用变长参数则可以直接省去组装过程。因为普通参数有 positional 和 keyword 两种参数类型，所以变长参数也可以分为两类：变长位置参数、关键字参数。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="var-positional-argument"&gt;var-positional Argument&lt;/h2&gt;
&lt;p&gt;与普通位置参数对应的就是变长位置参数 var-positional argument，定义非关键字参数的方法很简单，只需要在参数名前面加上一个 &lt;code&gt;*&lt;/code&gt; 即可，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;

&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际调用时就不再需要组装的步骤，直接将参数挨个传递进去即可。如果已经有了一个 tuple 或者 list 对象，将其一一拆开传递进去是合法的，但是这样做太繁琐，可以直接在对象前面加上一个星号，将其转换成变长位置参数，这种写法是非常常见的。实际上星号后面的参数无论本身就是一个 tuple 还是 list，都会转化成一个 tuple 传递给函数，显然 tuple 内的元素可以是任意多个。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="var-keyword-argument"&gt;var-keyword Argument&lt;/h2&gt;
&lt;p&gt;与普通关键字参数对应的就是变长关键字参数 var-keyword argument，一个函数可以接收一个 &lt;code&gt;dict&lt;/code&gt; 对象作为普通参数，也可以将其定义为变长关键字参数。定义方法就是在参数名前面加上两个 &lt;code&gt;*&lt;/code&gt;，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;name:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;age:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;other:&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Michael&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Beijing&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Adam&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gender&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Engineer&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同理，可以将 dict 拆开后传递，也可以将 dict 转换成变长关键字参数，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;city&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Beijing&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;job&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Engineer&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;extra&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;city&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;extra&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;job&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;extra&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而且可以验证，上面例子中的 &lt;code&gt;**kw&lt;/code&gt; 是 &lt;code&gt;extra&lt;/code&gt; 的一份拷贝，操作 kw 不会影响 extra。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;extra&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;city&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Beijing&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;job&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Engineer&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;extra&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extra&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="keyword-only-argument"&gt;Keyword-only Argument&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-3102/"&gt;PEP 3102 -- Keyword-Only Arguments 原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keyword-only arguments&lt;/code&gt; 是 Python 3 中引入的新传参方式，在函数调用时必须以关键字的方式传递否则会报错。&lt;/p&gt;
&lt;p&gt;我们已经知道普通的 position arguments 可以按照位置隐式地传递，也可以通过关键字的方式显式地传递，而且 Python 支持可变参数 var-positional arguments，但是前提是 position arguments 必须全部放到 var-positional arguments 的前面（左边）。这个约束有时候并不是我们想要的，如前所述如果一个函数既想要一组  var-positional arguments 也想要几个可选的 keyword 参数，那么只能通过定义 keyword argument 的方式进行传递，然后在函数内部从这个 dict 中提取出 keyword。这样做有时候不太方便，而且有时候出于安全或者是提高代码可读性的考虑，我们想定义只能通过 keyword 方式传参的参数，因此引入了 keyword-only 参数。&lt;/p&gt;
&lt;p&gt;定义 keyword-only 参数的方法很简单，只要稍微改动一下之前的规则，允许常规参数出现在变长位置参数的后面即可，这时候这个常规参数就是 keyword-only 参数了，它必须通过关键字的方式进行传递：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果一个函数本身不需要接收可变参数，按照前面的规则就必须给它传递一个冗余的可变参数，但是这样做很不安全，所以进一步修改一下规则，把这个冗余的可变参数名省略掉只剩下一个单独的星号，如下面的形式即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;keyword-only 参数也可以有默认值，如果它带有默认值，那么调用函数时可以不传递新参数，否则必须传参。&lt;/p&gt;
&lt;h2 id="positional-only-arguments"&gt;Positional-only Arguments&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0570/"&gt;PEP 570 -- Python Positional-Only Parameters &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PEP 570 中还提出了一个新的符号 &lt;code&gt;/&lt;/code&gt; 来定义 positional-only 参数，与 &lt;code&gt;*&lt;/code&gt; 的作用刚好相反，&lt;code&gt;/&lt;/code&gt; 之前的参数全部都是 positional-only，即只能通过 position 的方式传参，不能通过关键字的方式。这个提议针对 Python 3.8 及以后的版本，目前在 accept 阶段，还没到 final 阶段，所以暂时先不讨论。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;综上，Python 中一共有 5 种参数，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位置参数&lt;/li&gt;
&lt;li&gt;默认参数&lt;/li&gt;
&lt;li&gt;可变参数&lt;/li&gt;
&lt;li&gt;关键字参数&lt;/li&gt;
&lt;li&gt;keyword-only 参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这五种参数的定义顺序有严格要求，有两条约束必须遵守，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变参数 &lt;code&gt;*args&lt;/code&gt; 必须作为最后一个位置参数出现&lt;/li&gt;
&lt;li&gt;关键字参数 &lt;code&gt;**kw-args&lt;/code&gt; 必须作为最后一个参数出现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合这两条就可以知道，keyword-only 参数只能出现在 &lt;code&gt;*args&lt;/code&gt; 和 &lt;code&gt;**kw-args&lt;/code&gt; 之间，所以函数的参数必须是下面的顺序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;positional&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keyword&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，如果调用函数时存在 &lt;code&gt;**args&lt;/code&gt; 惨素而且忽略了 default 参数，那么 &lt;code&gt;**args&lt;/code&gt; 会填到 default 寄存器的位置中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;show&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;a = &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;b = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;c = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;*args = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;d = &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;**kw-args&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;param1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;param2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# a =  1 &lt;/span&gt;
&lt;span class="c1"&gt;# b =  2 &lt;/span&gt;
&lt;span class="c1"&gt;# c =  4 &lt;/span&gt;
&lt;span class="c1"&gt;# *args =  (5,) &lt;/span&gt;
&lt;span class="c1"&gt;# d =  3 &lt;/span&gt;
&lt;span class="c1"&gt;# **kw-args {&amp;#39;param1&amp;#39;: 6, &amp;#39;param2&amp;#39;: 7}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;虽然 Python 支持各种方式的参数，但是实际应用中最好尽量减少参数组合，提高代码可读性。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/3112503/"&gt;Python 核心编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26381341/"&gt;Python Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888"&gt;函数的参数 - 廖雪峰的官方网站&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #8 —— Decorator 装饰器</title><link href="https://qian-gu.github.io/posts/cs/python-notes-8-decorator.html" rel="alternate"></link><published>2020-06-07T22:39:00+08:00</published><updated>2020-06-07T22:39:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-06-07:/posts/cs/python-notes-8-decorator.html</id><summary type="html">&lt;p&gt;Decorator 学习笔记&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0318/"&gt;PEP 318 -- Decorators for Functions and Methods 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-3129/"&gt;PEP 3129 -- Class Decorators 原文链接&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="what-decorator"&gt;What Decorator&lt;/h2&gt;
&lt;p&gt;一句话解释 decorator：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Decorator 是函数调用上的一种 “ 装饰 ”，这些装饰本质上是一个（高阶）函数，接受一个 callable 对象作为参数，（可选）返回一个 callable 对象，完成对目标的装饰。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，作为参数的 callable 对象就是等着被装饰的目标函数，而且这些函数自身也都带有参数，此时 decorator 就是一个高阶函数，返回值是一个闭包函数。&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;p&gt;函数式编程的背景知识是理解 Decorator 的关键。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;举例如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nd"&gt;@dec2&lt;/span&gt;
&lt;span class="nd"&gt;@dec1&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dec2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="why-decorator"&gt;Why Decorator&lt;/h2&gt;
&lt;p&gt;为什么需要定义 decorator 呢？一般来说，decorator 是给原函数增加一些额外的 “ 装饰 ”，比如 log，profiler 等操作。使用 decorator 带来的好处是，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以将这些事务性的代码和原函数代码隔离开&lt;/li&gt;
&lt;li&gt;decorator 可以在其他地方复用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 decorator &lt;strong&gt;让代码更加优美，也提高代码了的可读性。&lt;/strong&gt; 体现了 python 之禅的理念：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Beautiful is better than ugly.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Readability counts.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;在引入 decorator 之前，如果想对函数做变换（&lt;code&gt;transformation&lt;/code&gt;），只能将变换的代码放在函数体的最后，这样写出的代码很笨拙不容易理解。比如将 class 中的 method 定义为静态方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;perform&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;operation&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;classmethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方法在函数体很长时可读性就很差，而且为了声明一个函数把同一个名字重复写 3 次的做法也很不 Pythonic，所以 Python 为此专门发明了一种新语法糖：用 &lt;code&gt;@&lt;/code&gt; 符号表示的 decorator。比如下面这个函数经过了两次变换，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;classmethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就可以改写成这样的形式，写出来的代码看起来很简洁，也很有高级感。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nd"&gt;@classmethod&lt;/span&gt;
&lt;span class="nd"&gt;@synchronized&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Decorator 是在 python2.4 中才引入的，实际上在此之前的 python2.2 中就已经有两个 decorator 了：&lt;code&gt;classmethod()&lt;/code&gt; 和 &lt;code&gt;staticmethod()&lt;/code&gt;。当时大家都认为很快就会在整个 python 语言中加入这种语法支持。所以你可能会好奇为什么花了这么久的时间大家才达成共识，拖到 python2.4 才完成这项功能。下面列举了一些主要原因，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;decorator 的位置，几乎每个人都同意把 decorating/transforming 放在函数体的最后是不合适的，但是应该放在哪里却无法达成共识&lt;/li&gt;
&lt;li&gt;语法约束，Python 是一门约束非常强的语言以防你 “ 把事情搞砸 ”（包括视觉上和语法上），最好不要有让新手产生错误理解的语法&lt;/li&gt;
&lt;li&gt;大家都不熟悉 decorator 的概念，对于理解线性代数或者是已经掌握了一门其他编程语言的人来说，大部分 Python 代码都是非常直观的。几乎没有人在 Python 之前接触过 decorator 的概念&lt;/li&gt;
&lt;li&gt;关于语法的讨论一般来说更加容易引起争论&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="understanding-decorator"&gt;Understanding Decorator&lt;/h2&gt;
&lt;p&gt;如果仅从面向过程 / 面向对象的角度是很难理解 decorator 语法的，这是因为 decorator 的很多概念实际上来自于函数式编程，所以如果先接受了一些基本的函数式编程的概念，decorator 就很容易理解了。&lt;/p&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;FP 中最基本的概念：函数作为一等公民，和变量有同等地位，下面的概念都源自于这个最基本的原理。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下面的代码例子来自于参考资料 &lt;a href="https://github.com/yasoob/intermediatePython/blob/master/decorators.rst"&gt;Intermediate Python&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="everything-is-a-object"&gt;Everything is a Object&lt;/h3&gt;
&lt;p&gt;Python 中万物皆为对象 Object，数字、list、tuple、dict、function、method 这些都是对象，因为函数是对象，而且和变量有同等地位，我们可以创建变量指向同一个对象，自然也可以创建一个函数的引用，通过引用来调用这个函数，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yasoob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hi &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;# output: &amp;#39;hi yasoob&amp;#39;&lt;/span&gt;

&lt;span class="c1"&gt;# We can even assign a function to a variable like&lt;/span&gt;
&lt;span class="n"&gt;greet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;
&lt;span class="c1"&gt;# We are not using parentheses here because we are not calling the function hi&lt;/span&gt;
&lt;span class="c1"&gt;# instead we are just putting it into the greet variable. Let&amp;#39;s try to run this&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;# output: &amp;#39;hi yasoob&amp;#39;&lt;/span&gt;

&lt;span class="c1"&gt;# Let&amp;#39;s see what happens if we delete the old hi function!&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;#outputs: NameError&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;#outputs: &amp;#39;hi yasoob&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="nestedfunction"&gt;NestedFunction&lt;/h3&gt;
&lt;p&gt;因为函数和变量的地位相同，我们可以在函数内定义变量，自然也可以在函数内定义新的函数，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yasoob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;now you are inside the hi() function&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;now you are in the greet() function&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;welcome&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;now you are in the welcome() function&amp;quot;&lt;/span&gt;

    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;welcome&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;now you are back in the hi() function&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c1"&gt;#output:now you are inside the hi() function&lt;/span&gt;
&lt;span class="c1"&gt;#       now you are in the greet() function&lt;/span&gt;
&lt;span class="c1"&gt;#       now you are in the welcome() function&lt;/span&gt;
&lt;span class="c1"&gt;#       now you are back in the hi() function&lt;/span&gt;

&lt;span class="c1"&gt;# This shows that whenever you call hi(), greet() and welcome()&lt;/span&gt;
&lt;span class="c1"&gt;# are also called. However the greet() and welcome() functions&lt;/span&gt;
&lt;span class="c1"&gt;# are not available outside the hi() function e.g:&lt;/span&gt;

&lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c1"&gt;#outputs: NameError: name &amp;#39;greet&amp;#39; is not defined&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="function-as-return-value"&gt;Function as Return Value&lt;/h3&gt;
&lt;p&gt;因为函数和变量的地位相同，变量可以作为函数的返回值，自然函数也可以作为函数的返回值。（注意，函数名后面加上括号表示调用该函数，不加括号则表示这个函数的引用）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yasoob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;greet&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;now you are in the greet() function&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;welcome&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;now you are in the welcome() function&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;yasoob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;greet&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;welcome&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#outputs: &amp;lt;function greet at 0x7f2143c01500&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;#This clearly shows that `a` now points to the greet() function in hi()&lt;/span&gt;
&lt;span class="c1"&gt;#Now try this&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="c1"&gt;#outputs: now you are in the greet() function&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="function-as-parameter"&gt;Function as Parameter&lt;/h3&gt;
&lt;p&gt;因为函数和变量的地位相同，变量可以作为函数的参数，自然函数也可以作为函数的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hi yasoob!&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;doSomethingBeforeHi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;I am doing some boring work before executing hi()&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="n"&gt;doSomethingBeforeHi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;#outputs:I am doing some boring work before executing hi()&lt;/span&gt;
&lt;span class="c1"&gt;#        hi yasoob!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="put-it-all"&gt;Put it All&lt;/h3&gt;
&lt;p&gt;有了前面的这几个概念，decorator 的理解就非常简单了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先 decorator 是一个高阶函数，它可以接收一个（被装饰的函数）函数作为自己的参数&lt;/li&gt;
&lt;li&gt;其次 decorator 返回值也是一个函数（闭包函数），它完成对目标的装饰&lt;/li&gt;
&lt;li&gt;经过 decorator 装饰之后，调用原函数时，实际上执行的是 decorator 的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;因为我们实际调用的是 decorator 的返回值，所以打印原函数的 &lt;code&gt;--name--&lt;/code&gt; 时得到的就不再是原函数的名字了，这和一般的预期不符，我们希望的效果是 “decorator 是透明的 ”。python 提供了工具 &lt;code&gt;functool.wraps&lt;/code&gt; 来解决问题，本质上，&lt;code&gt;wraps()&lt;/code&gt; 也是一个装饰器。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;根据这两点，我们就可以写出一个自己的 log decorator 了，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;]&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;


&lt;span class="nd"&gt;@log&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@log&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;


&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中的 log 函数是一个 decorator，只有一个参数 func，接收被装饰的函数名，它的返回值是定义在自己内部的 wrapper 函数；因为 wrapper 函数用到了上层 log 函数的变量 func，所以它是一个闭包函数。func 自带的参数通过 wrapper 的 &lt;code&gt;args&lt;/code&gt; 和 &lt;code&gt;kwargs&lt;/code&gt; 传递到内部。这段代码运行结果如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
[Fri Jun 12 23:07:12 2020]add was called
[Fri Jun 12 23:07:13 2020]sub was called
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="decorator-with-arguments"&gt;Decorator with Arguments&lt;/h3&gt;
&lt;p&gt;前面的这个 log 例子中的 decorator 不带参数，无法区分装饰的目标，统一把 log 输出到 stdout 中。如果我们想把不同操作的 log 保存在不同文件中，该怎么做呢？显然 decorator 必须要能够再接收一个额外的参数，实际上直接给 log 函数增加新参数是不行的，我们只能采用一种曲线救国的方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 decorator 外面再包一层函数，这个函数的功能是接收参数并且返回我们想要的实现装饰功能的 ( 闭包 ) 函数。&lt;/strong&gt;一般带参数的 decorator 的形式如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nd"&gt;@decomaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deco&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;decomaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deco&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种形式看起来依然比较难理解，实际等效于下面的形式，首先 decomaker 使用 deco-args 作为参数，返回闭包函数赋值给 deco，然后 deco 对 foo 进行装饰。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;deco&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;decomaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deco&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;deco&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以 log 的例子修改如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;operator.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;decorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;] &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;
            &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;opened&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;opened&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;decorator&lt;/span&gt;


&lt;span class="nd"&gt;@log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;add.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sub.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;


&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;log-to-file 是一个有参 decorator，接收一个名为 log-file 的参数，并返回 log-decorator 函数。运行之后会在显示 log 记录的同时把记录写入到对应的两个文件中。&lt;/p&gt;
&lt;h2 id="decorator-class"&gt;Decorator Class&lt;/h2&gt;
&lt;p&gt;前面介绍的语法是 function 装饰 function，实际上 decorator 也可以写成 class 的形式，class 作为 decorator 只需要实现下面两点即可，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 &lt;code&gt;--init--&lt;/code&gt; 方法，用来接收被 decorated 的函数名&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;--call--&lt;/code&gt; 方法，实现装饰效果&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition tip"&gt;
&lt;p class="admonition-title"&gt;Tip&lt;/p&gt;
&lt;p&gt;实际上成为 decorator 的要求只有一个：它必须接受一个 callable 对象作为参数，并且返回一个 callable 对象。根据这个约束，上面两点就很容易理解了。&lt;/p&gt;
&lt;p&gt;根据这个约束，可以推测出一个事实：如果 func 本身不需要参数而且 decorator 本身也不需要的参数，那么 decorator 也不需要写成返回闭包函数的形式，下面的代码也能正常运行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;decorating &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;dec2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;decorating again &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;

&lt;span class="nd"&gt;@dec2&lt;/span&gt;
&lt;span class="nd"&gt;@dec&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;say&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;不过这种 decorator 的限制比较强，自身和目标函数都不能带参数，可能实用性不大，但是可以帮助我们理解 decorator 的概念。因为一般函数都 decorator 都是带参数的，所以就像前面的例子表现的一样 decorator 大部分情况下都是一个返回闭包的高阶函数。&lt;/p&gt;
&lt;p&gt;关于这个约束，实际上接收 callable 对象作为参数是必须的，返回 callable 对象则不一定，如果这个 decorator 设计成不需要后续再串接其他 decorator，那么返回值就不必是 callable 对象，如内建的 properity 等。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;用 class 实现 decorator 的好处是保持用法不变的同时代码更加清晰，而且可以通过继承扩展出新的 decorator。继续以 log 装饰器为例，首先我们把它改造成 class 形式，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BasicLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A basic log class.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;] &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="nd"&gt;@BaiscLog&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@BasicLog&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;


&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个 BasicLog 的效果和最开始的 log decorator 效果是一样的，不过看起来更清晰一点，后期扩展也更容易。显然，这个 BasicLog 无法接收参数，所以也不能根据不同操作保存到不同 log 文件中。我们改造一下它，让它可以接收参数。需要注意的是：无法在 BasicLog 的基础上直接通过简单的继承构造出一个新的 decorator，而应该做如下修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--init--&lt;/code&gt; 不再接收 func 参数，而是接收 class 参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--call--&lt;/code&gt; 接收 func 参数并实现装饰效果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的改动类似于 function 形式的 decorator，无参数时 &lt;code&gt;--call--&lt;/code&gt; 就是需要返回的闭包函数，它直接完成装饰工作；有参数时，&lt;code&gt;--init--&lt;/code&gt; 用来接收其他参数，而 &lt;code&gt;--call--&lt;/code&gt; 变成了一个原来闭包函数的 wrapper，它负责接受 func 参数，定义在 &lt;code&gt;--call--&lt;/code&gt; 内部的闭包函数 deco 完成真正的装饰工作。&lt;/p&gt;
&lt;p&gt;修改后的新 decorator 如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sleep&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FileLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A log class for writing log into files.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;operator.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;deco&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;] &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;
            &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;opened&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;opened&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;deco&lt;/span&gt;

&lt;span class="nd"&gt;@FileLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;add.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="nd"&gt;@FileLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sub.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="build-in-decorator"&gt;Build-in Decorator&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;@propority&lt;/p&gt;
&lt;p&gt;可以把 class 的 method 伪装成属性，本来 &lt;code&gt;Foo.func()&lt;/code&gt; 的调用方法就变成了 &lt;code&gt;Foo.func&lt;/code&gt; 形式，可以让调用者写出简短的代码，同时又能保证对参数的检查等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@staticmethod&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;@calssmethod&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;这三个内置 decorator 的返回结果都不是 callable 对象，所以它们只能放在 decorator 的最外层，后面有个相关例子。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="class-decorator"&gt;Class Decorator&lt;/h2&gt;
&lt;p&gt;Decorator 不仅可以装饰 function，它也可以装饰 class。&lt;/p&gt;
&lt;p&gt;在 python2.4 引入 decorator 的时候，只能用于 function 或者是 method，class 是无法使用 decorator 的。几乎可以确定地说，decorator 能实现的功能用 metaclass 同样可以实现，但是 metaclass 的方式太过晦涩，由于 Guido 的坚持反对，直到在 PEP3129 中讨论了 class 的 decorator 之后，在 python3.0 中最终加入 class decorator。&lt;/p&gt;
&lt;p&gt;Class decorator 的设计目标和语法和 function decorator 完全相同，唯一的区别就是你在 “ 装饰 ” class 对象。语法如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="nd"&gt;@foo&lt;/span&gt;
&lt;span class="nd"&gt;@bar&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;随便写个 class 然后直接用前面的 log 函数进行装饰，代码如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;] &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;

&lt;span class="nd"&gt;@log&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Class for general people.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;My name is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Change name to &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

&lt;span class="n"&gt;Jack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
[Fri Jun 12 23:16:27 2020] People was called
My name is Jack
Change name to Tom
My name is Tom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果和我们的预期不符，只有例化对象时调用了 log 进行装饰，调用其他方法时却没有调用。&lt;/p&gt;
&lt;p&gt;最无脑的解决方法是给每个方法前面都加上装饰，虽然这样修改之后结果如我们预期，但是这种方法违反了 DRY 原则，每个方法都要手动加上装饰，以后新增方法也要添加，如果不需要 log 功能又要逐行删掉所有的装饰语句，这很不 pythonic。我们期望的效果是：只在 class 的定义处只做一次装饰声明，实现对内部所有方法的装饰。&lt;/p&gt;
&lt;p&gt;修改方法一：根据前面的思路对于 class 的 decorator，显然输入参数是一个 class，最终返回的也是一个 class，只需要在函数内部对输入 class 的 &lt;code&gt;--getattribute--&lt;/code&gt; 方法进行特殊定义即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="n"&gt;orig&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;getattribute&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;getattribute&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;getattribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;] &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;orig&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;getattribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;getattribute&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;getattribute&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;cls&lt;/span&gt;

&lt;span class="nd"&gt;@new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Class for general people.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;My name is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Change name to &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

&lt;span class="n"&gt;Jack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法二：要修改一个 class 的行为，除了上面的方法之外还有一种就是给原始 class 包一层，只需要修改 wrapper class 的 &lt;code&gt;--getattr--&lt;/code&gt; 方法即可通过代理和授权实现 decorator 的效果。代码如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;NewCls&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Decorated new class.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NewCls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inst&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;[&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ctime&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;] &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="o"&gt;.--&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; was called&amp;quot;&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;

        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nb"&gt;getattr&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;getattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;NewCls&lt;/span&gt;


&lt;span class="nd"&gt;@new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;log&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Class for general people.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;My name is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;change&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Change name to &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;

&lt;span class="n"&gt;Jack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Jack&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;change&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Jack&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
[Fri Jun 12 23:20:51 2020] get-name was called
My name is Jack
[Fri Jun 12 23:20:51 2020] change-name was called
Change name to Tom
[Fri Jun 12 23:20:51 2020] get-name was called
My name is Tom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="caveats"&gt;Caveats&lt;/h2&gt;
&lt;p&gt;这部分内容来自于参考链接 &lt;a href="https://www.cnblogs.com/cicaday/p/python-decorator.html"&gt;详解 Python 的装饰器&lt;/a&gt;，非常有意思，搬运过来记录一下。&lt;/p&gt;
&lt;p&gt;第一个例子如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;html&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;begin outer function.&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;begin of inner wrapper function.&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;&lt;/span&gt;&lt;span class="si"&gt;{tag}&lt;/span&gt;&lt;span class="s2"&gt;&amp;gt;&lt;/span&gt;&lt;span class="si"&gt;{content}&lt;/span&gt;&lt;span class="s2"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="si"&gt;{tag}&lt;/span&gt;&lt;span class="s2"&gt;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;end of inner wrapper function.&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;end of outer function&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapper&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;

&lt;span class="nd"&gt;@html&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Toby&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt;!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码的运行结果如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
begin&lt;span class="w"&gt; &lt;/span&gt;outer&lt;span class="w"&gt; &lt;/span&gt;function.
end&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;outer&lt;span class="w"&gt; &lt;/span&gt;function
begin&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;inner&lt;span class="w"&gt; &lt;/span&gt;wrapper&lt;span class="w"&gt; &lt;/span&gt;function.
end&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;inner&lt;span class="w"&gt; &lt;/span&gt;wrapper&lt;span class="w"&gt; &lt;/span&gt;function.
&lt;span class="nt"&gt;&amp;lt;b&amp;gt;&lt;/span&gt;Hello&lt;span class="w"&gt; &lt;/span&gt;Toby!&lt;span class="nt"&gt;&amp;lt;/b&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;b&amp;gt;&lt;/span&gt;Hello&lt;span class="w"&gt; &lt;/span&gt;Toby!&lt;span class="nt"&gt;&amp;lt;/b&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个结果说明一旦一个函数被装饰过，那么以后就再也无法调用原函数了，原函数名指向的是被装饰过的函数，而且是最里层的那个闭包函数。所以尽量把逻辑都写在最里层的闭包内，以防出现与预期不符的结果。&lt;/p&gt;
&lt;p&gt;第二个例子，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;

    &lt;span class="nd"&gt;@logging&lt;/span&gt;  &lt;span class="c1"&gt;# 装饰实例方法，OK&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; is running!&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;@logging&lt;/span&gt;  &lt;span class="c1"&gt;# 装饰静态方法，Failed&lt;/span&gt;
    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;check&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Car&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;The model of your car is &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt; is not a car!&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Traceback (most recent call last):&lt;/span&gt;
&lt;span class="sd"&gt;...&lt;/span&gt;
&lt;span class="sd"&gt;  File &amp;quot;example-4.py&amp;quot;, line 10, in logging&lt;/span&gt;
&lt;span class="sd"&gt;    @wraps(func)&lt;/span&gt;
&lt;span class="sd"&gt;  File &amp;quot;C:\Python27\lib\functools.py&amp;quot;, line 33, in update-wrapper&lt;/span&gt;
&lt;span class="sd"&gt;    setattr(wrapper, attr, getattr(wrapped, attr))&lt;/span&gt;
&lt;span class="sd"&gt;AttributeError: &amp;#39;staticmethod&amp;#39; object has no attribute &amp;#39;--module--&amp;#39;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个例子证明了 &lt;code&gt;@staticmethod&lt;/code&gt; 返回的 staticmethod 对象不是 callable 的，所以无法再继续传递给其他 decorator。解决方法也很简单，调整一下顺序将 staticmethod 放在最后就好了。&lt;/p&gt;
&lt;h2 id="using-3rd-lib"&gt;Using 3rd Lib&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/micheles/decorator"&gt;decorator.py&lt;/a&gt; 和 &lt;a href="https://pypi.org/project/wrapt/"&gt;wrapt&lt;/a&gt; 都是帮助我们写 decorator 的第三方包，使用它们的好处是一方面可以减少函数嵌套的层数，像前面带参数的 decorator 要嵌套定义 3 层，看起来有点难懂；另一方面可以帮我们解决函数签名等问题。详细内容直接看官方文档即可。&lt;/p&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0318/"&gt;PEP318&lt;/a&gt; 和 &lt;a href="https://wiki.python.org/moin/PythonDecoratorLibrary"&gt;Python Decorator Library&lt;/a&gt; 中列举了很多可以直接使用的 decorator 例子，具体使用方法直接看原文即可。&lt;/p&gt;
&lt;h2 id="design-decorator"&gt;Design Decorator&lt;/h2&gt;
&lt;p&gt;这部分是扩展阅读。PEP318 提到了很多设计 decorator 时的考虑因素和对比取舍，了解这些背景知识可以增加我们对 Python 的理解。下面是一些内容的翻译和笔记。&lt;/p&gt;
&lt;h3 id="name-choice"&gt;Name Choice&lt;/h3&gt;
&lt;p&gt;很多人抱怨 decorator 这个名字，因为它和实际的用法并不一致，之所以选择这个名字，很可能是借鉴了编译器领域的术语，可能以后会换成一个更加合适的名字。&lt;/p&gt;
&lt;h3 id="goals"&gt;Goals&lt;/h3&gt;
&lt;p&gt;Decorator 的设计目标包括，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种语法应该能适用于任何 wrapper，包括用户自定义的函数以及已经存在的内建函数 &lt;code&gt;classmethod()&lt;/code&gt;、&lt;code&gt;staticmethod()&lt;/code&gt;，这个要求也意味着 decorator 的语法要能支持传参&lt;/li&gt;
&lt;li&gt;能支持多个 wrapper 嵌套&lt;/li&gt;
&lt;li&gt;语法要足够明显，至少要让新手写代码时可以安全地忽略它的存在&lt;/li&gt;
&lt;li&gt;一旦解释就应该很容易记住 "that ...[is] easy to remember once explained."&lt;/li&gt;
&lt;li&gt;方便未来扩展&lt;/li&gt;
&lt;li&gt;容易书写，代码会经常使用这种语法&lt;/li&gt;
&lt;li&gt;不会增加快速浏览代码的难度，应该很容易搜索&lt;/li&gt;
&lt;li&gt;不要使其他工具难以支持&lt;/li&gt;
&lt;li&gt;允许将来的编译器做优化，未来会有一个 python 的 JIT 编译器，所以需要把 decorator 放在函数定义的前面&lt;/li&gt;
&lt;li&gt;从函数的结尾处挪到函数的开头，more in your face&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="current-syntax"&gt;Current Syntax&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nd"&gt;@dec2&lt;/span&gt;
&lt;span class="nd"&gt;@dec1&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dec2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dec1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样就不需要像原来那样再定义一个同名的变量，多做一次赋值。decorator 就在函数声明的附近，&lt;code&gt;@&lt;/code&gt; 符号可以明确表明这里有一些新语法。&lt;/p&gt;
&lt;p&gt;Decorator 的顺序设计是为了和数学中的函数规则相匹配，比如 &lt;span class="math"&gt;\((g \circ f)(x)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(g(f(x))\)&lt;/span&gt; 是等价的，在 python 中，&lt;code&gt;@g @f def foo()&lt;/code&gt; 会翻译成 &lt;code&gt;foo=g(f(foo))&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;decorator 语法允许调用一个返回 decorator 的函数，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nd"&gt;@decomaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;decomaker&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argA&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argB&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之所以允许一个函数返回 decorator，部分原因是 @ 符号可以看作是一个表达式（虽然在语法上仅限于作用在函数上），所以任何时候调用都会返回这个表达式。&lt;/p&gt;
&lt;h3 id="syntax-alternatives"&gt;Syntax Alternatives&lt;/h3&gt;
&lt;p&gt;实际上在确定最终的语法之前，还有很多变种语法，下面列举了几大类，从中可以看到 python 设计的思路和决策取舍，增加对 python 的理解。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Decorator Location&lt;/p&gt;
&lt;p&gt;一种写法如下，把 decorator 放在 def 和函数名，或者是函数名和参数表之间，其缺点是无法使用 &lt;code&gt;def foo(&lt;/code&gt; 来 grep 寻找函数定义，而且有多个 decorator 时代码会变得非常笨重。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nd"&gt;@classmethod&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nd"&gt;@accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="nd"&gt;@returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="nd"&gt;@classmethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt; &lt;span class="nd"&gt;@accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="nd"&gt;@returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;另外一种写法是把 decorator 放在参数表和行尾的冒号之间，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nd"&gt;@classmethod&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nd"&gt;@accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="nd"&gt;@returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;Guido 总结了下面几个理由来反对这种写法，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐藏了关键信息&lt;/li&gt;
&lt;li&gt;如果参数表和 decorator 都很长，很容易忘记两者之间的转化&lt;/li&gt;
&lt;li&gt;decorator 在行中间，cut/copy 重用很麻烦&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一种写法把 decorator 放在函数体内部的开头 docstring 的位置，这种写法的主要问题是要先 “ 偷窥 ” 一下函数内部才能确定 decorators，而且 decorator 在函数运行的时候并不会被执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nd"&gt;@accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nd"&gt;@returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;还有一种写法是产生一个新的代码块，这种写法的问题是 decorated 和 undecorated 函数的缩进不一样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;decorate&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nb"&gt;classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;decorate&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Syntax forms&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;@decorator&lt;/code&gt; 方式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nd"&gt;@classmethod&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="nd"&gt;@accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;主要的反对意见是之前的 Python 中没有用到 @ 符号（IPython 和 Leo 中用到了），而且  @ 符号没有实际含义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;|decorator&lt;/code&gt; 方式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="nb"&gt;classmethod&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这种语法的好处是 IPython 和 Leo 不会冲突，缺点是 &lt;code&gt;|&lt;/code&gt; 符号和大写字母 &lt;code&gt;I&lt;/code&gt;、小写字母 &lt;code&gt;i&lt;/code&gt; 很像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 list 语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;classmethod&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;主要问题是 list 语法是有实际含义的，而且这种写法无法很清楚地表明这就是一个 decorator。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用其他括号的 list 语法，&amp;lt;...&amp;gt;, [[...]] 等&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;classmethod&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;accepts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;returns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;两个方括号的写法只能表明 decorator 不是一个 list，而 &amp;lt;&amp;gt; 的方式解析起来很麻烦，而且容易和大于、小于号产生歧义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;decorator()&lt;/code&gt; 函数&lt;/p&gt;
&lt;p&gt;这个函数其实是一个使用内省机制实现操作内部函数的 magic function，Guido 坚决反对这种用法，因为不引入新语法，这种写法看起来 “ 魔力值 ” 会非常高，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Using functions with "action-at-a-distance" through sys.settraceback may be okay for an obscure feature that can't be had any other way yet doesn't merit changes to the language, but that's not the situation for decorators. The widely held view here is that decorators need to be added as a syntactic feature to avoid the problems with the postfix notation used in 2.2 and 2.3. Decorators are slated to be an important new language feature and their design needs to be forward-looking, not constrained by what can be implemented in 2.3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用新的关键字 / block&lt;/p&gt;
&lt;p&gt;这种写法用到了新的关键字 &lt;code&gt;using&lt;/code&gt;，而且 block 看起来是个普通的代码块，但实际上它并不是，如果在 block 内尝试写语句则会报错，这会让使用者非常困扰。Guido 拒绝了这种方案，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;... the syntactic form of an indented block strongly suggests that its contents should be a sequence of statements, but in fact it is not -- only expressions are allowed, and there is an implicit "collecting" of these expressions going on until they can be applied to the subsequent function definition. ...&lt;/p&gt;
&lt;p&gt;... the keyword starting the line that heads a block draws a lot of attention to it. This is true for "if", "while", "for", "try", "def" and "class". But the "using" keyword (or any other keyword in its place) doesn't deserve that attention; the emphasis should be on the decorator or decorators inside the suite, since those are the important modifiers to the function definition that follows. ...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Why @&lt;/p&gt;
&lt;p&gt;Javadoc 和 Java1.5 用到了  @ 符号作为标记，这种用法和 python 非常相似。之前的 Python 版本不支持  @ 符号意味着这些代码无法在旧版本的 python 上运行，所以也就不会导致微妙的语法错误，这也意味着 decorator 的声明不再有歧义。即使这样仍然有人认为 @ 符号的选用太过随意，提议用其他符号来代替，比如 |, [|...|], &lt;em&gt;[...]&lt;/em&gt;, &amp;lt;...&amp;gt; 等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;Decorator 是一个高阶函数，可以在不影响目标函数的前提下，对其进行装饰，实现一些增强 / 辅助效果。Decorator 可以是 function 形式也可以是 class 形式，它修饰的对象可以是 function 也可以是 class。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/3112503/"&gt;Python 核心编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/yasoob/intermediatePython/blob/master/decorators.rst"&gt;Intermediate Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://coolshell.cn/articles/11265.html"&gt;Python 修饰器的函数式编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cnblogs.com/cicaday/p/python-decorator.html"&gt;详解 Python 的装饰器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.codementor.io/@sheena/advanced-use-python-decorators-class-function-du107nxsv"&gt;Advanced Uses of Python Decorators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.python.org/moin/PythonDecoratorLibrary"&gt;Python Decorator Library&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26381341/"&gt;Python Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #7 —— Generator 生成器</title><link href="https://qian-gu.github.io/posts/cs/python-notes-7-generator.html" rel="alternate"></link><published>2020-06-01T15:13:00+08:00</published><updated>2020-06-01T15:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-06-01:/posts/cs/python-notes-7-generator.html</id><summary type="html">&lt;p&gt;Generator 学习笔记&lt;/p&gt;</summary><content type="html">&lt;h2 id="what-is-generator"&gt;What is Generator&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0255/"&gt;PEP 255 -- Simple Generators 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Python 中的 generator 有两类，generator function 和 generator expressions。Genrator Function 实际上是一个工厂函数（&lt;code&gt;factory&lt;/code&gt;），使用 lazily 计算方式。其特点就是：遇到 &lt;code&gt;yield&lt;/code&gt; 之后，函数后续代码就不再执行，但是也不会退出函数，在下次被调用时会从 yield 之后继续执行。&lt;/p&gt;
&lt;p&gt;任意一个 &lt;code&gt;generator&lt;/code&gt; 都是一个 &lt;code&gt;iterator&lt;/code&gt;，但是反之不一定成立。generator 本质上是一种特殊的更高级的 &lt;code&gt;Iterator&lt;/code&gt;，高级的地方在于，不用实现 &lt;code&gt;--iter()--&lt;/code&gt; 和 &lt;code&gt;--next()--&lt;/code&gt; 方法，只需要一个关键字 &lt;code&gt;yield&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="why-generator"&gt;Why Generator&lt;/h2&gt;
&lt;p&gt;因为 list comprehensions 语法非常简洁，所以在实际中使用非常广泛，但是 list comprehensions 存在的一个问题是，它的返回值是一个 list 对象，当数据量比较小的时候，直接用 list comprehensions 没有问题，但是当数据量比较大的时候问题就出现了，&lt;strong&gt;&lt;code&gt;list 对象会占用大量的内存空间&lt;/code&gt;&lt;/strong&gt;。很多时候实际上我们并不需要一次性全部把 list 生成好放到内存中，因为我们每次只处理其中的一个元素，如果只是在每次需要对应的元素时才生成它，那么就能节省大量的内存空间了，这就是 generator 出现的原因。&lt;/p&gt;
&lt;h2 id="construct-generator"&gt;Construct Generator&lt;/h2&gt;
&lt;p&gt;如何得到一个生成器呢？&lt;/p&gt;
&lt;h3 id="generator-function"&gt;Generator Function&lt;/h3&gt;
&lt;p&gt;使用关键字 &lt;code&gt;yield&lt;/code&gt; 可以把一个普通函数转换成 generator。下面是一个产生 Fibonacci 数列的典型例子，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt;
        &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="generator-expression"&gt;Generator Expression&lt;/h3&gt;
&lt;p&gt;另外一种得到 generator 的方法是 generator expressions，&lt;a href="https://www.python.org/dev/peps/pep-0289/"&gt;PEP 289 -- Generator Expressions 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;顾名思义，generator expressions 就是产生 genrator 的表达式，这个表达式的返回值是一个 generator 对象。&lt;/p&gt;
&lt;p&gt;Generator Expression 和 List Comprehension 语法非常相似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List Comprehension: &lt;code&gt;[expr for iter-var in iterable if cond-expr]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Generator Expression: &lt;code&gt;(expr for iter-var in iterable if cond-expr)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是因为它们的语法非常相似，所以把代码中已有的 list comprehensions 改成 generator comprehensions 非常容易。&lt;/p&gt;
&lt;p&gt;list comprehensions 的出现极大地降低了 &lt;code&gt;filter()&lt;/code&gt; 和 &lt;code&gt;map()&lt;/code&gt; 的使用，同样 generator expressions 的出现极大地降低了 &lt;code&gt;itertools.ifilter()&lt;/code&gt; 和 &lt;code&gt;itertools.imap()&lt;/code&gt; 的使用，而且 &lt;code&gt;itertools&lt;/code&gt; 中的其他迭代器还能和 generator comprehensions 配合起来使用。&lt;/p&gt;
&lt;p&gt;Reduction 函数（比如 &lt;code&gt;sum()&lt;/code&gt;, &lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt; 等）会把一个 Iterable 对象转换成一个单独的值，这种场景非常适合配合使用 generator。&lt;/p&gt;
&lt;p&gt;虽然经过优化之后，在中、小数据量的时候，list comprehensions 和 generator expressions 的性能是差不多的，但是对于大数据量的场景，generator expressions 仍然具有性能优势。&lt;/p&gt;
&lt;h2 id="using-generator"&gt;Using Generator&lt;/h2&gt;
&lt;p&gt;因为 generator 本身是一个可迭代对象 &lt;code&gt;Iterable&lt;/code&gt;，所以我们可以直接在 for 循环中使用它，就像迭代 list 对象一样。下面是《python 核心编程》中的一个例子，说明了 generator expressions 的优势和用法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：如何获取一个文件中最大的行长度？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;版本一：，打开文件，用 &lt;code&gt;readlines()&lt;/code&gt; 把所有的行都读到一个 list 中，然后迭代该 list，找到最大行长度，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/etc/motd&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;longest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;allLines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readlines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;allLines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;linelen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;linelen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;longest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;linelen&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;版本二：针对版本一，使用 list comprehensions 简化代码，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/etc/motd&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;longest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;allLines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readlines&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;allLines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;linelen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;linelen&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;longest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;linelen&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;版本一和版本二的问题在于，&lt;code&gt;readlines&lt;/code&gt; 会把所有文件内容都读出来，不适用于大文件的情况。因为迭代器是支持文件类型的，所以我们可以用迭代器来替换 &lt;code&gt;readlines&lt;/code&gt;。而且我们已经获取到行内容了，可以直接把行长度存下来，而不是行内容。这里的优化有两个：iterator 的使用可以简化代码，直接保存行长度节省内存。版本三的代码如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/etc/motd&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;longest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;allLines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;allLines&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;版本三的代码的问题在于，因为 allLines 本质上还是一个 list，所以虽然使用了迭代器，仍然需要把整个文件都读到内存中。这个时候就该 generator expressions 出场了，用它来代替 list comprehensions，然后把它放到 max 函数里面，就有版本四的代码，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/etc/motd&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;longest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;longest&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;至此，已经不存在占用内存过大的问题了。不过还可以进一步将其简化为一行代码，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/etc/motd&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最终版的代码非常简洁，用 1 行代码高性能地实现了前面 9 行低效代码的功能，同时也不晦涩。&lt;/p&gt;
&lt;h2 id="list-comprehension-iterator-generator"&gt;List Comprehension &amp;amp; Iterator &amp;amp; Generator&lt;/h2&gt;
&lt;p&gt;总结这三种语法，可以深刻体会到 Python 的设计哲学：&lt;strong&gt;Simple is better than complex.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这三种语法让我们可以写出更加简洁优美的代码，不需要写繁琐的 for 循环，也不需要定义和维护一堆中间变量，就可以写出 streaming code，而且大数据量场景下 generator 的 memory/CPU 效率也很高。&lt;/p&gt;
&lt;p&gt;下面有一张国外作者文章 &lt;a href="https://nvie.com/posts/iterators-vs-generators/"&gt;Iterables vs. Iterators vs. Generators&lt;/a&gt;中的图，帮助区分和理解这三个概念。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://nvie.com/img/relationships.png"&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0255/"&gt;PEP 255 -- Simple Generators 原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0289/"&gt;PEP 289 -- Generator Expressions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/3112503/"&gt;Python 核心编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nvie.com/posts/iterators-vs-generators/"&gt;Iterables vs. Iterators vs. Generators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://foofish.net/iterators-vs-generators.html"&gt;完全理解 Python 迭代对象、迭代器、生成器&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #6 —— Iterator 迭代器</title><link href="https://qian-gu.github.io/posts/cs/python-notes-6-iterator.html" rel="alternate"></link><published>2020-05-24T22:47:00+08:00</published><updated>2020-05-24T22:47:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-05-24:/posts/cs/python-notes-6-iterator.html</id><summary type="html">&lt;p&gt;Iterator 学习笔记&lt;/p&gt;</summary><content type="html">&lt;h2 id="what-is-iterator"&gt;What is Iterator&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0234/"&gt;PEP 234 -- Iterators 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Sequence 是 python 中的一种数据结构，它们的成员是有序排列的，可以通过下标来访问特定元素，比如字符串、list、tuple 等都是 sequence。很多时候我们需要对 sequence 进行顺序访问，最简单的方法是写一个 for 循环，通过计数的方式实现迭代。但是计数的方式很原始也不高效，所以 python 提供了 iterator 来迭代 sequence。Iterator 在 Python 中使用非常广泛，它不仅对 sequence 的支持是无缝的，它还能迭代那些具有 sequence 的行为但实际上并不是 sequence 的对象，比如 dict 的 keys 以及 file。&lt;/p&gt;
&lt;p&gt;Iterator 实际上是一个实现了工厂模式的对象，它通过 &lt;code&gt;next()&lt;/code&gt; 方法来获取元素，而不是通过 index 计数来实现。for 循环只要调用 iterator 的 next 方法，就能获得 sequence 中的下一项，当迭代完所有的 item 后，再次调用会返回一个 &lt;code&gt;StopIteration&lt;/code&gt; 的异常，这个异常并不代表发生了错误，而是告诉调用者，迭代已经完成了。&lt;/p&gt;
&lt;h2 id="iteratable-vs-iterator"&gt;Iteratable vs Iterator&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;含有 &lt;code&gt;--iter--()&lt;/code&gt; 或 &lt;code&gt;--getitem--()&lt;/code&gt; 方法的对象称为 “ 可迭代对象 ”：&lt;code&gt;Iteratable&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以用 &lt;code&gt;isinstance()&lt;/code&gt; 判断一个对象是否为 &lt;code&gt;Iteratable&lt;/code&gt; 对象，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;

&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;([],&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;({},&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;实现了 &lt;code&gt;next()&lt;/code&gt; 方法的对象称为迭代器：&lt;code&gt;Iterator&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以用 &lt;code&gt;isinstance()&lt;/code&gt; 判断一个对象是否为 &lt;code&gt;Iterator&lt;/code&gt; 对象，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;

&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;([],&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;({},&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;abc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;lsit&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt; 等都是 &lt;code&gt;Iterable&lt;/code&gt;，但不是 &lt;code&gt;Iterator&lt;/code&gt;，可以用 &lt;code&gt;iter()&lt;/code&gt; 得到其对应的 &lt;code&gt;Iterator&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，python 的 for 循环作用于 Iterable 时，会自动调用 &lt;code&gt;iter()&lt;/code&gt; 来得到对应的 Iterator，然后不断调用 next 获取其中的元素，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Python 在底层实现时，会自动替换成下面的方式，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;fetch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;StopIteration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结论：&lt;strong&gt;对于 &lt;code&gt;Iterable&lt;/code&gt; 对象，我们可以直接用 for 循环来迭代。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="why-iterator"&gt;Why Iterator&lt;/h2&gt;
&lt;p&gt;翻译自 PEP234：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了一种可扩展的 iterator 接口&lt;/li&gt;
&lt;li&gt;加强了 list 的迭代性能&lt;/li&gt;
&lt;li&gt;dict 的迭代性能巨大提升&lt;/li&gt;
&lt;li&gt;迭代功能的底层实现是真正的迭代，而不是用随机访问来模拟&lt;/li&gt;
&lt;li&gt;兼容目前已有的所有用户自定义的 class、模拟 sequence 和 dict 的扩展对象、甚至那些只实现了 &lt;code&gt;{--getitee--, keys, valus, itmes}&lt;/code&gt; 的 mappings&lt;/li&gt;
&lt;li&gt;迭代那些非 sequence 对象的代码可以更加简洁，可读性更高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="construct-iterator"&gt;Construct Iterator&lt;/h2&gt;
&lt;p&gt;如何得到一个迭代器呢？&lt;/p&gt;
&lt;h3 id="bit"&gt;BIT&lt;/h3&gt;
&lt;p&gt;对于 Python 内建数据类型，比如容器，只需要用内建函数 &lt;code&gt;iter()&lt;/code&gt; 就可以得到对应的迭代器，具体有两种调用方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sentinel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iter(obj)&lt;/code&gt;，返回一个迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iter(func, sentinel)&lt;/code&gt;，iter 会重复调用 func，直到迭代返回值为 sentinel 时停止迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="delegate"&gt;Delegate&lt;/h3&gt;
&lt;p&gt;如果是一个自定义容器，内部包含一个 list、tuple、dict 等可迭代对象，那么可以直接在自定义容器中定义一个 &lt;code&gt;--iter()--&lt;/code&gt; 方法，将迭代请求委托到容器内容对象上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;children&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.-&lt;/span&gt;&lt;span class="n"&gt;children&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="implement-iterator-protocal"&gt;Implement Iterator Protocal&lt;/h3&gt;
&lt;p&gt;有时候内建类型的迭代协议无法满足我们的需求，这个时候可以自行实现迭代协议。只要一个 class 实现了下面两个方法，就可以当作迭代器来使用，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 &lt;code&gt;--iter()--&lt;/code&gt; 方法，返回值是 &lt;code&gt;self&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;next()&lt;/code&gt; 方法，返回一个 item 或者是 StopIteration 异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个方法分别对应了前面区分过的两种协议，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意一个实现了 &lt;code&gt;--iter()--&lt;/code&gt; 或 &lt;code&gt;--getitme--()&lt;/code&gt; 的对象，都可以用 for 循环来迭代 —— &lt;strong&gt;Iterable 对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;任意一个实现了 &lt;code&gt;next()&lt;/code&gt; 的对象都可以当作是 iterator —— &lt;strong&gt;Iterator 协议&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;迭代的概念本身只涉及第二种协议，容器类的对象一般都支持第一种协议。目前 iterator 要求这两种协议都支持，支持第一种协议的目的是为了让 iterator 同时也是 Iterable，这样它的行为和 sequence 类似，特别是在用 for 循环中使用 iterator 的场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义一个产生随机 sequence 的 class，然后使用 for 循环迭代该对象，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;#! /usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;choice&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RandSeq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;seq&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RandSeq&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rock&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;paper&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;scissors&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以像前面介绍的一样，用 &lt;code&gt;isinstance()&lt;/code&gt; 来检查，说明我们的 RandSeq 类既是一个 Iterable 也是一个 Iterator。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Iterable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# True&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="generator"&gt;Generator&lt;/h3&gt;
&lt;p&gt;Generator 是一种特殊的 iterator，最典型的例子就是 Fibonacci 数列。可以直接根据需要写一个 generator 直接调用，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;frange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;yiled&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;frange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果 generator 涉及到比较复杂的控制（比如暴露属性等），可以把 generator 函数扩展成 class 形式。比如前面的 RandSeq 例子可以扩展出更加复杂的功能，然后将 &lt;code&gt;--iter--&lt;/code&gt; 内部的 return 改为 yield 即可。&lt;/p&gt;
&lt;h2 id="using-iterator"&gt;Using Iterator&lt;/h2&gt;
&lt;h3 id="sequence"&gt;Sequence&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;myTuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;xyz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;45.67&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="mi"&gt;123&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;xyz&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;netx&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="mf"&gt;45.67&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;stdin&amp;gt;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class="ne"&gt;StopIteration&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="dict"&gt;Dict&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dict 内部实现了一个 &lt;code&gt;sq-contaisn&lt;/code&gt; 的函数，它实现了 &lt;code&gt;has-key()&lt;/code&gt; 相同的功能，所以可以这么写，&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;# equivalent to&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;dict 内部还实现了一个 &lt;code&gt;tp-iter&lt;/code&gt; 的函数，可以产生一个针对所有 keys 的高效迭代器。所以可以这么写，&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;# equivalent to, but much faster than&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;keys&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只要不违反 “ 禁止修改 dict 内容 ” 的约束，就可以这么用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dict 实际上有 3 种 iterator，&lt;code&gt;for x in dict&lt;/code&gt; 实际上是 &lt;code&gt;for x in dict.iterkeys()&lt;/code&gt; 的缩写&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterkeys&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;itervalues&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="file"&gt;File&lt;/h3&gt;
&lt;p&gt;file 对象内部实现了 &lt;code&gt;tp-iter&lt;/code&gt; 方法，所以访问文件内容的代码可以写得更简洁，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;myFile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;

&lt;span class="c1"&gt;# as a shorthand for&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;

&lt;span class="c1"&gt;# equivalent, but faster than&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="restrictions"&gt;Restrictions&lt;/h3&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;在用 iterator 时，sequence/dict 的内容是不能被修改的。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;sequence 中除了 list，其它（tuple 和 string）都是不可变的，所以只需要注意 list 的情况即可。对于 dict，只允许对一个已经存在的 key 设置它的值，其他操作（增加 / 删除 /&lt;code&gt;update()&lt;/code&gt;）都是不允许的。原因就是 iterator 和实际对象是绑定在一起的，一旦修改了原对象，效果会马上体现出来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# legal&lt;/span&gt;
&lt;span class="n"&gt;myDict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;myDict&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;myDict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myDict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="c1"&gt;# illegal&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;myDict&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;myDict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际上，在 python 的迭代器出现之前，这个限制就已经存在了，比如 C++ 也有类似的约束。&lt;/p&gt;
&lt;h2 id="special-iterator"&gt;Special Iterator&lt;/h2&gt;
&lt;h3 id="reversed-iterator"&gt;Reversed Iterator&lt;/h3&gt;
&lt;p&gt;获得一个反向迭代器的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用 BIF &lt;code&gt;reversed()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;--reversed--()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;将对象转化为 list 对象&lt;/li&gt;
&lt;li&gt;使用 generator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直接使用 &lt;code&gt;reversed()&lt;/code&gt; 的问题在于待处理的对象必须是大小确定的，如果一个对象大小不固定而且又没有实现 &lt;code&gt;--reversed--()&lt;/code&gt; 方法，那么直接将其转化为 list 对象可能会占用大量内存，更优的做法是在 &lt;code&gt;--reversed--()&lt;/code&gt; 中定义一个 generator。&lt;/p&gt;
&lt;h3 id="using-itertools"&gt;Using &lt;code&gt;itertools&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Python 内建的工具包，可以产生一系列各种各样的 iterator，比如无穷迭代器 &lt;code&gt;count()&lt;/code&gt;, &lt;code&gt;cycle()&lt;/code&gt;, &lt;code&gt;repeat()&lt;/code&gt;，有限长度的 &lt;code&gt;accumulate()&lt;/code&gt;, &lt;code&gt;compress()&lt;/code&gt;, &lt;code&gt;chain()&lt;/code&gt; 等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;

&lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 10&lt;/span&gt;
&lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# 11&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;itertools&lt;/code&gt; 常见的 iterator 有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成切片： &lt;code&gt;itertools.islice()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;丢弃部分数据： &lt;code&gt;itertools.dropwhile()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;产生所有排列组合： &lt;code&gt;itertools.permutations()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一次性迭代不同容器内的元素： &lt;code&gt;itertools.chain()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结：遇到看似复杂的迭代任务，不要着急自己写复杂的 for index 循环或者是 iterator，而是应该首先看看 &lt;code&gt;itertools&lt;/code&gt; 里面是否提供了相关功能，往往有惊喜。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="enumerate"&gt;&lt;code&gt;enumerate()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果想在迭代对象时，同时知道对应的索引，该怎么办？&lt;/p&gt;
&lt;p&gt;或许你会想在 iterator 的基础上，再加一个计数器，在每次 for 循环中不断自增，类似这样，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;
    &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是这种写法很丑陋，最优雅的答案是用内建函数 &lt;code&gt;enumerate()&lt;/code&gt;，它的返回值是一个 &lt;code&gt;enumerate&lt;/code&gt; 对象，本质上就是个迭代器，返回一个由 index 和 value 组成的 tuple。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0234/"&gt;PEP 279&lt;/a&gt; 介绍了这个函数的实现原理，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;Generates an indexed series: (0, coll[0]), (1, coll[1]) ...&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="zip"&gt;&lt;code&gt;zip()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果想同时迭代多个对象，每次迭代分别从中取出一个元素，应该怎么办？&lt;/p&gt;
&lt;p&gt;最优雅的方式是用 &lt;code&gt;zip()&lt;/code&gt; 函数，zip 函数的返回值是一个 iterator，所以可以直接在 for 循环中使用，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0234/"&gt;PEP 234 -- Iterator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0234/"&gt;PEP 279 -- The enumerate() built-in function&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/3112503/"&gt;Python 核心编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26381341/"&gt;Python Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640"&gt;迭代器 - 廖雪峰的官方网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nvie.com/posts/iterators-vs-generators/"&gt;Iterables vs. Iterators vs. Generators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://foofish.net/iterators-vs-generators.html"&gt;完全理解 Python 迭代对象、迭代器、生成器&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Git Flow 小结</title><link href="https://qian-gu.github.io/posts/tools/git-flow-summary.html" rel="alternate"></link><published>2020-05-24T12:55:00+08:00</published><updated>2020-05-24T12:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-05-24:/posts/tools/git-flow-summary.html</id><summary type="html">&lt;p class="first last"&gt;git-flow 翻译、总结、实践&lt;/p&gt;
</summary><content type="html">&lt;p&gt;git-flow 是 Vincent Driessen 在 2010 年写的文章 &lt;cite&gt;A successful Git branching model&lt;/cite&gt;- 中提出的一种管理 git branch 的模型，当时 git 才刚刚被发明出来。经过 10 来年的发展，已经有很多公司都采用这种方式作为标准流程来管理自己的软件开发了。如果像 Web App 这类的持续交付 continuous delivery 的软件，可以采用更简单的 &lt;cite&gt;GitHub Flow&lt;/cite&gt;-，但是对于传统的那种版本概念非常清晰的软件，git-flow 还是非常适用的。下面的内容是原文的简单汇总和翻译，完整内容请看原文。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;这里还有一篇翻译：&lt;cite&gt;Git 分支管理策略&lt;/cite&gt;-&lt;/p&gt;
&lt;p class="last"&gt;Git 的工作流程有很多中，git-flow 是之前最流行的做法。就像作者自己所说，git-flow 非常适合传统的软件开发，但是对于 CI/CD 的项目，则显得太繁琐，推荐使用 Github FLow 和 GitLab FLow，这里有相关的翻译和介绍：&lt;cite&gt;Git 工作流程&lt;/cite&gt;-&lt;/p&gt;
&lt;/div&gt;
&lt;!-- -A successful Git branching model: https://nvie.com/posts/a-successful-git-branching-model/ --&gt;
&lt;!-- -GitHub Flow: https://guides.github.com/introduction/flow/ --&gt;
&lt;!-- -Git 分支管理策略 : http://www.ruanyifeng.com/blog/2012/07/git.html --&gt;
&lt;!-- -Git 工作流程 : http://www.ruanyifeng.com/blog/2015/12/git-workflow.html --&gt;
&lt;hr class="docutils" /&gt;
&lt;img alt="GitFlow Diagram" src="https://nvie.com/img/git-model&amp;#64;2x.png" /&gt;
&lt;div class="section" id="why-git"&gt;
&lt;h2&gt;Why Git&lt;/h2&gt;
&lt;p&gt;网上有很多 Git 和 SVN 这种集中式的代码管理系统优缺点的对比。简而言之，Git 从根本上改变了程序员对 branch/merge 的思考方式，&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;SVN 方式：merge 要非常小心 conflict，一般很久才 merge 一次&lt;/li&gt;
&lt;li&gt;Git 方式：每天都会进行，是日常工作的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git 让码农的生活更加容易。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="decentralized-centralized"&gt;
&lt;h2&gt;Decentralized &amp;amp; Centralized&lt;/h2&gt;
&lt;p&gt;Git 实际上是一个分布式的管理系统，并不存在技术意义上真正的 central repo，但是因为需要一个大家都能访问的服务器节点（比如 GitHub）方便相互之间同步，所以在 Git 中一般把这个服务器节点叫做 &lt;tt class="docutils literal"&gt;origin&lt;/tt&gt;。项目中的所有成员都和 origin 打交道，完成 &lt;tt class="docutils literal"&gt;pull&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;push&lt;/tt&gt; 等操作。&lt;/p&gt;
&lt;p&gt;有时候对于某个比较大的 feature，可能需要多个同学一起完成，这个时候相关的同学可以组成一个 subteam，他们相互之间进行 pull/push，如下图所示，Alice 和 Bob，Alice 和 David，David 和 Clair 组成了 3 个 subteam。要组建 subteam 也非常简单，Alice 只需要定义一个 &lt;tt class="docutils literal"&gt;git remote&lt;/tt&gt;，指向 Bob 的 repo 地址即可。&lt;/p&gt;
&lt;img alt="Decentralized &amp;amp; Centralized Diagram" src="https://nvie.com/img/centr-decentr&amp;#64;2x.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="main-branch"&gt;
&lt;h2&gt;Main Branch&lt;/h2&gt;
&lt;p&gt;主分支一共有两条，即服务器上的 central repo 应该有两条生命期无限长的 branch，&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;master&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;develop&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个小组成员都应该对 &lt;tt class="docutils literal"&gt;origin/master&lt;/tt&gt; 分支非常熟悉，它是发布产品的主分支，&lt;tt class="docutils literal"&gt;HEAD&lt;/tt&gt; 指向的永远是可以随时在产品中部署的代码。&lt;/p&gt;
&lt;p&gt;而 &lt;tt class="docutils literal"&gt;origin/develop&lt;/tt&gt; 分支是用来发布新 feature 的主分支，&lt;tt class="docutils literal"&gt;HEAD&lt;/tt&gt; 指向的代码永远指向最新交付的新功能。有些人把它叫做 集成分支，顾名思义它是用来做集成的，也就是所有开发者会把开发的新 feature 代码都集成到这个分支中，为 release 做准备。所有 nightly build 都应该用这个分支的代码。&lt;/p&gt;
&lt;p&gt;当 develop 分支上的代码保持稳定，达到可以 release 的程度了，所有的修改都要通过某种方式 merge 回 master 分支，并且用版本号打个 tag（具体方法后面 release 分支一节描述）。所以每次 merge 回 master，都是发布了一个新的产品 release，所以可以利用 Git 提供的 hook 函数实现只要 master 有新的 commit，就自动编译和推送最新代码到产品服务器上。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="supporting-branch"&gt;
&lt;h2&gt;Supporting Branch&lt;/h2&gt;
&lt;p&gt;除了 master 和 develop 两个主分支，还有一些支持性的分支以实现小组成员之间的并行开发，比如跟踪不同的新 feature，修改 bug 等。和主分支不同都是，这些支持性的分支的生命周期是有限的。这里一共定义了 3 种分支，&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Feature branches&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Release branches&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Hotfix branch&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这 3 个分支每个都有非常明确的目的，使用也非常严格，从哪个分支中 branch 出来，最终 merge 到哪个 branch 都有严格要求。这些 branch 从技术上来说就是普通的 branch，并无特殊之处，但是因为我们特殊的用法所以将其归为一大类。&lt;/p&gt;
&lt;div class="section" id="feature-branches"&gt;
&lt;h3&gt;Feature Branches&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;来源：可能是 &lt;tt class="docutils literal"&gt;develop&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;终点：必须是 &lt;tt class="docutils literal"&gt;develop&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;命名规则：除了 master, develop, release-*, hotfix-* 之外，其他名字都可以&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;顾名思义，Feature 分支的目的就是为了开发新 feature，有时候开始开发新 feature 的时候并不知道最终 merge 回哪个 release 分支，只要开始开发这个 feature，那么该 feature 分支就会一直存在，直到最后 merge 回 develop 或者是丢弃掉（中途放弃开发）。&lt;/p&gt;
&lt;p&gt;Feature 分支一般只存在于相关开发者的本地 repo 中，并不会存在 origin 上，除非是多和协作共同完成一个大 feature 的情况。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建 feature 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;creating&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;feature&lt;span class="w"&gt; &lt;/span&gt;branch
git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;-b&lt;span class="w"&gt; &lt;/span&gt;feature-xxx&lt;span class="w"&gt; &lt;/span&gt;develop
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;结束 feature 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;merge&lt;span class="w"&gt; &lt;/span&gt;back&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;develop&lt;span class="w"&gt; &lt;/span&gt;branch
git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;develop
git&lt;span class="w"&gt; &lt;/span&gt;merge&lt;span class="w"&gt; &lt;/span&gt;--no-ff&lt;span class="w"&gt; &lt;/span&gt;feature-xxx
git&lt;span class="w"&gt; &lt;/span&gt;branch&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;feature-xxx
git&lt;span class="w"&gt; &lt;/span&gt;push&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;develop
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--no-ff&lt;/span&gt;&lt;/tt&gt; 来保留 branch 信息。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="release-branch"&gt;
&lt;h3&gt;Release Branch&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;来源：可能是 &lt;tt class="docutils literal"&gt;develop&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;终点：必须是 &lt;tt class="docutils literal"&gt;develop&lt;/tt&gt; &amp;amp; &lt;tt class="docutils literal"&gt;master&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;命名规则：release-*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Release 分支的作用是为最终产品发布做准备，在这个 branch 上允许做最后一刻的修改，比如微小的 bug 修改，为发布准备 meta-data（版本号，build 日期等等），在 release 分支上做这些事情的好处是可以保持 develop 分支的干净整洁。&lt;/p&gt;
&lt;p&gt;创建 release 分支的时间点非常关键，主要有两方面的约束，&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;不能太早，相关功能的代码要全部 ready：当前要发布的 release 包含的新 feature 必须都已经合入 develop 之中&lt;/li&gt;
&lt;li&gt;不能太晚，代码要防污染：不能包含下一次 release 对应的 feature 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;约束 1 要求 &lt;tt class="docutils literal"&gt;develop&lt;/tt&gt; 分支（几乎）完成了新 release 的所有功能才可以创建 &lt;tt class="docutils literal"&gt;release&lt;/tt&gt; 分支。约束 2 要求未来下一次 release 的 feature 代码则一定不能合并进来，这些新 feature 必须等到创建当前 release 之后才能合进 develop 分支。&lt;/p&gt;
&lt;p&gt;在创建了 release 分支之后，develop 分支就可以为 “ 下一次 release” 做准备了。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建 release 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;-b&lt;span class="w"&gt; &lt;/span&gt;release-1.2&lt;span class="w"&gt; &lt;/span&gt;develop
./bump-version.sh&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.2
git&lt;span class="w"&gt; &lt;/span&gt;commit&lt;span class="w"&gt; &lt;/span&gt;-a&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bumped version number to 1.2&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;创建好的 release 分支可能会存在一段时间，这段时间内如果有 bug 修改，应该在 release 分支上，而不是 develop 上。新 feature 禁止直接加到 release 分支上，而是应该加到 develop 上，等待下一次的 release。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;结束 release 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;master
git&lt;span class="w"&gt; &lt;/span&gt;merge&lt;span class="w"&gt; &lt;/span&gt;--no-ff&lt;span class="w"&gt; &lt;/span&gt;release-1.2
git&lt;span class="w"&gt; &lt;/span&gt;tag&lt;span class="w"&gt; &lt;/span&gt;-a&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.2
git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;develop
git&lt;span class="w"&gt; &lt;/span&gt;merge&lt;span class="w"&gt; &lt;/span&gt;-no-ff&lt;span class="w"&gt; &lt;/span&gt;release-1.2
git&lt;span class="w"&gt; &lt;/span&gt;branch&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;release-1.2
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;当 release 分支最终达到可以 release 状态的时候，需要做的事情有&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;把 release 分支 merge 回 master（前面描述过，master 的每个结点都是一个 release 版本）&lt;/li&gt;
&lt;li&gt;给 master 分支打 tag，方便以后回溯版本&lt;/li&gt;
&lt;li&gt;把 release 分支 merge 回 develop 分支（保存 release 分支上的 bug 修改）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="hotfix-branches"&gt;
&lt;h3&gt;Hotfix Branches&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;来源：可能是 &lt;tt class="docutils literal"&gt;master&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;终点：必须是 &lt;tt class="docutils literal"&gt;develop&lt;/tt&gt; &amp;amp; &lt;tt class="docutils literal"&gt;master&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;命名规则：hotfix-*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;hotfix 分支的作用和 release 有点类似，也是为了新产品发布，但是它是计划之外的。hoftfix 是为了应对那种意外发现的，急待解决的产品 bug，如果发现产品上有一个马上就要解决的重大 bug，那么就可以从 master 的该节点上创建一个 hotfix 分支。&lt;/p&gt;
&lt;p&gt;典型场景：&lt;/p&gt;
&lt;p&gt;突然发现 master 分支上正在使用的产品版本（比如说是 release-1.2）有一个致命 bug，但是 develop 分支因为合入了新 feature，还没有稳定，不能直接在 develop 分支上进行修复，此时就需要创建一个 hotfix 分支。&lt;/p&gt;
&lt;p&gt;由上面的例子可以看出，hotfix 分支存在的意义是让团队中的一部分人来进行快速的产品 fix，另外一部分人仍然按照计划进行开发，相互不影响。&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建一个 hotfix 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;-b&lt;span class="w"&gt; &lt;/span&gt;hotfix-1.2.1&lt;span class="w"&gt; &lt;/span&gt;master
./bump-version.sh&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.2.1
git&lt;span class="w"&gt; &lt;/span&gt;commit&lt;span class="w"&gt; &lt;/span&gt;-a&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bumped version number to 1.2.1&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;在修改完 bug 之后，把修改结果 commit&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;commit&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;FIxed severe production problem&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;结束 hotfix 分支&lt;/p&gt;
&lt;p&gt;最后 bugfix 的内容除了要 merge 回 master，还要 merge 回 develop，以保证下一次 release 的时候这个 bug 已经被修复了。这个过程和结束 release  分支很类似。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;master
git&lt;span class="w"&gt; &lt;/span&gt;merge&lt;span class="w"&gt; &lt;/span&gt;--no-ff&lt;span class="w"&gt; &lt;/span&gt;hotfix-1.2.1
git&lt;span class="w"&gt; &lt;/span&gt;tag&lt;span class="w"&gt; &lt;/span&gt;-a&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.2.1
git&lt;span class="w"&gt; &lt;/span&gt;checkout&lt;span class="w"&gt; &lt;/span&gt;-b&lt;span class="w"&gt; &lt;/span&gt;develop
git&lt;span class="w"&gt; &lt;/span&gt;merge&lt;span class="w"&gt; &lt;/span&gt;--no-ff&lt;span class="w"&gt; &lt;/span&gt;hotfix-1.2.1
git&lt;span class="w"&gt; &lt;/span&gt;branch&lt;span class="w"&gt; &lt;/span&gt;-d&lt;span class="w"&gt; &lt;/span&gt;hotfix-1.2.1
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;有个特殊情况：&lt;strong&gt;如果存在一个 release 分支，那么应该将 hotfix 分支 merge 到 release 分支，而不是 develop 分支&lt;/strong&gt;。Merge 到 release 的 bugfix 代码最终会随着 release 代码一起合入到 develop 分支中，不需要担心丢失。（如果 develop 分支需要马上就合入这个 bugfix，等不到 release  分支结束，那么也可以将 bugfix 合入到 develop 中。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;这个模型并没有提出什么惊人的新概念，但是在实际工作中非常有用，这个优雅的模型可以让整个 team 中的成员对 branch 分支有一个共同的认识。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="practice-git-flow"&gt;
&lt;h2&gt;Practice -- git-flow&lt;/h2&gt;
&lt;p&gt;上面是原文的翻译和总结，在实践中，有个 git 扩展 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;git-flow&lt;/span&gt;&lt;/tt&gt; 工具可以帮助我们遵守这套规则。这里有一篇 &lt;cite&gt;git flow cheatsheet&lt;/cite&gt;- 方便查看。&lt;/p&gt;
&lt;!-- -git flow cheatsheet: https://danielkummer.github.io/git-flow-cheatsheet/ --&gt;
&lt;div class="section" id="install"&gt;
&lt;h3&gt;Install&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;git-flow
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="setup"&gt;
&lt;h3&gt;Setup&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;init
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;回答一系列问题即可，推荐使用默认值&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="features"&gt;
&lt;h3&gt;Features&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建一个 feature 分支：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;基于 develop 创建了一个新 feature 分支，并切换过去&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;feature&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;MYFEATURE
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;结束一个 feature 分支：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;把 MYFEATURE 分支 merge 回 develop 分支&lt;/li&gt;
&lt;li&gt;删除该 feature 分支&lt;/li&gt;
&lt;li&gt;切换回 develop 分支&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;feature&lt;span class="w"&gt; &lt;/span&gt;finish&lt;span class="w"&gt; &lt;/span&gt;MYFEATURE
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;发布一个 feature&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;feature&lt;span class="w"&gt; &lt;/span&gt;publish&lt;span class="w"&gt; &lt;/span&gt;MYFEATURE
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;把 feature 分支发布到 remote 服务器，方便其他人使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;获取一个其他人发布的 feature&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;feature&lt;span class="w"&gt; &lt;/span&gt;pull&lt;span class="w"&gt; &lt;/span&gt;origin&lt;span class="w"&gt; &lt;/span&gt;MYFEATURE
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="release"&gt;
&lt;h3&gt;Release&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建一个 release 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;release&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;RELEASE&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;BASE&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;通过一个可选项 [BASE] 来制定 develop 上的某个特定节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;把 release 分支的结果发布给其他开发者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;release&lt;span class="w"&gt; &lt;/span&gt;publish&lt;span class="w"&gt; &lt;/span&gt;RELEASE
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;结束一个 release 分支&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;把 release 分支 merge 回 master 分支&lt;/li&gt;
&lt;li&gt;用 release 分支的名字给 master 打 tag&lt;/li&gt;
&lt;li&gt;把 release 分支 merge 回 develop 分支&lt;/li&gt;
&lt;li&gt;删除 release 分支&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;release&lt;span class="w"&gt; &lt;/span&gt;finish&lt;span class="w"&gt; &lt;/span&gt;RELEASE
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;别忘了把你的 tag push 到远程 repo：git push origin --tags&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="hotfix"&gt;
&lt;h3&gt;Hotfix&lt;/h3&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建一个 hotfix 分支&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;hotfix&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;VERSION&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;BASENAME&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;结束一个 hotfix 分支&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;把 hotfix 分支 merge 回 develop 和 master 分支&lt;/li&gt;
&lt;li&gt;用 hotfix 的 version 给 master 分支打 tag&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;flow&lt;span class="w"&gt; &lt;/span&gt;hotfix&lt;span class="w"&gt; &lt;/span&gt;finish&lt;span class="w"&gt; &lt;/span&gt;VERSION
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="zsh-extension"&gt;
&lt;h3&gt;Zsh Extension&lt;/h3&gt;
&lt;p&gt;zsh 里面有两个相关插件，&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;git flow completion&lt;/tt&gt;，自动补全&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;git-flow&lt;/span&gt;&lt;/tt&gt;，提供命令的各种 alias&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给 zsh 安装 &lt;cite&gt;git flow completion&lt;/cite&gt;- 插件的步骤，&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;下载插件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;https://github.com/bobthecow/git-flow-completion&lt;span class="w"&gt; &lt;/span&gt;~/.oh-my-zsh/custom/plugins/git-flow-completion
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;更新 &lt;tt class="docutils literal"&gt;.zshrc&lt;/tt&gt; 文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;plugins&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&amp;lt;some-plugin&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;another-plugin&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;git-flow-completion&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;重新 source 之后就可以看到自动补全的效果了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- -git flow completion: https://github.com/bobthecow/git-flow-completion --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="ref"&gt;
&lt;h2&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;cite&gt;A successful Git branching model&lt;/cite&gt;-&lt;/p&gt;
&lt;p&gt;&lt;cite&gt;git flow cheatsheet&lt;/cite&gt;-&lt;/p&gt;
&lt;/div&gt;
</content><category term="Tools"></category><category term="Git"></category><category term="Workflow"></category></entry><entry><title>Python 学习笔记 #5 —— Comprehension 解析式</title><link href="https://qian-gu.github.io/posts/cs/python-notes-5-comprehension.html" rel="alternate"></link><published>2020-05-16T20:58:00+08:00</published><updated>2020-05-16T20:58:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-05-16:/posts/cs/python-notes-5-comprehension.html</id><summary type="html">&lt;p&gt;List &amp;amp; Dict Comprehension 学习笔记&lt;/p&gt;</summary><content type="html">&lt;h2 id="what-is-list-comprehensions"&gt;What is List Comprehensions&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0202/"&gt;PEP 202 -- List Comprehensions 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;List Comprehensions 是一种 python 语法扩展，它可以实现用 for 和 if 语句直接构建 list。&lt;/p&gt;
&lt;h3 id="examples"&gt;Examples&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nv"&gt;text&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;]
[&lt;span class="mi"&gt;0&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;]


&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;]
[&lt;span class="mi"&gt;0&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;]


&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;]
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fruit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="s2"&gt;&amp;quot;Apples&amp;quot;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Peaches&amp;quot;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Pears&amp;quot;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bananas&amp;quot;&lt;/span&gt;]

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fruit&lt;/span&gt;]
[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Apples&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bananas&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Apples&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bananas&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Apples&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bananas&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Apples&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bananas&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;]

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fruit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;P&amp;quot;&lt;/span&gt;]
[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;]

&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fruit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;P&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;]
[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Pears&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;]
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;[&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;zip&lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;nums&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;fruit&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;]&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;]
[&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Peaches&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Bananas&amp;#39;&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="why-comprehensions"&gt;Why Comprehensions&lt;/h2&gt;
&lt;p&gt;如果想用从一个 list 中挑选出一部分满足条件的元素组成一个新的 list，该怎么做？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法一：最直观简单的方法，写一个 &lt;code&gt;for&lt;/code&gt; 循环，然后从中挨个挑选出符合条件的元素&lt;/li&gt;
&lt;li&gt;方法二：使用函数式编程中的 &lt;code&gt;map()&lt;/code&gt;/&lt;code&gt;filter()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然方法一和方法二都能实现相同的功能，为什么还需要再提出 list comprehensions 呢？&lt;/p&gt;
&lt;p&gt;答案是：为了更加优雅的构建 list。&lt;/p&gt;
&lt;p&gt;方法一虽然简单但是很臃肿，方法二要调用两个函数（&lt;code&gt;map&lt;/code&gt;/&lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;）仍然不够简化，所以出现了 &lt;code&gt;list comprehensions&lt;/code&gt;， 它实际上来自于函数式编程语言 Haskell，&lt;strong&gt;提供了另外一种更加简洁的实现方法（Simple is better than complex.）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="understanding-and-using-list-comprehensions"&gt;Understanding and Using List Comprehensions&lt;/h2&gt;
&lt;h3 id="list-comprehensions"&gt;以数学的角度理解 list comprehensions&lt;/h3&gt;
&lt;p&gt;下面这个集合表示从自然数中挑选出符合条件 &lt;code&gt;x &amp;gt; 5&lt;/code&gt; 且 &lt;code&gt;x &amp;lt; 10&lt;/code&gt; 的所有元素，&lt;/p&gt;
&lt;div class="math"&gt;$$new\-list = \{x | x \in N, x &amp;gt; 0, x &amp;lt; 10\}$$&lt;/div&gt;
&lt;p&gt;下面是 Python 的实现版本，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对比一下 python 版本的代码就可以知道两者非常相似，只不过 python 用 for 和 if 语句来描述数学中的条件表达式。尤其是 python 中有集合 &lt;code&gt;set&lt;/code&gt; 的概念，set 也是可以写成 comprehensions 形式的，这个时候就和数学就完全等价了。&lt;/p&gt;
&lt;h3 id="list-comprehensions_1"&gt;如何写 list comprehensions&lt;/h3&gt;
&lt;p&gt;因为 list comprehensions 本质是 for 和 if 的简洁写法，所以我们可以总结出一个模板，只要满足这个模板的 for 循环就可以改成写 list comprehensions.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以改写成下面的形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="list-comprehensions_2"&gt;循环嵌套的 list comprehensions&lt;/h3&gt;
&lt;p&gt;循环嵌套的 list comprehensions 例子：将矩阵展平，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;flattened&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;flattend&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="list-comprehensions_3"&gt;提高 list comprehensions 的可读性&lt;/h3&gt;
&lt;p&gt;因为 python 支持在括号之间断行，所以前面的例子，可以改写成下面的形式以提高可读性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itme&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;itme&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;


&lt;span class="n"&gt;flattend&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;matrix&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="_1"&gt;小结&lt;/h3&gt;
&lt;p&gt;无论是单层还是嵌套的 for 循环，改成 list comprehensions 的方法其实方法非常简单，就是把普通的 for 循环调整了顺序，将循环内的语句写在了最前面，剩余部分按原顺序写就可以了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上面的语法只适用于一个元素（the Right One）&lt;/li&gt;
&lt;li&gt;不允许写成 &lt;code&gt;[x, y for ...]&lt;/code&gt; 形式，但是可以写成一个 tuple 元素的形式 &lt;code&gt;[(x, y) for ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许嵌套形式 &lt;code&gt;[...  for x... for y...]&lt;/code&gt;，就像嵌套循环一样，最后一个 index 是变化最快的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GvR 也说 &lt;code&gt;map()&lt;/code&gt; / &lt;code&gt;filter()&lt;/code&gt; 函数用起来实在太繁琐了，我们应该多使用 comprehensions。但是我们应该记住，谨防滥用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;filter and map should die and be subsumed into list comprehensions, not grow more variants. I'd rather introduce built-ins that do iterator algebra (e.g. the iterzip that I've often used as an example).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;（关于 &lt;code&gt;iterator&lt;/code&gt;，后面的学习笔记中会有介绍。）&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="dict-comprehensions"&gt;Dict Comprehensions&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0274/"&gt;PEP 274 -- Dict Comprehensions 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;dict comprehensions 和 list comprehensions 非常相似，不同之处就是采用 &lt;code&gt;dict&lt;/code&gt; 的相关语法：用 &lt;code&gt;{}&lt;/code&gt; 而不是 &lt;code&gt;[]&lt;/code&gt;，同时关键字 &lt;code&gt;for&lt;/code&gt; 前面的部分表达式改成了用冒号隔开的 key-value 对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;text&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;chr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;65&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;someDict&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;someDict&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;


&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;list&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;addrs&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;barry&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;zope&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;com&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;barry&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;python&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;org&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nx"&gt;guido&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;python&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;org&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;def&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;()}&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="set-comprehensions"&gt;Set Comprehensions&lt;/h2&gt;
&lt;p&gt;set comprehensions 和 list comprehensions 非常相似，唯一的区别就是用 &lt;code&gt;{}&lt;/code&gt; 而不是 &lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;squared&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;squared&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;显然因为最终生成的是集合，所以重复元素只会保存一个。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/"&gt;Python List Comprehensions: Explained Visually&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.jianshu.com/p/dd85d2cd89d1"&gt;用数学思维理解 Comprehension&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #4 —— Python 之禅</title><link href="https://qian-gu.github.io/posts/cs/python-notes-4-the-zen-of-python.html" rel="alternate"></link><published>2020-05-10T14:36:00+08:00</published><updated>2020-05-10T14:36:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-05-10:/posts/cs/python-notes-4-the-zen-of-python.html</id><summary type="html">&lt;p&gt;学习 Python 之禅&lt;/p&gt;</summary><content type="html">&lt;p&gt;著名的 python 之禅，&lt;a href="https://www.python.org/dev/peps/pep-0020/"&gt;PEP 20 -- The Zen of Python 原文链接&lt;/a&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;item&lt;/th&gt;
&lt;th&gt;detail&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PEP&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Title&lt;/td&gt;
&lt;td&gt;The Zen of Python&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Author&lt;/td&gt;
&lt;td&gt;tim.peters at gmail.com (Tim Peters)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;Active&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;Informational&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;19-Aug-2004&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Post-History&lt;/td&gt;
&lt;td&gt;22-Aug-2004&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="abstract"&gt;Abstract&lt;/h2&gt;
&lt;p&gt;很久之前，Python 先驱 Tim Peters 将 BDFL（Benevolent director for life，仁慈的终身独裁者，特指 Python 之父 Guido van Rossum）的 Python 设计指导原则总结成 20 条格言，只记录下了其中的 19 条。&lt;/p&gt;
&lt;h2 id="the-zen-of-python"&gt;The Zen of Python&lt;/h2&gt;
&lt;p&gt;网上有很多不同版本的翻译，有些语言风趣幽默，有些正经严肃。我个人更喜欢严肃的翻译，因为幽默的翻译有时候需要特定的语境和背景只是才能理解，反而增加了理解难度。下面的翻译一些是我按照自己的理解写的，有些是网上别人的翻译（因为出处已经无法找到了，所以只能感谢原作者的分享了）。文学水平太低做不到 &lt;code&gt;达雅&lt;/code&gt;，只能争取做到 &lt;code&gt;信&lt;/code&gt;，尽量不要误导大家。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Beautiful is better than ugly.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优美胜于丑陋&lt;/p&gt;
&lt;p&gt;PEP8 中提到，Python 的理念是代码更多时候是用来读的，所以以编写 &lt;code&gt;优美&lt;/code&gt; 的代码为目标，&lt;code&gt;if a == 0 and b == 1 or c == True:&lt;/code&gt; 要比 &lt;code&gt;if a == 0 &amp;amp;&amp;amp; b == 1 || c == True:&lt;/code&gt; 更加优美。优美的代码包含的内容非常广泛，PEP8 提供了一些如何写出优美代码的建议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Explicit is better than implicit.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显式胜于隐式&lt;/p&gt;
&lt;p&gt;代码应该清晰易懂，比如良好的命名可以提高代码的可读性。几个不好的例子，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;太宽泛： &lt;code&gt;my-list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;太冗长： &lt;code&gt;list-of-machine-learning-data-set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;太模糊： &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;O&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于命名可以参考 PEP8.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Simple is better than complex.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单胜于复杂&lt;/p&gt;
&lt;p&gt;选择最简单实现方案，python 有很多功能强大的内置 method，合理利用它们可以减少你的代码量，删繁就简只保留核心代码。一个直观例子是用 &lt;code&gt;enumerate()&lt;/code&gt; 来迭代容器，另外一个例子是用 &lt;code&gt;zip()&lt;/code&gt; 快速创建字典。减少代码量不仅仅可以提高可读性，还意味着出错的概率更低，而且代码的性能更好（因为通常库实现更加高效）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Complex is better than complicated.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复杂胜于凌乱&lt;/p&gt;
&lt;p&gt;如果复杂不可避免，也要避免晦涩的实现。复杂和晦涩的区别，我理解就是复杂是可以通过分解来理解，但是晦涩特指那种非常难理解的语法、不符合常规思维的实现方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Flat is better than nested.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;扁平胜于嵌套&lt;/p&gt;
&lt;p&gt;代码尽量少嵌套，降低理解难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sparse is better than dense.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;间隔胜于紧凑&lt;/p&gt;
&lt;p&gt;适当的间隔和空行能提高可读性，同参考 PEP8.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Readability counts.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可读性很重要&lt;/p&gt;
&lt;p&gt;同参考 PEP8，两个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用下划线对很长的数字分组，&lt;code&gt;money = 1-000-000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;f-string 可以大幅提高代码的可读性， &lt;code&gt;print(f"I have {money} dollars.")&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Special cases aren't special enough to break the rules.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规则至高无上，没有什么特例可以打破规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Although practicality beats purity.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是实用性胜过代码的纯粹性&lt;/p&gt;
&lt;p&gt;与前一句相矛盾，提醒我们掌握它们之间的平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Errors should never pass silently.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要默许任何错误&lt;/p&gt;
&lt;p&gt;默许的错误会导致隐患，使用异常处理以尽量写出健壮的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Unless explicitly silenced.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除非你确定要这么做&lt;/p&gt;
&lt;p&gt;在某些情况下，小错误是可以容忍的，和前一条组合在一起，避免走极端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;In the face of ambiguity, refuse the temptation to guess.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面对歧义，拒绝猜测的诱惑&lt;/p&gt;
&lt;p&gt;避免写含糊不清的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;There should be one-- and preferably only one --obvious way to do it.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应该有且只有一个最优解决方案 —— 最显而易见的实现方案&lt;/p&gt;
&lt;p&gt;python 的语法非常灵活，库也非常强大，所以同一个问题可以有非常多种不同实现方式，那么最优方案应该是那个最直观的解决方案。不要走标新立异的路线，用最显而易见的方法，花费最少的时间解决问题，珍惜自己的生命，也珍惜读者（代码维护者）的生命。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;life is short, you need pyhton.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Although that way may not be obvious at first unless you're Dutch.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然一开始并不容易，除非你是 Pyhton 之父&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Now is better than never.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在开始做胜过永远拖延&lt;/p&gt;
&lt;p&gt;拒绝拖延症！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Although never is often better than &lt;em&gt;right&lt;/em&gt; now.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是不假思索地的行动还不如拖延&lt;/p&gt;
&lt;p&gt;行动前要仔细思考，制定计划。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If the implementation is hard to explain, it's a bad idea.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果实现方案很难向别人解释，那么它就是个坏方案&lt;/p&gt;
&lt;p&gt;小黄鸭调试法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If the implementation is easy to explain, it may be a good idea.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反之亦然，良好的实现方案应该清晰容易理解&lt;/p&gt;
&lt;p&gt;好方案的一个共同特点就是清晰易懂，因为它们抓住了问题的关键点，从而可以用简单的方法高效地解决问题 —— &lt;code&gt;奥卡姆剃刀&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Namespaces are one honking great idea -- let's do more of those!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命名空间是一个绝妙的理念，我们要多加利用&lt;/p&gt;
&lt;p&gt;给变量起名字是一门艺术，尤其是大工程多人协同工作时，难免会有命名冲突，因为好名字是大家有共识的，使用命名空间可以让你不再有命名冲突的烦恼。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="easter-egg"&gt;Easter Egg&lt;/h2&gt;
&lt;p&gt;在解释器中用下面的命令就可以看到原文。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;this&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://liuwynn.github.io/2019/04/24/Python%E4%B9%8B%E7%A6%85/"&gt;Python 之禅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/lanphaday/article/details/2151918"&gt;《Python 之禅》的翻译和解释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.infoq.cn/article/e5FEa0D6JFADgKkHVyuE"&gt;怎样让你写的 Python 代码更优雅？&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #3 —— Docstring 风格</title><link href="https://qian-gu.github.io/posts/cs/python-notes-3-docstring-style.html" rel="alternate"></link><published>2020-04-26T19:20:00+08:00</published><updated>2020-04-26T19:20:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-04-26:/posts/cs/python-notes-3-docstring-style.html</id><summary type="html">&lt;p&gt;翻译 PEP257 -- Docstring Conventions&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;PEP 257 -- Docstring Conventions 原文链接&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;item&lt;/th&gt;
&lt;th&gt;detail&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PEP&lt;/td&gt;
&lt;td&gt;257&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Title&lt;/td&gt;
&lt;td&gt;Docstring Conventions&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Author&lt;/td&gt;
&lt;td&gt;David Goodger &lt;goodger at python.org&gt;, Guido van Rossum &lt;guido at python.org&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;Active&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;Informational&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;29-May-2001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Post-History&lt;/td&gt;
&lt;td&gt;13-Jun-2001&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="_1"&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文描述了 Python docstrings 的语法和惯例。&lt;/p&gt;
&lt;h2 id="_2"&gt;基本原理&lt;/h2&gt;
&lt;p&gt;本文的目的是在 high-level 的层次对 docstrings 结构进行标准化：应该包含哪些内容，以及如何表述（docstrings 内部不需要任何的标记性语法）。本文的内容是惯例，而不是严格的语法或法律。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"A universal convention supplies all of maintainability, clarity, consistency, and a foundation for good programming habits too. What it doesn't do is insist that you follow it against your will. That's Python!"&lt;/p&gt;
&lt;p&gt;—Tim Peters on comp.lang.python, 2001-06-16&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你违法了这些惯例，最差的结果也只不过是你的作品看起来比较丑陋。但是一些软件（比如 &lt;a href="docutils.sourceforge.net"&gt;Docutils&lt;/a&gt; 系统）会感知到 docstrings，所以遵守这些惯例可以让你获得最好的结果。&lt;/p&gt;
&lt;h2 id="_3"&gt;标准&lt;/h2&gt;
&lt;h3 id="docstrings"&gt;Docstrings 是什么&lt;/h3&gt;
&lt;p&gt;docstrings 是一个字符串，是 &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt; 中的第一个语句，这些字符会变成该 object 的特殊属性 &lt;code&gt;--doc--&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所有的 module 都应该有 docstrings，module 中所有可以导出的 function 和 class 也都应该有 docstrings。class 的 public method（包括 &lt;code&gt;--init--&lt;/code&gt; 构造器）也应该有 docstrings。一个 package 可以在自己目录下面 &lt;code&gt;--init--.py&lt;/code&gt; 文件的 docstrings 中进行描述。&lt;/p&gt;
&lt;p&gt;Python 文件中其他位置的字符串也可以成为文档的一部分，它们无法被 Python 的字节码编译器识别，runtime 的时候也无法访问（也就是说，没有赋值给 &lt;code&gt;--doc--&lt;/code&gt; 属性），但是有两种类型的 docstrings 可以被软件工具识别出来：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 module, class, &lt;code&gt;--init--&lt;/code&gt; 方法的顶层，简单赋值语句后面的字符串，叫做 “attribute docstrings”&lt;/li&gt;
&lt;li&gt;在 docstrings 之后紧跟着出现的字符串，叫做 “additional docstrings”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于这两种 docstrings 的详细描述请参考 &lt;a href="https://www.python.org/dev/peps/pep-0258/"&gt;PEP258 "Docutils Design Specification"&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;为了保持一致性，永远使用三个双引号 &lt;code&gt;"""triple double quotes"""&lt;/code&gt; 包围 docstrings。如果在 docstrings 中使用到了反斜线，请使用 &lt;code&gt;r"""raw triple double quotes"""&lt;/code&gt;，对于使用 Unicode 字符的情况，请使用 &lt;code&gt;u"""Unicode triple quoted string"""&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;docstrings 有两种形式：单行、多行。&lt;/p&gt;
&lt;h3 id="docstrings_1"&gt;单行 Docstrings&lt;/h3&gt;
&lt;p&gt;单行 docstrings 显而易见，就是只有一行。举例，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;kos&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Return the pathname of the KOS root directory.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;kos&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;kos&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;kos&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;即使是单行的情况，仍然使用三双引号，方便以后扩展成多行的情况&lt;/li&gt;
&lt;li&gt;开头和结尾的引号在同一行，这样看起来要美观一些&lt;/li&gt;
&lt;li&gt;docstrings 前后没有空行&lt;/li&gt;
&lt;li&gt;docstrings 用一个以句号结尾的短语，它用命令性的方式规定了 function/method 的效果（比如 “Do this”，“Return that”），而不是描述性的方式（比如，不要写成这样 "Returns the pathname..."）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单行的 docstrings 不应该是 function/method 的参数的重新声明（可以通过内省实现），不要写成这样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;function(a, b) -&amp;gt; list&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这种类型的 docstrings 只适合于 C 函数（比如内建函数），因为 C 没有内省机制。然而内省无法决定返回值的类型，所以要在 docstrings 中进行说明。所以 docstrings 应该优先选择下面的方式，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Do X and return a list.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="docstrings_2"&gt;多行 Docstrings&lt;/h3&gt;
&lt;p&gt;多行 docstrings 的结构分为 2 段，第一段是一个类似于单行 docstrings 的总结行，第二段是更详细的描述，两段之间用一个空行隔开。总结行可能会被自动化索引工具使用到，所以让它的长度保持在一行内，并且用空行和其他部分隔开非常重要。总结行可以放在开头引号的同一行，也可以放到下一行。整个 docstrings 和引号的缩进保持一致（见下面的例子）。&lt;/p&gt;
&lt;p&gt;class 的 docstrings 的后面要插入一（多）个空行。一般来说 class 的 methods 之间会通过一个空行进行隔离，docstrings 也需要一个空行来和第一个 method 进行隔离。&lt;/p&gt;
&lt;p&gt;一个脚本（作为一个单独的程序）的 docstrings 应该可以当作 Usage message 来使用，当使用不正确的参数（或者是表示 help 的 -h 参数）调用脚本时打印出这些内容。这种 docstrings 应该包含脚本的功能、命令行语法、环境变量、文件等信息。Usage message 可以非常详细（内容长达几个全屏），达到可以指导一个新用户正确使用本脚本命令，这个信息也可以作为高级用户查询所有选项和参数的快速参考。&lt;/p&gt;
&lt;p&gt;一个 module 的 docstrings 应该列出所有可以被导出的 class，exception 和 function 以及其他 objects，每个对象都有一个单行的总结性描述（这些总结比 docstrings 的总结行更简洁）。&lt;/p&gt;
&lt;p&gt;一个 package 的 docstrings（比如，&lt;code&gt;--init--.py&lt;/code&gt; 的 docstrings）也应该列出可以导出的 module 和 subpackage。&lt;/p&gt;
&lt;p&gt;一个 function/method 的 docstrings 应该总结它的行为，描述它的参数，返回值，副作用，抛出的 exception，调用时的约束。同时应该指出可选参数，无论 keyword 参数是不是接口的一部分，都应该进行描述。&lt;/p&gt;
&lt;p&gt;一个 class 的 docstrings 应该总结它的行为，列出 public method 和 instance varibale。如果它本身的设计目的是子类化，并且针对 subclass 留有额外的接口，那么这个额外接口应该在 docstrings 中单独列出来。构造器应该在 &lt;code&gt;--init--&lt;/code&gt; 方法的 docstrings 中描述，其他的 method 都在自己的 docstrings 中进行描述。&lt;/p&gt;
&lt;p&gt;如果一个 subclass 的大部分行为都继承自另外一个 class，那么它的 docstrings 应该提到这一点并且总结两者的不同之处。用动词 &lt;code&gt;override&lt;/code&gt; 来说明 subclass 的方法重写了 superclass 的同名方法；用动词 &lt;code&gt;extend&lt;/code&gt; 来表示 subclass 的方法调用了 superclass 的同名方法，并且添加了自己额外的功能。&lt;/p&gt;
&lt;p&gt;在 docstrings 中涉及到 function/method 的参数时不要用 Emacs 的大写惯例。Python 对大小写敏感而且参数的名字可以用作是 keyword 参数，所以 docstrings 应该使用正确的参数名字。最好按照每行一个参数的形式列出来。举例，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;complex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Form a complex number.&lt;/span&gt;

&lt;span class="sd"&gt;    Keyword arguments:&lt;/span&gt;
&lt;span class="sd"&gt;    real -- the real part (default 0.0)&lt;/span&gt;
&lt;span class="sd"&gt;    imag -- the imaginary part (default 0.0)&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;complex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zero&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除非是所有内容都可以在一行内完全放下，否则把结尾的引号单独放在一行，这样 Emacs 的 &lt;code&gt;fill-paragraph&lt;/code&gt; 命令就可以使用了。&lt;/p&gt;
&lt;h3 id="docstrings_3"&gt;处理 Docstrings 的缩进&lt;/h3&gt;
&lt;p&gt;docstrings 工具可以对 docstrings 的第二行及以后的行进行整体的缩进删除，删除的长度是后面这些行中的最小缩进，也就是说后面这些行的缩进最小化。第一行 docstrings 的任何缩进都是没有用的，会被删除。后续行的缩进也会被保留下来。应该删掉 docstrings 开头和结尾的空行。&lt;/p&gt;
&lt;p&gt;因为代码比描述更准确，这里贴出来这个规则（算法）的实现，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;trim&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;docstring&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;docstring&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="c1"&gt;# Convert tabs to spaces (following the normal Python rules)&lt;/span&gt;
    &lt;span class="c1"&gt;# and split into a list of lines:&lt;/span&gt;
    &lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;docstring&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expandtabs&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitlines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;# Determine minimum indentation (first line doesn&amp;#39;t count):&lt;/span&gt;
    &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;maxint&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]:&lt;/span&gt;
        &lt;span class="n"&gt;stripped&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lstrip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;stripped&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;indent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stripped&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;# Remove indentation (first line is special):&lt;/span&gt;
    &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;maxint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:]:&lt;/span&gt;
            &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;indent&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rstrip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="c1"&gt;# Strip off trailing and leading blank lines:&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# Return a single string:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面这个例子中的 docstrings 包含两个换行符号，所以一共有 3 行，第一行和最后一行是空行，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    This is the second line of the docstring.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在命令行中运行一下看看，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#!text
&amp;gt;&amp;gt;&amp;gt; print repr(foo.--doc--)
&amp;#39;\n    This is the second line of the docstring.\n    &amp;#39;
&amp;gt;&amp;gt;&amp;gt; foo.--doc--.splitlines()
[&amp;#39;&amp;#39;, &amp;#39;    This is the second line of the docstring.&amp;#39;, &amp;#39;    &amp;#39;]
&amp;gt;&amp;gt;&amp;gt; trim(foo.--doc--)
&amp;#39;This is the second line of the docstring.&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一旦经过 trim 处理， 下面这两种 docstring 是等效的，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A multi-line&lt;/span&gt;
&lt;span class="sd"&gt;    docstring.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    A multi-line&lt;/span&gt;
&lt;span class="sd"&gt;    docstring.&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="_4"&gt;参考&lt;/h2&gt;
&lt;p&gt;参考阅读&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0256/"&gt;PEP 256 -- Docstring Processing System Framework&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0258/"&gt;PEP 258 -- Docutils Design Specification&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;附：实践&lt;/h2&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/PyCQA/flake8-docstrings"&gt;flake8-docstrings&lt;/a&gt; 工具来帮助自己检查 docstrings 是否符合规范。&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #2 —— PEP8 实践</title><link href="https://qian-gu.github.io/posts/cs/python-notes-2-pep8-in-practice.html" rel="alternate"></link><published>2020-04-19T14:56:00+08:00</published><updated>2020-04-19T14:56:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-04-19:/posts/cs/python-notes-2-pep8-in-practice.html</id><summary type="html">&lt;p&gt;总结实际 coding 中遵循 PEP8 时用到的工具和插件&lt;/p&gt;</summary><content type="html">&lt;h2 id="pep8-pcqa"&gt;PEP8 &amp;amp; PCQA&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0008/"&gt;PEP8&lt;/a&gt; 之前已经介绍过了，这里有&lt;a href="http://guqian110.github.io/posts/python/python-notes-1-pep8.html"&gt;中文翻译（前一篇博客）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://meta.pycqa.org/en/latest/code-of-conduct.html"&gt;PCQA&lt;/a&gt; 是 Python Code Quality Authority 的缩写，它是一个松散的组织，聚集了各地的开发者，大家以在线协作的方式，为广大 python 码农提供各种 automatic style and quality reporting 工具，方便大家做项目时可以在不同项目都能保持代码风格一致。&lt;/p&gt;
&lt;p&gt;PCQA 源自于 &lt;code&gt;Ian Cordasco&lt;/code&gt; 在把 &lt;code&gt;Flake8&lt;/code&gt; 迁移到 Git 时发出的一封邮件，大家积极提议把项目迁移到 &lt;code&gt;GitLab&lt;/code&gt; 上，所以他在 &lt;code&gt;GitLab&lt;/code&gt; 和 &lt;code&gt;GitHub&lt;/code&gt; 上都建了一个 group 来专门维护 &lt;code&gt;Flake8&lt;/code&gt; 和 &lt;code&gt;flake8-docstrings&lt;/code&gt;。后来其他人开发维护的各种 lint 工具也源源不断地加入，PCQA 逐渐壮大。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="https://github.com/PyCQA"&gt;PCQA 的 GitHub 主页&lt;/a&gt; 上可以看到很多工具，很多常见的 linter 和 formatter 工具大部分来自于 PCQA，下文会经常看到 PCQA 的身影。&lt;/p&gt;
&lt;h2 id="linter"&gt;Linter&lt;/h2&gt;
&lt;h3 id="pycodestyle"&gt;pycodestyle&lt;/h3&gt;
&lt;p&gt;PCQA 荣誉出品，&lt;a href="https://github.com/PyCQA/pycodestyle"&gt;pycodestyle&lt;/a&gt; 原名叫 &lt;code&gt;pep8&lt;/code&gt;，后应 python 之父的&lt;a href="https://github.com/PyCQA/pycodestyle/issues/466"&gt;要求&lt;/a&gt;，后来改名为 &lt;code&gt;pycodestyle&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This package used to be called pep8 but was renamed to pycodestyle to reduce confusion. Further discussion can be found in the issue where Guido requested this change, or in the lightning talk at PyCon 2016 by @IanLee1521: slides video.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装和使用方法直接看 &lt;a href="https://github.com/PyCQA/pycodestyle"&gt;pycodestyle Github 主页&lt;/a&gt;，或者在命令行中查询。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pycodestyle&lt;span class="w"&gt; &lt;/span&gt;-h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;关于配置，pycodestyle 的 &lt;a href="https://pep8.readthedocs.io/en/latest/index.html"&gt;文档&lt;/a&gt; 里面有详细介绍，如果想自定义忽略某些检查项，则根据文档查阅这些检查项对应错误代码，在配置文件中添加忽略选项即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pycodestyle 是一个非常基础、应用非常广泛的工具，很多 lint 工具底层都依赖于它！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="pyflakes"&gt;pyflakes&lt;/h3&gt;
&lt;p&gt;PCQA 荣誉出品，&lt;a href="https://github.com/PyCQA/pyflakes"&gt;pyflakes Github 主页&lt;/a&gt; 介绍到 pyflakes 的设计原则非常简单：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;it will never complain about style, and it will try very, very hard to never emit false positives.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它通过解析每个源文件的 syntax tree，而不是通过 import 的方式来检查代码，所以很安全没有副作用，速度也会比 &lt;a href="https://github.com/PyCQA/pylint"&gt;pylint&lt;/a&gt; 和 &lt;a href="http://pychecker.sourceforge.net/"&gt;Pychecker&lt;/a&gt; 快很多。但是付出的代价就是它能检查的类型有限。&lt;/p&gt;
&lt;p&gt;pyflakes 的使用方法也非常简单，没有命令行参数，像下面这样直接调用即可，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;pyflakes&lt;span class="w"&gt; &lt;/span&gt;my-file.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;所以 pyflakes 只是检查语法错误，而不检查 code style，如果想要语法检查 + style 检查，那么可以使用下面介绍的 &lt;a href="https://gitlab.com/pycqa/flake8"&gt;flake8&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="flake8"&gt;flake8&lt;/h3&gt;
&lt;p&gt;PCQA 荣誉出品，&lt;a href="https://gitlab.com/pycqa/flake8"&gt;flake8&lt;/a&gt; 实际上是一个集成工具，它集成了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PyFlakes&lt;/li&gt;
&lt;li&gt;pycodestyle&lt;/li&gt;
&lt;li&gt;Ned Batchelder's McCabe script&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过一个单条的 &lt;code&gt;flake8&lt;/code&gt; 命令可以启动这三个命令进行检查。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;flake8&lt;span class="w"&gt; &lt;/span&gt;my-file.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;详细用法可以通过 help 选项查看或者阅读 &lt;a href="http://flake8.pycqa.org/en/latest/index.html"&gt;flake8 的文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;flake8 流行的一个重要原因是它提供扩展功能，官方已经为 flake8 开发了很多插件。比如 &lt;a href="https://github.com/PyCQA/flake8-docstrings"&gt;flake8-docstirngs&lt;/a&gt; 基于 PEP257 检查文档的 docstrings。&lt;/p&gt;
&lt;p&gt;每个插件的安装方法直接参考该插件的文档即可，安装完之后就可以像前面一样直接使用了。下面几个是常用插件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/PyCQA/pep8-naming"&gt;pep8-naming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/PyCQA/flake8-bugbear"&gt;flake8-bugbear&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/PyCQA/flake8-import-order"&gt;flake8-import-order&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/PyCQA/flake8-commas"&gt;flake8-commas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/PyCQA/flake8-docstrings"&gt;flake8-docstrings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pylint"&gt;pylint&lt;/h3&gt;
&lt;p&gt;PCQA 荣誉出品，提到 &lt;a href="https://github.com/PyCQA/pylint"&gt;pylint&lt;/a&gt;，必须先引用官网的一句话，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It's not just a linter that annoys you!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pylint 会检查代码语法错误，coding style（默认的检查标准和 PEP8 非常相似），它还能建议代码应该如何重构，它还会根据检查结果对你的代码打分 XD。&lt;/p&gt;
&lt;p&gt;不过 pylint 的检查非常严格，而且运行速度也要慢一些，所以很多人更喜欢用 flake8 等其他工具。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;上面的工具的使用流程都是一样的：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;em&gt;写代码&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;命令行调用工具检查&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;根据检查结果逐个修改代码&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;迭代 1~3 直到没有 error 和 warning&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;如果经常改动代码，这个过程会重复很多次，依然会很繁琐，所以下面介绍的几个工具可以提供自动化处理，减轻工作量。&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="formatter"&gt;Formatter&lt;/h2&gt;
&lt;h3 id="autopep8"&gt;autopep8&lt;/h3&gt;
&lt;p&gt;来自于一个日本程序猿之手，&lt;a href="https://github.com/hhatto/autopep8"&gt;autopep8&lt;/a&gt; 依赖于 pycodestyle，安装和使用说明直接看 Github 主页即可。通过命令行使用起来稍微有点繁琐，后面小节中有介绍使用 sublime 插件实现一键调用。&lt;/p&gt;
&lt;h3 id="yapf"&gt;yapf&lt;/h3&gt;
&lt;p&gt;首先必须说明 &lt;a href="https://github.com/google/yapf"&gt;yapf&lt;/a&gt; 并不是 Google 的官方产品，仅仅是恰好代码所属权是 Google。&lt;/p&gt;
&lt;p&gt;下面内容是一段官方文档的翻译：&lt;/p&gt;
&lt;p&gt;目前大部分的 python formatter 工具的机制是根据 lint 结果把 error 信息逐个修掉。这么做有很明显的局限性，比如某些代码虽然遵循了 PEP8，但是并不代表它的 coding style 是良好的。&lt;/p&gt;
&lt;p&gt;yapf 才用了另外一种思路，它基于 &lt;a href="https://clang.llvm.org/docs/ClangFormat.html"&gt;clang-format&lt;/a&gt; 工具，使用算法提取代码，尽最大努力将其 format 成最佳 style，即使有时候代码并没有违背规范。它终结了 formatting 的圣战：如果项目中有代码改动，将整个 codebase 用 yapf 过一遍，那么所有代码的风格就会保持一致，在 code review 的时候就不再有无意义的争吵。&lt;/p&gt;
&lt;p&gt;yapf 的终极目标是产生的代码和（遵循规范的）程序猿写出的代码一样，它可以替你完成维护代码中的一些繁琐的事情。&lt;/p&gt;
&lt;p&gt;安装和使用方法见官方主页。&lt;/p&gt;
&lt;h3 id="black"&gt;black&lt;/h3&gt;
&lt;p&gt;查看资料说 &lt;a href="https://github.com/psf/black"&gt;black&lt;/a&gt; 和 yapf 类似，但是限制条件比较多，没有太多的自定义选项，所以优点是省心。因为基于 python3，目前我还在使用 python 2.7，所以暂时记录一下，以后切换成 python 3 了再补坑。&lt;/p&gt;
&lt;h2 id="practice-in-sublime"&gt;Practice in Sublime&lt;/h2&gt;
&lt;p&gt;sublime 有很多 linter 和 formater 插件，下面总结一下。&lt;/p&gt;
&lt;h3 id="sublimelinter"&gt;SublimeLinter&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/SublimeLinter/SublimeLinter"&gt;SublimeLinter&lt;/a&gt; 是一个 sublime 的插件，可以提供一个框架，配合扩展插件完成各种语法和规则的 lint 检查。&lt;/p&gt;
&lt;p&gt;SublimeLinter 官方出品的扩展插件命名为 &lt;code&gt;SublimeLinter-xxx&lt;/code&gt; 的格式，第三方的插件则命名为 &lt;code&gt;SublimeLinter-contrib-xxx&lt;/code&gt; 的格式，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成 &lt;code&gt;iverilog&lt;/code&gt; 的插件 &lt;a href="https://packagecontrol.io/packages/SublimeLinter-contrib-iverilog"&gt;Sublime​Linter-contrib-iverilog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;集成 &lt;code&gt;verilator&lt;/code&gt; 的插件 &lt;a href="https://packagecontrol.io/packages/SublimeLinter-contrib-verilator"&gt;Sublime​Linter-contrib-verilator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;集成 &lt;code&gt;modelsim&lt;/code&gt; 的插件 &lt;a href="https://packagecontrol.io/packages/SublimeLinter-contrib-modelsim"&gt;Sublime​Linter-contrib-modelsim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面介绍的插件都是官方出品的插件。&lt;/p&gt;
&lt;h3 id="sublimelinter-pep8-sublimelinter-pycodestyle"&gt;Sublime​Linter-pep​8 / Sublime​Linter-pycodestyle&lt;/h3&gt;
&lt;p&gt;如前文所述，因为 &lt;code&gt;pep8&lt;/code&gt; 已经改名叫 &lt;code&gt;pycodestyle&lt;/code&gt;，所以 sublimlinter 也弃用了 &lt;a href="https://packagecontrol.io/packages/SublimeLinter-pep8"&gt;Sublime​Linter-pep​8&lt;/a&gt;，而是使用 &lt;a href="https://packagecontrol.io/packages/SublimeLinter-pycodestyle"&gt;Sublime​Linter-pycodestyle&lt;/a&gt; 为 sublimelinter 提供与 &lt;a href="https://github.com/PyCQA/pycodestyle"&gt;pycodestyle&lt;/a&gt; 的集成接口。&lt;/p&gt;
&lt;p&gt;安装完之后就可以看到效果了，根据提示修改代码即可。&lt;/p&gt;
&lt;h3 id="sublimelinter-pyflakes"&gt;Sublime​Linter-pyflakes&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://packagecontrol.io/packages/SublimeLinter-pyflakes"&gt;Sublime​Linter-pyflakes&lt;/a&gt; 为 sublimelinter 提供与 &lt;a href="https://github.com/PyCQA/pyflakes"&gt;pyflakes&lt;/a&gt; 的集成接口，安装完之后也可以看到效果。&lt;/p&gt;
&lt;h3 id="sublimelinter-flake8"&gt;SublimeLinter-flake8&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://packagecontrol.io/packages/SublimeLinter-flake8"&gt;Sublime​Linter-flake8&lt;/a&gt; 为 sublimelinter 提供与 &lt;a href="https://gitlab.com/pycqa/flake8"&gt;flake8&lt;/a&gt; 的集成接口，安装完之后也可以看到效果。&lt;/p&gt;
&lt;p&gt;因为 flake8 已经在底层集成了 pycodestyle 和 pyflake，所以只安装 SublimeLinter-flake8 即可，没有必要安装把这三个插件都安装了，这样会有很多重复提示。&lt;/p&gt;
&lt;h3 id="autopep8_1"&gt;AutoPEP8&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://packagecontrol.io/packages/AutoPEP8"&gt;AutoPEP8&lt;/a&gt; 为 sublime 提供与 &lt;a href="https://github.com/hhatto/autopep8"&gt;autopep8&lt;/a&gt; 的集成接口，可以一键调用 autopep8 检查代码是否符合 PEP8 规范，使用起来特别方便，目前安装量有 117K。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：AutoPEP8 不是完整的 linter，严格说应该属于 formatter，只能实现 PEP8 规范中的部分功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装完成后可以通过快捷键 &lt;code&gt;ctrl + 8&lt;/code&gt; 或者是 &lt;code&gt;shift + ctrl + 8&lt;/code&gt; 直接使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ctrl + 8&lt;/code&gt;：会生成一个 patch 文件，可以预览改动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift + ctrl + 8&lt;/code&gt;：直接修改目标文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pyyapf-python-formatter"&gt;Py​Yapf Python Formatter&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://packagecontrol.io/packages/PyYapf%20Python%20Formatter"&gt;PyYapf&lt;/a&gt; 为 sublime 提供与 yapf 集成的接口，安装之后可以通过快捷键或者是 &lt;code&gt;ctrl + shift + p&lt;/code&gt; 在 sublime 内调用 yapf。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;综上，python 有众多 linter 和 formatter 工具，很多工具之间的功能大部分都是重复的，选择一个用着顺手的即可。因为我使用 sublime text 作为主力编辑器，所以 PEP8 实践的最佳方案是：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;item&lt;/th&gt;
&lt;th&gt;solution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;editor&lt;/td&gt;
&lt;td&gt;sublime&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;linter&lt;/td&gt;
&lt;td&gt;sublimelinter-flake8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;formatter&lt;/td&gt;
&lt;td&gt;PyYapf&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="CS"></category><category term="PEP8"></category><category term="python"></category><category term="Sublime Text"></category></entry><entry><title>Python 学习笔记 #1 —— PEP8 编程风格</title><link href="https://qian-gu.github.io/posts/cs/python-notes-1-pep8-style.html" rel="alternate"></link><published>2020-04-12T13:55:00+08:00</published><updated>2020-04-12T13:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-04-12:/posts/cs/python-notes-1-pep8-style.html</id><summary type="html">&lt;p&gt;翻译 PEP8 -- Style Guide for Python Code&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0008/"&gt;PEP 8 -- Style Guide for Python Code 原文链接&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;item&lt;/th&gt;
&lt;th&gt;detail&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PEP&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Title&lt;/td&gt;
&lt;td&gt;Style Guide for Python Code&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Author&lt;/td&gt;
&lt;td&gt;Guido van Rossum&lt;guido at python.org&gt;, Barry Warsaw&lt;barry at python.org&gt;, Nick Coghlan&lt;ncoghlan at gmail.com&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;Active&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;Process&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;05-Jul-2001&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Post-History&lt;/td&gt;
&lt;td&gt;05-Jul-2001, 01-Aug-2013&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_1"&gt;介绍&lt;/h2&gt;
&lt;p&gt;本文介绍 Python 主要发布版本中标准库的 code style，对于 CPython 中的 C 代码的 style guide 请查看相关文档 &lt;a href="https://www.python.org/dev/peps/pep-0007/"&gt;PEP7&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文和 &lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;PEP257(docstring 规范 )&lt;/a&gt; 来源于 Guido 写的原始文章：《python code style》，部分来自于 Barry 的 &lt;a href="http://barry.warsaw.us/software/STYLEGUIDE.txt"&gt;GNU Mailman style guide&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文随着语言本身的变化不断进化，舍弃了部分规则的同时新加了一些规则。&lt;/p&gt;
&lt;p&gt;许多项目都有自己的 coding style guide，如果和本文有任何冲突，应该以该项目自己的 guide 为准。&lt;/p&gt;
&lt;h2 id="_2"&gt;尽信书，不如无书&lt;/h2&gt;
&lt;p&gt;Guido 的一个重要见解是：代码更多是用来读而不是写。本文提供的 guideline 的目的是提高代码的可读性，使得广泛的 python 代码保持一致性。正如 &lt;a href="https://www.python.org/dev/peps/pep-0020/"&gt;PEP20&lt;/a&gt; 所述，“ 可读性非常重要 ”。&lt;/p&gt;
&lt;p&gt;一篇 style guide 主要内容是一致性。虽然本文的一致性很重要，但是一个项目内的一致性更重要，最重要的是一个 module 或者 function 内部的一致性。&lt;/p&gt;
&lt;p&gt;但最重要的是，要知道什么时候不保持一致性，在实际应用时候有些 guide 并不适用，如果有疑问，根据自己的最佳判断，看看其他代码例子然后决定怎么写代码看起来最好。不要羞于发问。&lt;/p&gt;
&lt;p&gt;特别注意：不要为了遵守本文而破坏向后的兼容性！&lt;/p&gt;
&lt;p&gt;一些可以忽略本 guideline 的情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遵守本 guideline 会导致代码的可读性下降，即使对于那些习惯于遵守本文来阅读代码的人来说&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（可能出于历史原因）为了保持和周边代码的一致性可以忽略本 guideline，虽然这是个清理其他人垃圾的好机会（实现真正的极限编程 Extreme Programming）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码出现在本规范之前，并且没有其他理由去修改它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码需要和不支持本规范的旧版本 Python 代码保持一致&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_3"&gt;代码布局&lt;/h2&gt;
&lt;h3 id="_4"&gt;缩进&lt;/h3&gt;
&lt;p&gt;每级缩进为 4 个空格。&lt;/p&gt;
&lt;p&gt;连续行应该按照包围的元素对齐，要么使用 python 圆括号、方括号、花括号的隐式行连接在垂直方向对齐，要么使用 &lt;code&gt;hanging indent&lt;/code&gt;。使用 hanging indent 的时候应该注意，第一行不应该有任何参数，后续行多一级缩进以便和其他行能清晰地区分开。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;

&lt;span class="c1"&gt;# Aligned with opening delimiter.&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Add 4 spaces (an extra level of indentation) to distinguish arguments from the rest.&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Hanging indents should add a level.&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;

&lt;span class="c1"&gt;# Arguments on first line forbidden when not using vertical alignment.&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Further indentation required as indentation is not distinguishable.&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于后续的行，4 个 space 的规则是可选的，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Hanging indents *may* be indented to other than 4 spaces.&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果 if 语句的条件部分太长以至于要写成多行的形式，要注意，一个双字符的关键字（比如 if）加上一个空格，再加上右括号，会天然形成一个 4 space 的缩进。这会导致条件语句和 if 内部的嵌套语句（本身也是 4 space 缩进）产生视觉冲突。本文没有明确规定如何（是否需要）进一步在视觉上区分条件语句和内嵌语句，可选但是不限于下面几种方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# No extra indentation.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt;
    &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;another&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Add a comment, which will provide some distinction in editors&lt;/span&gt;
&lt;span class="c1"&gt;# supporting syntax highlighting.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt;
    &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;another&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Since both conditions are true, we can frobnicate.&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Add some extra indentation on the conditional continuation line.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;
        &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;is&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;another&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（也可参考下面关于二元操作符前后断行的讨论）&lt;/p&gt;
&lt;p&gt;右括号可以和最后一行第一个非空格字符对齐，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;takes&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以和第一行的第一个字符对齐，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;some&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;takes&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;code&gt;hanging indentation&lt;/code&gt; 是指除了首行之外，其他行都缩进的打印风格。在 python 中，这个术语指的是一个带括号的语句，左括号是该行的最后一个字符，除了右括号，剩余行都会加上缩进&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="tabs-spaces"&gt;Tabs 还是 Spaces？&lt;/h3&gt;
&lt;p&gt;首选空格 space 作为缩进方式。&lt;/p&gt;
&lt;p&gt;只有为了和已有代码中的 tab 保持一致才能继续使用 tab。&lt;/p&gt;
&lt;p&gt;python 3 不允许 tab 和 space 混合使用，python 2 中的 tab 和 space 混合使用时，应该先统一转换成 space。&lt;/p&gt;
&lt;p&gt;如果 python 2 的命令行解释器带了 &lt;code&gt;-t&lt;/code&gt; 选项，如果有 tab 和 space 混合使用的情况，它会报告 warning，如果带了 &lt;code&gt;-tt&lt;/code&gt; 选项，则会报告 error。强烈推荐使用这些选项。&lt;/p&gt;
&lt;h3 id="_5"&gt;最大行长度&lt;/h3&gt;
&lt;p&gt;所有行的最大行长是 79 个字符。&lt;/p&gt;
&lt;p&gt;对于基本没有结构化约束的长的文本（docstring 和注释），其长度不能超过 72 个字符。&lt;/p&gt;
&lt;p&gt;限制编辑器的宽度的好处是可以并列打开多个文件，在 code review 的时候比较两个版本的代码时很方便。&lt;/p&gt;
&lt;p&gt;许多工具的默认 warp 功能会破坏代码的视觉结构，使得代码难以理解。选择这些限制的目的就是为了防止 warp 功能设置为 80 个字符的编辑器自动 warp，即使有些编辑器在最后一列放了一个标记来提醒。一些基于 web 的工具甚至都不提供 warp 功能。&lt;/p&gt;
&lt;p&gt;一些团队强烈希望更长的行长，如果代码由一个可以达成一致的团队维护，那么可以把限制放宽到 99 个字符，但是注释和 docstring 仍然不超过 72 个字符。&lt;/p&gt;
&lt;p&gt;Python 标准库是保守主义，所以要求行长不超过 79（docstring 和注释不超过 72）。&lt;/p&gt;
&lt;p&gt;对于很长的行，优先选择的方式应该是使用括号隐式的断行，而不是使用 &lt;code&gt;\&lt;/code&gt; 来断行。&lt;/p&gt;
&lt;p&gt;反斜线 &lt;code&gt;\&lt;/code&gt; 有时候还是有用的，比如较长的 &lt;code&gt;with&lt;/code&gt; 语句不能使用括号的方式，所以只能选择反斜线。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/path/to/some/file/you/want/to/read&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
     &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/path/to/some/file/being/written&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（对于这种 with 语句，可以参考前面讨论 if 语句的处理方式）&lt;/p&gt;
&lt;p&gt;这种情况的另外一个例子是 &lt;code&gt;assert&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;确保在后续的行中适当地缩进。&lt;/p&gt;
&lt;h3 id="_6"&gt;应该在二元操作符的前还是后断行？&lt;/h3&gt;
&lt;p&gt;几十年以来，我们一直推荐的是在二元操作符之后断行，但是这样可能会伤害到代码的可读性，原因有两个：运算符一般分布在不同列，并且每个运算符和它的操作数被分开了，放到了操作数的前一行。下面的例子说明了需要读者的眼睛额外做一些工作来分辨那些变量是相加，哪些变量是相减，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="c1"&gt;# operators sit far away from their operands&lt;/span&gt;
&lt;span class="n"&gt;income&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gross&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wages&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
          &lt;span class="n"&gt;taxable&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;interest&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dividends&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;qualified&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dividends&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;
          &lt;span class="n"&gt;ira&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;deduction&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;
          &lt;span class="n"&gt;student&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;loan&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;interest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了解决这个可读性的问题，数学家和出版商遵循了相反的约定。Donald Knuth 在他的 &lt;em&gt;&lt;code&gt;Computer and Typesetting&lt;/code&gt;&lt;/em&gt; 系列中解释了传统的规则：“ 虽然段落中的公式总是在二元操作符、关系操作符的后面断开，但是单独显示出来的公式却总是在二元操作符的前面断开。”&lt;/p&gt;
&lt;p&gt;遵循数学家的传统通常可以得到可读性更好的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="c1"&gt;# easy to match operators with operands&lt;/span&gt;
&lt;span class="n"&gt;income&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gross&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wages&lt;/span&gt;
          &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;taxable&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;interest&lt;/span&gt;
          &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dividends&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;qualified&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dividends&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ira&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;deduction&lt;/span&gt;
          &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;student&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;loan&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;interest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 python 代码中，在二元符号之前或之后都可以断行，只要在本地保持一致即可。对于新写的代码，推荐使用 Knuth 的风格。&lt;/p&gt;
&lt;h3 id="_7"&gt;空行&lt;/h3&gt;
&lt;p&gt;顶层的 &lt;code&gt;function&lt;/code&gt; 和 &lt;code&gt;class&lt;/code&gt; 定义前后需要两个空行。&lt;/p&gt;
&lt;p&gt;class 内部的 &lt;code&gt;method&lt;/code&gt; 定义前后需要一个空行。&lt;/p&gt;
&lt;p&gt;一组功能相关的 function 可以通过额外的一个空行来区分（谨慎使用）。一组相关的单行代码之间的空行可以省掉（比如一组 dummy implementation）。&lt;/p&gt;
&lt;p&gt;在 function 内部（谨慎）使用空行区分逻辑段。&lt;/p&gt;
&lt;p&gt;python 接受 &lt;code&gt;control-L&lt;/code&gt; 作为空格，许多工具把这些字符当作页面分割符，所以你可以用它们来区分文件中的相关段落。注意，一些编辑器和基于 web 的阅读器可能无法识别 control-L，会在其位置显示一个其他符号。&lt;/p&gt;
&lt;h3 id="_8"&gt;源文件的编码格式&lt;/h3&gt;
&lt;p&gt;python 核心发布版本中的代码总是使用 UTF-8 来编码（python 2 中用 ASCII）。&lt;/p&gt;
&lt;p&gt;python 2 中使用 ASCII 的文件和 python 3 中使用 UTF-8 的代码不应该有编码申明。&lt;/p&gt;
&lt;p&gt;在标准库中，只有以测试目的或者注释、docstring 中需要提及包含非 ASCII 字符的作者名时，才能使用非默认编码方式；其他情况下，在字符串中优先使用 &lt;code&gt;\x&lt;/code&gt;，&lt;code&gt;\u&lt;/code&gt;，&lt;code&gt;\U&lt;/code&gt;，&lt;code&gt;\N&lt;/code&gt; 来转义非 ASCII 字符。&lt;/p&gt;
&lt;p&gt;对于 python 3.0 和更高版本来说，标准库使用了下面的政策（见 &lt;a href="https://www.python.org/dev/peps/pep-3131"&gt;PEP3131&lt;/a&gt;）：标准库中所有标识符 &lt;strong&gt;必须&lt;/strong&gt; 使用 ASCII 标识符，并在尽可能使用英语单词（在很多情况下，缩写和术语是非英语）。除此之外，string literals 和注释必须也使用 ASCII。只有两个例外，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;测试非 ASCII 的测试用例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作者的名字&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果作者的名字不是基于拉丁字符，&lt;strong&gt;必须&lt;/strong&gt; 提供一个拉丁字母音译。&lt;/p&gt;
&lt;p&gt;鼓励具有全球受众的开源项目采取类似的策略。&lt;/p&gt;
&lt;h3 id="imports"&gt;Imports&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt; 通常应该分开每行一个，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;但是这么写也是 ok 的，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;subprocess&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PIPE&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;import 必须放在文件的顶部，位于 module 注释和 docstring 的后面，在模块的全局变量 / 常量的前面。&lt;/p&gt;
&lt;p&gt;import 应该按照下面的顺序分组：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;标准库 import&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关的第三方库 import&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地应用 / 库的特定 import&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在每组之间插入一个空行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐使用绝对路径导入，因为当 import 系统配置不正确时（比如 package 内的一个目录以 &lt;code&gt;sys.path&lt;/code&gt; 结尾），这么做的可读性更好，性能也更好（至少 error 信息更加清晰）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;mypkg.sibling&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;mypkg&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;mypkg.sibling&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;然而，显式的相对路径也是一种可接受的方案，特别是使用绝对路径会导致不必要的复杂 package 布局的情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.sibling&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;标准库中的代码应该避免复杂的 package 布局，并且永远使用绝对路径 import。&lt;/p&gt;
&lt;p&gt;隐式的相对路径 import 永远都不应该使用，在 python 3 中已经删除了它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当从一个包含 class 的 module 中 import 一个 class 时，一般可以这么写，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;myclass&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MyClass&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;foo.bar.yourclass&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;YourClass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果这种拼写方式导致名字冲突，那么可以这么写，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;myclass&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;foo.bar.yourclass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;然后在代码中使用 &lt;code&gt;myclass.Myclass&lt;/code&gt; 和 &lt;code&gt;foo.bar.yourcalss.YourClass&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该避免使用通配符 &lt;code&gt;*&lt;/code&gt;（&lt;code&gt;from &amp;lt;module&amp;gt; import *&lt;/code&gt;），因为这样会使得命名空间中的名字变得不清晰，使很多读者和许多自动化工具产生混淆。有一种情况下可以使用 &lt;code&gt;*&lt;/code&gt; ，即将内部的接口作为 public API 的一部分重新发布出来。（比如，有一个可选的加速模块，它有某个提前无法知道是否会被重写的端口，使用纯 Python 将其实现的情况）&lt;/p&gt;
&lt;p&gt;当使用这种重新发布名称时，以下关于 public 和 内部接口的规则仍然适用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="dunber-name"&gt;模块级别的 dunber name&lt;/h3&gt;
&lt;p&gt;模块级别的 &lt;code&gt;dunber&lt;/code&gt;（即使那些使用双下划线 &lt;code&gt;--&lt;/code&gt; 包围的名字），比如 &lt;code&gt;--all--&lt;/code&gt;，&lt;code&gt;--author--&lt;/code&gt;，&lt;code&gt;--version--&lt;/code&gt; 等等，应该放在 module 的 docstring 的后面，任何 &lt;code&gt;import&lt;/code&gt; 语句之前（&lt;code&gt;form --future--&lt;/code&gt; 除外）。python 要求 future-import 必须位于除过 docstring 之外的任何代码之前。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;This is the example module.&lt;/span&gt;

&lt;span class="sd"&gt;This module does stuff.&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;future&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;barry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;FLUFL&lt;/span&gt;

&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nb"&gt;all&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0.1&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;author&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Cardinal Biggles&amp;#39;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dunber&lt;/code&gt; 指的是 &lt;code&gt;Double&lt;/code&gt; + &lt;code&gt;Underscore&lt;/code&gt; 的合体，指那些带双下划线的 method 或 attribute，如 &lt;code&gt;--init--&lt;/code&gt;、&lt;code&gt;--main--&lt;/code&gt;、&lt;code&gt;--verison--&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;https://wiki.python.org/moin/DunderAlias&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An awkward thing about programming in Python: there are lots of double underscores. [snip] My problem with the double underscore is that it's hard to say. How do you pronounce --init--? "underscore underscore init underscore underscore"? "under under init under under"? Just plain "init" seems to leave out something important. I have a solution: double underscore should be pronounced "dunder". So --init-- is "dunder init dunder", or just "dunder init".&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="string"&gt;string 引用&lt;/h2&gt;
&lt;p&gt;在 python 中，单引号和双引号字符串是一样的，本文关于这个不会给出建议。选择一个规则并且坚持下去即可。当一个 string 包含单引号或者是双引号时，在内部使用另外一种引号，这样可以避免在代码内部使用反斜线 &lt;code&gt;\&lt;/code&gt;，提高代码的可读性。&lt;/p&gt;
&lt;p&gt;根据 &lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;PEP257&lt;/a&gt;，对于三引号 string，永远使用双引号。&lt;/p&gt;
&lt;h2 id="_9"&gt;表达式和语句中的空格&lt;/h2&gt;
&lt;h3 id="_10"&gt;一些小问题&lt;/h3&gt;
&lt;p&gt;避免下面情况中出现的无关空格，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;紧跟在括号之后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;spam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;eggs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;spam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;eggs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 trailing 逗号和右括号之间&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紧贴在逗号，分号，冒号之前&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然而，&lt;code&gt;slice&lt;/code&gt; 内部的冒号就像是个二元操作符（把它当作是优先级最低的操作符），所以两边应该有相同数量的空格。在一个扩展 slice 中，所有的冒号必须有相同的间距。例外情况：slice 的一个参数被忽略了，它附带的空格也就被忽略了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;:],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt; &lt;span class="n"&gt;step&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;fn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;ham&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紧跟在（函数调用参数列表）的左括号之后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;spam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;spam&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紧跟在 index 或者是 slice 的左括号之前&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;dct&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;dct&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了和其他赋值语句对齐，在赋值语句周围使用多于 1 个空格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;             &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;             &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_11"&gt;别的建议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免尾部空格。因为一般它都是不可见的，这可能会导致困惑：比如，反斜线后面跟着一个空格和一个换行符时，并不算做是一个有效的续行标记。一些编辑器不会保留尾部空格，并且很多项目（比如 CPython 自身）在 commit 之前会有相关检查来滤掉它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永远在二元操作符两边加上单个空格，比如赋值 &lt;code&gt;=&lt;/code&gt;，增量赋值 &lt;code&gt;+=&lt;/code&gt;，&lt;code&gt;-=&lt;/code&gt;，比较 &lt;code&gt;==&lt;/code&gt;，&lt;code&gt;&amp;lt;&lt;/code&gt;，&lt;code&gt;&amp;gt;&lt;/code&gt;，&lt;code&gt;！=&lt;/code&gt;，&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;=&lt;/code&gt;，&lt;code&gt;&amp;gt;=&lt;/code&gt;，&lt;code&gt;in&lt;/code&gt;，&lt;code&gt;not&lt;/code&gt;，&lt;code&gt;is&lt;/code&gt;，&lt;code&gt;not&lt;/code&gt;，布尔运算符 &lt;code&gt;and&lt;/code&gt;，&lt;code&gt;or&lt;/code&gt;，&lt;code&gt;not&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用了具有不同优先级的运算符，考虑在低优先级的运算符周围加上额外的空格。使用自己的判断，但是空格数量不要超过 1 个，并且在二元运算符周围使用相同数量的空格。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;submitted&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;hypot2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;submitted&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;hypot2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数注解应该使用正常的冒号规则，如果有 &lt;code&gt;-&amp;gt;&lt;/code&gt;，要在其周围加上空格（参考下文函数注解部分的更多信息）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AnyStr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;PosInt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;AnyStr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;PosInt&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt; 用来标记关键字参数或者是参数默认值时，不要使用空格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;complex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;magic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;complex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;magic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;real&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;当参数有类型注释且有默认值时，要在 &lt;code&gt;=&lt;/code&gt; 周围加上空格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AnyStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AnyStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AnyStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AnyStr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;munge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;AnyStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复合语句（单行有多个语句）一般是不允许的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blah&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;最好不要这样，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blah&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有时候 &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; 可以和一小块代码放在同一行，但是多行语句时不要这样做，同时避免行长太长导致折叠！&lt;/p&gt;
&lt;p&gt;最好不要这样，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blah&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;lst&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;绝对不要这样，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blah&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blah&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;thing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cleanup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;long&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                             &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;like&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;blah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_12"&gt;什么时候使用尾部逗号&lt;/h2&gt;
&lt;p&gt;尾部逗号一般是可选的，除非是在构造单元素的 &lt;code&gt;tuple&lt;/code&gt; 时它是强制性必须存在的，在 python2 的 &lt;code&gt;print&lt;/code&gt; 中逗号是语法的一部分。为了清晰起见，推荐用（冗余的）圆括号包围起来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;FILES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;setup.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;FILES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;setup.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用版本控制系统时冗余的尾部逗号通常非常有用，比如随着时间发展，由值或者是参数组成的 &lt;code&gt;list&lt;/code&gt;，&lt;code&gt;import&lt;/code&gt; 的内容不断增多的时候，在最后加上尾部逗号非常有用。一般的写法是每个值一行，然后在最后添加一个元素后面加上尾部逗号，最后在下面的另外一行加上右括号。但是如果元素都在同一行，那么就没有理由加尾部逗号（除非是上面提到的单元素 tuple）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="n"&gt;FILES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;setup.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s1"&gt;&amp;#39;tox.ini&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FILES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
           &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;FILES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;setup.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tox.ini&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,]&lt;/span&gt;
&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FILES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="_13"&gt;注释&lt;/h2&gt;
&lt;p&gt;和代码相冲突的注释比没有注释更糟糕，在代码改变之后永远第一时间更新相关注释。&lt;/p&gt;
&lt;p&gt;注释应该是完整的句子，除非是用标识符开头的语句（永远不要改变标识符的大小写！），其他情况下第一个单词的首字母应该大写。&lt;/p&gt;
&lt;p&gt;块注释一般由一段或者是多段的完整句子组成，并且每句都带一个句号。&lt;/p&gt;
&lt;p&gt;在多语句的注释中，每句结束后面应该有两个空格，除非是最后一句。&lt;/p&gt;
&lt;p&gt;用英语写注释时，遵循 &lt;a href="https://book.douban.com/subject/3296585/"&gt;&lt;code&gt;Strunk and White&lt;/code&gt;&lt;/a&gt; 风格&lt;/p&gt;
&lt;p&gt;如果你是非英语 python 码农，请使用英语写注释，除非你 120% 确保代码永远不会被不说你母语的人读到。&lt;/p&gt;
&lt;h3 id="_14"&gt;块注释&lt;/h3&gt;
&lt;p&gt;块注释一般放在代码前面，和代码的缩进同级，块注释中的每一行都以 &lt;code&gt;#&lt;/code&gt; + 一个空格开头（除非是注释内部的缩进）。&lt;/p&gt;
&lt;p&gt;块注释内部的段落用一个以 &lt;code&gt;#&lt;/code&gt; 开头的空行隔开。&lt;/p&gt;
&lt;h3 id="_15"&gt;行内注释&lt;/h3&gt;
&lt;p&gt;谨慎地使用行内注释。&lt;/p&gt;
&lt;p&gt;行内注释指的是和代码在同一行的注释，行内注释和代码应该用至少 2 个空格隔开，且以一个 &lt;code&gt;#&lt;/code&gt; + 一个空格开始。&lt;/p&gt;
&lt;p&gt;行内注释一般没有必要，事实上还会分散注意力。不要写类似下面的注释，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;                 &lt;span class="c1"&gt;# Increment x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是有时候，这样写是很有用的，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;                 &lt;span class="c1"&gt;# Compensate for border&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="docstring"&gt;docstring&lt;/h3&gt;
&lt;p&gt;docstirng 的规则总结在 &lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;PEP257&lt;/a&gt; 内，其内容永远都不会改变。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为所有的 public &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt; 写 docstirng。对非 public method 没有必要写 docstirng，但是你应该写个注释描述该 method 的作用。这个注释应该出现在 &lt;code&gt;def&lt;/code&gt; 行的下面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0257/"&gt;PEP257&lt;/a&gt; 描述了良好的 docstirng 惯例，要特别注意的是，多行的 docstirng 的结尾 &lt;code&gt;"""&lt;/code&gt; 应该单独放一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Return a foobang&lt;/span&gt;

&lt;span class="sd"&gt;Optional plotz says to frobnicate the bizbaz first.&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于单行的 docstring，把结尾的 &lt;code&gt;"""&lt;/code&gt; 放在该行内&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_16"&gt;命名规范&lt;/h2&gt;
&lt;p&gt;python 库的命名规则有点混乱，我们一直没有完全统一，然而，这里列了一些当前推荐的命名标准。新写的 &lt;code&gt;module&lt;/code&gt; 和 &lt;code&gt;package&lt;/code&gt;（包括第三方的 framework）应该遵守下面的标注，但是如果一个已经存在的库有其他的 style，只要内部保持一致性即可。&lt;/p&gt;
&lt;h3 id="_17"&gt;最重要的规则&lt;/h3&gt;
&lt;p&gt;API 中那些对用户可见的公共接口的名字，应该遵循反映用法而不是内部实现的原则。&lt;/p&gt;
&lt;h3 id="_18"&gt;描述性的：命名风格&lt;/h3&gt;
&lt;p&gt;有许多不同的命名 style，下面这些可以帮助我们识别出正在使用什么样的 style，而和他们用来做什么没有关系。&lt;/p&gt;
&lt;p&gt;下面是一些常见的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;b&lt;/code&gt;（单个小写字母）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;B&lt;/code&gt;（单个大写字母）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lowercase&lt;/code&gt; 小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lower-case-with-underscores&lt;/code&gt; 小写带下划线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UPPERCASE&lt;/code&gt; 大写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UPPER-CASE-WITH-UNDERSCORES&lt;/code&gt; 大写带下划线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CapitalizedWords&lt;/code&gt;（或者叫 CapWords，CamelCase —— 驼峰命名法），有时也叫做 StudlyCaps&lt;/p&gt;
&lt;p&gt;注意：在驼峰中使用首字母缩写时，所有字母都要大写，所以 &lt;code&gt;HTTPServerError&lt;/code&gt; 比 &lt;code&gt;HttpServerError&lt;/code&gt; 要好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mixedCase&lt;/code&gt;（和驼峰不同之处在于第一个字母小写）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;capitalized-Words-With-Underscores&lt;/code&gt;（丑陋！）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一种使用短缩写前缀来使一组相关的名字形成一个 group，Pyhton 中这种场景并不多见，这里只是为了全面而提一下。比如，&lt;code&gt;os.stat()&lt;/code&gt; 函数返回了一个 &lt;code&gt;tuple&lt;/code&gt;，内部的变量是 &lt;code&gt;st-mode&lt;/code&gt;, &lt;code&gt;st-size&lt;/code&gt;, &lt;code&gt;st-mtime&lt;/code&gt; 之类的名字。（这么做的目的是为了强调和 &lt;code&gt;POSIX&lt;/code&gt; 系统调用的相关性，以帮助程序员熟悉它）&lt;/p&gt;
&lt;p&gt;X11 库里面所有的 public 函数都加了 &lt;code&gt;X&lt;/code&gt; 前缀，在 python 里，这种风格通常是没有必要的，因为 &lt;code&gt;attribute&lt;/code&gt; 和 &lt;code&gt;method&lt;/code&gt; 调用的时候前面一般都会带上 object 前缀，而函数名前面会带上 module 的名字。&lt;/p&gt;
&lt;p&gt;除此之外，下面的这种带前缀或后缀下划线 &lt;code&gt;-&lt;/code&gt; 的格式是可以的（通常和一些惯例结合在一起使用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-single-leading-underscore-&lt;/code&gt;，弱 “ 内部使用 ” 标志。比如，&lt;code&gt;from M import *&lt;/code&gt; 不会导入类似以 &lt;code&gt;-&lt;/code&gt; 开头的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;single-trailing-underscore-&lt;/code&gt;，用来避免和 python 内部的关键字相冲突&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Tkinter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Toplevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ClassName&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--double-leading-underscore&lt;/code&gt;，用来给 class 的 attribute 命名，调用它时会被矫正（在 class FooBar 中，&lt;code&gt;--boo&lt;/code&gt; 会变成 &lt;code&gt;-FooBar-boo&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--double-leading-and-trailing-underscore--&lt;/code&gt;，“magic” 对象 /attribute，存在于用户控制的 &lt;code&gt;namespcae&lt;/code&gt;，比如，&lt;code&gt;--init--&lt;/code&gt;，&lt;code&gt;--import--&lt;/code&gt;，或者 &lt;code&gt;--file--&lt;/code&gt;。仅仅像文档说明的这样用，永远不要自己发明这种名字。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_19"&gt;规范性的：命名惯例&lt;/h3&gt;
&lt;h4 id="_20"&gt;避免使用的名字&lt;/h4&gt;
&lt;p&gt;永远都不要使用小写字母 &lt;code&gt;l&lt;/code&gt;，大写字母 &lt;code&gt;O&lt;/code&gt;，大写字母 &lt;code&gt;I&lt;/code&gt; 作为单字母变量名。&lt;/p&gt;
&lt;p&gt;在某些字体中，这些字符会和数字 0/1 混淆不清，如果要使用小写字母 &lt;code&gt;l&lt;/code&gt;，使用 &lt;code&gt;L&lt;/code&gt; 代替。&lt;/p&gt;
&lt;h4 id="ascii"&gt;兼容 ASCII&lt;/h4&gt;
&lt;p&gt;如 &lt;a href="https://www.python.org/dev/peps/pep-3131"&gt;PEP3131&lt;/a&gt; 中所述，标准库中的标识符必须是 ASCII 兼容的。&lt;/p&gt;
&lt;h4 id="package-module"&gt;package 和 module 的名字&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;module&lt;/code&gt; 必须使用简短，全小写的名字。如果使用下划线能提高代码的可读性，那么就可以使用。 虽然不鼓励使用下划线，但是 &lt;code&gt;package&lt;/code&gt; 也必须也用简短、全小写的名字。&lt;/p&gt;
&lt;p&gt;如果一个模块的底层实现使用的是 C/C++，并且有个用 python 模块来提供更高层次接口（比如，面向对象），那么这个 C/C++ module 名字必须要有下划线前缀（比如，&lt;code&gt;-socket&lt;/code&gt;）。 &lt;/p&gt;
&lt;h4 id="class"&gt;class 的名字&lt;/h4&gt;
&lt;p&gt;class 的名字一般应该使用 &lt;code&gt;CapWords&lt;/code&gt; 的惯例。&lt;/p&gt;
&lt;p&gt;如果 interface 被文档化了并且主要作为被调用的场景，那么可以换成 function 的命名惯例。&lt;/p&gt;
&lt;p&gt;注意，对于内置的名字有个单独的惯例：大部分内置名字一般是单个单词（或者是两个单词连在一起），&lt;code&gt;CapWords&lt;/code&gt; 之用于 exception 和内置常量。&lt;/p&gt;
&lt;h4 id="_21"&gt;类型变量的名字&lt;/h4&gt;
&lt;p&gt;在 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 中的类型变量名字，相比于短名字，如 &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;AnyStr&lt;/code&gt;，&lt;code&gt;Num&lt;/code&gt;，一般优先使用 &lt;code&gt;CapWords&lt;/code&gt;。推荐给变量加上后缀 &lt;code&gt;-co&lt;/code&gt; 或者是 &lt;code&gt;-contra&lt;/code&gt; 来声明相关的协变量或者是逆变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;typing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TypeVar&lt;/span&gt;

&lt;span class="n"&gt;VT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TypeVar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;VT-co&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;covariant&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;KT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;contra&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TypeVar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;KT-contra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contravariant&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="exception"&gt;Exception 的名字&lt;/h4&gt;
&lt;p&gt;因为 exception 应该是个 class，所以使用 class 的规则即可。但是，如果某个 exception 确实是个 error，则应该给它加上 &lt;code&gt;Error&lt;/code&gt; 后缀。&lt;/p&gt;
&lt;h4 id="_22"&gt;全局变量名&lt;/h4&gt;
&lt;p&gt;希望这些变量只会在单个 module 内使用。它的命名规则和 function 一样。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;from M import *&lt;/code&gt; 来使用的 module，应该使用 &lt;code&gt;--all--&lt;/code&gt; 机制来防止暴露 global 变量，或者使用以前加前缀的规则，比如给这些 global 变量加上单个下划线（表明你想暗示这些变量是 module 内，非 publicc 的）。&lt;/p&gt;
&lt;h4 id="function"&gt;Function 和 变量 名&lt;/h4&gt;
&lt;p&gt;function 名应该小写，如果有必要，使用下划线将单词分隔开以提高可读性。&lt;/p&gt;
&lt;p&gt;变量名和函数的规则一样。&lt;/p&gt;
&lt;p&gt;只有在为了和旧代码（比如 &lt;code&gt;threading.py&lt;/code&gt;）保持兼容性时，才允许使用 &lt;code&gt;mixedCase&lt;/code&gt; 风格的名字。&lt;/p&gt;
&lt;h4 id="function-method"&gt;Function 和 Method 的参数&lt;/h4&gt;
&lt;p&gt;永远要把 &lt;code&gt;self&lt;/code&gt; 作为例化 mehod 的第一个参数。&lt;/p&gt;
&lt;p&gt;永远使用 &lt;code&gt;cls&lt;/code&gt; 作为例化 class 的第一个参数。&lt;/p&gt;
&lt;p&gt;如果一个 function 的参数名和关键字相冲突，一般最好在尾部加一个后缀的单下划线，而不是使用缩写或是故意拼写错误。所以 &lt;code&gt;class-&lt;/code&gt; 比 &lt;code&gt;clss&lt;/code&gt; 要更好（也许最好的方式是使用一个同义词来避免这种情况）。&lt;/p&gt;
&lt;h4 id="mehtod-instance"&gt;Mehtod 和 Instance 的名字&lt;/h4&gt;
&lt;p&gt;使用和 function 一样的命名规则：用下划线把小写单词分隔开以提高可读性。&lt;/p&gt;
&lt;p&gt;只有非 public 的 method 和 instance variables 才可以加上前缀下划线。&lt;/p&gt;
&lt;p&gt;为了避免和类名相冲突，使用两个前缀下划线来触发 python 的命名矫正规则。&lt;/p&gt;
&lt;p&gt;python 会使用 class 的名字来矫正这些名字：如果 class &lt;code&gt;Foo&lt;/code&gt; 有一个名字为 &lt;code&gt;--a&lt;/code&gt; 的 attribute，则无法通过 &lt;code&gt;Foo.--a&lt;/code&gt; 来访问它（用户可以通过 &lt;code&gt;Foo.-Foo--a&lt;/code&gt; 的方式来访问）。一般来说，双下划线前缀只应该用来避免和子类中的名字相冲突的情况。&lt;/p&gt;
&lt;h4 id="_23"&gt;常量&lt;/h4&gt;
&lt;p&gt;常量定义一般和 module 同级别，并且全部大写，用下划线隔开单词。比如 &lt;code&gt;MAX-OVERFLOW&lt;/code&gt; 和 &lt;code&gt;TOTAL&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="_24"&gt;继承的设计&lt;/h4&gt;
&lt;p&gt;始终要考虑一个 class 的 method 和 instance variables（统称为：&lt;code&gt;attribute&lt;/code&gt;）应该是 public 还是 non-public。如果有疑问，那么就选择做成 non-public；因为之后将其再改为 public 要比反过来做更容易。&lt;/p&gt;
&lt;p&gt;public attribute 是那些你希望和你的 class 不相关的用户可以使用的 attribute，并且你应该保证以后修改时不会发生向后不兼容的情况。non-public attribute 是那些不打算给第三方使用的 attribute，你没必要保证 non-public attribute 以后不会改变或甚至是被删除。&lt;/p&gt;
&lt;p&gt;我们不使用术语 &lt;code&gt;private&lt;/code&gt;，是因为 python 里面的 attribute 并不是真正的 private（为了避免大量不必要的工作）。&lt;/p&gt;
&lt;p&gt;基类中还有另外一类 attribute，它们会作为 subclass API 中一部分（通常在别的语言里面叫作 &lt;code&gt;protected&lt;/code&gt;）。有些 class 被特意设计成被继承形式，一般是为了扩展或者修改原来 class 的行为。当设计这种 class 时，要小心决定哪些 attribute 是 public 的，哪些 attribute 是 subclass 的 API，哪些是真正只有 base class 才会使用的。&lt;/p&gt;
&lt;p&gt;遵守以上的思想，这里有一些 pythonic guideline：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public attrbute 不应该有前缀下划线&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你的 public attribute 的名字和保留的关键字冲突了，在属性的最后缀上一个下划线。优先选择这种方法而不是采用缩写或者是错误拼写（但是尽管有这样的规则，对于 class method 作为第一个参数的情况，优先选择用 'cls' 表示 class 类型的变量 / 参数）&lt;/p&gt;
&lt;p&gt;注意 1：对于 class 的 method 的参数命令参考前面的讨论。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于简单的 public data attribute，最好直接暴露它的名字，而不是再写一个复杂的 accessor/mutator method。如果一个 data attribute 需要增加功能，python 提供了一个方便的途径。这种情况下，使用 property 来隐藏简单的数据访问背后的 功能实现。&lt;/p&gt;
&lt;p&gt;注意 1：property 应该只在 new-style 的 class 中实现。&lt;/p&gt;
&lt;p&gt;注意 2：虽然有些副作用（比如 caching）是可以接受的，但是要尽量尝试让 function 的行为没有副作用&lt;/p&gt;
&lt;p&gt;注意 3：property 会让调用者认为访问开销相对较小，所以尽量避免使用 property 来做大开销的计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你的 class 可能会被扩展出 subclass，并且你不希望 subclass 使用一些 attribute，那么考虑用两个下划线前缀、没有下划线后缀的方式给这些 property 命名。这样会触发 python 的命名矫正算法，这个 attribute 的名字前会加上 class 的名字。这样可以避免 subclass 意外使用相同名字时的冲突。&lt;/p&gt;
&lt;p&gt;注意 1：只有 class 的名字才会合入到 attribute 名字中，所以如果 subclass 的名字和其 attribute 的名字和父类名字相同，那么还是会有冲突&lt;/p&gt;
&lt;p&gt;注意 2：命名矫正在某些情况下很不方便，比如 debug 或者是 &lt;code&gt;--getattr--()&lt;/code&gt;。但是命名矫正算法的文档很完善，使用起来也很方便。&lt;/p&gt;
&lt;p&gt;注意 3：并不是每个人都喜欢命名矫正，尽量避免和潜在的高级调用者产生命名冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="public-internal"&gt;public 和 internal 接口&lt;/h3&gt;
&lt;p&gt;任何的向后兼容只适用于 public 接口，因此，让用户能清晰地区分出 public 和 内部接口非常重要。&lt;/p&gt;
&lt;p&gt;文档化的接口可以认为是 public 接口，除非文档中明确说明该接口是拥有向后兼容豁免权的临时 / 内部接口。所有没有文档化的接口都应该视为内部接口。&lt;/p&gt;
&lt;p&gt;为了更好地支持 introspection，module 应该用 &lt;code&gt;--all--&lt;/code&gt; 明确声明 public API 的名字。如果没有 public API，那么就把 &lt;code&gt;--all--&lt;/code&gt; 设置为空 list。&lt;/p&gt;
&lt;p&gt;即使合理地设置了 &lt;code&gt;--all--&lt;/code&gt;，内部接口（package、module、class、function、attribute 或其他名字）还是应该加上单下划线前缀。&lt;/p&gt;
&lt;p&gt;如果 namespace（package、module、class）被认为是内部的，那么包含在内的接口也会被认为是内部的。&lt;/p&gt;
&lt;p&gt;import 的名字应该永远被认为是实现细节。除非是 module API 的一部分，否则别的 module 不能间接访问这些名字。比如，&lt;code&gt;os.path&lt;/code&gt; 或者是一个 package 的 &lt;code&gt;--init--&lt;/code&gt; module。&lt;/p&gt;
&lt;h2 id="_25"&gt;编程建议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;代码不能伤害其他 python 的实现（比如 PyPy、Jython、IronPython、Cython、Psyco 等等）&lt;/p&gt;
&lt;p&gt;比如，字符串连接时不要依赖于 CPython 中的高效实现形式 &lt;code&gt;a += b&lt;/code&gt; 或者是 &lt;code&gt;a = a + b&lt;/code&gt; 。即使在 Cpython 中这种优化也是很脆弱的（只适用于部分类型），而且如果不使用 &lt;code&gt;refcouting&lt;/code&gt; 那么就完全不会产生这种优化。库中对性能敏感的部分，应该使用 &lt;code&gt;''.join()&lt;/code&gt; 的方式。这样可以保证在各种实现中，字符串连接的时间开销是线性的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和类似 &lt;code&gt;None&lt;/code&gt; 这样的单例对象的比较，应该永远使用 &lt;code&gt;is&lt;/code&gt; 或者是 &lt;code&gt;is not&lt;/code&gt;，永远不要使用等号操作符。&lt;/p&gt;
&lt;p&gt;此外，如果你的目的是 &lt;code&gt;if x is not None&lt;/code&gt; 那么要小心别写成 &lt;code&gt;if x&lt;/code&gt;。举例：判断一个默认值是 None 的变量 / 参数是否被设置成其他值，这个值（比如容器）的类型在 boolean 表达式中可能会是 false！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;is not&lt;/code&gt; 而不是 &lt;code&gt;not ... is&lt;/code&gt;。虽然两个表达式的功能相同，但是前一种写法的可读性更强：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用丰富的比较实现排序时，最好实现所有的比较符（六个：&lt;code&gt;--eq--&lt;/code&gt;, &lt;code&gt;--ne--&lt;/code&gt;, &lt;code&gt;--lt--&lt;/code&gt;, &lt;code&gt;--le--&lt;/code&gt;, &lt;code&gt;--gt--&lt;/code&gt;, &lt;code&gt;--ge--&lt;/code&gt;），而不是依赖于其他（只在特定比较上验证过的）代码&lt;/p&gt;
&lt;p&gt;为了最小化开销，装饰器 &lt;code&gt;functools.total-ordering()&lt;/code&gt; 可以提供一个工具来生成缺少的比较操作。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0207"&gt;PEP207&lt;/a&gt; 指出 python 实现了反射机制，所以，解析器可能会把 &lt;code&gt;y &amp;gt; x&lt;/code&gt; 转换成 &lt;code&gt;x &amp;lt; y&lt;/code&gt;，把 &lt;code&gt;y &amp;gt;= x&lt;/code&gt; 转换成 &lt;code&gt;x &amp;lt;= y&lt;/code&gt;，把 &lt;code&gt;x == y&lt;/code&gt; 转换成 &lt;code&gt;x != y&lt;/code&gt;。&lt;code&gt;sort()&lt;/code&gt; 和 &lt;code&gt;min()&lt;/code&gt; 可以确保使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 操作符，&lt;code&gt;max()&lt;/code&gt; 使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 操作符。但是，最好实现这六个操作符，这样在其他地方就不会有困惑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;始终使用 &lt;code&gt;def&lt;/code&gt; 而不是赋值语句来把一个 lambda 表达式绑定到一个标识符上&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;前一种形式意味着生成的 function 对象是 &lt;code&gt;f&lt;/code&gt; 而不是通用的 &lt;code&gt;&amp;lt;lambda&amp;gt;&lt;/code&gt;。这在回溯和 stirng 显示的时候更加有用。赋值语句会消除 lambda 表达式优于显式使用 def 语句的唯一优势。（即 lambda 表达式可以内嵌在一个更大的表达式中）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 &lt;code&gt;Exception&lt;/code&gt; 而不是 &lt;code&gt;BaseException&lt;/code&gt; 中继承 exception，直接从 &lt;code&gt;BaseException&lt;/code&gt; 中继承得到的 exception 是保留的，捕捉这些异常是大部分情况下一件错误的事情。&lt;/p&gt;
&lt;p&gt;基于需要捕捉 exception 的代码，而不是抛出 exception 的位置代码来设计 exception hierarchies。以编程的角度回答 “ 发生了什么错误 ?” 这个问题，而不是只是说 “ 发生了错误 ”（内置 exception hierarchies 的例子见 &lt;a href="https://www.python.org/dev/peps/pep-3151"&gt;PEP3151&lt;/a&gt;） &lt;/p&gt;
&lt;p&gt;应该遵守 class 的命名规则，除非你的 exception 本身就是一个 error，那么就给这个 exception class 名字加上 &lt;code&gt;Error&lt;/code&gt; 后缀。用于非本地控制或其他形式的非 error exception 不需要特殊的后缀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适当地使用 exception 链，在 python 3 中，为了不丢失原始的回溯信息，应该使用 &lt;code&gt;raise X from Y&lt;/code&gt; 来表示明确的替换。&lt;/p&gt;
&lt;p&gt;当故意替换内部 exception 时（在 python 2 中用 &lt;code&gt;raise X&lt;/code&gt;，在 python 3 中用 &lt;code&gt;raise X from None&lt;/code&gt;），确保相关的细节被转移到了新的 exception 中（比如把 &lt;code&gt;KeyError&lt;/code&gt; 转换成 &lt;code&gt;AttributeError&lt;/code&gt; 时保留属性名，或在新的 exception 中嵌入原始 exception 的文本内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 python 2 中抛出一个 exception 时，使用 &lt;code&gt;raise ValueError('message')&lt;/code&gt; 而不是以前的形式 &lt;code&gt;raise ValueError, message&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;后面这种格式在 python 3 中是非法的。&lt;/p&gt;
&lt;p&gt;使用括号的格式意味着如果 exception 的参数特别长或者包含格式化字符串时不必使用换行符号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当捕获 exception 时，如果可以尽量加上明确的 exception 名字，而不是写一个光秃秃的 &lt;code&gt;except:&lt;/code&gt; 块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Yes&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;platform&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;specific&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ImportError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;specific&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;一个光秃秃的 &lt;code&gt;except:&lt;/code&gt; 块会捕捉到 &lt;code&gt;SystemExit&lt;/code&gt; 和 &lt;code&gt;KeyboardInterrupt&lt;/code&gt;，导致很难通过 &lt;code&gt;Control-C&lt;/code&gt; 的方式中断一个程序，而且会掩盖其他问题。如果你想捕获程序的所有异常，使用 &lt;code&gt;except Exception:&lt;/code&gt;（光秃秃的 &lt;code&gt;except&lt;/code&gt; 相当于 &lt;code&gt;except BaseException:&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;允许使用使用光秃秃的 except 的两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;exception 处理代码会打印或者记录 log，这样用户至少知道发生了错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码需要做一些清理工作，这种情况下最好使用 &lt;code&gt;raise.try...finally&lt;/code&gt; 使 exception 可以继续向上传递&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当把一个 exception 绑定到一个名字时，优先使用 python2.6 中新加的显式名字绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;exc&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;DataProcessingFailedError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;exc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这个语法只有 python3 才支持，它可以避免和原来基于逗号的语法之间的歧义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当捕捉到操作系统的错误时，优先使用 python3.3 中的 explicit exception hierarchy 而不是 &lt;code&gt;errno&lt;/code&gt; 值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此外，对于所有的 &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;except&lt;/code&gt; 块，&lt;code&gt;try&lt;/code&gt; 语句中只使用必要的最小化代码，这样可以避免 bug 被掩盖掉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# Too broad!&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;collection&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;KeyError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;# Will also catch KeyError raised by handle-value()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;found&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特定代码的局部资源，使用 &lt;code&gt;with&lt;/code&gt; 语句来确保这个资源使用完成后被清理干净，下次还能继续使用。也可以用 &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了获取 / 释放资源，其他时候都应该通过独立的 function 或 method 来调用上下文管理器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="ow"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;后面这个例子没有提供任何信息来指示 &lt;code&gt;--enter--&lt;/code&gt; 和 &lt;code&gt;--exit--&lt;/code&gt; 两个 method 除了在 tansaction 之后关闭连接之外做的其他事情，。在这种情况下，明确指明很重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回语句要保持一致性。要么所有 function 的返回语句都返回一个表达式，要么都不返回。如果有返回语句返回的是表达式，那么不返回值的返回语句应该明确声明 &lt;code&gt;return None&lt;/code&gt;，并且位于 function 的最后一句
（如果能跑到这一句的话）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 string method 而不是 stirng module。&lt;/p&gt;
&lt;p&gt;string mothod 总是速度更快，而且和 unicode string 共享相同的 API，如果要求兼容 python2.0 以前的版本则可以忽略这条规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;''.startswith()&lt;/code&gt; 和 &lt;code&gt;''.endswith()&lt;/code&gt; 而不是 string 切片来检查前缀 / 后缀。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;startwith()&lt;/code&gt; 和 &lt;code&gt;endswith()&lt;/code&gt; 更加清晰，而且不易出错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象类型的比较应该使用 &lt;code&gt;isinstance()&lt;/code&gt; 而不是直接比较类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果检查一个对象是否为 string，记得它有可能是个 unicode string！在 python 2 中，&lt;code&gt;str&lt;/code&gt; 和 &lt;code&gt;unicode&lt;/code&gt; 有相同的基类 &lt;code&gt;basestring&lt;/code&gt;，所以你可以这么做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;basestring&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;注意在 python 3 里面，&lt;code&gt;unicode&lt;/code&gt; 和 &lt;code&gt;basestring&lt;/code&gt; 都不再存在了（只有 &lt;code&gt;str&lt;/code&gt;），并且 bytes 对象不再是 string 的一种，它是整数序列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于序列（stirngs，list，tupels）来说，空序列的值是 false：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写 string 时不要依赖结尾的空格，这种空格在视觉上难以区分，而且一些编辑器（比如 reindent.py）会删掉他们。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;==&lt;/code&gt; 来比较 boolean 值和 &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;更糟糕的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;greeting&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;try...finally&lt;/code&gt; 的最后一个分支中使用流程控制语句 &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;break&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;，而且这个语句会跳转到外面，不鼓励这种方式。因为这种语句会隐式地取消所有的正在通过最后一个分支传播的 exception：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_26"&gt;函数注解&lt;/h3&gt;
&lt;p&gt;随着 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 的引入，下面的函数注解规则有些变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了前向兼容，python 3 中的函数注解应该优先使用 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 的语法（在之前的章节中有一些注解的推荐规则）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不再鼓励使用本文以前推荐的实验性注释风格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，除了标准库，鼓励使用 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 中的实验性规则。比如，使用 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 中的 style 为一个大型第三方库 / 应用添加注解，检查添加这些注解的容易程度，观察这些注解的出现是否提高了可读性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python 的标准库应该保守地使用这些注解，但是新代码和大型的重构可以使用这种注解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果代码想用另外一种方式使用函数注解，推荐在文件顶部添加这样一条注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;ignore&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这会告诉 type checker 忽略所有的注解（在 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 中可以找到更加详细的关于细颗粒度的关闭 type checker 的报错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 linter 类似，type checker 是独立可选的工具，python 解释器默认不会报出任何 type checker 的内容，而且不会基于注释改变它们的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户不想使用 type checker 时可以忽略它们。但是，第三方库的用户可能希望在这些库上运行 type checker，为此，&lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt; 推荐使用 &lt;code&gt;stub&lt;/code&gt; 文件：相比于 .py 文件，type checker 优先读取 .pyi 文件。stub 文件可以和库一起发布，也可以通过单独的 typeshed repo 发布（通过库的作者许可）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于需要向后兼容的代码，可以以注释的方式添加类型注解，相关内容见 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_27"&gt;变量注解&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0526/"&gt;PEP526&lt;/a&gt; 介绍了变量注解，对于变量的注解风格和前面描述的函数注解类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 module 级别的变量，class 和 instance variables，局部变量，应该在冒号后面加个空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冒号前面不应该有空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果赋值语句有右侧内容，那么等号两边的空格数应该相等&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# Correct:&lt;/span&gt;

&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;coords&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Tuple&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;unknown&amp;gt;&amp;#39;&lt;/span&gt;

&lt;span class="c1"&gt;# Wrong:&lt;/span&gt;

&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;  &lt;span class="c1"&gt;# No space after colon&lt;/span&gt;
&lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;  &lt;span class="c1"&gt;# Space before colon&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="c1"&gt;# No spaces around equality sign&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然 python 3 可以使用 &lt;a href="https://www.python.org/dev/peps/pep-0526/"&gt;PEP526&lt;/a&gt;，但是对于所有版本的 python，首先以 stub 文件的语法优先选择变量注解。（细节见 &lt;a href="https://www.python.org/dev/peps/pep-0484"&gt;PEP484&lt;/a&gt;） &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_28"&gt;翻译参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.python.org/dev/peps/pep-0008/"&gt;PEP8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/ratsniper/article/details/78954852"&gt;Python PEP8 编码规范中文版&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_29"&gt;附&lt;/h2&gt;
&lt;p&gt;Google 推出过开源项目的 coding style 规范，包含了常见编程语言，如 &lt;code&gt;C++&lt;/code&gt;,  &lt;code&gt;java&lt;/code&gt;, &lt;code&gt;Python&lt;/code&gt;, &lt;code&gt;Shell&lt;/code&gt; 等。因为已经有国内程序员凭热情创建和维护的中文版本，所以就不再翻译了。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/google/styleguide"&gt;Google Style Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://zh-google-styleguide.readthedocs.io/en/latest/"&gt;Google 开源项目风格指南 ( 中文版 )&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>Python 学习笔记 #0 —— 新的开始</title><link href="https://qian-gu.github.io/posts/cs/python-notes-0-summary.html" rel="alternate"></link><published>2020-04-05T23:56:00+08:00</published><updated>2020-04-05T23:56:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2020-04-05:/posts/cs/python-notes-0-summary.html</id><summary type="html">&lt;p&gt;千里之行，适于足下&lt;/p&gt;</summary><content type="html">&lt;h2 id="background"&gt;Background&lt;/h2&gt;
&lt;p&gt;工作太忙博客荒废了 4 年多时间，现在重新拾起，利用周末时间充电学习希望能坚持下去，立个 flag：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;争取以后每个周末能学习一点新内容，总结记录下来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写这个学习笔记的原因是我对很多 Python 概念和用法一知半解，所以想重新学习 Python 的知识，顺便记录下来方便以后温故而知新。&lt;/p&gt;
&lt;h2 id="road-map"&gt;Road Map&lt;/h2&gt;
&lt;p&gt;收集了一些学习资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/"&gt;Python doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/"&gt;PEP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://book.douban.com/subject/3112503/"&gt;Python 核心编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/yasoob/intermediatePython"&gt;Intermediate Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://book.douban.com/subject/26709315//"&gt;Effective Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://book.douban.com/subject/26381341/"&gt;Python Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以循序渐进一本一本书地学习，网上有很多从入门到高阶的书籍列表，比如大名鼎鼎的 &lt;a href="https://docs.python-guide.org/"&gt;The Hitchhiker’s Guide to Python!&lt;/a&gt;。&lt;/p&gt;</content><category term="CS"></category><category term="PEP"></category><category term="python"></category></entry><entry><title>FIFO 设计笔记</title><link href="https://qian-gu.github.io/posts/ic/fifo-design-notes.html" rel="alternate"></link><published>2015-10-02T22:13:00+08:00</published><updated>2015-10-02T22:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-10-02:/posts/ic/fifo-design-notes.html</id><summary type="html">&lt;p&gt;总结 FIFO 的注意事项&lt;/p&gt;</summary><content type="html">&lt;p&gt;FIFO 的重要性就不用再重复了，在笔试面试的时候也常常被问到，总结一下设计 FIFO 需要注意的问题。&lt;/p&gt;
&lt;p&gt;FIFO 可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Sync FIFO: write 和 read 使用同一个时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Async FIFO: write 和 read 分别使用两个时钟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计 FIFO 的时候，通常需要考虑的问题有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FIFO 的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO 空满的判断&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sync-fifo"&gt;Sync FIFO&lt;/h2&gt;
&lt;p&gt;Sync FIFO 的框图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync fifo" src="/images/fifo-design-notes/sync-fifo.png"&gt;&lt;/p&gt;
&lt;p&gt;因为同步 FIFO 的读写速率是相同的，所以 FIFO 的大小设置不必考虑读写速率差这个因素，要简单很多。&lt;/p&gt;
&lt;p&gt;在 FIFO 内部，一般使用 dual port RAM 存储数据。双端口 RAM 有两套独立的读写地址，读地址和写地址分别由读指针和写指针来产生：写指针指向下一个数据被写入的地址，读指针指向下一个被读出的数据的地址，通过判断读写指针的相对大小，就可以得到 FIFO 的状态（full / empty）。&lt;/p&gt;
&lt;p&gt;还有另外一种方法来产生 full / empty 信号：FIFO 内部维护一个计数器，每次写入一个数据 cnt++，每次读出一个数据 cnt--。这种方法产生 full / empty 很简单：当 cnt == 0，表示 FIFO empty；当 cnt == max，表示 FIFO full。虽然这种方法产生 full / empty 很简单，但是需要额外的计数器，而且计数器的位宽随着 FIFO 的深度增加，不仅占用的资源更多，而且会降低 FIFO 最终可以达到的速度。&lt;/p&gt;
&lt;h2 id="async-fifo"&gt;Async FIFO&lt;/h2&gt;
&lt;p&gt;一般异步 FIFO 的读写速率不同，如果写速度 &amp;gt; 读速度，则当数据量超过一定长度时，会出现溢出的情况，为了防止这种情况，可以采用两种措施：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;预先知道写速率和模式（burst / nonburst），最小的读速率，根据这些条件设置 FIFO 的深度&lt;/p&gt;
&lt;p&gt;通常发送端的数据都是突发的形式，FIFO 的深度至少要大于等于突发数据的最大长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;握手机制（full / empty）&lt;/p&gt;
&lt;p&gt;很多情况下，突发数据的长度和分布是预先不知道的，此时则无法确保 FIFO 的深度足够大，因此需要握手机制来告诉发送端已经没有多余的空地址保存数据 or 告诉接收端已经内部已经没有剩余的可以读取的数据。通常使用如下的 FSM 来实现：&lt;/p&gt;
&lt;p&gt;发送端，写数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="wr fsm" src="/images/fifo-design-notes/wr-fsm.png"&gt;&lt;/p&gt;
&lt;p&gt;接收端，读数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rd fsm" src="/images/fifo-design-notes/rd-fsm.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="gray-code"&gt;Gray Code&lt;/h3&gt;
&lt;p&gt;在异步 FIFO 中，因为一些内部的信号要从写 / 读时钟域传递到读 / 写时钟域，所以必须要解决异步信号同步的问题，而且有的信号不止 1 bit，如果使用 “ 同步桥 ”，则因为各个 bit 的同步时延不一定（1~2T），所以不能用同步桥。&lt;/p&gt;
&lt;p&gt;这个问题可以使用 gray code 解决：gray code 是循环码，每次只有 1 bit 变化，这样就避免了多 bits 变化的数据同步问题。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync" src="/images/fifo-design-notes/sync.png"&gt;&lt;/p&gt;
&lt;p&gt;gray code 与 binary code 的相互想换见另&lt;a href=""&gt;外一篇 blog&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="wr-ptr-rd-ptr-sync-lag"&gt;wr-ptr / rd-ptr Sync Lag&lt;/h3&gt;
&lt;p&gt;异步 FIFO 还有个问题是：地址信号跨时钟域时，可能会有 1T 的时延，这个多余的时延并不会导致 full /empty 错误置位，引起错误的 overf：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果地址信号传递到读时钟域时延时了 1T，此时接收端并不知道数据已经写入了 FIFO，仍然认为 FIFO 是空的，这种情况只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 underflow；&lt;/p&gt;
&lt;p&gt;如下图，先写满 FIFO，然后开始读：在 t6 时 FIFO 读空，empty = 1，在 t7 时，写入了一个新数据，此时 FIFO 内已经有有效数据了，但是 wr-ptr 同步到读时钟域要花费 2T，所以在 t9 时 empty = 0。有两个时钟周期（t7, t8） rd 被阻塞了，但是并不影响 FIFO 正常工作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="empty" src="/images/fifo-design-notes/empty.png"&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="empty timing" src="/images/fifo-design-notes/empty-timing.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果地址信号传递到写时钟域时延是了 1T，此时发送端并不知道 FIFO 已经有空余地址了，仍然认为 FIFO 是满的，这种情况也是只会对 FIFO 的吞吐率 throughput 有影响，但是不会导致 overfl；&lt;/p&gt;
&lt;p&gt;如下图，先写满 FIFO，然后开始读：在 t5 时，full = 1，在 t6 时，读出了一个数据，此时 FIFO 已经有空余地址了，但是 rd-ptr 同步到写时钟域要花费 2T，所以在 t8 时 full = 0。有两个时钟周期（t6, t7） wr 被阻塞了，但是并不影响 FIFO 正常工作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="full" src="/images/fifo-design-notes/full.png"&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="full timing" src="/images/fifo-design-notes/full-timing.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="full-empty-generation"&gt;Full / Empty Generation&lt;/h3&gt;
&lt;p&gt;因为 wr-ptr 和 rd-ptr 相同时，FIFO 既可能是 full，也有可能是 empt，所以需要额外的 1 bit 来区别这两种情况：&lt;/p&gt;
&lt;p&gt;假设 FIFO 的深度是 8，则地址为 3 bits，初始时 wr-ptr 和 rd-ptr 都是 &lt;code&gt;0000&lt;/code&gt;，FIFO 此时是 empty：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当连续 8 个数据写入到 FIFO full，wr-ptr = &lt;code&gt;1000&lt;/code&gt;，而 rd-ptr = &lt;code&gt;0000&lt;/code&gt;，&lt;strong&gt;MSB 不同，剩余位相同&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当连续 8 次读取数据 FIFO empty，rd-ptr = wr-ptr = &lt;code&gt;1000&lt;/code&gt;，&lt;strong&gt;所有 bits 都相等&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;借助这多余的 1 bit，可以区分出是 wr-ptr 太快，将 rd-ptr 套圈了（wr-ptr = &lt;code&gt;1000&lt;/code&gt;，rd-ptr = &lt;code&gt;0000&lt;/code&gt;， 即 full），还是 rd-ptr 更快，追上了 wr-ptr（rd-ptr = wr-ptr = &lt;code&gt;1000&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="full empty gen" src="/images/fifo-design-notes/full-empty-gen.png"&gt;&lt;/p&gt;
&lt;p&gt;这种 wr-ptr / rd-ptr 用 gray code 保存，比较 /+1 用 binary 保存的方式，使得 design / debug 变得很简单，但是需要的资源比较多。如果全部使用 gray code，虽然可以降低资源占用，但是需要其他逻辑。&lt;/p&gt;
&lt;h3 id="dual-clock-fifo-design"&gt;Dual Clock FIFO Design&lt;/h3&gt;
&lt;p&gt;下图是使用 Dual port RAM 的异步 FIFO 框图，其中 wr-ptr 和 rd-ptr 直接使用 gray code，节省了 gray code 和 binary code 之间的转换逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img alt="dual clock fifo" src="/images/fifo-design-notes/dual-port-fifo.png"&gt;&lt;/p&gt;
&lt;p&gt;和前面的逻辑类似，使用多 1 bit 来辅助区分 full / empt，不过因为改成用 gray code 来比较，所以稍有不同，下图显示了 FIFO 从 empty 到 full 再到 empty 的过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="full empty condition" src="/images/fifo-design-notes/full-empty-condition.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FIFO empty&lt;/p&gt;
&lt;p&gt;当 wr-ptr = rd-ptr 时 FIFO empty&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO full&lt;/p&gt;
&lt;p&gt;如上图，FIFO 初始状态为 empty，然后连续写入 8 个数据，再读出 8 个数据，此时 wr-ptr = rd-ptr = 7，FIFO 又变为 empty。此时如果再写入一个数据，wr-ptr = 8，rd-ptr = 7，如果仍然使用前面介绍的方法（MSB 不同，剩余位相同 )，则会得出 FIFO full 的错误结论，实际上 FIFO 并没有满。&lt;/p&gt;
&lt;p&gt;仔细观察 gray code 的对称性，就可以知道，当 full 时（wr-ptr 将 rd-ptr 套圈时），MSB 不同，wr-ptr 的 2nd MSB 要先翻转，才和 rd-ptr 相同。所以，当下面 3 个条件都满足时，FIFO full：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;wr-ptr 和 rd-ptr 的 MSB 不相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wr-ptr 的 2nd MSB 翻转后和 rd-ptr 的 2nd MSB 相等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;剩余 bits 全部相等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;总结 FIFO 的设计，只要注意 FIFO 通过 wr-ptr 和 rd-ptr 得到 full / empty，而且使用 gray code 来跨时钟域，基本上就没问题了 :-D&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379/ref=sr-1-1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1432020884&amp;amp;sr=1-1&amp;amp;keywords=advanced+fpga+design"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="FIFO"></category></entry><entry><title>数字信号处理中的各种频率</title><link href="https://qian-gu.github.io/posts/telecom/summary-of-frequency-in-digital-signal-processing.html" rel="alternate"></link><published>2015-08-27T22:06:00+08:00</published><updated>2015-08-27T22:06:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-08-27:/posts/telecom/summary-of-frequency-in-digital-signal-processing.html</id><summary type="html">&lt;p&gt;总结信号处理中的各种角频率&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近实习的时候，发现自己的 DSP 基本功还是不够扎实，关于模拟 / 数字角频率，频率，采样速率等一些概念理解的都不太深刻，愧对老师和这么多年的学习，Google 到一些讲解的比较清楚的 blog，备忘（抄袭）过来，温故而知新。&lt;/p&gt;
&lt;h2 id="unit-circle-sincos"&gt;unit circle &amp;amp; sin(cos)&lt;/h2&gt;
&lt;p&gt;首先从最基本的三角函数的定义开始：&lt;/p&gt;
&lt;p&gt;三角函数的定义方式有很多种，我觉得基于单位圆的定义是最形象，对之后理解各种角频率的物理 / 数学含义最有帮助。&lt;/p&gt;
&lt;p&gt;我们应该是在初中的时候第一次接触到三角函数，那时候三角函数的定义是直接给个三角形，然后直接定义 sin(cos) 为哪条边比哪条边的值，然后给出 sin(cos)  的波形如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sine &amp;amp; cosine" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/71/Sine-cosine-one-period.svg/600px-Sine-cosine-one-period.svg.png"&gt;
"Sine cosine one period" by Geek3 - Own work. Licensed under CC BY 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Sine-cosine-one-period.svg#/media/File:Sine-cosine-one-period.svg&lt;/p&gt;
&lt;p&gt;当我们将这个三角形和单位圆联系在一起的时候，sin(cos) 的几何意义就很明显了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="enter image description here" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9d/Circle-trig6.svg/338px-Circle-trig6.svg.png"&gt;&lt;/p&gt;
&lt;p&gt;"Circle-trig6" by This is a vector graphic version of Image:Circle-trig6.png by user:Tttrung which was licensed under the GFDL. Based on en:Image:Circle-trig6.png, which was donated to Wikipedia under GFDL by Steven G. Johnson. - This is a vector graphic version of Image:Circle-trig6.png by user:Tttrung which was licensed under the GFDL. ; Based on en:Image:Circle-trig6.png, which was donated to Wikipedia under GFDL by Steven G. Johnson.. Licensed under CC BY-SA 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Circle-trig6.svg#/media/File:Circle-trig6.svg&lt;/p&gt;
&lt;p&gt;图中红色的线段长度就是 sin 的值，蓝色的线段长度就是 cos 的值，如果我们假设坐标系的原点和单位圆重合，脑补一下下面的场景：有个小球（只能）沿着单位圆的圆周做运动。这时候，我们就会发现一个事实：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sin(t) 是小球 t 时刻在 y 轴上的投影，cos(t) 是小球 t 时刻在 x 轴上的投影。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进一步，当小球的运动速率是匀速率的时候，就有了上面提到的波形，更加形象的图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="enter image description here" src="https://upload.wikimedia.org/wikipedia/commons/3/3b/Circle-cos-sin.gif"&gt;&lt;/p&gt;
&lt;p&gt;"Circle cos sin" by LucasVB - Own work. Licensed under Public Domain via Commons - https://commons.wikimedia.org/wiki/File:Circle-cos-sin.gif#/media/File:Circle-cos-sin.gif&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 关于投影，wiki 上有个解释欧拉公式的图特别好：&lt;/p&gt;
&lt;p&gt;"Sine and Cosine fundamental relationship to Circle (and Helix)" by Tdadamemd - Own work by uploader (.gif frames created in Powerpoint). Licensed under CC BY-SA 3.0 via Commons - https://commons.wikimedia.org/wiki/File:Sine-and-Cosine-fundamental-relationship-to-Circle-(and-Helix).gif#/media/File:Sine-and-Cosine-fundamental-relationship-to-Circle-(and-Helix).gif&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有了上面简单的背景，就可以开始逐个讨论信号处理中的概念了。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;Ω&lt;/h2&gt;
&lt;p&gt;我们已经知道小球在圆周上做匀速率的圆周运动时，它在两个坐标轴上的投影就分别是 sin(cos)，如果我们想进一步描述小球的运动速率的快慢呢？&lt;/p&gt;
&lt;p&gt;假设小球完整转一圈所花费的时间为 T，转动的角度为 2π，则我们可以定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模拟角频率&lt;/strong&gt; &lt;code&gt;Ω = 2π/T&lt;/code&gt;，单位是 rad / s&lt;/p&gt;
&lt;p&gt;来描述小球的转动速率的快慢。&lt;/p&gt;
&lt;p&gt;当 t = 2π 时，y = sin(Ω&lt;em&gt;2π)，这时候可以看出 Ω 的物理含义：&lt;/em&gt;&lt;em&gt;在 2π 的时间内，小球所完成的圈数。&lt;/em&gt;*&lt;/p&gt;
&lt;p&gt;下面的 Matlab 小程序演示了 2π 时间内 Ω 和周期的对应关系：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;(:,&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;OMEGA=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;num2str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OMEGA&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;t / s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;amp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;y = sin(OMEGA*t)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="OMEGA" src="/images/summary-of-frequency-in-digital-signal-processing/OMEGA.jpg"&gt;&lt;/p&gt;
&lt;h2 id="f"&gt;f&lt;/h2&gt;
&lt;p&gt;小球在二维平面上的圆周运动投影到一维的坐标轴 x(y) 轴上看，则是左右（上下）振动。和 Ω 类似，我们也可以定义一个物理量来描述这种振动的快慢：&lt;/p&gt;
&lt;p&gt;小球完成一次完整的圆周运动所花费的时间为 T，也就是完成一次振动花费了 T 时间，我们定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;频率&lt;/strong&gt; &lt;code&gt;f = 1 / T&lt;/code&gt;，单位是 Hz&lt;/p&gt;
&lt;p&gt;来描述振动的快慢。由前面 Ω 的定义式可知，&lt;code&gt;Ω = 2π * f&lt;/code&gt;，有 y = sin(2π * f * t)。&lt;/p&gt;
&lt;p&gt;当 t = 1s 时，y = sin(2π * f)，这时候可以看出 f 的物理意义：&lt;strong&gt;在 1s 的时间内，小球所完成的振动次数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的 Matlab 小程序演示了 1s 时间内 f 和振动周期的对应关系：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;(:,&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;num2str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;t / s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;amp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;y = sin(2*pi*f*t)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="f" src="/images/summary-of-frequency-in-digital-signal-processing/f.jpg"&gt;&lt;/p&gt;
&lt;h2 id="w"&gt;w&lt;/h2&gt;
&lt;p&gt;计算机的世界是离散的，所以当连续信号经过采样、量化得到离散信号后：&lt;/p&gt;
&lt;p&gt;y = sin(Ω&lt;em&gt;t) = sin(Ω&lt;/em&gt;n&lt;em&gt;Ts) = sin(Ω&lt;/em&gt;Ts&lt;em&gt;n) = sin(w&lt;/em&gt;n)&lt;/p&gt;
&lt;p&gt;从数学上我们就可以得到：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字角频率&lt;/strong&gt; &lt;code&gt;w = Ω*Ts = Ω / Fs&lt;/code&gt;，单位是 rad&lt;/p&gt;
&lt;p&gt;可以看到，w 是用采样频率 Fs 对 Ω 进行归一化得到的，所以 w 准确地应该叫做归一化数字角频率。&lt;/p&gt;
&lt;p&gt;连接模拟和数字的桥梁就是采样频率 Fs，由计算过程可以知道，w 相同的两个信号，它们的 Ω 不一定相同。因为丢失了 Fs 信息，所以单独讨论 w 是没有意义的。&lt;/p&gt;
&lt;p&gt;虽然单独讨论 w 是没有意义的，但是这不代表 w 没有物理意义，当小球的振动频率为 f 时，每秒在圆周上转过的角度为 Ω = 2π * f，而采样频率为 Fs 就是说每秒钟对小球进行 Fs 次采样（拍照），显然有 Fs 个样值（照片）。这些样值（照片）是均匀分布的，所以每两个样值点之间的弧度为 2π * f / Fs = w，这也就是 w 的物理含义：&lt;strong&gt;相邻两个样值点之间的弧度数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;================================== summary ====================================&lt;/p&gt;
&lt;p&gt;这几个频率之间是线性关系，可以得到下面的对应关系：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;Item&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Min&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Mid&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Max&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;n&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;(N-1)/2&lt;/td&gt;
&lt;td style="text-align: center;"&gt;N&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Ω&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Ωs/2&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Ωs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;f&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Fs/2&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Fs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;w&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;π&lt;/td&gt;
&lt;td style="text-align: center;"&gt;2*π&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由频谱的搬移过程可以知道，w 从 π 到 2π 是负频率搬移的结果，所以通常分析的时候 w 的范围为 [-π, π)，如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left;"&gt;Item&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Min&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Mid&lt;/th&gt;
&lt;th style="text-align: center;"&gt;Max&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;Ω&lt;/td&gt;
&lt;td style="text-align: center;"&gt;-Ωs/2&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Ωs/2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;f&lt;/td&gt;
&lt;td style="text-align: center;"&gt;-Fs/2&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;Fs/2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left;"&gt;w&lt;/td&gt;
&lt;td style="text-align: center;"&gt;-π&lt;/td&gt;
&lt;td style="text-align: center;"&gt;0&lt;/td&gt;
&lt;td style="text-align: center;"&gt;π&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Trigonometric-functions"&gt;Trigonometric functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://anony3721.blog.163.com/blog/static/51197420111129503233/"&gt;阿英讲频率 f，角频率 Ω 和数字频率 w 的物理含义 -- 附 MATLAB 仿真&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zhuanlan.zhihu.com/wille/19763358"&gt;傅里叶分析之掐死教程（完整版）更新于 2014.06.06&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="digital procesing"></category><category term="frequency"></category></entry><entry><title>低功耗设计</title><link href="https://qian-gu.github.io/posts/ic/low-power-design.html" rel="alternate"></link><published>2015-06-18T21:42:00+08:00</published><updated>2015-06-18T21:42:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-06-18:/posts/ic/low-power-design.html</id><summary type="html"></summary><content type="html">&lt;p&gt;在一些情况下，是不需要考虑低功耗设计的，但是更多的情况下，低功耗是必须考虑的，总结一下 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt; 中介绍的低功耗设计的方法。&lt;/p&gt;
&lt;h2 id="sources-of-power-consumption"&gt;Sources of Power Consumption&lt;/h2&gt;
&lt;p&gt;首先，分析功耗的来源。&lt;/p&gt;
&lt;p&gt;功耗可以分为 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Inrush&lt;/p&gt;
&lt;p&gt;浪涌电流（Inrush current）也叫做启动电流（start-up current）。它指的是设备上电时产生的瞬间最大电流，这个值和设备有关。基于 SRAM 的 FPGA 有很大的浪涌电流，因为它需要从外部 ROM 中下载数据来配置内部逻辑资源，反之，基于 anti-fuse 的 FPGA 因为不需要上电配置，所以也就不存在浪涌电流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Static&lt;/p&gt;
&lt;p&gt;待机电流（Standby current）是指待机状态下的电流，由待机电流产生的功耗称为待机功耗（standby power），也就是静态功耗（static power）。静态功耗和浪涌功耗类似，也和器件的电气特性密切相关。（静态功耗包含了晶体管的漏电流导致的功耗）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamic&lt;/p&gt;
&lt;p&gt;动态功耗（Dynamic power）是门电路的逻辑值切换时产生的功耗。动态功耗可以从一个定义式中计算出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，ASIC 的总功耗定义为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Ptotal = Pdynamic + Pstatic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，动态功耗占了主要部分，典型应用中，动态功耗占到总功耗的 80% 。&lt;/p&gt;
&lt;h2 id="power-reduction-power-reduction"&gt;Power Reduction Power Reduction&lt;/h2&gt;
&lt;p&gt;可以从系统的不同层次来降低功耗，下图展示了不同级别的不同技术，虽然可以在各个级别进行，但是在抽象层次越高的级别，得到的效果越有效，即在系统层（system level）和体系结构层（architecture level）进行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="level" src="/images/low-power-design/level.png"&gt;&lt;/p&gt;
&lt;p&gt;下面一张表展示了各个级别对功耗降低程度的影响：&lt;/p&gt;
&lt;p&gt;&lt;img alt="opportunities" src="/images/low-power-design/opportunities.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下面分别从不同层次总结。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="system-level"&gt;System Level&lt;/h2&gt;
&lt;h3 id="soc-approach"&gt;SoC Approach&lt;/h3&gt;
&lt;p&gt;对于纳米级高端芯片，I/O 使用比芯片内核更高的电压，占到了总功耗的 50% 以上。如果有很多芯片的话，芯片之间的连线会消耗大量的功耗，所以就提出了 SoC，以缩减面积，降低成本。&lt;/p&gt;
&lt;h3 id="hwsw-partitioning"&gt;HW/SW Partitioning&lt;/h3&gt;
&lt;p&gt;相比于硬件，使用软件高级语言编程可以很方便的实现功能。但是，一些功能可以使用硬件来实现，来降低功耗。&lt;/p&gt;
&lt;p&gt;比如通信算法中有很多递归运算，实现递归的软件代码可能很少，但是这段只占代码量的 10% 的代码却花费了 90% 的执行时间，如果将这段代码使用硬件实现，就能够节约大量能源，显著降低功耗。&lt;/p&gt;
&lt;p&gt;常规的软硬件划分方法如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Partitioning" src="/images/low-power-design/partitioning.png"&gt;&lt;/p&gt;
&lt;p&gt;典型的设计流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Specifications&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partitioning&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Synthesis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Integration&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Co-Simulation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verification&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先，设计者根据规范和自身经验对系统性能做出推测，根据推测来决定系统哪部分用硬件实现，哪部分用软件实现。&lt;/p&gt;
&lt;p&gt;然后，对软硬件进行描述，硬件用 Verilog/VHDL，软件使用 C 。&lt;/p&gt;
&lt;p&gt;下一步对软硬件进行协同仿真，验证设计功能。如果不满足要求，则从系统划分开始重新再来。&lt;/p&gt;
&lt;h3 id="low-power-software"&gt;Low Power Software&lt;/h3&gt;
&lt;p&gt;软件设计部分也可以像硬件设计一样，在设计时就进行一些优化，得到更加绿色、高效的系统。&lt;/p&gt;
&lt;p&gt;比如，将下面的两个循环合并为一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// code1&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// code2&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为减少了循环计数器（初始化、递增、比较），所以循环指令数目就减少了。&lt;/p&gt;
&lt;h3 id="choice-of-processor"&gt;Choice of Processor&lt;/h3&gt;
&lt;p&gt;选择处理器会对整体功耗产生明显影响。（高级话题，以后再补）&lt;/p&gt;
&lt;h2 id="architecture-level-power-reduction"&gt;Architecture Level Power Reduction&lt;/h2&gt;
&lt;h3 id="advanced-clock-gating"&gt;Advanced Clock Gating&lt;/h3&gt;
&lt;p&gt;同步设计中，时钟占据了整个动态功耗的绝大部分，在许多情况下都可以通过门控时钟将绝大多数不使用的电路关闭掉。&lt;/p&gt;
&lt;p&gt;门控时钟有如下的两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组合门控时钟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="combinational" src="/images/low-power-design/combinational.png"&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时序门控时钟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="sequential" src="/images/low-power-design/sequential.png"&gt;&lt;/p&gt;
&lt;h3 id="dynamic-voltage-and-frequency-scaling-dvfs"&gt;Dynamic Voltage and Frequency Scaling (DVFS)&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="cache-based-architecture"&gt;Cache Based Architecture&lt;/h3&gt;
&lt;p&gt;缓存一方面可以缓解内存和 CPU 之间速度的差异，还可以用来减少访问内存的次数，把需要频繁访问的数据保存在缓存中，可以使得计算能耗大量下降。&lt;/p&gt;
&lt;h3 id="log-fft-architecture"&gt;Log FFT Architecture&lt;/h3&gt;
&lt;p&gt;对于大规模运算的应用，使用对数系统（ logarithmic number system，LNS）比线性系统更好。LNS 在降低平均位元活跃度的同时用加法和奖罚实现乘除运算，使其效率比线性系统更高。&lt;/p&gt;
&lt;h3 id="asynchronous-clockless-design"&gt;Asynchronous (Clockless) Design&lt;/h3&gt;
&lt;p&gt;同步设计的时钟信号带来的问题很多，同时产生的功耗也很大，所以移除时钟是一个很有诱惑力的想法，这就是异步设计的基本意图，不过异步设计不是简单的移除时钟，仍然需要对电路进行某种控制。异步电路本质上进行自我控制，因此也成为自定时电路。&lt;/p&gt;
&lt;h3 id="power-gating"&gt;Power Gating&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="multi-threshold-voltage"&gt;Multi-threshold Voltage&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="multi-supply-voltage"&gt;Multi-supply Voltage&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h3 id="gate-memory-power"&gt;Gate Memory Power&lt;/h3&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h2 id="register-transfer-level-rtl-power-reduction"&gt;Register Transfer Level (RTL) Power Reduction&lt;/h2&gt;
&lt;p&gt;在大规模 ASIC 中，在 RTL 级完成时，至少 80% 的功耗已经确定了，后端流程无法解决所有的功耗问题，后端无法解决微架构、RTL 代码风格对动态和静态功耗的影响，所以在 RTL 阶段就要将功耗相关的问题一起解决。&lt;/p&gt;
&lt;h3 id="state-machine-encoding-and-decomposition"&gt;State Machine Encoding and Decomposition&lt;/h3&gt;
&lt;p&gt;在各种状态机编码类型中，格雷码是最符合低功耗设计的。因为格雷码相邻码之间只有一位翻转，所以消耗的能量最少。（格雷码是最优的，有个 条件就是状态机是按顺序跳转的，如果状态跳转的次序是不定的，那么格雷码的优势就不存在了）&lt;/p&gt;
&lt;p&gt;即使因为一些原因，没有使用格雷码，仍然可以通过降低翻转较多的状态的切换频率，来降低功耗。&lt;/p&gt;
&lt;p&gt;还有一种方法是将 FSM 进行分解为两个，两个小的 FSM 组合起来等效于原始的 FSM。当一个的 FSM 激活时，可以关闭另外一个 FSM，这样绝大多数时间内只需要给较小且更有效率的子 FSM 提供时钟，从而降低了功耗。&lt;/p&gt;
&lt;h3 id="binary-number-representation"&gt;Binary Number Representation&lt;/h3&gt;
&lt;p&gt;虽然在大多数应用中，补码比原码更方便，但是有些特殊应用中，在切换过程中原码更有优势。比如 0 和 -1 分别用原码和补码表示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Signed Magnitude&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00000000&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10000001&lt;/span&gt;

&lt;span class="c1"&gt;// 2&amp;#39;s compliment&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;00000000&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;11111111&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当从 0 变为 1 时，原码只需要变化两位，而补码所有位都会变化。&lt;/p&gt;
&lt;h3 id="basic-gated-clock"&gt;Basic Gated Clock&lt;/h3&gt;
&lt;p&gt;门控时钟在 Architecture 部分已经说过了，这里从 RTL 的角度再重复一下。RTL 的代码风格会影响到最终的实现结果，所以应该在编写 RTL 的时候需要特别注意。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bad&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b0;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;load&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;good&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ow"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b0;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;load&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="one-hot-encoded-multiplexer"&gt;One Hot Encoded Multiplexer&lt;/h3&gt;
&lt;p&gt;Mux 的编码方案也可以采用独热码的方式，从而减少开关切换的数目，降低功耗。&lt;/p&gt;
&lt;h3 id="removing-redundant-transactions"&gt;Removing Redundant Transactions&lt;/h3&gt;
&lt;p&gt;有时候，一些没有意义的数据切换去掉，从而降低功耗。比如前级的逻辑产生一些数据，但是在后级逻辑中没有使用，这时候就可以修改设计，在前面一级就关闭，在需要数据的时候，让真正生成数据的电路工作。&lt;/p&gt;
&lt;h3 id="resource-sharing"&gt;Resource Sharing&lt;/h3&gt;
&lt;p&gt;如果有一些相同的操作，那么可以使用资源共享的方法，避免运算逻辑重复出现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// bad example&lt;/span&gt;
&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SEL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b000&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b001&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b010&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b011&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;!&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b101&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b110&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b111&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="c1"&gt;// good example&lt;/span&gt;
&lt;span class="n"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;equal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SEL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b000&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b001&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b010&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;equal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b011&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;!&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;equal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;equal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b101&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;!&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b110&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;!&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;equal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;!&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b111&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cmp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="using-ripple-counters-for-low-power"&gt;Using Ripple Counters for Low Power&lt;/h3&gt;
&lt;p&gt;行波计数器属于异步设计，会给时序分析，电路的可靠性带来很多问题。所以一般要避免使用的。不过在一些低速的应用中（比如数码管显示），仍然可以使用行波计数器来降低功耗。&lt;/p&gt;
&lt;h3 id="bus-inversion"&gt;Bus Inversion&lt;/h3&gt;
&lt;p&gt;当总线上的当前数据和下一个数据之间的汉明距离大于 N/2 时（N 是总线宽度），就将下一个数据反向再传输。这样做可以降低总线上出现的转换次数，从而降低功耗。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bus" src="/images/low-power-design/bus-trans.png"&gt;&lt;/p&gt;
&lt;h2 id="transistor-level-power-reduction"&gt;Transistor Level Power Reduction&lt;/h2&gt;
&lt;p&gt;寄存器级别的技术基本属于后端 &amp;amp; 微电子科学了，就不再总结了。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category></entry><entry><title>流水线 pipeline 的艺术</title><link href="https://qian-gu.github.io/posts/ic/the-art-of-pipelining.html" rel="alternate"></link><published>2015-05-19T00:00:00+08:00</published><updated>2015-05-19T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-05-19:/posts/ic/the-art-of-pipelining.html</id><summary type="html">&lt;p&gt;总结流水线设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;PC 世界永恒不变的信条就是提高性能，其中一个方法就是提高系统的时钟频率。&lt;/p&gt;
&lt;p&gt;在另外一篇 blog &lt;a href="http://guqian110.github.io/pages/2015/03/18/static-timing-analysis-1-basic.html"&gt;静态时序分析 STA&lt;/a&gt; 中已经总结过了，限制系统最大工作频率的因素有很多，设计者能够控制的是 DFF 之间的组合逻辑的时延 Tcomb，降低最大时延路径（关键路径，critical path）的时延 Tcomb，就可以提高系统的工作频率。&lt;/p&gt;
&lt;p&gt;如何降低呢？方法就是流水线（pipeline）。&lt;/p&gt;
&lt;h2 id="pipeline-intro"&gt;Pipeline Intro&lt;/h2&gt;
&lt;p&gt;所谓流水线（pipeline）设计，应该是从汽车工业中的 流水生产线 借鉴过来的说法吧。&lt;/p&gt;
&lt;p&gt;在汽车生产的时候，假设分为 5 个阶段，每个阶段都需要 1 个工人花费 1 小时完成，因为后续的阶段必须等前面阶段完成后才能进行，所以总共需要 5 个小时才能完成一辆汽车。但是采用流水线方式，在进行后续阶段时，前面的阶段可以进行新的工作，那么每个小时都可以生产出一辆汽车了，生产效率提高了 5 倍。&lt;/p&gt;
&lt;p&gt;可以看到，流水线之所以可以大大提高效率的原因在于：传统的方式，某个阶段进行时，其他阶段是空闲等待的，浪费时间；而流水方式中，在处理后续阶段时，前面的阶段可以进行新的加工，每时每刻，每个工人都是在工作的，这就是流水线能提高生产效率的原因。&lt;/p&gt;
&lt;p&gt;和汽车生产类似，组合逻辑路径可以看作是一条生产线，路径上的每个逻辑单元都可以看作是一个阶段，都会产生时延。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果不采用流水设计，前后级组合逻辑依次工作，那么这条路径的模型就是原始的生产线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果采用流水设计，那么前后级组合逻辑可以同时工作，就像新的生产线一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="a-simple-example"&gt;A Simple Example&lt;/h2&gt;
&lt;p&gt;采用流水设计的方法就是：&lt;strong&gt;在较长的组合逻辑路径中插入 DFF，将其分割为几个小的组合逻辑，新的 Tcomb 显然小于原来的 Tcomb，所以系统的时钟频率就可以提高了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例来说明：设计一个电路完成 i = (a + b + c + d) + (e + f + g + h) 运算。&lt;/p&gt;
&lt;p&gt;下面是没有流水的设计：&lt;/p&gt;
&lt;p&gt;&lt;img alt="no-pipe" src="/images/the-art-of-pipelining/no-pipeline.png"&gt;&lt;/p&gt;
&lt;p&gt;可以计算出第一级 DFF 到第二级 DFF 之间数据路径的时延为 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Tff = Tco + Tcomb
    = Tco + 3*Tadder
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是插入两级流水的设计：&lt;/p&gt;
&lt;p&gt;&lt;img alt="piple" src="/images/the-art-of-pipelining/pipeline.png"&gt;&lt;/p&gt;
&lt;p&gt;现在相邻的两级 DFF 之间的组合逻辑只有 1 级加法器，而不是原来的 3 级，这时数据路径的时延为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Tff = Tco + Tcomb
    = Tco + Tadder
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;显然，采用流水后 Tff 更小，系统能够达到的工作时钟频率也就更高。&lt;/p&gt;
&lt;h2 id="performance-increase-from-pipelining"&gt;Performance Increase from Pipelining&lt;/h2&gt;
&lt;p&gt;下面更加详细地分析一下流水带来的速度性能的提升。&lt;/p&gt;
&lt;p&gt;首先说明，可以使用系统的流量 throughout 和系统的时滞 latency 来衡量速度性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;throughout&lt;/code&gt;: 每个时钟周期处理的数据量，单位一般是 bps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;latency&lt;/code&gt;: 数据输入到数据输出之间的时间，一般用 时钟周期的个数 来表示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示，两个 DFF 之间存在着大规模的组合逻辑：&lt;/p&gt;
&lt;p&gt;&lt;img alt="before" src="/images/the-art-of-pipelining/before.png"&gt;&lt;/p&gt;
&lt;p&gt;组合逻辑的时延决定了系统的最大工作频率（也即时钟周期 T 的最小值），此时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;latency&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eq1&lt;/span&gt;
&lt;span class="n"&gt;Tbefore&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;latency&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eq2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 Treg 表示 DFF 带来的时延，Tclk 表示时钟的 skew 和 jitter 带来的时延。&lt;/p&gt;
&lt;p&gt;在使用流水之后，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="after" src="/images/the-art-of-pipelining/after.png"&gt;&lt;/p&gt;
&lt;p&gt;此时，每个 stage 的周期为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Tstage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而时延最大的那个 stage 决定了系统的最大工作频率（也即时钟周期 Tclk 的最小值），此时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;stage&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;

&lt;span class="n"&gt;latency&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在理想状况下，各 stage 的时延应该相等，从而达到最小的 latency。即&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Tcombi = Tcomb / n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以，最小的流水周期 Tpipe 为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代入 latency 的表达式，有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;latency&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eq3&lt;/span&gt;

&lt;span class="n"&gt;Tafter&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tpipe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Eq4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先比较系统的工作频率，或者 throughout（Eq2 和 Eq4）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Fafter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fbefore&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tbefore&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tafter&lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;显然这个数 &amp;gt; 1，即&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: 系统的工作频率和 throughout 得到了提升。&lt;/p&gt;
&lt;p&gt;如果定义 k = (Treg + Tclk) / (Tcomb  + Treg + Tclk)，为 reg 和 clk 占的总周期的比例，则&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Fafter / Fbefore = 1 / [(1-k/n) + k]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其次，比较 latency（Eq1 和 Eq3）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Lafter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Lbefore&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tcomb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Treg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;显然这个数 &amp;gt; 1，即&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: 系统的 latency 增加了（增加的很小，近似可以忽略）。&lt;/p&gt;
&lt;p&gt;最后比较面积：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;conclusion&lt;/strong&gt;: 使用流水比不使用流水多使用了 n * m 个 DFF，还使用了更多的连线资源。&lt;/p&gt;
&lt;p&gt;综上，可以看到，虽然流水可以提高系统的工作频率和吞吐率，但是它付出的代价是面积和功耗的增加，这也是&lt;strong&gt;速度和面积之间相互转化&lt;/strong&gt;的体现。&lt;/p&gt;
&lt;h2 id="dxl-instruction"&gt;DXL Instruction&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt; 中还介绍了 DXL 指令集的实现，简单记录一下笔记，详细过程还是看书吧。&lt;/p&gt;
&lt;p&gt;DXL 指令是 32 位的 RISC 微处理器，每条指令最多由 5 个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Instruction Fetch (IF)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Instruction Decode/Register Fetch (ID)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execution/Effective address cycle (EX)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory access/branch completion cycle (MEM)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Write Back Cycle (WB)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;非流水的方式实现如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl nopipe" src="/images/the-art-of-pipelining/dxl-nopipeline.png"&gt;&lt;/p&gt;
&lt;p&gt;因为是非流水的方式，所以指令不能并行执行，必须等到前一条指令执行完之后才能开始执行下一条指令，如下图所示，假设每条指令需要 8 ns，那么执行 4 条指令总共需要 8 * 4 = 32 ns。&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl order1" src="/images/the-art-of-pipelining/dxl-order1.png"&gt;&lt;/p&gt;
&lt;p&gt;采用流水的方式，在 5 级操作中都加上一个流水阶段（即每个阶段加入一组 DFF），实现如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl pipeline" src="/images/the-art-of-pipelining/dxl-pipeline.png"&gt;&lt;/p&gt;
&lt;p&gt;因为是流水的方式，所以指令可以并行执行，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dxl order2" src="/images/the-art-of-pipelining/dxl-order2.png"&gt;&lt;/p&gt;
&lt;p&gt;假设执行每条指令花费 10 ns，那么执行 5 条指令：&lt;/p&gt;
&lt;p&gt;非流水的方式总共花费 10 * 5 = 50 ns；流水的方式每条指令花费 5 个时钟周期，每个周期只有 2 ns，完成 5 条指令只需要 5 个时钟周期，总共花费 9 * 2 = 18 ns；性能是原来的 50/18 = 2.8 倍。&lt;/p&gt;
&lt;h2 id="pipelining-principles"&gt;Pipelining Principles&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt; 还总结了流水需要注意的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有的中间值必须在各周期锁存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能复用任何模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个阶段的所有操作必须在一个周期内完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冒险会给流水带来问题，冒险分为&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;结构冒险，由于资源不够，无法同时支持所有指令同时执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据冒险，执行需要的中间数据还没有计算出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制冒险，分支点流水线和其他指令改变程序的计数器的值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决以上问题的方法就是停止流水线直至风险解除，在流水线中插入多个 “ 气泡 ”（缺口）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="another-example"&gt;Another Example&lt;/h2&gt;
&lt;p&gt;将前面总结的 “ 在组合逻辑路径中插入 DFF，形成流水 ” 的思路进一步扩展，可以得到更加上层的流水思想。&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379/ref=sr-1-1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1432020884&amp;amp;sr=1-1&amp;amp;keywords=advanced+fpga+design"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt; 中介绍了一个算法中使用流水的例子，其关键在于 “ 拆开环路 ”：&lt;/p&gt;
&lt;p&gt;假设要计算 x^3 这个值，下面这段软件的代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Xpower = 1;
for (i = 0; i &amp;lt; 3; i++)
    Xpower = X * Xpower;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将这段软件代码翻译成 Verilog 代码，重复使用相同的寄存器和计算资源，得到的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="iterative" src="/images/the-art-of-pipelining/iterative.png"&gt;&lt;/p&gt;
&lt;p&gt;这种迭代的方法无法实现并行计算，其性能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Throughput = 8 /1, or 8 bits /clock
Latency = 3 clocks
Timing = One multiplier delay in the critical path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而使用 pipeline 的方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// stage 1&lt;/span&gt;
&lt;span class="n"&gt;X1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Xpower1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// stage 2&lt;/span&gt;
&lt;span class="n"&gt;X2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Xpower2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Xpower1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// stage 3&lt;/span&gt;
&lt;span class="n"&gt;Xpower&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Xpower2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;得到的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="pipeline" src="/images/the-art-of-pipelining/pipelined.png"&gt;&lt;/p&gt;
&lt;p&gt;可以并行计算，其性能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Throughput = 8 bits / clock (assuming one new input per clock)
Latency = Betw een one and two multiplier delays, 0 clocks
Timing = Two multiplier delays in the critical path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到，throughout 的提升是以面积为代价的。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;THE ART OF HARDWARE ARCHITECTURE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379/ref=sr-1-1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1432020884&amp;amp;sr=1-1&amp;amp;keywords=advanced+fpga+design"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="pipeline"></category></entry><entry><title>学习 Vim 之 vim-signature 插件</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-signature-plugin.html" rel="alternate"></link><published>2015-05-06T10:37:00+08:00</published><updated>2015-05-06T10:37:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-05-06:/posts/tools/learning-vim-signature-plugin.html</id><summary type="html">&lt;p&gt;学习 vim 书签的基本知识和 vim-signature 插件的使用方法。&lt;/p&gt;</summary><content type="html">&lt;p&gt;在追踪代码时，经常跳转到很多新文件中，想回到原点时就比较麻烦了，这时候就需要 “ 书签 ” 了。&lt;/p&gt;
&lt;h2 id="bookmarks"&gt;Bookmarks&lt;/h2&gt;
&lt;p&gt;用 &lt;code&gt;:help marks&lt;/code&gt; 来查看关于书签的说明：&lt;/p&gt;
&lt;p&gt;书签可以分为 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lowercase marks&lt;/p&gt;
&lt;p&gt;书签名只能为 'a - 'z，只在所在文件内有效，不能在文件之间跳转，不同书签名不能包含有相同字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uppercase  marks&lt;/p&gt;
&lt;p&gt;书签名只能为 'A - 'Z，也叫文件书签，可以在文件之间跳转，不同书签名不能包含有相同字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;numbered marks&lt;/p&gt;
&lt;p&gt;书签名只能为 '0 - '9，用 &lt;code&gt;.viminfo&lt;/code&gt; 文件来设置&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用字母 a-zA-Z 建立的书签能被保存下来，再次打开时仍然存在，而用数字 0-9 建立的书签在关闭文件后就被删除了，不能恢复，所以 一般使用 a-zA-Z 更多一点吧。&lt;/p&gt;
&lt;p&gt;知道这些最基本的东西就可以顺利使用书签了。&lt;/p&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;常用的几个 Vim 内置的书签命令如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置书签 &lt;code&gt;m{a-zA-Z}&lt;/code&gt;，如 ma&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除书签 &lt;code&gt;:delm {marks}&lt;/code&gt;，如 :delm a&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转书签&lt;/p&gt;
&lt;p&gt;跳转有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 backtick 键（数字 1 键左边），跳转到设置书签时光标所在的行和列，如 `a&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用单引号 &lt;code&gt;'&lt;/code&gt;，跳转到书签所在行的第一个非空字符处（不包含列信息），如 'a&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&lt;/code&gt; `` 回到到上次修改的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列出所有书签 &lt;code&gt;:marks&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="vim-signature"&gt;Vim-signature&lt;/h2&gt;
&lt;p&gt;使用 Vim 书签时，最大的不方便之处是：书签是不可见的，也就是说我们输入命令之后，是无法看到书签是否建立成功了，外观上是看不出书签行和普通行的区别的。还好有个很不错的插件 &lt;a href="https://github.com/kshenoy/vim-signature"&gt;vim-signature&lt;/a&gt; 可以帮助我们实现可视化的书签。&lt;/p&gt;
&lt;p&gt;在 github 项目上有这个插件的简单介绍，另外在 Vim 中也可以看 help 文档查阅详细帮助，这里只记录我用到简单配置。&lt;/p&gt;
&lt;h3 id="install"&gt;Install&lt;/h3&gt;
&lt;p&gt;使用这个插件需要 vim 支持 sign 特性，使用命令 &lt;code&gt;:echo has('signs')&lt;/code&gt; 来查看 vim 是否支持这个特性，如果结果是 1，则支持，如果结果是 0，需要重新编译 vim。&lt;/p&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;vim-signature&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="usage_1"&gt;Usage&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;:help signature&lt;/code&gt; 可以查看帮助文档。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;m[a-zA-Z]    Toggle mark and display it in the leftmost column

m,           Place the next available mark
m&amp;lt;Space&amp;gt;     Delete all marks
]`           Jump to next mark
[`           Jump to prev mark
]&amp;#39;           Jump to start of next line containing a mark
[&amp;#39;           Jump to start of prev line containing a mark
`]           Jump by alphabetical order to next mark
`[           Jump by alphabetical order to prev mark
&amp;#39;]           Jump by alphabetical order to start of next line having a mark
&amp;#39;[           Jump by alphabetical order to start of prev line having a mark

m[0-9]       Toggle the corresponding marker !@#$%^&amp;amp;*()
m&amp;lt;S-[0-9]&amp;gt;   Remove all markers of the same type
]-           Jump to next line having a marker of the same type
[-           Jump to prev line having a marker of the same type
]=           Jump to next line having a marker of any type
[=           Jump to prev line having a marker of any type
m&amp;lt;BS&amp;gt;        Remove all markers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;而且 help 中列出了具体配置，我们可以对其修改，自定义快捷键。总结一下我常用的操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置书签 &lt;code&gt;mx&lt;/code&gt;，比如 ma&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除书签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接在目标行重新输入 &lt;code&gt;mx&lt;/code&gt;，旧书签就会被删除，并且设定到光标所在行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将光标移动到旧书签行，重新输入 &lt;code&gt;mx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有 lowercase + uppercase marks，&lt;code&gt;m&amp;lt;Space&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除所有 numbered marks，&lt;code&gt;m&amp;lt;BS&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转书签&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;]`&lt;/code&gt;，跳转到前一个书签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[`&lt;/code&gt;，跳转到后一个书签&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;]-&lt;/code&gt;，跳转到之前同一类型的 numbered marks 书签行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[-&lt;/code&gt;，跳转到之后同一类型的 numbered marks 书签行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/kshenoy/vim-signature"&gt;vim-signature&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.tuicool.com/articles/f6feae"&gt;像 IDE 一样使用 Vim&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category><category term="vim-signature"></category></entry><entry><title>Regular Expression 小结</title><link href="https://qian-gu.github.io/posts/cs/summary-of-regular-expression.html" rel="alternate"></link><published>2015-04-27T00:00:00+08:00</published><updated>2015-04-27T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-04-27:/posts/cs/summary-of-regular-expression.html</id><summary type="html">&lt;p&gt;regular expression 学习笔记&lt;/p&gt;</summary><content type="html">&lt;p&gt;看完了 &lt;a href="http://book.douban.com/subject/6959486/"&gt;Introducing Regular Expressions&lt;/a&gt;，记录一下学习笔记。这本书是非常简单的入门书，一天时间就能看完。作者还推荐了基本进阶书：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1872091/"&gt;Mastering Regular Expressions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3443904/"&gt;Regular Expressions Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2363803/"&gt;Regular Expression Pocket Reference&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;看完这本书，基本上已经满足项目中简单的 RE 需求，以后需要深入的话，再补这几本书。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="what-is-a-re"&gt;What Is a RE?&lt;/h2&gt;
&lt;p&gt;引用 Ken Thompson 的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A regular expression is a pattern which specifies a set of strings of characters; it is said
to match certain strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="basic"&gt;Basic&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;metacharacters&lt;/p&gt;
&lt;p&gt;元字符，在表达式中有特殊的含义，也是保留字。一共有 14 个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;.   // 匹配任意字符
\   // 对字符转义
|   // 选择操作（或）
^   // 行起始
$   // 行结束
?   // 匹配 0 或 1 次
&lt;span class="k"&gt;*&lt;/span&gt;   // 匹配 0 或 多次
+   // 匹配 1 或 多次
[]  // 字符组符号
{}  // 量词或代码块符号
()  // 分组符号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;character shorthand&lt;/p&gt;
&lt;p&gt;也叫做 character escape，中文翻译成：“ 字符组简写 ” / “ 转义字符 ”，常用简写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\d      // 数字字符，= [0-9]
\D      // 非数字字符， = [^0-9]
\w      // 单词字符
\W      // 非单词字符
\s      // 空格
\n      // 换行
\r      // 回车
\b      // 单词边界
\a      // 报警符
\cx     // 控制字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="simple-match-patterns"&gt;Simple Match Patterns&lt;/h2&gt;
&lt;p&gt;几个常见的模式匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string literals&lt;/p&gt;
&lt;p&gt;使用普通字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;digits&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\d      // 简写形式
[0-9]   // 0~9 任意一个数字
[1278]  // 限定备选集合为 1，2，7，8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;non-digits&lt;/p&gt;
&lt;p&gt;&lt;em&gt;大写的简写形式&lt;/em&gt; 或者 &lt;em&gt;取反&lt;/em&gt; 即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\D
[^0-9]
[^\d]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;word characters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\w              // 简写形式
[a-zA-Z0-9]     // a~z、A~Z、0~9 任意一个字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;non-word characters&lt;/p&gt;
&lt;p&gt;&lt;em&gt;大写的简写形式&lt;/em&gt; 或者 &lt;em&gt;取反&lt;/em&gt; 即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\W
[^a-zA-Z0-9]
[^\w]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;whitespace&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\s
[ \t\r\n]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;any characters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="boundaries"&gt;Boundaries&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行首、行尾&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;^       // 行首
$       // 行尾
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单词边界&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\b      // 单词边界
\&amp;lt;      // 单词开头
\&amp;gt;      // 单词结尾
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非单词边界&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="alternation-groups-and-backreferences"&gt;Alternation, Groups, and Backreferences&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Alternation&lt;/p&gt;
&lt;p&gt;比如要匹配 THE 或者 The 或者 the，使用如下的语法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(THE|The|the)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Subpatterns&lt;/p&gt;
&lt;p&gt;THE、The、the 是 3 个子模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(THE|The|the)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;括号对于子模式不是必须的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;tT&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ceinry&lt;/span&gt;&lt;span class="o"&gt;]*&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以匹配 the、The、their 等单词，严格意义上中括号内的叫做 字符组 &lt;code&gt;character classes&lt;/code&gt;，不过因为两者有近似的功能，所以也可以将其做一类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Capturing Groups and Backreferences&lt;/p&gt;
&lt;p&gt;对于括号 () 内的模式进行捕获，将其存储在临时内存中，然后可以通过后向引用重用已捕获的内容。&lt;/p&gt;
&lt;p&gt;重引用时 &lt;code&gt;\1&lt;/code&gt;、&lt;code&gt;$1&lt;/code&gt; 表示对第一个分组的引用；&lt;code&gt;\2&lt;/code&gt;、&lt;code&gt;$2&lt;/code&gt; 表示对第二个分组的引用；依次类推。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Non-Capturing Groups&lt;/p&gt;
&lt;p&gt;对于之后不会进行引用的分组，可以使用非捕获分组，因为不会对其分配内存所以可以提高性能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(?:THE|The|the)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="character-classes"&gt;Character Classes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Character Classes&lt;/p&gt;
&lt;p&gt;也叫做 方括号表达式，字符组可以帮助我们匹配特定字符或者特定的字符序列：&lt;/p&gt;
&lt;p&gt;匹配特定字符&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;aeiou&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;匹配元音字符&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;匹配特定字符序列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\b[1][24680]\b      // 匹配 10～19 之间的偶数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Negated Character Classes&lt;/p&gt;
&lt;p&gt;匹配与字符组不匹配的字符，方法就是在开头加上 脱字符 &lt;code&gt;^&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[^aeiou]    // 不想匹配元音字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Union and Difference&lt;/p&gt;
&lt;p&gt;字符组可以像集合一样操作（如求并集、求差集），实际上字符组还有一个名字就叫做 字符集 &lt;code&gt;character set&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并集：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[0-3][6-9]      // 匹配 0~3 或者 6~9 之间的数字
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;差集：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[a-z&amp;amp;&amp;amp;[^m-r]]   // 匹配 a~z 之间，但是排除 m~r 之间的字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POSIX Character Classes&lt;/p&gt;
&lt;p&gt;&lt;code&gt;POSIX&lt;/code&gt; (Portable Operating System Interface ) 是 IEEE 维护的一系列标准，格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;[[: xxxx:]]&lt;/span&gt;
&lt;span class="na"&gt;[[&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s"&gt;^ xxxx:]]        // 取反匹配&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 xxxx 取值为 digit、word 等，举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;[[:alnum:]]         // 匹配字母和数字
[[:alpha:]]         // 匹配大写或小写字母
[[:ascii:]]         // 匹配 ASCII 范围内的字符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般不常用 POSIX 格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="matching-unicode-and-other-characters"&gt;Matching Unicode and Other Characters&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Matching a Unicode Character&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;/uxxxx      // syntax
/u00e9      // = character é 
/u6c60      // = character 池
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Matching Characters with Octal Numbers&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;`\xxx`      // xxx 是 3 位 8 进制数字
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;比如 é 也可以用 &lt;code&gt;\351&lt;/code&gt; 来匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Matching Control Characters&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;\cx         // x 是想匹配的控制字符
\c@         // 空字符 0.NUll
\cG         // 报警字符 BEL
\cH         // 退格符 Backspcace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="quantifiers"&gt;Quantifiers&lt;/h2&gt;
&lt;h3 id="greedy-lazy-and-possessive"&gt;Greedy, Lazy, and Possessive&lt;/h3&gt;
&lt;p&gt;量词的属性有 贪婪，懒惰，占有。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Greedy&lt;/p&gt;
&lt;p&gt;所谓 “ 贪婪 ” 就是说 在匹配前会选定尽可能多的内容，也就是整个输入。然后开始匹配时，会首先匹配整个字符串，如果失败，则回退一个字符，重新匹配（这个过程叫做回溯 backtracking），直到找到匹配的内容或者没有字符可以尝试为止。&lt;/p&gt;
&lt;p&gt;量词的默认属性是贪婪的。&lt;/p&gt;
&lt;p&gt;形象的描述是：它先 “ 吃 ” 进所有的字符，然后每次 “ 吐 ” 出一点，慢慢咀嚼消化 ...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It takes a mouthful, then spits back a little at a time, chewing on what it just ate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lazy&lt;/p&gt;
&lt;p&gt;量词的另外一种策略。从待匹配的内容起始位置开始尝试匹配，每次检查字符串的一个字符，寻找匹配内容，最后会尝试匹配整个字符串。&lt;/p&gt;
&lt;p&gt;形象的描述是：它每次只吃一点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It chews one nibble at a time&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Possessive&lt;/p&gt;
&lt;p&gt;占有量词会抓取整个目标，然后尝试寻找匹配。不过它只尝试一次，不会回溯。&lt;/p&gt;
&lt;p&gt;形象的描述是：它不 “ 咀嚼 ” 而是直接 “ 吞咽 ”，然后才想知道 “ 吃 ” 的是什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It doesn’t chew; it just swallows, then wonders what it just ate. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="basic-quantifiers"&gt;Basic Quantifiers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;    匹配 0 或 1 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;    匹配 1 或 多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;    匹配 0 或 多次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些量词默认是贪心的，也就是说第一次尝试时会尽可能多地匹配字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.*&lt;/code&gt; 叫做 &lt;code&gt;Kleene star&lt;/code&gt;，以纪念 RE 的发明人 Stephen Kleene。&lt;/p&gt;
&lt;h3 id="range-syntax"&gt;Range Syntax&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt;   精确匹配 n 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt;  匹配 n 次 或 多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{m,n}&lt;/code&gt; 匹配 m 至 n 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{0,1}&lt;/code&gt; 与 &lt;code&gt;?&lt;/code&gt; 相同（0 或 1 次）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{1,0}&lt;/code&gt; 与 &lt;code&gt;+&lt;/code&gt; 相同（1 或 多次）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{0,}&lt;/code&gt;  与 &lt;code&gt;*&lt;/code&gt; 相同（0 或 多次）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lazy-quantifiers"&gt;Lazy Quantifiers&lt;/h3&gt;
&lt;p&gt;懒惰的意思就是匹配尽可能少的字符，它就是个懒虫！它总会找到匹配下限。比如 5*?，它不会匹配任何内容，因为 * 的下限是 0 次；再比如 5+?，它只会匹配 1 个 5，因为 + 的下限是 1 次；再比如 5{2,5}?，它只会匹配 2 个 5，因为下限是 2。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;?? &lt;/li&gt;
&lt;li&gt;+?&lt;/li&gt;
&lt;li&gt;*?&lt;/li&gt;
&lt;li&gt;{n}?&lt;/li&gt;
&lt;li&gt;{n,}?&lt;/li&gt;
&lt;li&gt;{m,n}?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面这些加了 ? 的 RE 表示懒惰匹配，也就是 &lt;em&gt;找下限&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id="possessive-quantifiers"&gt;Possessive Quantifiers&lt;/h3&gt;
&lt;p&gt;占有式量词就是贪婪式量词的弱化版，只在第一次进行匹配，如果失败就停止，而不是继续回溯下去。它会将自己的输入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;?+&lt;/li&gt;
&lt;li&gt;++&lt;/li&gt;
&lt;li&gt;*+&lt;/li&gt;
&lt;li&gt;{n}+&lt;/li&gt;
&lt;li&gt;{n,}+&lt;/li&gt;
&lt;li&gt;{m,n}+&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些量词后面加了 + 的 RE 表示占有匹配，也就是只检查第一次尝试。&lt;/p&gt;
&lt;h2 id="lookarounds"&gt;Lookarounds&lt;/h2&gt;
&lt;p&gt;环视 是一种非捕获分组，它的作用是检查模式的前 / 后的内容来匹配，也成为 零宽度断言 &lt;code&gt;zero-width
assertions&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Positive Lookaheads&lt;/p&gt;
&lt;p&gt;正前瞻。 pattern 之后必须紧随着 lookaround 的才会被匹配。&lt;/p&gt;
&lt;p&gt;比如想找到所有之后紧随着一个 marinere 的 ancyent ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ancyent (?=marinere)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Negative Lookaheads&lt;/p&gt;
&lt;p&gt;反前瞻。对正前瞻的取反，也就是 pattern 之后必须没有 lookarounds 的才会被匹配。&lt;/p&gt;
&lt;p&gt;比如想找到所有后面没有 marinere 的 ancyent：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ancyent (?!marinere)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Positive Lookbehinds&lt;/p&gt;
&lt;p&gt;正后顾。后顾和前瞻的方向相反，检查 pattern 之前的内容，之前有 lookarounds 的 pattern 才会被匹配到。&lt;/p&gt;
&lt;p&gt;比如想找到所有之前有 ancyent 的 marinere：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(?&amp;lt;=ancyent) marinere
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Negative Lookbehinds&lt;/p&gt;
&lt;p&gt;反后顾。对正后顾的取反，也就是 pattern 之前必须没有 lookarounds，才会被匹配。&lt;/p&gt;
&lt;p&gt;比如想找到所有之前不存在 ancyent 的 marinere：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(?&amp;lt;!ancyent) marinere
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于正、反；前瞻、后顾可以用下面的规律记：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前瞻 / 后顾：&lt;/strong&gt;以 lookarounds 为原点，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pattern 在 lookarounds 之前就是 前瞻&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pattern 在 lookarounds 之后就是 后顾&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;正 / 反：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果条件是 lookarounds   存在，就是 正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果条件是 lookarounds 不存在，就是 负&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解了这些基础知识，基本上就可以读懂、书写 RE 了，还需要的就是平时多加思考练习，然后看更加高阶的书了。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6959486/"&gt;Introducing Regular Expressions&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="regular expression"></category></entry><entry><title>Verilog HDL coding style</title><link href="https://qian-gu.github.io/posts/ic/verilog-hdl-coding-style-guide.html" rel="alternate"></link><published>2015-04-21T10:12:00+08:00</published><updated>2015-04-21T10:12:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-04-21:/posts/ic/verilog-hdl-coding-style-guide.html</id><summary type="html">&lt;p&gt;参考网上的资料和书籍，总结一份自己的 Coding Style Guide&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Update (2022/09/22):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;补充一些资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/lowRISC/style-guides"&gt;lowRISC/style-guides&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[ 编写可读代码的艺术 ]（https://book.douban.com/subject/10797189/）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Update (2015/04/21):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考了网上流传的 华为 coding style guide 和 其他的一些资料，还有 &lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr-1-1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt; 的内容，重新整理一下自己的 Coding Style Guide，以便做项目的时候参考对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt; : 2.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Date&lt;/strong&gt; : 2015-04-21&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Author&lt;/strong&gt; : Qian Gu (guqian110@gmail.com)&lt;/p&gt;
&lt;h2 id="goal"&gt;Goal&lt;/h2&gt;
&lt;p&gt;干干净净的代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码整洁、结构合理、层次清晰、注释明了、没有烂代码、没有冗余代码，合理地建立目录，合理地分配到不同文件中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下面分几个方面来总结，如何达到这样的目的。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="module-partition"&gt;Module Partition&lt;/h2&gt;
&lt;p&gt;把代码划分为 模块、函数、任务，形成合理的层次结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划分的原则：高内聚、低耦合&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般来说，每个模块、函数、任务完成一个功能，隐藏内部实现细节，提供一个干净的接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;灵活掌握，不要划分出太多的模块，不必拘泥于 “ 模块最好在 500 行左右 ”（太多的实例和连线反而容易出错）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低耦合的原则就是模块之间尽量用少的连线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提取公共代码、常用代码形成模块、函数、任务，便于使用和以后移植，有可能的话，参数化、通用化、IP 化（比如 CRC 计算、时钟分频、同步电路、通用 GPIO 控制等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;划分模块时，将相关组合逻辑划分到同一模块，以便综合时进行优化（一般工具不会越过模块边界来优化）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在模块内部，合理切分逻辑，让相关代码组合在一起形成逻辑块，合理安排逻辑块的顺序，并且用固定长度的横线分割这些逻辑块，加以注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块内部不要存在重复的代码（子模块、函数、任务、循环语句、寄存器组、for/generate）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了减少修改内容、避免出错、移植方便、创建可重用模块，在编写代码的时候使用 define、parameter、localparam 定义可重定义的参数（如 SIZE、WIDTH、DEPTH 等）。如果可能，把所有 define 放在一个 definition.vh 中，编译时首先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="coding-style"&gt;Coding Style&lt;/h2&gt;
&lt;p&gt;灵活合理地运用，才能设计出强壮的、简洁的代码，目标是可以清晰地表达出设计意图。&lt;/p&gt;
&lt;h3 id="part-a"&gt;Part A&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计时把应用文档和设计文档写好，在设计文档中要把设计思路、数据通路、实现细节等描述清楚，在经过评审之后才能开始编写代码（磨刀不误砍柴工，节约时间，而且项目可控、可实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用可靠的 IP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个模块放到一个单独的文件中，&amp;lt; 文件名 &amp;gt;=&amp;lt; 模块名 &amp;gt;.&amp;lt; 扩展名 &amp;gt;（很多小模块则可以放到一个文件中，便于管理，如 cell 库）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Top 模块只包含子模块的例化（即使有逻辑，也是简单的 glue 逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照合理的层次结构组织各个模块，存放在合理的目录结构中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part-b"&gt;Part B&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;避免书写可能导致竞争冲突（race condition）的语句（给仿真调试带来很大的麻烦）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免实例化具体的门级电路（可读性差、难于理解维护、不可移植）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用内部三态电路，使用 MUX 代替&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免任何器件的输入悬空（会导致很大的电流消耗）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免使用嵌入式的综合指令（synthesis directive）（仿真工具忽略这些指令，仿真和综合结果不一致）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免 Latch，避免无意中形成的 Latch（常规设计中，只有顶层模块的 clock-gate 会使用 latch，以节省功耗）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part-c"&gt;Part C&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证时钟和复位信号没有 glitch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量保持时候总和复位信号的简单，不要使用复杂的组合逻辑（便于测试、后端生成时钟树和复位树）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量做到所有寄存器同时复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小心使用门控时钟（Gated clock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在模块内部产生时钟，最好使用同步设计，用 clock enable 来实现低频时钟操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在模块内部产生复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果确实要使用门控时钟、内部时钟、内部复位，把这些信号的代码放到一个独立的模块里，并在顶层模块例化这个独立模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个模块内尽量只使用一个时钟。多时钟设计中，时钟域隔离带逻辑（同步电路）放到一个独立的模块中
只使用时钟的一个沿（上升 or 下降）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对跨时钟域的信号要进行同步处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免多周期路径（multicycle-path）和假路径（false-path），一旦有这种路径，在代码和设计文档中标注写明
写可测性的设计（DFT, Design for Test）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part-d"&gt;Part D&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于组合逻辑，使用 always @*&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意 "=" 和 "&amp;lt;="&lt;/p&gt;
&lt;p&gt;不要在一个 always 块中混杂使用两者&lt;/p&gt;
&lt;p&gt;组合逻辑，使用 "="&lt;/p&gt;
&lt;p&gt;时序逻辑，使用 "&amp;lt;="&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写合理的 FSM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无优先级的多路复用器使用 case，有优先级的多路复用器使用 if-else 或者是 ? :&lt;/p&gt;
&lt;p&gt;通常，case 的时序比 if-else 的时序好，优先级编码器只有在信号先后到来的时候才使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part-e"&gt;Part E&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;模块的输入信号尽量用 DFF 先锁存再使用（若输入是其他的寄存器输出则不必）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块的输出信号尽量用 DFF 先锁存再输出（便于综合和 STA，处理起来简单，Timing 更好）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用端口名映射法进行模块实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明每一个用到的信号（若无声明，默认是 1 bit 的 wire）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计代码中，reg 只能在一个 always 中复制；验证代码无此要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计代码中，函数、任务不要使用全局变量；验证代码无此要求&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part-f"&gt;Part F&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;`include 的文件名不要包含路径名（后期编译、综合、移植困难）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用 &lt;code&gt;define 做常数声明，把&lt;/code&gt;define 定义的参数放在一个独立的文件中，然后在模块头部 `include 这个文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头文件保护&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有全局的，不会被修改的常量采用 define 定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用域只在一个模块内，使用 localparam 代替 `define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了模块可配置、可移植，使用 parameter&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="part-g"&gt;Part G&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用简洁的写法（可省略的 begin-end 省略不写）&lt;/p&gt;
&lt;p&gt;我看到有一些 coding style 中要求即使只有一条语句，if-else、case 等语句的 begin-end 也要写上，这样是为了方便以后添加代码，而且减少出错的机会。&lt;/p&gt;
&lt;p&gt;不过我更认同 Cummings 的观点：&lt;a href="http://www.sunburst-design.com/papers/Wheres-Waldo-Coding.pdf"&gt;The Sunburst Design - "Where's Waldo" Principle of Verilog Coding&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am a big fan of very concise coding. In general (but not always), the shorter the code,
the better. The more code I can see, nicely spaced and formatted on one page, the easier
it is to understand the intent of the design or verification code.&lt;/p&gt;
&lt;p&gt;I call this the "Where's Waldo" Principle based on the child puzzle-books of the same
name. Even though Waldo is dressed in a bright red and white stripped shirt, when he is
surrounded by enough additional clutter, he is hard to find. Just as Waldo is hard to find
when surrounded by clutter, simple RTL coding bugs can be obscured when surrounded
by poorly spaced and formatted RTL code and silly comments that state the obvious.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如下面这段 11 行、129 个字符的代码可以使用 3 行、57 个字符的代码代替：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// code1&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// end-if-begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// end-else-begin&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// end-always-begin&lt;/span&gt;

&lt;span class="c1"&gt;// code2&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="naming"&gt;Naming&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;建立一套命名约定和缩略语清单，以文档的形式记录下来，严格遵守&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用有意义而且有效的名字，含义清楚、名副其实，避免含糊误导&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块名大写，所在文件名小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数、任务、信号、变量、端口名字用小写字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;`define、parameter、localparam、const、enum 用大写字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子模块的名字应该使用调用模块的名字作为前缀，如 emi、emi-ahb、emi-reg、emi-sram&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用协议定义的标准名字，根据需要在这些名字前附加前缀（模块名）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一信号的名字在各个子模块中保持一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入到同一个模块的连线用模块的名字作前缀（前缀比后缀更清晰）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每行定义一个信号，上面一行 / 同一行的尾部加上简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号名的定义顺序：控制信号、相应信号、数据信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词首字母缩写，大写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;DMI&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// Data Memory Interface&lt;/span&gt;
&lt;span class="n"&gt;DEC&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// Decoder&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块间信号名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分为两部分，第一部分表示信号方向，大写，第二部分表示信号意义，小写，下划线连接。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CPUMMU&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// write request form CPU to MMU&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模块内命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单词缩写，下划线连接，小写。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sdram&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wr&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;en&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// SDRAM write enable&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统级命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟信号、置位信号、复位信号等需要输送到各个模块的全局信号，以 &lt;code&gt;SYS-&lt;/code&gt; 前缀开头。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SYS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;100&lt;/span&gt;&lt;span class="n"&gt;MHz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;// system clock&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SYS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// system counter set&lt;/span&gt;
&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SYS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// system counter reset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;低电平有效信号命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;低电平有效信号加后缀 &lt;code&gt;-n&lt;/code&gt;，举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;// low valid reset&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;经过锁存器的信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过锁存器的信号加后缀 &lt;code&gt;-r&lt;/code&gt;，以和锁存前区别。举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="c1"&gt;// latch input data&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;参数名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;parameter 全部大写，用 parameter 定义有实际意义的常数，比如 LED 亮灯状态、状态机状态等，避免 "magic number"。举例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;WAIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;常用信号名缩写：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;acknowledge&lt;/td&gt;
&lt;td&gt;ack&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;ready&lt;/td&gt;
&lt;td&gt;rdy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;adress&lt;/td&gt;
&lt;td&gt;addr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;enable&lt;/td&gt;
&lt;td&gt;en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;receive&lt;/td&gt;
&lt;td&gt;rx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arbiter&lt;/td&gt;
&lt;td&gt;arb&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;frame&lt;/td&gt;
&lt;td&gt;frm&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;req&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;check&lt;/td&gt;
&lt;td&gt;chk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;generate&lt;/td&gt;
&lt;td&gt;gen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;resest&lt;/td&gt;
&lt;td&gt;rst&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clock&lt;/td&gt;
&lt;td&gt;clk&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;grant&lt;/td&gt;
&lt;td&gt;gnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;segment&lt;/td&gt;
&lt;td&gt;seg&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;cfg&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;increase&lt;/td&gt;
&lt;td&gt;inc&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;source&lt;/td&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;control&lt;/td&gt;
&lt;td&gt;ctrl&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;input&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;statistic&lt;/td&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;counter&lt;/td&gt;
&lt;td&gt;cnt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;switcher&lt;/td&gt;
&lt;td&gt;sf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data in&lt;/td&gt;
&lt;td&gt;din&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;output&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;timer&lt;/td&gt;
&lt;td&gt;tmr&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data out&lt;/td&gt;
&lt;td&gt;dout&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;packet&lt;/td&gt;
&lt;td&gt;pkt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;tmporary&lt;/td&gt;
&lt;td&gt;tmp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decode&lt;/td&gt;
&lt;td&gt;de&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;priority&lt;/td&gt;
&lt;td&gt;pri&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;transmit&lt;/td&gt;
&lt;td&gt;tx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;decrease&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;pointer&lt;/td&gt;
&lt;td&gt;ptr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;valid&lt;/td&gt;
&lt;td&gt;vld&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delay&lt;/td&gt;
&lt;td&gt;dly&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;rd&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write enable&lt;/td&gt;
&lt;td&gt;wr-en&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disable&lt;/td&gt;
&lt;td&gt;dis&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;read enbale&lt;/td&gt;
&lt;td&gt;rd-en&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;wr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="format"&gt;Format&lt;/h2&gt;
&lt;h3 id="poart-declaration"&gt;Poart Declaration&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽量使用 Verilog-2001 标准，减少代码行，便于修改和删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每行只声明一个端口，这样可以在上面 / 后面添加简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明顺序：按照功能分组，分组前添加注释，分组之间空行分割，便于阅读&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在功能分组内，哪个信号最主控，哪个就最靠前。（控制信号、数据信号），顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;test-mode 信号，工作模式（=0）或 测试模式（=1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使能信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据信号&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="module-instantiate"&gt;Module Instantiate&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;例化名和模块名保持一致，加统一的前缀，如 u1-&lt;module-name&gt;、u2-&lt;module-name&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;端口名映射法，not 位置映射法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化端口顺序 = 模块端口声明顺序，不用的端口也列出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化&lt;em&gt;大模块&lt;/em&gt;时，每个端口占用一行，&lt;code&gt;.port-name&lt;/code&gt; 对齐，&lt;code&gt;.(signal-name)&lt;/code&gt; 也对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化&lt;em&gt;大量小模块&lt;/em&gt;时，可以多个端口放在同一行的紧凑形式（如大量 PAD 实例化）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="task-function"&gt;Task &amp;amp; Function&lt;/h3&gt;
&lt;p&gt;使用 C 语言的习惯，在合适的位置添加空格&lt;/p&gt;
&lt;h3 id="statement"&gt;Statement&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每个语句单独成行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 always、for、while 语句，begin 最好在它们的下一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 initial、if、elseif、else 语句，begin 最好与它们同行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;end 占用单独一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个逻辑块内不加空行，表明它们之间的紧密关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同逻辑块之间添加空行，表明每个逻辑块实现不同的功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;7。 每行不多于 80 个字符，以提高可读性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;采用缩进，不要嵌套太深&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合理使用 tab （1 tab = 4 space）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="expression"&gt;Expression&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用括号表示优先级（括号有可能影响综合结果的情况不在此列）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双目、三目操作符左右空格，如 =、+、-、×、/、%、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、&amp;amp;、&amp;amp;&amp;amp;、|| 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逗号 (,) 只在逗号后加空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分号 (;) 只在分号后加空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行尾不加空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上下行有关时，使用空格对齐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达式很长时，适当位置断行，使用空格对齐某些变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="comments"&gt;Comments&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件头，使用 doxverilog 注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在逻辑块、重要代码行的上方添加注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释简明扼要，足够说明设计意图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保证注释和代码一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有效实用的注释格式，Doxygen&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;英文注释，标点后空一格，英文习惯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释复杂过程，列出要点和步骤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块开始要有模块级的注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块端口，简要注释，描述功能和有效电平&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊注释：note、warning、todo&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="lint"&gt;Lint&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编译时，打开 vcs 或 ncveriog 的 lint 检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查编译的输出结果，Warning 可能导致仿真失败、综合失败，尽量修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否生成 latch&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检测 always 敏感列表是否完全&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="appdidx"&gt;Appdidx&lt;/h2&gt;
&lt;p&gt;FSM 的模板&lt;a href="http://guqian110.github.io/pages/2014/06/05/fsm-design.html"&gt;另外一篇博客&lt;/a&gt;中已经总结过了。下面是一个简单的模块模板格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;
&lt;span class="normal"&gt;59&lt;/span&gt;
&lt;span class="normal"&gt;60&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Module Declaration                                                            //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MODULE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;PARAM1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PARAM2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;//----------------------------------&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// Interface1&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// comments&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;//----------------------------------&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// Interface2&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Parameter Declarations                                                        //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;DIN&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;DOUTA&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;DOUTE&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;DOUTCTR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;// Main Body of Code                                                             //&lt;/span&gt;
&lt;span class="c1"&gt;///////////////////////////////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Instantiate sub module                                //&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;MODULE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NAMW&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;MODULE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;NAMW&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Some Logic                                            //&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////////////&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//----------------------------------------&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// sequential logic&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;posdge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//---------------------------------------&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// combinational logic&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</content><category term="IC"></category><category term="Verilog"></category><category term="coding style"></category></entry><entry><title>时钟生成</title><link href="https://qian-gu.github.io/posts/ic/clock-generate-unit.html" rel="alternate"></link><published>2015-04-19T00:00:00+08:00</published><updated>2015-04-19T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-04-19:/posts/ic/clock-generate-unit.html</id><summary type="html">&lt;p&gt;总结时钟生成&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;&lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr-1-1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt; 时钟生成 笔记，内容基本上都是书上的内容，还有我自己的总结，混合在一起，就不加引用符号了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果说总线互连（Bus Matrix）是系统各骨架，CPU 是系统的大脑，那么时钟生成模块（CGM）就是系统的心脏，整个系统就是在时钟的脉搏下有序协调地工作。&lt;/p&gt;
&lt;p&gt;我们在设计时钟生成模块时，我们需要考虑下面这些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;芯片需要多少时钟？它们之间的关系是同步到还是异步的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;芯片需要几个时钟源？时钟源是在芯片内还是芯片外？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要使用 PLL 吗？需要几个 PLL？PLL 最高工作频率是多少？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何分频生成各个模块所需要的时钟频率？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了节省功耗需要几种工作模式？它们之间如何切换？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试模式下如何处理时钟信号？综合时如何插入扫描链？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码如何编写才能方便后端做时钟树综合？后端如何做时钟树综合？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="clock"&gt;Clock&lt;/h2&gt;
&lt;p&gt;我们都知道，电路设计可以分为 &lt;strong&gt;同步设计&lt;/strong&gt; 和 &lt;strong&gt;异步设计&lt;/strong&gt; 两种，两者的优缺点就不再赘述。由于同步设计的一些优点，一般推荐使用同步设计，即使有异步信号，也将其转化为同步信号，来避免异步信号导致的问题。&lt;/p&gt;
&lt;p&gt;虽然同步电路有很多优点，但是它也有一些缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首要问题是 &lt;strong&gt;时序收敛问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也就是要保证所有的 flip-flop 的输入端和时钟端之间满足 setup/hold time 的要求，否则就会出现亚稳态，导致电路无法正常工作。&lt;/p&gt;
&lt;p&gt;不满足 setup time 的要求，可以通过降低工作频率的方法解决，但是不满足 hold time 时，芯片根本就无法工作。&lt;/p&gt;
&lt;p&gt;时序收敛点工作都是由 EDA 工具自动完成的，我们只要设置合理的时间约束，综合及布局布线工具就可以实现时钟平衡，时序分析工具就可以检查电路是否满足时序收敛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，对时钟信号要求高&lt;/p&gt;
&lt;p&gt;同步设计的基础是时钟信号。关于时钟信号，另外一篇博客 &lt;a href="http://guqian110.github.io/pages/2015/03/18/static-timing-analysis-1-basic.html"&gt;静态时序分析 STA 1 —— 基础知识&lt;/a&gt; 有一些总结，比如时钟偏斜 skew、时钟抖动 jitter、占空比失真 Duty Cycle Distortion。&lt;/p&gt;
&lt;p&gt;时钟偏斜 skew 的解决方法是采用 EDA 工具进行时钟树综合，它的原理就是按照时钟树的最大长度去平衡其他的时钟路径。但是这种方法会引入大量延迟单元的插入，使得电路的面积和功耗大大增加。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="design-principle"&gt;Design Principle&lt;/h2&gt;
&lt;p&gt;下面是设计时钟生成模块（CGM）时要遵守的一些原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CGM 要独立于系统的其他模块，其他模块所使用的时钟都要从 CGM 中引出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CGM 要有很好的层次结构，既便于前端定义时钟和分析时序，又便于后端做时钟树综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了调整性能和功耗，CGM 应该支持分频器和停时钟，而且软件能灵活控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在时钟切换和启停时钟时，一定不能出现毛刺，否则电路不能正常工作&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="clock-divider"&gt;Clock Divider&lt;/h2&gt;
&lt;p&gt;在一个系统中，各个模块可能需要不同的工作频率，这就需要通过 PLL 把时钟源的频率提高到高频，然后通过不同的分频器为每个模块分出不同的工作频率。&lt;/p&gt;
&lt;p&gt;以前总结一篇关于 &lt;a href="http://guqian110.github.io/pages/2014/10/13/clock-dividers.html"&gt;时钟分频器&lt;/a&gt; 的博客。&lt;/p&gt;
&lt;h2 id="clock-switch"&gt;Clock Switch&lt;/h2&gt;
&lt;p&gt;有时候，我们需要在模块运行的过程中切换时钟，切换时钟最简单的方法就是使用 MUX。但是这种方法会造成毛刺（glitch）。如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;书上提供了一个通用的没有 glitch 的时钟切换模块，支持多个时钟的切换，其中 select 信号必须使用 one-hot 编码。（代码略 ...）&lt;/p&gt;
&lt;h2 id="clock-generation"&gt;Clock Generation&lt;/h2&gt;
&lt;p&gt;有了上面的基础，就可以设计时钟生成模块了。书里面以一个 时钟切换 + 时钟分频 的组合来说明如何设计。&lt;/p&gt;
&lt;p&gt;书后面一章还提供了一个实际项目中的 CGM 的设计文档，以供参考。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/EDA%E7%B2%BE%E5%93%81%E6%99%BA%E6%B1%87%E9%A6%86-Verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E9%AD%8F%E5%AE%B6%E6%98%8E/dp/B00HNVY3SY/ref=sr-1-1?ie=UTF8&amp;amp;qid=1429188978&amp;amp;sr=8-1&amp;amp;keywords=verilog%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock generate unit"></category></entry><entry><title>可配置设计</title><link href="https://qian-gu.github.io/posts/ic/configurable-design.html" rel="alternate"></link><published>2015-04-17T00:00:00+08:00</published><updated>2015-04-17T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-04-17:/posts/ic/configurable-design.html</id><summary type="html">&lt;p&gt;总结可配置设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://book.douban.com/subject/26612391/"&gt;Verilog 编程艺术&lt;/a&gt; 的可配置设计一章 学习笔记。&lt;/p&gt;
&lt;h2 id="configurable-design"&gt;Configurable design&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我们做设计的时候，就要考虑做成可以灵活配置的设计，不管是小模块，还是大模块，这样便于以后维护和移植。可配置模块的设计方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 parameter 和 `define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 for 语句生成多条语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 generate、for、if 等语句生成多条语句和多个实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过工具或脚本生成配置参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过工具或脚本直接生成 Verilog 代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;书里面总结了上面的这些方法，以前总结过另外一篇博客：Verilog 中的参数化建模，里面总结了 条件编译、`define、parameter、localparam 的用法和区别。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/2125482/"&gt;Reuse Methodology Manual for System-on-a-Chip Designs&lt;/a&gt; 是一本很经典的书，里面有全面详细的可重用设计的方法，有时间了看了再补上。&lt;/p&gt;
&lt;h2 id="paramter"&gt;Paramter&lt;/h2&gt;
&lt;p&gt;可配置设计最基本的方法，将配置选项放到端口参数上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; user 直接在例化时传递参数，无需修改 submodule 的源代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束：&lt;/strong&gt; 必须从 top 一级一级传递下去，每次修改 submodule 内的所有模块都需要同步修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 参数数量多时 parameter list 冗长，修改不灵活&lt;/p&gt;
&lt;h2 id="define"&gt;define&lt;/h2&gt;
&lt;p&gt;主要用于条件编译，比如条件定义是否包含某组端口或者例化某个 submodule。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 一处定义，处处使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; define 作用域问题&lt;/p&gt;
&lt;h2 id="generate-iffor"&gt;Generate if/for&lt;/h2&gt;
&lt;p&gt;generate if 在 module 内部可以代替 define，但是无法在端口定义上无法代替 define。&lt;/p&gt;
&lt;p&gt;generate for 或者是 for loop 在 module 内部可以实现参数化设计，典型例子是实现参数化的 N-1 mux。同理，当 case 分支的数量为参数化且每个分支内都可以写成统一的参数化形式时，就可以可以用 for 来代替 case。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#!&lt;/span&gt;&lt;span class="n"&gt;systemverilog&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux&lt;/span&gt;
&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;comb&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="package"&gt;Package&lt;/h2&gt;
&lt;p&gt;SV 引入的新方法，将公有定义放到 package 中，供 module 内部使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 公共定义几种在一个文件中，方便管理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 修改可配置参数，要修改 submodule 的源代码&lt;/p&gt;
&lt;h2 id="package-port-parameter"&gt;Package + Port Parameter&lt;/h2&gt;
&lt;p&gt;综合 Package 和 Port Paramter 的优点，具体方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 package 中将 meta 和 generated 参数各自定义成一个 struct&lt;/li&gt;
&lt;li&gt;在 package 中给出 default meta 和 default generated&lt;/li&gt;
&lt;li&gt;每个 module 端口使用 struct 参数（解决 parameter list 冗长问题）&lt;/li&gt;
&lt;li&gt;在 top 中计算重载过的 generated 参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 避免了冗长的 parameter list，且 parameter 定义集中在一起，方便管理；无作用域问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; parameter 仍然要层层传递，但 parameter list 仅包含 meta 和 generated，相对较少&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;systemverilog&lt;/span&gt;
&lt;span class="c1"&gt;// foo-pkg.sv&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// meta paramter&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="nx"&gt;Length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="nx"&gt;Width&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cfg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// generated paramter&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;packed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="nx"&gt;Area&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="nx"&gt;Perimeter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;cfg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cfg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DefaultCfg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;Length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;Width&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nx"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;gen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;cfg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;GenCfg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;Area&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DefaultCfg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DefaultCfg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nx"&gt;Perimeter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;DefaultCfg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Length&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;DefaultCfg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;endpackage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="ch"&gt;#!systemverilog&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sv&lt;/span&gt;
&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;#(&lt;/span&gt;
    &lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;cfg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;Cfg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DefaultCfg&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;localparam&lt;/span&gt; &lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cfg&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;GenCfg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&lt;/span&gt;
        &lt;span class="n"&gt;Area&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cfg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Length&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Cfg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Width&lt;/span&gt;
        &lt;span class="n"&gt;Perimeter&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cfg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Length&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Cfg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt; 

    &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="c1"&gt;#(&lt;/span&gt;
        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Cfg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cfg&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GenCfg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GenCfg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;BAR&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;
    &lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;写了个小实验 module 测试了一下这种用法，verilator 编译是没有问题的，但是 iverilog 对 sv 的支持实在是太差了，编译会报错。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="scripts"&gt;Scripts&lt;/h2&gt;
&lt;p&gt;有些复杂且规律的模块，如 meory wrapper 等可以用脚本自动化生成。包括某些顶层的配置，也可以用 make 等工具自动化生成相关配置文件和代码。&lt;/p&gt;
&lt;h3 id="adnes"&gt;Adnes&lt;/h3&gt;
&lt;p&gt;Andes 的配置工具提供一个友好清晰的图形界面，点击相关配置后就会生成 config.inc 文件，其中包含了根据配置生成的 define 和 parameter，然后被每个 sv 文件所包含。&lt;/p&gt;
&lt;h3 id="sifive"&gt;Sifive&lt;/h3&gt;
&lt;p&gt;Sifive 提供一个基于网页的图形化配置界面，同样可以生成相关配置文件和代码。&lt;/p&gt;
&lt;h3 id="westdegitial"&gt;WestDegitial&lt;/h3&gt;
&lt;p&gt;WestDegital 的开源 risc-v core 使用 config/Make 的方式，首先运行 config 文件，通过命令行参数的方式进行自定义配置，会自动生成相关配置文件，包括：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;#&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nv"&gt;text&lt;/span&gt;
&lt;span class="nv"&gt;snapshots&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;default&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;common&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;defines&lt;/span&gt;.&lt;span class="nv"&gt;vh&lt;/span&gt;&lt;span class="w"&gt;                       &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;`&lt;span class="nv"&gt;defines&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;testbench&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;design&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;defines&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt;                               &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;#&lt;span class="nv"&gt;defines&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nv"&gt;assembly&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;headers&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;pd&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;defines&lt;/span&gt;.&lt;span class="nv"&gt;vh&lt;/span&gt;&lt;span class="w"&gt;                           &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;`&lt;span class="nv"&gt;defines&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;physical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;design&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;perl&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;configs&lt;/span&gt;.&lt;span class="nv"&gt;pl&lt;/span&gt;&lt;span class="w"&gt;                         &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Perl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nv"&gt;configs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;hash&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;scripting&lt;/span&gt;
├──&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;pic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;map&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;auto&lt;/span&gt;.&lt;span class="nv"&gt;h&lt;/span&gt;&lt;span class="w"&gt;                          &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;PIC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;memory&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;based&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;on&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;configure&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;size&lt;/span&gt;
└──&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;whisper&lt;/span&gt;.&lt;span class="nv"&gt;json&lt;/span&gt;&lt;span class="w"&gt;                            &lt;/span&gt;#&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;JSON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;swerv&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;iss&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://book.douban.com/subject/26612391/"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="configurable design"></category></entry><entry><title>Verilog 的 case 小结</title><link href="https://qian-gu.github.io/posts/ic/summary-of-case-in-verilog.html" rel="alternate"></link><published>2015-04-15T15:50:00+08:00</published><updated>2015-04-15T15:50:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-04-15:/posts/ic/summary-of-case-in-verilog.html</id><summary type="html">&lt;p&gt;总结 case 的用法和需要注意的细节&lt;/p&gt;</summary><content type="html">&lt;p&gt;学习了 Cummings 大神 的 paper：&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston-FullParallelCase.pdf"&gt;"full-case parallel-case", the Evil Twins of Verilog Synthesis&lt;/a&gt; 和 &lt;a href="http://www.phei.com.cn/module/goods/wssd-content.jsp?bookid=38848"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结一下笔记。&lt;/p&gt;
&lt;h2 id="def"&gt;Def&lt;/h2&gt;
&lt;h3 id="syntax"&gt;Syntax:&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;case (case-expression)
 case-item1 : case-item-statement1;
 case-item2 : case-item-statement2;
 case-item3 : case-item-statement3;
 case-item4 : case-item-statement4;
 default : case-item-statement5;
endcase
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;等价于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;expression&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;===&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item1&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;statement1&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;expression&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;===&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item2&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;statement2&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;expression&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;===&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item3&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;statement3&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;expression&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;===&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item4&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;statement4&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;                                     &lt;/span&gt;&lt;span class="nv"&gt;case&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;item&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;statement5&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先说明一些基本名词的定义：&lt;/p&gt;
&lt;h3 id="case-statement-header"&gt;Case statement header&lt;/h3&gt;
&lt;p&gt;header 由 关键字 &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;casex&lt;/code&gt;/&lt;code&gt;casez&lt;/code&gt; + case expression 两部分组成，它们通常写在同一行（上面语法的第一行）。添加 "parallel-case" 或者 "full-case" 综合指令的方法就是把指令当作注释写在 header 的那一行，后续 case item 之前。&lt;/p&gt;
&lt;h3 id="case-expression"&gt;Case expression&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt; 关键字之后，括号中间的内容。它可以是一个常量（如 '1'），也可以是一个表达式，或者更常见的一个 1 bit / n bits 的向量，用来和后面的 case item 做比较。&lt;/p&gt;
&lt;h3 id="case-item"&gt;Case item&lt;/h3&gt;
&lt;p&gt;可以是单比特、向量、表达式，用来和 case expression 做比较。和高级编程语言（C 语言）不同的是，verilog 中的 case 自带隐含的 &lt;code&gt;break&lt;/code&gt; 语句，所以就不用再费心多写代码了。&lt;/p&gt;
&lt;h3 id="case-item-statement"&gt;Case item statement&lt;/h3&gt;
&lt;p&gt;case item 内的语句，多于 1 句时，要用 &lt;code&gt;begin-end&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="case-default"&gt;Case default&lt;/h3&gt;
&lt;p&gt;默认分支，虽然这个分支不是强制要求的，但是在所有分支后面加上 default 分支是一个良好的编程习惯。&lt;/p&gt;
&lt;h3 id="casez"&gt;Casez&lt;/h3&gt;
&lt;p&gt;case 语句的变种，casez 把 expression 或者是 item 中的 "z"/"?" 忽略，当作不关心的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Exercise caution when coding synthesizable models using the Verilog casez statement&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coding Style Guideline:&lt;/strong&gt; When coding a case statement with "don't cares," use a casez statement
and use "?" characters instead of "z" characters in the case items to indicate "don't care" bits.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="casex"&gt;casex&lt;/h3&gt;
&lt;p&gt;类似于 casez，不关心的值为 "z" / "?" / "x"。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Do not use casex for synthesizable code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="process"&gt;Process&lt;/h3&gt;
&lt;p&gt;case 的执行过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算 case expression，只计算一次，然后按照代码顺序从上向下和 case item 逐个比较&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较过程中，如果有 default 分支，则暂时先忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有某个 item 和 expression 匹配，则执行此 item 下的语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果匹配失败，有 default 分支，则执行该 default 分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果匹配失败，没有 default 分支，则终止&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个按照顺序比较的过程就是可能导致 priority encoder 的原因。&lt;/p&gt;
&lt;h3 id="reverse-case"&gt;reverse case&lt;/h3&gt;
&lt;p&gt;reverse case 是 case 的一个变形，也叫做 &lt;code&gt;case if true&lt;/code&gt;。这种风格中 case expression 是一个常量，而 case items 是由变量构成的表达式。这种风格通常用在 One-hot FSM 中，并且采用 parallel 方式。&lt;/p&gt;
&lt;p&gt;见另外一篇博客：&lt;a href="http://guqian110.github.io/pages/2014/06/05/fsm-design.html"&gt;有限状态机设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面讨论 full-case 和 parallel-case 的相关问题。很多人都会使用这两个综合指令，他们的理由是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;"full-case parallel-case" makes my designs smaller and faster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"full-case" removes latches from my designs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"parallel-case" removes large, slow priority encoders from my designs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而这些理由都不够准确或者说是危险的，因为这两个综合指令有时候完全不影响设计，有时候反而会使设计速度变慢、面积变大，有时候甚至会改变设计的功能。&lt;strong&gt;通常，这些指令都很危险。&lt;/strong&gt; 所以，Cummings 给他的 paper 起了如下的别名 ...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An alternate title for this paper could be: "How to add $200,000 to the cost and 3-6 months to the schedule of your ASIC design without trying!"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="full-case-statement"&gt;"full" case statement&lt;/h2&gt;
&lt;p&gt;"full" 的意思就是 expression 的任何取值都有一个 item/default 分支与其对应，否者就不是 "full case"。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1: Non-"full" case&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux3a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在这个例子中，当 sel 的取值是 2'b11 时，由于没有定义输出值 y 为多少，仿真器会保持之前的取值，综合器会综合出一个 latch。&lt;/p&gt;
&lt;p&gt;（基于 Virtex-4 器件，XST 的 synthesis report 给出的结果是 1 bit latch + 1 bit 3-to-1 multiplexers）&lt;/p&gt;
&lt;h3 id="hdl-full-case"&gt;HDL full case&lt;/h3&gt;
&lt;p&gt;从 HDL 仿真器的角度看，full case 语句就是 case item 包含了 expression 可以取的任何值。&lt;/p&gt;
&lt;h3 id="synthesis-full-case"&gt;Synthesis full case&lt;/h3&gt;
&lt;p&gt;从综合工具的角度看，full case 语句就是 expression 的每种可能的取值组合都被包含在 item 中。&lt;/p&gt;
&lt;p&gt;虽然 Verilog 语法不要求 case 语句必须是 HDL full 或者 synthesis full ，但是我们可以通过手动添加一个 default 分支来使得 case 变为 full。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2: "full" case&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux3a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在这个例子中，因为有了 default 分支，所以它是一个 full case。在仿真时，如果 sel 是 2'b11，那么 y 取值为 x（不确定，unknown），而综合器会把 x 当作 “ 不关心 ”（don't care，有可能为 1，也有可能为 0）。这就导致了仿真和综合不一致。解决这个问题的方法就是给 y 赋值一个常数 or 像其他 item 一样赋值一个输入。&lt;/p&gt;
&lt;p&gt;（基于 Virtex-4 器件，XST 的 synthesis report 给出的结果是 1 bit 3-to-1 multiplexers）&lt;/p&gt;
&lt;p&gt;P.S. 我们可以利用前后仿真不同这一点来帮助我们调试。在设计 FSM 时，default 分支处，next-state 赋值为 x，这样如果存在错误转换，next-state 就会保持为 x，在波形上很方便看到。&lt;/p&gt;
&lt;p&gt;还有一种方法是在所有的 item 之前，给输出赋一个默认值，这样即使不是 full，也不会产生 latch：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="xst-full-case"&gt;XST full case&lt;/h3&gt;
&lt;p&gt;综合指令是一些特殊的可以被综合工具识别，并指导综合工具工作的语句。不同的综合工具的综合指令语法不相同。我用的是 ISE 自带的 XST。查看 XST User Guide 就可以找到 full case 的相关指令：&lt;/p&gt;
&lt;p&gt;这个指令与架构（Architecture）无关、只适用于 verilog 的 case 语句：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只对 Verilog 有效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识所有的取值都被包含在 item 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻止 XST 对那些没有被包含的情况生成额外的电路&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用这个指令的方法有很多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Verilog Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;(* full-case *)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 case header 的上面一行&lt;/p&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// synthesis full-case&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方式，注释必须在 case header 的同一行&lt;/p&gt;
&lt;p&gt;example3:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;full-case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*)&lt;/span&gt;
&lt;span class="nt"&gt;casex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;select&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;b1xxx&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;bx1xx&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;bxx1x&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;bxxx1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;example4:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;casex&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;synthesis&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;full-case&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;b1xxx&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;bx1xx&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;bxx1x&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;4&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt;&lt;span class="nt"&gt;bxxx1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;res&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;data4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST Command Line&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xst run -vlgcase [full|parallel|full-parallel]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ISE Design Suit&lt;/p&gt;
&lt;p&gt;Process &amp;gt; Process Properties &amp;gt; Synthesis Options &amp;gt; Full Case.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 XST User Guide 中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XST automatically determines the characteristics of the case statements and generates
logic using multiplexers, priority encoders, and latches that best implement the exact
behavior of the case statement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，如果我们不添加综合指令，XST 会根据代码自动判断，选择 MUX、priority encoder、latch 来生成最合适的实现电路。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果生成 MUX，那么 synthesis report 在 Macro Recognition 步骤中会给出 MUX  macro 的内容&lt;/p&gt;
&lt;p&gt;注意，XST 是否会把 case 推译成 MUX，还取决于器件。对于 LUT4-based 器件，如果输入端口是 4 个，输出是 1 个，那么就会推译出 MUX；对于 LUT6-based 的器件，如 Virtex-5，那么需要输入端口是 8 个以上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果生成 Latch，那么 synthesis report 会给出 warning（只要生成 latch，不管是设计有意还是设计失误无意产生的，都会给出 warning，毕竟 latch 是很容易导致错误的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如上面的例子，如果改成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;@*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;(*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;full-case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;sel&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b00: y = a;&lt;/span&gt;
&lt;span class="s1"&gt;        2&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;b&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;span class="nt"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;@*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;sel&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;synthesis&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;full-case&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b00: y = a;&lt;/span&gt;
&lt;span class="s1"&gt;        2&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;b&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;span class="nt"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么就只会生成 1 bit 3-to-1 multiplexers，不会有多余的 latch。&lt;/p&gt;
&lt;p&gt;虽然这些指令有好处，但是一定要谨慎使用，而且使用时需要注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这些综合指令只对综合工具有用，仿真工具会自动忽略这些指令，所以有可能造成前后仿真不一致的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有时候使用指令，会适得其反，导致结果面积变大、速度变慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般有迷信的说法：“ 使用 full case 指令，可以消除 latch。” 这个说法太绝对了，事实上并不总是这样。如果有多个输出需要赋值，而有些分支只忽略了一些赋值，那么即使使用 full-case 指令，也不能避免 latch 的产生。&lt;/p&gt;
&lt;p&gt;举例，在下面的例子中，仍然会产生 latch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nt"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;@*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;casez&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;sel&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;synthesis&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;full-case&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b100: y1 = 3&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b100&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b010: y1 = 3&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b010&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b001: y2 = 3&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;b001&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;endcase&lt;/span&gt;
&lt;span class="nt"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们使用 full case 指令的目的就是为了避免生成意外的 latch，但是这种方法有以上的各种弊端。其实还有一种更加简单的方法来避免 latch，就是前面说的，&lt;strong&gt;在 case 前，给所有的输出赋一个默认值。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="parallel-case-statement"&gt;"parallel" case statement&lt;/h2&gt;
&lt;p&gt;"parallel" 的意思就是 expression 的取值每次有且只有一个 item 与其对应，否则就不是 "parallel" case，而匹配的 items 称为 "overlapping" case items。&lt;/p&gt;
&lt;h3 id="non-parallel-case-statements"&gt;Non-parallel case statements&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;@sel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;casez&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b1??: y = 3&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b?1?: y = 3&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b010&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b??1: y = 3&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b001&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当输入是 3'b011, 3'b101, 3'b110, 3'b111 时，会有多个 item 与 expression 对应，所以不是 parallel 的，会综合出一个 priority encoder。&lt;/p&gt;
&lt;h3 id="parallel-case-statements"&gt;Parallel case statements&lt;/h3&gt;
&lt;p&gt;对上面的例子稍微修改一下，就得到了 parallel case：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;@sel&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;casez&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b1??: y1 = 1&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b01?: y2 = 1&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b001: y3 = 1&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="xst-parallel-case"&gt;XST parallel case&lt;/h3&gt;
&lt;p&gt;语法同 full case，只需要将 full-case 替换为 parallel-case 即可。如果 case 本来就是 parallel 的，那么这个指令就完全不起作用，只是一些额外的代码。&lt;/p&gt;
&lt;p&gt;不要故意使用 Non-parallel case 来推译 priority encoder，这是不好的编程习惯。如果我们的目的就是要生成 priority encoder，应该使用级联的 if-else 语句，这样更能表达意图。&lt;/p&gt;
&lt;p&gt;下面的这些 guideline 可以帮助我们避免 case 生成 priority encoder，从而避免前后仿真不一致：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Code all intentional priority encoders using if-else-if statements. It is easier for a typical design engineer to recognize a priority encoder when it is coded as an if-else-if statement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Case statements can be used to create tabular coded parallel logic. Coding with case statements is recommended when a truth-table-like structure makes the Verilog code more concise and readable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Examine all synthesis tool case-statement reports &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Change the case statement code, as outlined in the above coding guidelines, whenever the synthesis tool reports that the case statement is not parallel (whenever the synthesis tool reports "no" for "parallel-case")&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="synthesis-coding-styles"&gt;Synthesis coding styles&lt;/h2&gt;
&lt;p&gt;在总结了 full-parallel-case 之后，Cummings 大神给出了建议：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sunburst Design Assumption: it is generally a bad coding practice to give the synthesis tool
different information about the functionality of a design than is given to the simulator.&lt;/p&gt;
&lt;p&gt;Guideline: In general, do not use "full-case parallel-case" directives with any Verilog case
statements.&lt;/p&gt;
&lt;p&gt;Guideline: There are exceptions to the above guideline but you better know what you're doing if
you plan to add "full-case parallel-case" directives to your Verilog code.&lt;/p&gt;
&lt;p&gt;Guideline: Educate (or fire) any employee or consultant that routinely adds "full-case
parallel-case" to all case statements in their Verilog code, especially if the project involves the
design of medical diagnostic equipment, medical implants, or detonation logic for thermonuclear
devices!&lt;/p&gt;
&lt;p&gt;Guideline: only use full-case parallel-case to optimize onehot FSM designs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;甚至建议要开除写 full-parallel-case 的员工 ...&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;总结一下所有的 guidelines：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Exercise caution when coding synthesizable models using the Verilog casez statement&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Do not use casex for synthesizable code&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; In general, do not use "full-case parallel-case" directives with any Verilog case
statements.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; There are exceptions to the above guideline but you better know what you're doing if you plan to add "full-case parallel-case" directives to your Verilog code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Code all intentional priority encoders using if-else-if statements. It is easier for a typical design engineer to recognize a priority encoder when it is coded as an if-else-if statement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Coding with case statements is recommended when a truth-table-like structure makes the Verilog code more concise and readable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Examine all synthesis tool case-statement reports.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Change the case statement code, as outlined in the above coding guidelines, whenever the synthesis tool reports that the case statement is not parallel (whenever the synthesis tool reports "no" for "parallel-case").&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; only use full-case parallel-case to optimize onehot FSM designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coding Style Guideline:&lt;/strong&gt; When coding a case statement with "don't cares," use a casez statement and use "?" characters instead of "z" characters in the case items to indicate "don't care" bits.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Educate (or fire) any employee or consultant that routinely adds "full-case parallel-case" to all case statements in their Verilog code.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion:&lt;/strong&gt; "full-case" and "parallel-case" directives are most dangerous when they work! It is better to code a full and parallel case statement than it is to use directives to make up for poor coding practices.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston-FullParallelCase.pdf"&gt;"full-case parallel-case", the Evil Twins of Verilog Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.phei.com.cn/module/goods/wssd-content.jsp?bookid=38848"&gt;Verilog 编程艺术&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="case"></category></entry><entry><title>不想当司机的厨子不是好码农 —— 读《浪潮之巅》</title><link href="https://qian-gu.github.io/posts/book/on-top-of-tides-review.html" rel="alternate"></link><published>2015-03-27T21:45:00+08:00</published><updated>2015-03-27T21:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-27:/posts/book/on-top-of-tides-review.html</id><summary type="html">&lt;p&gt;以前在 CSDN 上面写下的胡言乱语，现在看来最大的感触当时怎么那么天真，或者说 幼稚...&lt;/p&gt;</summary><content type="html">&lt;p&gt;暑假加上开学的一段时间看完了《浪潮之巅》，感触颇大 ... 好不容易等到期末放假回家了，记录下一点笔记，希望几年之后毕业的时候还可以坚持这份近乎无知的单纯，老子当年也是一腔热血，准备创业的人 -.-&lt;/p&gt;
&lt;h2 id="_1"&gt;关于作者&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;作者吴军，男，清华大学计算机系（本科）和电子工程系（硕士），并于 1993-1996 年在清华任讲师。他于 1996 年起在美国约翰霍普金斯大学攻读博士，并于 2002 年获得计算机科学博士学位。在清华和约翰霍普金斯大学期间，吴军博士致力于语音识别、自然语言处理，特别是统计语言模型的研究。他曾获得 1995 年的全国人机语音智能接口会议的最佳论文奖和 2000 年 Eurospeech 的最佳论文奖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是书封面内侧的作者介绍，同时我找到了他在 Google 上的&lt;a href="https://sites.google.com/site/junwu02"&gt;个人主页&lt;/a&gt;。不得不说同样是人，同样是学生，人和人的差距怎么这么大呢？&lt;/p&gt;
&lt;p&gt;人生就是不停在分岔路口进行选择，而且，根据前面的选择，后来可以面对的选择也是不同的（不知道是否满足马尔科夫性 ...），只是，有的人越走越 nb，而有的人则走偏了，成为了逗 b。大家都是从小学开始，有的人从小就是乖孩子，用现在流行的话说就是 “ 别人家的孩子 ”，学习好，嘴巴甜。什么老师、家长、叔叔、阿姨都喜欢的要死；而有的人打架，跷课，是个 “ 问题王 ”。不过，我觉得小时候还是调皮一点比较好，人生苦短，抓紧时间玩耍才好。借用吴军博士在个人主页上的一句话&lt;strong&gt;“ 我不喜欢做什么，由于生命有限，很多不重要的事只好不做了。”&lt;/strong&gt; 只是，他把节省下来的时间学习，钻研，而我却用来玩，甚至现在还在玩，自责 ing...&lt;/p&gt;
&lt;p&gt;貌似扯的越来越远，严重跑题了。对不起我的语文老师啊&lt;/p&gt;
&lt;p&gt;总之，一句话，NB 的人各有各的 NB，而逗 B 们大体都有相似的硬伤，比如 IQ or EQ。已经走错 N 次路口的我们还有救，能做的就是学习 NB 的人为何这么牛，然后尽量变得和他们一样牛，至少不再那么逗 B。&lt;/p&gt;
&lt;h2 id="_2"&gt;浪潮之巅&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;近一百多年来，总有些公司很幸运地、有意识或无意识地站在技术革命的浪尖之上。一旦处在了那个位置，即使不做任何事情，也可以集随波浪顺顺当当地向前漂十几年，甚至更长的时间。在这十几年到几十年间，它们代表着科技的浪巅，直到下一波浪巅的来临。从一百多年前算起，AT&amp;amp;T、IBM 公司、苹果（Apple）公司、英特尔（Intel）公司、微软（Microsoft）公司、思科（Cisco）公司、雅虎（Yahoo!）公司和 Google 公司，或许还有接下来的 Facebook 公司，都先后被幸运地推倒了浪尖。&lt;br&gt;
......&lt;br&gt;
虽然对于一个公司来讲，赶上一次浪潮不能保证它长盛不衰，但是，对于一个人来讲，一生赶上这样的一次浪潮就够了。对于一个弄潮的年轻人来讲，最幸运的莫过于赶上一波浪潮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看完了《浪潮之巅》，作为职业码农，表示收获很大。我对于 AT&amp;amp;T、IBM 公司的认识不再那么肤浅，他们经历的兴衰成败，取得今天的成就是多么的不容易；了解了 IT 领域的罗马帝国 —— 微软公司是如何在十几年间建成罗马的；纵观摩托罗拉、雅虎、SUN、网景等公司的历史，知道了现实中的差之毫厘，失之千里，为他们与机会失之交臂而扼腕叹息 ... &lt;/p&gt;
&lt;p&gt;总结以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我想通了 CEO 的工资那么高的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以前总觉得当 CEO 最舒服了，不用思考那些很枯燥的技术问题，每天开会吃饭就能挣到可观的收入，而且走到哪都受人尊敬。现在明白了其实并不是这样，其实他们的压力更大，当好一名 CEO 的难度很大，他们肩负着更大的责任，他们得设计整个公司的战略，同时对股东和员工们负责，所以高薪是他们应得的。一个工程师在技术上的失误可以通过各种方法来补救，但是一个不乘职的 CEO 会毁掉一家公司，机会都是给有准备的人的，一旦失去，很难遇到下次。纵观书里面的公司，他们大多经历过低谷和巅峰，当 CEO 决策失误时，有可能导致公司由巅峰走向低谷，甚至破产。这时候，如果遇到一个英明乘职的 CEO，他们可以把公司从破产的边缘挽救回来，比如惠普公司的 CEO 马克 · 赫德，GE 公司的韦尔奇，IBM 的郭士纳等等，而遇到一个糟糕的 CEO，那只能准备关门或者别人来收购了 ...&lt;/p&gt;
&lt;p&gt;乔布斯在库比蒂诺市的议会上说他的目标不是在福布斯排行榜上排到多少名，或者有多大的名气，而是想办一家传奇公司，这家公司可以一直长盛不衰，比如像惠普一样。排除他恭维市政府官员的因素，根据《乔布斯传》来看，他看中的的确不是金钱和名利。自从他去世，人们就在不停的讨论苹果公司是不是在走下坡路，甚至什么时候衰败为可以被别人收购的二流公司，一如当年乔布斯离开的时候。作为 “ 伪果粉 ” 但愿苹果还能保持他们的独特的魅力。可见成为一名英明的 CEO 是多么的艰难，CEO 对公司又是多么的重要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机工业的生态链&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IT 产业是不断变化的，并且有着它自身发展规律，这些规律被总结成为定律（IT Lows）。以前只知道摩尔定律（Moore's Low），最想不通的一件事就是为什么芯片的集成度每 18 个月就翻一番，而我的电脑却越来越慢，甚至不如 n 年以前的电脑。现在知道了安迪 - 比尔定律（Andy and Bill's Low），终于明白了为什么微软的系统越做越臃肿，为什么现在的程序员们不像以前那么精打细算了。用户很反感新软件把硬件提升带来的好处几乎全部消耗光，但是，各个硬件厂商恰恰是靠软件开发商用光自己提供的硬件资源而得以生存，否则就没人愿意花钱买新机器了，旧的已经满足需求了。&lt;/p&gt;
&lt;p&gt;了解了产业链结构，许多以前想不通的事也就变得顺理成章。自身的知识决定了眼界啊。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公司运作方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在搞技术的人眼中，运作公司，搞金融和财务是一件和编代码完全不同的事，应该有很深的门道在里面，很容易产生一种想法：“ 学技术的人都有着不同程度的自闭倾向，我更适合和机器打交道。我不是学管理和财务的，创业、办公司这种事和我绝缘。” 至少以前我一直是这么认为的。虽然这本书在介绍公司制度，运作方式等方面不是很全面也不权威，但是它给我最深的印象就是 “ 搞技术的人也可以办公司，而且可以办的很好 ”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;科学家在人们心目中一直是带着厚厚镜片，言语木讷，不食人间烟火，在英语中叫 Nerd。其实不然，书中很多我们看到的科学家，都是商业上非常敏锐的人，而很多商业巨子，自己就是科学家。  &lt;/p&gt;
&lt;p&gt;人的商业知识和眼光不是天生的，需要不断地、有心地学习。Google 早期的时候，创始人拉里 · 佩奇经常一边和我们一起吃饭，一边研究着某个公司的财务报告，一边和我们谈他的体会。Google 不少早期的员工后来成了成功的创始人和投资人，其中包括 Twitter 的创始人威廉姆斯。而佩奇自己也从一个技术专家成长为商业奇才。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一家典型的美国科技公司的成长史，一般都是创始人有着独特的技术或者眼光、点子，和好朋友合伙办一家小公司，然后逐渐成长，自己主动去找风投或者做的足够好，风投主动找他们，然后公司规模越来越大，成立董事会，寻找合适的 CEO，接着就是上市 IPO 等等。不知道在中国办公司是什么样子的呢？以后得多看点别的书，涨姿势了 ...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商业模式、公司基因、中国、天使投资&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于创业，书里面有一个很重要的概念就是 “ 商业模式 ”。比如你准备去找红杉资本，对方首先就问你的商业模式是什么，如果在 5 分钟之内还是解释不清，估计也就没有机会了。商业模式一定要简单，不能太复杂。喝多公司的成功其实是商业模式的成功，比如 Dell 的 “ 直销模式 ” 和 Google 的广告商业模式等等。可以说，一个好的商业模式就是一台印钞机。&lt;/p&gt;
&lt;p&gt;还有就是 “ 公司基因 ”，这个很大程度上由创始人和他们的业务决定的。有的公司基因中就存在着创新，比如 3M 公司，Google 等，他们可以很快的转型，做出更多的产品，保持公司的业绩；而有的公司则天生没有这种基因，比如 “ 蓝色巨人 ” IBM，他们以大型机、系统和服务为核心，很难在 PC 市场获得成功。&lt;/p&gt;
&lt;p&gt;作为金融小白，只知道红杉资本，KPCB 等有名的 VC，而国内的则不是很了解了，只知道李开复、薛蛮子、雷军、王啸等人。我们学校毕业没有找工作而去创业的人不是没有，但是也不多。考虑到大环境，我觉得应该还是不错的。作为一个 211，连 985 都不是的学校，而且学校的状况真的是每况愈下，真的替学校捉鸡，毕竟，母校就是一个自己可以随意嫌弃，但是别人不能说一句不好的地方。&lt;/p&gt;
&lt;p&gt;因为不想写报告，闲的无聊才写的，没想到我竟然这么能扯。此刻还有大干一番事业的雄心壮志，所谓出生牛犊不怕虎，估计到毕业的时候了解的多了，也就没有那个胆量去创业了，找一份自认为还不错的工作，这辈子就奉献给郭嘉了 ...&lt;/p&gt;
&lt;p&gt;想想真的是 &lt;strong&gt;“ 我不喜欢做什么，由于生命有限，很多不重要的事只好不做了。”&lt;/strong&gt;，以后不能再这么浑浑噩噩下去了，找一些自己感兴趣的、重要的事，坚持做下去，每天进步一小点的感觉其实要比打游戏好的多。&lt;/p&gt;</content><category term="Book"></category><category term="review"></category><category term="On Top of Tides"></category></entry><entry><title>静态时序分析 STA 2 —— Xilinx STA</title><link href="https://qian-gu.github.io/posts/ic/static-timing-analysis-2-xilinx-sta.html" rel="alternate"></link><published>2015-03-22T00:00:00+08:00</published><updated>2015-03-22T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-22:/posts/ic/static-timing-analysis-2-xilinx-sta.html</id><summary type="html">&lt;p&gt;总结 Xilinx 时序约束的一些基本内容&lt;/p&gt;</summary><content type="html">&lt;p&gt;*&lt;em&gt;总结 Xilinx 时序约束的一些基本内容，基本上是 &lt;a href="http://www.xilinx.com/support/documentation/sw-manuals/xilinx14-2/ug612.pdf"&gt;UG612 Timing Closure User Guide&lt;/a&gt; 的翻译和概括。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;P.S. 找到一篇 Xilinx 的文章，也很简洁实用：&lt;a href="http://china.xilinx.com/china/xcell/xl37/e10-14.pdf"&gt;赛灵思 FPGA 设计时序约束指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="xilinx-sta"&gt;Xilinx STA&lt;/h2&gt;
&lt;p&gt;按照路径所覆盖的范围，可以将时序路径要求分为 4 大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Input paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Register-to-register paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Output paths&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Path specific exceptions&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;添加约束最有效的方法就是先添加全局约束，然后根据需求考虑是否添加指定路径上的特殊约束。在很多案例中，只需要添加全局约束就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FPGA 器件执行工具都是由指定的时序要求驱动的。如果时序约束过头的话，就会导致内存使用增加，工具运行时间增加。更重要的是，过约束还会导致性能下降。因此，推荐使用实际设计要求的约束值。&lt;/p&gt;
&lt;p&gt;下面分别讨论每种路径上的约束。&lt;/p&gt;
&lt;h2 id="input-paths"&gt;Input paths&lt;/h2&gt;
&lt;p&gt;所谓 “ 输入路径 &lt;code&gt;input paths&lt;/code&gt;”，指的是从 “FPGA 外部引脚 ---&amp;gt; 内部读取这个数的寄存器 ” 之间的路径。&lt;/p&gt;
&lt;p&gt;在输入路径模型中，发送端是一个外部设备（当然也可以是 FPGA），接收端是 FPGA 芯片，输入路径讨论的就是以接收端的 FPGA 为视角，如何正确接收输入的数据。&lt;/p&gt;
&lt;p&gt;依据接口类型，可以将输入路径的时序分为 2 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;System Synchronous Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Source Synchronous Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而对于输入路径的约束方法就是使用 &lt;code&gt;OFFSET IN&lt;/code&gt; 来约束，它约束了 输入数据 和 用于捕获这个数据的时钟沿 之间的关系。（顾名思义，输入路径约束的是方向为 IN 的数据和时钟的相对偏移 OFFSET 的关系）&lt;/p&gt;
&lt;p&gt;下面分别对两类输入路径进行讨论：&lt;/p&gt;
&lt;h3 id="system-synchronous-inputs"&gt;System Synchronous Inputs&lt;/h3&gt;
&lt;p&gt;所谓 System Synchronous Inputs 其实就是指 “ 发送端 和 接收端 使用同一个系统（system）时钟 ”。布线延时和时钟倾斜会限制这种接口的工作时钟频率，由于这个原因，这种接口一般应用在 SDR 中。&lt;/p&gt;
&lt;p&gt;system synchronous SDR 应用示例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system synchronous SDR" src="/images/static-timing-analysis-2-xilinx-sta/system-synchronous-in-sdr.png"&gt;&lt;/p&gt;
&lt;p&gt;其时序为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发送器件在某个时钟的上升沿将数据发送出去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FPGA 在下一个时钟的上升沿捕获到数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于这种接口的时序，使用 &lt;code&gt;OFFSET IN&lt;/code&gt; 是最有效方便的添加约束的方法。对于接口中的每个时钟，都有一个对应的 offset in 约束，这个约束覆盖了所有的使用该时钟来捕获输入数据的路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加约束的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先对接口的时钟添加周期约束（period constraint）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 其次为接口添加全局 offset in 约束（global Offset In）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;OFFSET = IN value VALID value BEFORE clock;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OFFSET=IN &lt;value&gt; 约束了数据变有效的沿和时钟的捕获数据的沿之间的距离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VALID &lt;value&gt; 约束了数据保持有效的时间长度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 1. 在下面理想的 system synchronous SDR interface 时序图中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example1" src="/images/static-timing-analysis-2-xilinx-sta/example1.png"&gt;&lt;/p&gt;
&lt;p&gt;数据在时钟沿的前 5 ns 变为有效，并且保持了 5 ns 时间，所以在这个实例中的时序约束应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;SysClk&amp;quot; TNM-NET = &amp;quot;SysClk&amp;quot;;
TIMESPEC &amp;quot;TS-SysClk&amp;quot; = PERIOD &amp;quot;SysClk&amp;quot; 5 ns HIGH 50%;
OFFSET = IN 5 ns VALID 5 ns BEFORE &amp;quot;SysClk&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而且这个约束对于 data1 和 data2 共同有效。&lt;/p&gt;
&lt;p&gt;例 2. 不是理想的 system synchronous SDR interface 中，假设时钟周期为 5 ns，并且占空比为 50%，数据在发送时钟上升沿之后的 500 ps 之后变有效，并且持续 4 ns。则时序约束应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;clock&amp;quot; TNM-NET = CLK; 
TIMESPEC TS-CLK = PERIOD CLK 5.0 ns HIGH 50%; 
OFFSET = IN 4.5 ns VALID 4 ns BEFORE clock;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="source-synchronous-inputs"&gt;Source Synchronous Inputs&lt;/h3&gt;
&lt;p&gt;所谓 Source Synchronous Inputs 其实就是指 “ 发送端重新生成一个时钟信号，并且将数据和时钟信号有着相似的布线，两者的延时基本相同，在接收数据的 FPGA 端，使用这个时钟来捕获这个数据 ”。布线延时和时钟倾斜不再是限制这种接口工作速度的因素，所以这种接口一般应用在双倍数据速率的 DDR 中。&lt;/p&gt;
&lt;p&gt;source synchronous DDR 应用示例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="source synchronous SDR" src="/images/static-timing-analysis-2-xilinx-sta/source-synchronous-in-ddr.png"&gt;&lt;/p&gt;
&lt;p&gt;其时序为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;发送器件在某个时钟的上升沿和下降沿都会发送一个独立的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收端的 FPGA 使用发送端传递过来的这个再生时钟来捕获数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对于这种接口的时序，使用 &lt;code&gt;OFFSET IN&lt;/code&gt; 是最有效方便的添加约束的方法。对于接口中的每个时钟，都有一个对应的 offset in 约束，这个约束覆盖了所有的使用该时钟来捕获输入数据的路径。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加约束的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先对接口的时钟添加周期约束（period constraint）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 其次为时钟的上升沿添加全局 offset in 约束（global Offset In）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 最后为时钟的下降沿添加全局 offset in 约束（global offset in）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;OFFSET = IN value VALID value BEFORE clock RISING;
OFFSET = IN value VALID value BEFORE clock FALLING;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举例： &lt;/p&gt;
&lt;p&gt;例 3. 在下面理想的 source synchronous DDR interface 时序图中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example3" src="/images/static-timing-analysis-2-xilinx-sta/example3.png"&gt;&lt;/p&gt;
&lt;p&gt;输入时钟的周期为 5 ns，并且占空比为 50%，两 bit 的数据的有效时间都为 1/2 时钟周期，所以在这个实例中的时序约束应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;SysClk&amp;quot; TNM-NET = &amp;quot;SysClk&amp;quot;;
TIMESPEC &amp;quot;TS-SysClk&amp;quot; = PERIOD &amp;quot;SysClk&amp;quot; 5 ns HIGH 50%;

OFFSET = IN 1.25 ns VALID 2.5 ns BEFORE &amp;quot;SysClk&amp;quot; RISING;
OFFSET = IN 1.25 ns VALID 2.5 ns BEFORE &amp;quot;SysClk&amp;quot; FALLING;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例 4. 不是理想的 source synchronous DDR（数据和时钟的边沿对齐），假设时钟周期为 5 ns，并且占空比为 50%，上升沿和下降沿的数据都保持有效 2ns，并且位于时钟波形的高低电平的中间位置，也就是说，在数据有效的前后各有 250 ps 的空白。&lt;/p&gt;
&lt;p&gt;对于上升沿，因为数据相对于捕获它的时钟沿后了 250 ps，并且有效时间持续了 2 ns；对于下降沿，数据也沿后了 250 ps， 并且有效时间持续了 2 ns，所以时序约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;clock&amp;quot; TNM-NET = CLK; 
TIMESPEC TS-CLK = PERIOD CLK 5.0 ns HIGH 50%; 
OFFSET = IN -250 ps VALID 2 ns BEFORE clock RISING; 
OFFSET = IN -250 ps VALID 2 ns BEFORE clock FALLING
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例 5. 不是理想的 source synchronous DDR（数据和时钟的中间位置对齐），假设时钟周期为 5 ns，并且占空比为 50%，上升沿和下降沿的数据都保持有效 2 ns，并且时钟沿对齐数据的中间位置，可以得出结论，在数据有效的前后各有 250 ps 的空白。&lt;/p&gt;
&lt;p&gt;对于上升沿，因为数据相对于捕获它的时钟提前了 1 ns，并且有效时间持续了 2 ns；对于下降沿，数据也提前了 1 ns，并且有效时间持续了 2 ns，所以时序约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;clock&amp;quot; TNM-NET = CLK; 
TIMESPEC TS-CLK = PERIOD CLK 5.0 ns HIGH 50%; 
OFFSET = IN 1 ns VALID 2 ns BEFORE clock RISING; 
OFFSET = IN 1 ns VALID 2 ns BEFORE clock FALLING;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="register-to-register-paths"&gt;Register-to-register paths&lt;/h2&gt;
&lt;p&gt;这部分讨论寄存器 - 寄存器之间同步路径上的周期约束（period constraint）。&lt;/p&gt;
&lt;p&gt;period constraint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义了时钟域的时序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖了内部寄存器之间的同步数据路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析单个时钟域内的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析两个相关联的时钟域之间的所有路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在分析时考虑了时钟域之间的相位、频率、不确定性因素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步时钟域的约束可以分为以下 3 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Automatically Related Synchronous DLL, DCM, PLL, and MMCM Clock Domains&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Manually Related Synchronous Clock Domains&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Asynchronous Clock Domains&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;使用工具对 DCM、PLL 和 MMCM 的输出时钟自动添加时钟关系，并且手动定义外部的相关时钟的关系。通过这种方法，可以保证所有的跨时钟域的同步路径都被正确约束、分析，使用这种方法来添加 period constraint 可以避免再添加额外的跨时钟域约束。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="automatically-related-synchronous-dll-dcm-pll-and-mmcm-clock-domains"&gt;Automatically Related Synchronous DLL, DCM, PLL, and MMCM Clock Domains&lt;/h3&gt;
&lt;p&gt;最常见的时钟信号就是下面两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入到 DCM、PLL 或者是 MMCM 的时钟信号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从这些单元输出，用来驱动内部的同步路径的时钟信号&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐的约束方法是 &lt;strong&gt;对输入到 DCM、PLL 或者是 MMCM 的时钟信号添加周期约束（period constraint）。&lt;/strong&gt; 通过对输入时钟添加周期约束，Xilinx 工具会&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自动为 DCM、PLL 或者是 MMCM 的输出生成一个新的周期约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定输出时钟之间的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分析这些同步域之间的任何路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;ClockName&amp;quot; TNM-NET = &amp;quot;TNM-NET-Name&amp;quot;;
TIMESPEC &amp;quot;TS-name&amp;quot; = PERIOD &amp;quot;TNM-NET-Name&amp;quot; PeriodValue HIGH HighValue%;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PeriodValue 定义时钟周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HighValue 定义时钟的占空比&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 6. 在下图的例子中&lt;/p&gt;
&lt;p&gt;&lt;img alt="example6" src="/images/static-timing-analysis-2-xilinx-sta/example6.png"&gt;&lt;/p&gt;
&lt;p&gt;输入时钟连接到 DCM 的输入端，因为输入时钟的时钟周期为 5 ns，并且占空比为 50%，所以添加的约束为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;ClkIn&amp;quot; TNM-NET = &amp;quot;ClkIn&amp;quot;;
TIMESPEC &amp;quot;TS-ClkIn&amp;quot; = PERIOD &amp;quot;ClkIn&amp;quot; 5 ns HIGH 50%;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面的例子中，我们给出上面的约束条件之后，DCM 会自动为它的两个输出添加约束，并且分析这两个时钟域&lt;/p&gt;
&lt;h3 id="manually-related-synchronous-clock-domains"&gt;Manually Related Synchronous Clock Domains&lt;/h3&gt;
&lt;p&gt;在有些情况中，Xilinx 工具无法自动分析指定同步时钟域之间的关系（比如相关的时钟信号从两个不同的管脚输入进入到 FPGA），&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种情形下，Xilinx 推荐的约束方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为每一个输入时钟都创建一个周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 手动定义时钟之间的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦我们定义了时钟约束，工具会自动分析两个同步域之间的所有路径，并且在分析时会把频率、相位、不确定因素都考虑进去。&lt;/p&gt;
&lt;p&gt;Xilinx 的约束系统可以通过在周期约束中加入频率和相位信息来添加更加复杂的周期约束（complex manual relationship）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为主时钟定义周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 以主时钟的约束为参考，为其他的相关时钟添加周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;PrimaryClock&amp;quot; TNM-NET = &amp;quot;TNM-Primary&amp;quot;;
NET &amp;quot;RelatedClock&amp;quot; TNM-NET = &amp;quot;TNM-Related&amp;quot;;
TIMESPEC &amp;quot;TS-primary&amp;quot; = PERIOD &amp;quot;TNM-Primary&amp;quot; PeriodValue HIGH HighValue%;
TIMESPEC &amp;quot;TS-related&amp;quot; = PERIOD &amp;quot;TNM-Related&amp;quot; TS-Primary-relation PHASE value;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 related PERIOD 的约束中，PERIOD 的值定义了相关时钟和主时钟之间的关系（以时钟周期为单位），这种关系用主时钟的 TIMESPEC 形式来定义；PHASE 的值定义了主时钟和相关时钟的上升沿之间的关系。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 7. 如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="example7" src="/images/static-timing-analysis-2-xilinx-sta/example7.png"&gt;&lt;/p&gt;
&lt;p&gt;CLK2X180 的频率是 CLK1X 的 2 倍，所以 PERIOD 的值为 1/2；CLK2X180 的相位相比于主时钟，偏移了 180 度，所以它的上升沿比主时钟的上升沿晚了 1.25 ns；所以这个例子的约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;Clk1X&amp;quot; TNM-NET = &amp;quot;Clk1X&amp;quot;;
NET &amp;quot;Clk2X180&amp;quot; TNM-NET = &amp;quot;Clk2X180&amp;quot;;
TIMESPEC &amp;quot;TS-Clk1X&amp;quot; = PERIOD &amp;quot;Clk1X7 5 ns HIGH 50%;
TIMESPEC &amp;quot;TS-Clk2X180&amp;quot; = PERIOD &amp;quot;Clk2X180&amp;quot; TS-Clk1X/2 PHASE +1.25 ns;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="asynchronous-clock-domains"&gt;Asynchronous Clock Domains&lt;/h3&gt;
&lt;p&gt;异步时钟是指频率或相位有一个不同或者都不相同的时钟。因为时钟是不相关的，所以在进行 setup/hold time 分析时，是无法确定时钟的最终关系的。因此，&lt;strong&gt;Xilinx 推荐在设计时使用一些特殊的方法来确保数据能被正确捕获。&lt;/strong&gt;然而，有时候设计者希望不考虑频率和相位之间的关系，在孤立的条件下限制数据传输的最大时延。&lt;/p&gt;
&lt;p&gt;Xilinx 约束系统允许不考虑源和目的时钟之间的频率、相位关系，直接约束数据路径的最大时延。语法就是使用带 &lt;code&gt;DATAPATHONLY&lt;/code&gt; 关键字的 &lt;code&gt;From-To&lt;/code&gt; 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为源同步寄存器定义时钟组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 为目的同步寄存器定义时钟组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 用带 &lt;code&gt;DATAPATHONLY&lt;/code&gt; 关键字的 &lt;code&gt;From-To&lt;/code&gt; 来约束两个时钟域之间的最大数据时延&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;CLKA&amp;quot; TNM-NET = FFS &amp;quot;GRP-A&amp;quot;;
NET &amp;quot;CLKB&amp;quot; TNM-NET = FFS &amp;quot;GRP-B&amp;quot;;
TIMESPEC TS-Example = FROM &amp;quot;GRP-A&amp;quot; TO &amp;quot;GRP-B&amp;quot; Delay DATAPATHONLY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 8. 以前面的图为例，假设 CLKA 输入到第一个寄存器 R1，CLKB 输入到第二个寄存器 R2，R1 的输出连接到 R2 的输入，能忍受的最大的数据时延为 5 ns，则约束为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;CLKA&amp;quot; TNM-NET = FFS &amp;quot;GRP-A&amp;quot;;
NET &amp;quot;CLKB&amp;quot; TNM-NET = FFS &amp;quot;GRP-B&amp;quot;;
TIMESPEC TS-Example = FROM &amp;quot;GRP-A&amp;quot; TO &amp;quot;GRP-B&amp;quot; 5 ns DATAPATHONLY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="output-paths"&gt;Output paths&lt;/h2&gt;
&lt;p&gt;这部分讨论如何为输出路径添加约束。输出约束覆盖了从 “ 内部同步单元 / 寄存器 ---&amp;gt; FPGA 输出管脚 ” 之间的所有路径。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="output example" src="/images/static-timing-analysis-2-xilinx-sta/output-example.png"&gt;&lt;/p&gt;
&lt;p&gt;在输出路径模型中，发送端是 FPGA 芯片，接收端是一个外部设备（当然也可以是 FPGA），输入路径讨论的就是以发送端的 FPGA 为视角，如何将待发送定数据正确发送出去。&lt;/p&gt;
&lt;p&gt;和输入路径对应，输出路径使用 &lt;code&gt;OFFSET OUT&lt;/code&gt; 来约束以达到时序要求。&lt;/p&gt;
&lt;p&gt;OFFET OUT 定义了输出数据和将该数据发送到输出管脚的时钟之间的关系。OFFSET OUT 的分析会自动将影响输出数据 / 输出时钟的内部因素考虑在内：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;时钟的频率和相位畸变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟的不确定性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据时延的调整&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和输入路径类似，输出路径的时序要求也可以依据接口的类型（system/source synchronous）和数据速率（SDR/DDR）来分类讨论。&lt;/p&gt;
&lt;h3 id="system-synchronous-output"&gt;System Synchronous Output&lt;/h3&gt;
&lt;p&gt;在 system synchronous output 中，发送端和接收端使用同一个时钟，所以发送端的 FPGA 只需要发生数据部分就可以了。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="system synchronous output" src="/images/static-timing-analysis-2-xilinx-sta/system-synchronous-out.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于 system synchronous output 接口，使用全局 OFFSET OUT 是最有效的方法。每个 OFFSET OUT 都约束了一个对应的输出时钟，并且所有使用这个时钟来触发的输出数据路径都被这个约束所覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为输出时钟定义一个时钟名（TNM）来分组，这个时钟组包含了所有被这个时钟触发的输出寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 定义接口的全局 OFFSET OUT 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;OFFSET = OUT value AFTER clock;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code&gt;OFFSET = OUT &amp;lt;value&amp;gt;&lt;/code&gt; 规定了 “ 接收器件的输入时钟（= 发送端 FPGA 的时钟）上升沿 ---&amp;gt; 发送端 FPGA 输出数据变有效 ” 直接的最大时延。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 9. 如下图所示的 System Synchronous SDR output interface&lt;/p&gt;
&lt;p&gt;&lt;img alt="example9" src="/images/static-timing-analysis-2-xilinx-sta/example9.png"&gt;&lt;/p&gt;
&lt;p&gt;假设发送端的输出数据必须在时钟上升沿之后的 5 ns 内变为有效，则约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;ClkIn&amp;quot; TNM-NET = &amp;quot;ClkIn&amp;quot;;
OFFSET = OUT 5 ns AFTER &amp;quot;ClkIn&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="source-synchronous-output"&gt;Source Synchronous Output&lt;/h3&gt;
&lt;p&gt;在 source synchronous output interface，发送端的 FPGA 会重新生成一个时钟信号，并且将时钟信号和数据一起发送出去，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="source synchronous output" src="/images/static-timing-analysis-2-xilinx-sta/source-synchronous-out.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于 source synchronous output 接口，使用全局 OFFSET OUT 是最有效的方法。每个 OFFSET OUT 都约束了一个对应的输出时钟，并且所有使用这个时钟来触发的输出数据路径都被这个约束所覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 为输出时钟定义一个时钟名（TNM）来分组、，这个时钟组包含了所有被这个时钟触发的输出寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 为时钟上升沿添加 global Offset Out 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 为时钟下降沿添加 global Offset Out 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OFFSET = OUT &amp;lt;value&amp;gt;&lt;/code&gt; 约束了从 “ 输入时钟的上升沿 ---&amp;gt; 发送端 FPGA 输出端口数据变为有效 ” 的最大时延。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键词 &lt;code&gt;REFERENCE-PIN&lt;/code&gt; 约定以重新生成的时钟作为参考，输出数据的 skew 报告就是以这个时钟作为参考生成的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 10. 下图是一个理想的 Source Synchronous DDR interface 时序图&lt;/p&gt;
&lt;p&gt;&lt;img alt="example10" src="/images/static-timing-analysis-2-xilinx-sta/example10.png"&gt;&lt;/p&gt;
&lt;p&gt;时钟周期为 5 ns，并且占空比为 50%，数据保持有效的时间为 1/2 时钟周期。所以，这个示例的约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;ClkIn&amp;quot; TNM-NET = &amp;quot;ClkIn&amp;quot;;
OFFSET = OUT AFTER &amp;quot;ClkIn&amp;quot; REFERENCE-PIN &amp;quot;ClkOut&amp;quot; RISING;
OFFSET = OUT AFTER &amp;quot;ClkIn&amp;quot; REFERENCE-PIN &amp;quot;ClkOut&amp;quot; FALLING
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="path-specific-exceptions"&gt;Path specific exceptions&lt;/h2&gt;
&lt;p&gt;通过前面的 3 节的讨论，对输入、寄存器 - 寄存器、输出路径进行约束，大部分时序路径都得到了正确约束，然后在一些情况中，存在少数不适应于全局约束的少数路径，这些例外最常见的就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;False Paths (Paths Between Registers That Do Not Affect Timing)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multi-Cycle Paths&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论。&lt;/p&gt;
&lt;h3 id="false-paths-paths-between-registers-that-do-not-affect-timing"&gt;False Paths (Paths Between Registers That Do Not Affect Timing)&lt;/h3&gt;
&lt;p&gt;如果有些路径不影响时序性能，那么我们就可以将这些路径从时序分析中移除。&lt;strong&gt;最常用的方法就是使用带 time ignore (&lt;code&gt;TIG&lt;/code&gt;) 关键词的 &lt;code&gt;FROM-TO&lt;/code&gt; 约束。&lt;/strong&gt; 使用这种约束，可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从源时钟域指定一组寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从目标时钟域指定一组寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将源到目标域的路径从时序分析中移除&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 在源时钟域指定一组寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 在目标时钟域指定一组寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 使用带 TIG 关键词的 FROM-TO 来移除这两个域之间的路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TIMESPEC &amp;quot;TSid&amp;quot; = FROM &amp;quot;SRC-GRP&amp;quot; TO &amp;quot;DST-GRP&amp;quot; TIG;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 11. 假设下图中的两个寄存器之间的路径并不影响设计的时序，希望将这条路径从时序约束中移除&lt;/p&gt;
&lt;p&gt;&lt;img alt="example11" src="/images/static-timing-analysis-2-xilinx-sta/example11.png"&gt;&lt;/p&gt;
&lt;p&gt;则本例的约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;CLK1&amp;quot; TNM-NET = FFS &amp;quot;GRP-1&amp;quot;;
NET &amp;quot;CLK2&amp;quot; TNM-NET = FFS &amp;quot;GRP-2&amp;quot;;
TIMESPEC TS-Example = FROM &amp;quot;GRP-1&amp;quot; TO &amp;quot;GRP-2&amp;quot; TIG;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="multi-cycle-paths"&gt;Multi-Cycle Paths&lt;/h3&gt;
&lt;p&gt;在多周期路径中，从发送端到接收端的同步单元，数据以低于周期约束中的 PERIOD 速率传输。这种情况最常见的场景是同步单元使用一个共同的 clock enable 来门控。&lt;/p&gt;
&lt;p&gt;通过定义一个多周期路径（Multi-Cycle path），这些同步单元的约束条件会比默认的周期约束宽松很多。方法就是先给周期约束定义一个标识，然后再声明 Multi-Cycle path 包含多少个时钟周期。然后工具就可以合理分配这些路径的优先级。&lt;/p&gt;
&lt;p&gt;定义一个多周期路径的 &lt;strong&gt;最常用的方法就是用 clock enable 信号定义一个时钟组，这样我们就可以用这个 clock enable 来定义一个包含了源、目的寄存器的时钟组，然后将多周期约束应用到这些寄存器之间的路径上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 对公用时钟域进行周期约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 定义所有基于同一个 clock enable 信号的寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 对新的时序要求进行 From:To(Multi-Cycle) 约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;TIMESPEC &amp;quot;TSid&amp;quot; = FROM &amp;quot;MC-GRP&amp;quot; TO &amp;quot;MC-GRP&amp;quot; &amp;lt;value&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MC-GRP&lt;/code&gt; 定义了一组公用时钟的寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有从 &lt;code&gt;MC-GRP&lt;/code&gt; 开始，到 &lt;code&gt;MC-GRP&lt;/code&gt; 结束的路径就是需要进行多周期约束的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;例 12. 如下图所示的假设情形中&lt;/p&gt;
&lt;p&gt;&lt;img alt="example12" src="/images/static-timing-analysis-2-xilinx-sta/example12.png"&gt;&lt;/p&gt;
&lt;p&gt;两个寄存器直接的路径被一个共同点 clock enable 控制，并且 clock enable 的变化速率是时钟频率的一半。则本例的时序约束如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NET &amp;quot;CLK1&amp;quot; TNM-NET = &amp;quot;CLK1&amp;quot;;
TIMESPEC &amp;quot;TS-CLK1&amp;quot; = PERIOD &amp;quot;CLK1&amp;quot; 5 ns HIGH 50%;
NET &amp;quot;Enable&amp;quot; TNM-NET = FFS &amp;quot;MC-GRP&amp;quot;;
TIMESPEC TS-Example = FROM &amp;quot;MC-GRP&amp;quot; TO &amp;quot;MC-GRP&amp;quot; TS-CLK1*2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;通过对这四种类型的 timing path 进行约束，基本上系统内所有路径都得到了合理约束。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/sw-manuals/xilinx14-2/ug612.pdf"&gt;Timing Closure User Guide&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="STA"></category><category term="Xilinx"></category></entry><entry><title>静态时序分析 STA 1 —— 基础知识</title><link href="https://qian-gu.github.io/posts/ic/static-timing-analysis-1-basic.html" rel="alternate"></link><published>2015-03-18T00:00:00+08:00</published><updated>2015-03-18T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-18:/posts/ic/static-timing-analysis-1-basic.html</id><summary type="html">&lt;p&gt;静态时序分析 STA 系列之 1，基础知识。&lt;/p&gt;</summary><content type="html">&lt;p&gt;静态时序分析（Static Timing）是数字 IC 设计中不可避免的话题，也是一个菜鸟成长必须掌握的技术。本文先总结 STA 中常见的定义、名词等。&lt;/p&gt;
&lt;h2 id="clock"&gt;Clock&lt;/h2&gt;
&lt;p&gt;时钟是数字电路的动力系统，可以说数字电路中最重要的信号就是时钟信号了。一般时钟信号的时序特性分为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;偏移 Skew&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抖动 Jitter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;占空比时钟 Duty Cycle Distortion&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于低速设计，基本不用考虑这些特征，但是对于高速设计，由于时钟本身造成的问题越来越普遍，因此有必要关注高速设计中的时序特性。&lt;/p&gt;
&lt;h3 id="skew"&gt;Skew&lt;/h3&gt;
&lt;p&gt;时钟信号要提供给整个电路的时序单元，所以时钟信号线非常长，并构成分布式的 RC 网路。它的延时与时钟线的长度、时序单元的负载电容、个数有关，由于时钟线长度及负载不同，会导致时钟信号到达相邻两个时序单元的时间不同，这个时间上的偏差就是 时钟偏移 &lt;code&gt;Skew&lt;/code&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="skew" src="/images/static-timing-analysis-1-basic/skew.jpg"&gt;&lt;/p&gt;
&lt;p&gt;假设时钟信号达到两个 DFF 的延时分别为 Tc1 和 Tc2，用 Tskew 来表示它们之间的时钟偏移，则计算公式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Tskew = Tc2 - Tc1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据差值可以分为正偏移和负偏移：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当时钟到达 DFF1 的延时更大时，也就是 C1 &amp;gt; C2 时，Tskew 为正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当时钟到达 DFF2 的延时更大时，也就是 C1 &amp;lt; C2 时，Tskew 为负&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意到是，时钟偏移永远存在，当其大到一定程度时，就会严重影响电路的时序。&lt;/p&gt;
&lt;p&gt;FPGA 在设计架构时，专门针对这种现象进行优化，采用全铜工艺和树状结构，并且设计了专用的时钟缓冲和驱动网络，这么做的目的就是尽量使时钟到达不同时序单元的路径一样长，从而使时钟偏移非常小，可以忽略不计。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;Skew 问题的解决方法就是：设计中的主要信号应该走全局时钟网络。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使采用了这样的设计，在实际电路中，时钟信号到达每个 DFF 的时间也不可能完全相等，Skew 是肯定存在的。所以 STA 仍然需要考虑该因素。在 PAR 之前，STA 只能根据设计的面积来粗略估计 Skew，在 PAR 之后，因为有了更具体的信息（线段长度、宽度、信号分布情况）STA 的估计值更加精确。&lt;/p&gt;
&lt;h3 id="jitter"&gt;Jitter&lt;/h3&gt;
&lt;p&gt;理想的时钟信号是方波，但是实际中的时钟信号边沿不可能是瞬间变化的，是个斜坡，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="clock" src="/images/static-timing-analysis-1-basic/clock.jpg"&gt;&lt;/p&gt;
&lt;p&gt;时钟抖动 &lt;code&gt;Jitter&lt;/code&gt; 的定义很多，最常见的有 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;周期抖动 &lt;code&gt;Period Jitter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Period Jitter" src="/images/static-timing-analysis-1-basic/period-jitter.jpg"&gt;&lt;/p&gt;
&lt;p&gt;实际时钟信号周期与理想时钟周期的差值的变化。这是最早最直接的一种衡量抖动的方式，这个指标说明了时钟信号每个周期的变化。&lt;/p&gt;
&lt;p&gt;因为这个差值是个随机变量，并且满足高斯分布，所以可以用期望和方差来描述。一般随机选择很多个周期，然后计算平均周期、标准差、峰峰值。标准差称为 “&lt;code&gt;RMS 抖动&lt;/code&gt;”，峰峰值称为 “&lt;code&gt;Pk-Pk 周期抖动&lt;/code&gt;”。知道 Pk-Pk 周期抖动，对于恰当配置系统和保持时间很有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周期差抖动 &lt;code&gt;Cycle-to-cycle Jitter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="c2c-jitter" src="/images/static-timing-analysis-1-basic/cycle-to-cycle-jitter.jpg"&gt;&lt;/p&gt;
&lt;p&gt;两个相邻时钟周期的差值的变化。根据定义可知，对周期抖动做一阶差分，就可以得到周期差抖动。&lt;/p&gt;
&lt;p&gt;这个差值也是一个服从高斯分布的随机变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相位抖动 &lt;code&gt;Phase Jitter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="phase-jitter" src="/images/static-timing-analysis-1-basic/phase-jitter.jpg"&gt;&lt;/p&gt;
&lt;p&gt;一个时钟沿相对于基准对齐之后，经过一段时间后，与理想位置的偏差。这个指标说明了周期抖动在各个时期的累计效应。&lt;/p&gt;
&lt;p&gt;因为需要累积一段时间，所以这个误差又称为 时间间隔误差（TIE, Timer Interval Error）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 周期抖动 和 周期差抖动 是单个周期或者相邻周期的偏差，所以表征为短期抖动行为。而相位抖动需要累积一段时间，所以表征为长期抖动行为。&lt;/p&gt;
&lt;p&gt;时钟抖动的原因就是噪声。&lt;strong&gt;时钟抖动是永远存在的&lt;/strong&gt;，当其大到可以和时钟周期相比拟的时候，会影响到设计，这样的抖动是不可接受的。&lt;/p&gt;
&lt;h3 id="duty-cycle-distortion"&gt;Duty Cycle Distortion&lt;/h3&gt;
&lt;p&gt;&lt;img alt="dcd" src="/images/static-timing-analysis-1-basic/dcd.jpg"&gt;&lt;/p&gt;
&lt;p&gt;占空比失真，即时钟不对称，有脉冲的时间和无脉冲的时间发生了变化。DCD 会吞噬大量的时序裕量，造成数字信号的失真，使过零区间偏离理想的位置。DCD 通常是由信号的上升沿和下降沿之间时序不同而造成的。&lt;/p&gt;
&lt;h2 id="ohters"&gt;Ohters&lt;/h2&gt;
&lt;p&gt;除去时钟信号，还有一些其他的相关定义。&lt;/p&gt;
&lt;h3 id="fan-outfan-out"&gt;Fan-out/Fan-out&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Fan-out&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数字电路中，逻辑门相互连接，组成更加复杂的电路，所以大多数逻辑门的输出端都连接着多个别的单元的输入。所以需要一个术语来描述逻辑门的驱动能力的大小，也就是扇出 &lt;code&gt;Fan-out&lt;/code&gt;。最大扇出数 &lt;code&gt;maximum fan-out&lt;/code&gt; 定义为一个逻辑门可以驱动的同类逻辑门的最大数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大多数 TTL 逻辑门能够为 10 个其他数字门或驱动器提供信号。因而，一个典型的 TTL 逻辑门有 10 个扇出信号。&lt;/p&gt;
&lt;p&gt;在一些数字系统中，必须有一个单一的 TTL 逻辑门来驱动 10 个以上的其他门或驱动器。这种情况下，被称为缓冲器（buf）的驱动器可以用在 TTL 逻辑门与它必须驱动的多重驱动器之间。这种类型的缓冲器有 25 至 30 个扇出信号。逻辑反向器（非门）在大多数数字电路中能够辅助这一功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块的扇出&lt;/strong&gt; 是指模块的直属下层模块的个数。一般认为，设计得好的系统平均扇出是 3 或 4。一个模块的扇出数过大或过小都不理想，过大比过小更严重。一般认为扇出的上限不超过 7。扇出过大意味着管理模块过于复杂，需要控制和协调过多的下级。解决的办法是适当增加中间层次。一个模块的扇入是指有多少个上级模块调用它。扇入越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇入而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是我们应避免的。&lt;/p&gt;
&lt;p&gt;设计得好的系统，上层模块有较高的扇出，下层模块有较高的扇入。其结构图像清真寺的塔，上面尖，中间宽，下面小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Fan-in&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与扇出相对的概念是 扇入 &lt;code&gt;Fan-in&lt;/code&gt;，它描述的是一个逻辑门能够处理的外部输入的能力。扇入大的逻辑门的速度要比扇入小的慢，原因是增加扇入相当于增加逻辑门的输入电容。我们可以用使用多级逻辑门来代替高扇入的设计。&lt;/p&gt;
&lt;h3 id="setupholdrecoveryremoval-time"&gt;Setup/Hold/Recovery/Removal Time&lt;/h3&gt;
&lt;p&gt;建立 / 保持时间是在同步设计中的概念：&lt;/p&gt;
&lt;p&gt;建立时间 &lt;code&gt;setup time&lt;/code&gt; ：触发器在时钟信号上升沿到来以前，要求输入数据必须保持稳定不变一段时间，这段时间就是器件需要的建立时间。如不满足 setup time，这个数据就不能被这一时钟打入触发器。&lt;/p&gt;
&lt;p&gt;保持时间 &lt;code&gt;hold time&lt;/code&gt; ：触发器在时钟信号上升沿到来以后，要求数据保持稳定不变一段时间，以便能够稳定读取，这段时间就是器件需要的保持时间。如果不满足 hold time，数据同样不能被打入触发器。&lt;/p&gt;
&lt;p&gt;恢复 / 撤销时间是在异步设计中的概念：&lt;/p&gt;
&lt;p&gt;恢复时间 &lt;code&gt;recovery time&lt;/code&gt; : 对于异步信号（比如异步复位 / 置位），信号变无效的边沿和下一个时钟沿之间必须满足一个最小的间隔。其意义在于，如果保证不了这个最小时间，也就是异步信号无效边离时钟边沿太近了，异步信号解除（无效）之后，没有给 DFF 足够的时间来恢复（recovery）到正常状态，那么就不能保证在时钟沿到来时 DFF 可以正常工作。&lt;/p&gt;
&lt;p&gt;撤销时间 &lt;code&gt;removal time&lt;/code&gt; : 对于异步信号（比如异步复位 / 置位），信号变有效的边沿和前一个时钟沿之间必须满足一个最小的间隔。其意义在于，如果保证不了这个最小时间，也就是异步信号的有效沿离时钟太近了，在时钟信号去除（无效）之前，异步信号提前有效了，可能会造成 DFF 处于不确定状态。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog-72c14a3d01013tpi.html?type=-1"&gt;更加详细的总结：锁存器 Latch v.s. 触发器 Flip-Flop&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="sta-intro"&gt;STA Intro&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Static-timing-analysis"&gt;STA 的 wiki&lt;/a&gt; 已经说的很明白了，下面的内容基本就是引用和翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Static timing analysis (STA) is a method of computing the expected timing of a digital circuit without requiring simulation.&lt;/p&gt;
&lt;p&gt;High-performance integrated circuits have traditionally been characterized by the clock frequency at which they operate. Gauging the ability of a circuit to operate at the specified speed requires an ability to measure, during the design process, its delay at numerous steps. Moreover, delay calculation must be incorporated into the inner loop of timing optimizers at various phases of design, such as logic synthesis, layout (placement and routing), and in in-place optimizations performed late in the design cycle. While such timing measurements can theoretically be performed using a rigorous circuit simulation, such an approach is liable to be too slow to be practical. Static timing analysis plays a vital role in facilitating the fast and reasonably accurate measurement of circuit timing. The speedup comes from the use of simplified timing models and by mostly ignoring logical interactions in circuits. It has become a mainstay of design over the last few decades.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="definitions"&gt;Definitions&lt;/h3&gt;
&lt;p&gt;STA 中的一些术语定义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;timing path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog-72c14a3d01013tpi.html?type=-1"&gt;FPGA STA( 三 ) --- STA 的基本概念&lt;/a&gt; 中说的很明白：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在做 STA 时，首先要把电路分解为一条条的 timing path。实际上我们也可以把 timing path 称为 data path，其本质就是指信号传播的途径。每一条 timing path 都具有一个起始点和一个终点。起始点是指电路中信号被时钟沿锁存的点；而信号经过一系列的组合逻辑的通道或者走线后被另外一个时钟沿捕获，这个点被称为终点。信号从起始点到终点所经过的通道就被称为 timing path。&lt;/p&gt;
&lt;p&gt;起点有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时序器件的 时钟输入端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路的 输入端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;终点也有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时序器件的 数据输入端&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路的 输出端口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入和输出排列组合一共就有 4 种 path：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路输入端口  -&amp;gt;  触发器的数据 D 端 (Pad-to-Setup)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发器的 clk 端  -&amp;gt;  触发器的数据 D 端 (Clock-to-Setup)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;触发器的 clk 端  -&amp;gt;  电路输出端口 (Clock-to-Pad)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电路输入端口  -&amp;gt;  电路输出端口 (Pad-to-Pad)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="path" src="/images/static-timing-analysis-1-basic/path.jpg"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;critical path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关键路径：从输入到输出，延时最大的那条路径称为 critical path。关键路径是系统中延时最大的路径，它决定了系统所能达到的最大时钟频率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arrival time&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;到达时间：信号到达某个特定位置所消耗的时间。一般将时钟信号到达的时刻作为参考的 0 时刻，为了计算到达时间，需要对路径中的所有组件的延时都进行计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;required time&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;需求时间：所能容忍的路径最大延时，也就是信号到达的最晚的时间。如果路径上的延时再大一些，则必须降低时钟频率，否则会产生 setup/hold time violation。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slack&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;时序裕量：&lt;code&gt;slack = required time - arrival time&lt;/code&gt;。如果计算出某条路径的 slack 是正数，说明这条路径的时延是满足要求的；如果计算出某条路径的 slack 是负数，则表示路径上的延时太大了，必须做出修改（修改设计 or 修改约束 or 换芯片），否则包含它的电路不能以预期的频率工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="purpose"&gt;Purpose&lt;/h3&gt;
&lt;p&gt;在同步设计中，数据的流动是统一步伐的，即时钟信号每改变一次，数据跟随改变一次。这种运作方式是基于同步器件（DFF 或者 Latch）来实现的，这类器件以时钟信号作为指示，将其输入端的数据复制到输出端。在同步设计中只存在两种时序错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setup time violation&lt;/p&gt;
&lt;p&gt;输入数据和时钟的关系不满足 setup time 的要求，即在时钟有效沿之前，输入数据没有保持稳定足够长的时间，数据将不能被这个时钟沿记录下来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hold time violation&lt;/p&gt;
&lt;p&gt;输入数据和时钟的关系不满足 hold time 的要求，即在时钟有效沿之后，输入数据没有保持稳定足够长的时间，数据将不能被时钟信号记录下来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导致数据和时钟不同步的原因很多，比如数据本身和时钟不同步、或者是电路进行了不同的操作，器件的温度、电压、制造工艺等因素也会产生影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态时序分析 STA 的主要目的是在上述可能的电路偏移情况存在的情况下，验证所有信号能够准时到达，并保证电路的正常功能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;工作频率对数字电路而言至关重要。提高工作频率意味着更强大的处理能力，但是也带来了时序瓶颈：时序冲突的概率变大，电路的稳定性降低。所以为了使电路的性能达到设计的预期目标，并满足电路工作环境的要求，必须对一个电路设计进行时序、面积、负载等多方面的约束，并自始至终使用这些约束来驱动 EDA 软件工作。&lt;/p&gt;
&lt;p&gt;ISE 具有一定的自动优化能力，对于一般的低速设计（处理时钟不超过 100MHz），基本上不需要时序方面的任何手动分析和处理；但是对于高速和大规模设计，需要设计人员自行添加时序方面的控制和处理，通过多次反复操作，根据反馈结果逐步调整设定，直到满足要求为止。&lt;/p&gt;
&lt;p&gt;以前小规模 FPGA 设计，只需要做动态的门级时序仿真就课同时完成逻辑功能验证和时序验证；随着 FPGA 设计规模和速度的提升，有必要将逻辑功能验证和时序验证分开：首先，逻辑功能的正确性，可以通过 RTL 级或者门级的功能仿真来验证；其次，时序分析通过 STA（Static Timing Analysis，静态时序分析）验证。&lt;/p&gt;
&lt;p&gt;时序分析的主要作用就是查看 FPGA 内部逻辑和布线的延迟，验证其是否满足设计者的约束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定芯片最高工作频率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制工程的综合、映射、布局布线等关键环节，减少逻辑和布线的延迟，从而尽可能提高工作频率。一般情况下，处理时钟高于 100MHz 的时候，必须添加合理的时序约束文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查时序约束是否满足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查目标模块是否满足约束，若不满足，通过时序分析器定位程序中不满足的部分，并给出具体原因，然后设计人员修改程序，直到满足约束。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析时钟质量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当采用了全局时钟等优质资源后，仍然不满足目标约束，则需要降低所约束的时钟频率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定分配引脚的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过时序分析可以指定 I/O 引脚所支持的接口标准、接口速率和其他电气特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STA 的目的就是要保证 DUT（Device Under Test）中所有的路径满足内部时序单位对 setup time 和 hold
 time 的要求。信号可以及时的从任一时序路径的起点传递到终点，同时要求在电路正常工作所需的时间内保持恒定。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="theory"&gt;Theory&lt;/h3&gt;
&lt;p&gt;STA 是基于前面介绍的时序路径的，在分析时，计算时序路径上数据信号的到达时间和要求时间的差值，以判断是否存在违反设计规则的错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Slack = Trequired-time - Tarrival-time
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果时序裕量 Slack 为正，表示满足时序，负值表示不满足时序。STA 按照上式分析设计中所有路径，如果 Slack 为负值，则该路径为影响设计的关键路径，需要修改设计以达到时序要求。&lt;/p&gt;
&lt;p&gt;STA 是通过 “ 穷举法 ” 抽取整个设计电路的所有时序路径，按照约束条件分析电路中是否有违反设计规则的问题，并计算出设计的最高频率。&lt;/p&gt;
&lt;p&gt;========= Update 05/18/2015===========================&lt;/p&gt;
&lt;p&gt;很多笔试题里面都有考计算最大时钟频率的题，看到几篇文章 :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-101/"&gt;Static Timing Analysis 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-102-setup-failures/"&gt;Static Timing Analysis 102 : Setup Failures.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-103-hold-failures/"&gt;Static Timing Analysis 103 : Hold Failures.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解释的很清楚，记一下笔记，顺便总结一下。&lt;/p&gt;
&lt;p&gt;首先，电路中的元件一般分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑，比如与非门、或非门等组合逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序逻辑，受时钟驱动的元件，比如 flip-flop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般时序分析都是分析前面介绍的 Path2 的路径，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="path2" src="/images/static-timing-analysis-1-basic/path2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在这个图中，第一级的 DFF 的输出经过组合逻辑进入第二级 DFF，图中的时序是满足条件的，电路可以正常工作；但是如果违反 setup / hold time 的话，电路就无法正常工作，下面分别说明：&lt;/p&gt;
&lt;h3 id="setup-time-failure"&gt;Setup Time Failure&lt;/h3&gt;
&lt;p&gt;前面已经提到了，对于任何 DFF，都必须满足 setup time 的要求：&lt;strong&gt;数据信号要在时钟信号之前到达 DFF，并保持稳定至少 setup time 时间，才能被成功打入 DFF&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分类讨论一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果中间的组合逻辑较少，产生的时延很小，那么在下一个时钟沿到来之前，数据满足 setup time，没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果中间的组合逻辑较多，产生的时延足够大，导致数据和时钟的关系不满足 setup time，则有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图是一个 setup time failure 的具体例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="setup failure" src="/images/static-timing-analysis-1-basic/setup-fail.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第一级的 DFF 在时钟的上升沿对输入数据 In 进行采样，并经过一段时间（Tco，clock to output delay）后输出为 FF1-out，输出数据经过中间的组合逻辑变为 FF2-in 输入到第二级 DFF，因为中间的组合逻辑的时延太大，FF2-in 违反了 setup time 的要求（图中橙色线条所示）。由于第二级 DFF 的输入不满足 setup time，所以这个 DFF 会进入亚稳态，它将花费 1
个或多个时钟周期才能脱离亚稳态，在这期间它的输出都是不确定的，那么下游逻辑将会在这期间采样到错误数值，电路会发生错误。&lt;/p&gt;
&lt;p&gt;如果中间的组合逻辑过多，产生的时延过大，以至于 FF2-in 的变化落在了第二个时钟沿的后面，这时所然没有违反 setup time 的要求，第二个 DFF 不会进入亚稳态，但是它采样的数据是旧数据，这个数据可能是错误的，同样会导致下游逻辑发生错误。&lt;/p&gt;
&lt;p&gt;如果我们将时钟频率降到足够低，那么就可以避免 setup time failure 的问题。&lt;/p&gt;
&lt;p&gt;通过上面的分析，可以知道 setup time 限制了中间组合逻辑的最大时延，所以这个 setup time constraint 也叫做 max delay constraint。为了保证在最恶劣的情况下设计仍然能够满足要求，在计算 setup time 时中应该使用最大的数据时延路径。&lt;/p&gt;
&lt;p&gt;P.S. 上面的图中还包含了 clock skew，clk1 和 clk2 没有对齐，这加剧了 setup time failure 的机率。在实际中，时钟信号到达各个 DFF 的时间是不同的，设计者必须将这个因素考虑在内。&lt;/p&gt;
&lt;h3 id="hold-time-failure"&gt;Hold Time Failure&lt;/h3&gt;
&lt;p&gt;和 setup time 对应，对于任何时序器件（DFF)，都必须满足 hold time 的要求：&lt;strong&gt;数据信号要在时钟信号达到之后保持稳定至少 hold time 的时间，否则输出是错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下图是一个 hold time failure 的具体例子：&lt;/p&gt;
&lt;p&gt;&lt;img alt="hold failure" src="/images/static-timing-analysis-1-basic/hold-fail.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第一级 DFF 在时钟的上升沿对输入数据 In 进行采样，经过一段时间（Tco）后，输出为 FF1-out，输出数据经过中间的组合逻辑变为 FF2-in，输入到第二级 DFF。因为中间的组合逻辑时延非常小，而且由于 clock skew 的原因，导致第二级 DFF 在第一个时钟周期的 hold time 内输入的 FF2-in 发生了变化，违法了 hold time 要求，DFF2 进入亚稳态，它将花费 1 个或多个时钟周期才能退出亚稳态，在此期间输出的是错误数据。&lt;/p&gt;
&lt;p&gt;在现实中，导致这个问题的因素有可能是设计的问题（比如两个 DFF 邻接，中间没有其他逻辑），也有可能是器件的原因。&lt;/p&gt;
&lt;p&gt;因为传输时延太小，从而导致在第一个时钟沿信号就被 DFF2 采样了，而设计本意是在第二个时钟沿采样，看起来好像是信号跑（racing）的太快了，所以 hold time failure 也叫做 race。&lt;/p&gt;
&lt;p&gt;通过上面的分析，可以知道 hold time 限制了中间组合逻辑的最小时延，所以这个 hold time constraint 也叫做 min delay constraint。为了保证在最恶劣的情况下设计仍然能够满足要求，在计算 hold time 时中应该使用最小的数据时延路径。&lt;/p&gt;
&lt;p&gt;P.S. 上面的例子中 clock skew 加剧了 hold time failure 的机率，如果两个时钟是对齐的，那么就不会出现 hold time failure，输出也就不会出错。&lt;/p&gt;
&lt;h3 id="summary"&gt;summary&lt;/h3&gt;
&lt;p&gt;假设理想的时钟为 clk，它的周期为 T，它连接到 DFF1 和 DFF2 的时钟为 clk1 和 clk2，它们相对于理想时钟的时延分别为 Tc1 和 Tc2；DFF 的参数分别为 Tsu，Th 和 Tco，中间组合逻辑的时延为 Tcomb。&lt;/p&gt;
&lt;p&gt;数据的时延：Tc1 + Tco + Tcomb&lt;/p&gt;
&lt;p&gt;时钟的时延：Tc2 + T  &lt;/p&gt;
&lt;p&gt;要满足 setup time 的要求，则有 Tc2 + T - (Tc1 + Tco + Tcomb) &amp;gt;= Tsu，整理一下即：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;T &amp;gt;= Tsu + Tco + Tcomb - Tskew     --Eq1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以可以确定出系统的最大工作频率：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Fmax &amp;lt;= 1 / (Tsu + Tco + Tcomb - Tskew)     -- Eq2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为 Tc1, Tc2, Tco, Tsu 都是固定值，所以一个系统的最大工作频率取决 Tcomb。&lt;/p&gt;
&lt;p&gt;而对于 hold time，则有不等式：Tc1 + Tco + Tcomb &amp;gt; Tc2 + Th，整理一下就有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Tco + Tcomb - Tskew &amp;gt; Th        -- Eq3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上一级 DFF 的输出数据不能传输太快，侵占了下一级 DFF 正在锁存的 hold time，也就是说限制了数据的传输速度的上限。&lt;/p&gt;
&lt;p&gt;有了前面的 3 个公式，就可以解决大部分问题了。比如华为某年的笔试题：&lt;/p&gt;
&lt;p&gt;下图中时钟周期为 T, 触发器 D1 的建立时间最大为 T1max，最小为 T1min。组合逻辑电路最大延迟为 T2max, 最小为 T2min。问，触发器 D2 的建立时间 T3 和保持时间应满足什么条件 ?&lt;/p&gt;
&lt;p&gt;&lt;img alt="huawei" src="/images/static-timing-analysis-1-basic/huawei.png"&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;题目中 Tco = 0，Tskew = 0&lt;/p&gt;
&lt;p&gt;对于 setup time 的要求，将 Tco = 0，Tskew = 0 代入 Eq1 得：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Tsu &amp;lt;= {T - Tcomb}min = T - T2max
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于 hold time 的要求，将 Tco = 0，Tskew = 0 代入 Eq2 得：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Th &amp;lt;= {Tcomb}min = T2min
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ictest8.com/debug/rf-pcb.htm"&gt;RF 类 IC demo 板 loadboard 设计参考资料之时钟部分&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ti.com.cn/cn/lit/an/zhca492/zhca492.pdf"&gt;正确理解时钟器件的抖动性能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://m.ee.ofweek.com/2014-10/ART-11000-2813-28889698.html"&gt;技术解析：详解各种抖动技术规范&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.elecfans.com/article/85/126/2008/2008112718522.html"&gt;时间抖动 (jitter) 的概念及其分析方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog-72c14a3d01013tpi.html?type=-1"&gt;锁存器 Latch v.s. 触发器 Flip-Flop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/shanghaiqianlun/article/details/8685047"&gt;TimeQuest 定时分析的基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Static-timing-analysis"&gt;Static timing analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.cn/dpool/blog/s/blog-72c14a3d01013tpi.html?type=-1"&gt;FPGA STA( 三 ) --- STA 的基本概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-101/"&gt;Static Timing Analysis 101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-102-setup-failures/"&gt;Static Timing Analysis 102 : Setup Failures.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vlsiinterviewquestions.org/2011/12/17/static-timing-analysis-103-hold-failures/"&gt;Static Timing Analysis 103 : Hold Failures.&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="STA"></category></entry><entry><title>相关系数及Matlab函数</title><link href="https://qian-gu.github.io/posts/telecom/correlation-coefficient-and-matlab-function.html" rel="alternate"></link><published>2015-03-16T00:00:00+08:00</published><updated>2015-03-16T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-16:/posts/telecom/correlation-coefficient-and-matlab-function.html</id><summary type="html">&lt;p&gt;总结相关系数的知识及其 Matlab 实现&lt;/p&gt;</summary><content type="html">&lt;h2 id="correlation"&gt;Correlation&lt;/h2&gt;
&lt;p&gt;首先总结一下基础背景知识：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Correlation-and-dependence"&gt;相关 &lt;code&gt;Correlation&lt;/code&gt;&lt;/a&gt; 是概率论与统计学中用来刻画两个随机变量之间统计关系的强弱和方向的量。在广义的定义下，有很多种类的相关系数（&lt;code&gt;correlation coefficient&lt;/code&gt;），它们通常用字母 &lt;code&gt;ρ&lt;/code&gt; 或者 &lt;code&gt;r&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;p&gt;我们通常说的相关系数的学名是：&lt;a href="http://en.wikipedia.org/wiki/Pearson-product-moment-correlation-coefficient"&gt;皮尔逊积差系数（Pearson's product moment coefficient）&lt;/a&gt;，这种相关系数只对两个变量的线性关系敏感。&lt;/p&gt;
&lt;h3 id="pearsons-product-moment-coefficient"&gt;Pearson's product moment coefficient&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在统计学中，基于总体的定义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pearson 相关系数使用两个变量的协方差（&lt;code&gt;covariance&lt;/code&gt;）和标准差（&lt;code&gt;standard deviations&lt;/code&gt;）来定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq1" src="http://upload.wikimedia.org/math/5/c/f/5cfbb6f9088ef5fbc8a84f59da872984.png"&gt;&lt;/p&gt;
&lt;p&gt;其中，cov 是协方差，sigma 是标准差。因为 cov 可以写作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq2" src="http://upload.wikimedia.org/math/8/8/a/88a377faf813d502d6ab1f8193481223.png"&gt;&lt;/p&gt;
&lt;p&gt;所以 Person 相关系数的定义式可以写作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq3" src="http://upload.wikimedia.org/math/e/2/6/e26e29b58777e55d79883c77edca4428.png"&gt;&lt;/p&gt;
&lt;p&gt;根据概率论知识可以得到如下的变形形式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq4" src="http://upload.wikimedia.org/math/0/9/d/09d413641c8ba8f54b6113e5857c69f8.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于样本来估计协方差和标准差，可以得到定义如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq5" src="http://upload.wikimedia.org/math/e/3/c/e3c7ff025788887bba2f3dfca7df94b9.png"&gt;&lt;/p&gt;
&lt;p&gt;通过变形，可以得到下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq6" src="http://upload.wikimedia.org/math/8/0/5/8059a4dddb8b6c2c5e1eeefcb9630d93.png"&gt;&lt;/p&gt;
&lt;h3 id="properties"&gt;Properties&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E7%9B%B8%E5%85%B3"&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当两个变量的标准差都不为零，相关系数才有定义。从柯西 - 施瓦茨不等式可知，相关系数的绝对值不超过 1。当两个变量的线性关系增强时，相关系数趋于 1 或 -1。当一个变量增加而另一变量也增加时，相关系数大于 0。当一个变量的增加而另一变量减少时，相关系数小于 0。当两个变量独立时，相关系数为 0. 但反之并不成立。这是因为相关系数仅仅反映了两个变量之间是否线性相关。比如说，X 是区间［－1，1］上的一个均匀分布的随机变量。Y = X2. 那么 Y 是完全由 X 确定。因此 Y 和 X 是不独立的。但是相关系数为 0。或者说他们是不相关的。当 Y 和 X 服从联合正态分布时，其相互独立和不相关是等价的。&lt;/p&gt;
&lt;p&gt;当一个或两个变量带有测量误差时，他们的相关性就受到削弱，这时，“ 反衰减 ” 性（disattenuation）是一个更准确的系数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog-6ce23c390101c6zc.html"&gt;【总结】matlab 求两个序列的相关性&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关系数只是一个比率，不是等单位量度，无什么单位名称，也不是相关的百分数，一般取小数点后两位来表示。相关系数的正负号只表示相关的方向，绝对值表示相关的程度。因为不是等单位的度量，因而不能说相关系数 0.7 是 0.35 两倍，只能说相关系数为 0.7 的二列变量相关程度比相关系数为 0.35 的二列变量相关程度更为密切和更高。也不能说相关系数从 0.70 到 0.80 与相关系数从 0.30 到 0.40 增加的程度一样大。&lt;/p&gt;
&lt;p&gt;对于相关系数的大小所表示的意义目前在统计学界尚不一致，但通常按下是这样认为的：&lt;/p&gt;
&lt;p&gt;相关系数      相关程度&lt;/p&gt;
&lt;p&gt;0.00-±0.30    微相关&lt;/p&gt;
&lt;p&gt;±0.30-±0.50   实相关&lt;/p&gt;
&lt;p&gt;±0.50-±0.80   显著相关&lt;/p&gt;
&lt;p&gt;±0.80-±1.00   高度相关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复习了基础知识，另外还有两个概念：&lt;/p&gt;
&lt;h3 id="cross-correlation"&gt;Cross-correlation&lt;/h3&gt;
&lt;p&gt;对于连续函数，有下面的定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq7" src="http://upload.wikimedia.org/math/3/a/a/3aa0f20ebd9e984d8a17642c11d43de2.png"&gt;&lt;/p&gt;
&lt;p&gt;对于离散函数，有下面的定义：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq8" src="http://upload.wikimedia.org/math/d/f/6/df665b17d676571c9dc7a1800e1b186a.png"&gt;&lt;/p&gt;
&lt;p&gt;在信号处理中，用 互相关 &lt;a href="http://en.wikipedia.org/wiki/Cross-correlation"&gt;Cross-correlation&lt;/a&gt; 来&lt;strong&gt;衡量两个序列之间的相似程度&lt;/strong&gt;，通常可以用于在长序列中寻找一个特定的短序列（也就是通信系统的同步中）。&lt;/p&gt;
&lt;p&gt;在数理统计中，互相关用来两个随机序列的相关性。&lt;/p&gt;
&lt;p&gt;从定义式中可以看到，互相关函数和卷积运算类似，也是两个序列滑动相乘，但是区别在于：&lt;/p&gt;
&lt;p&gt;互相关的两个序列都不翻转，直接滑动相乘，求和；卷积的其中一个序列需要先翻转，然后滑动相乘，求和。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;f(t) 和 g(t) 做相关 = f*(-t) 与 g(t) 做卷积&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="autocorrelation"&gt;Autocorrelation&lt;/h3&gt;
&lt;p&gt;自相关 &lt;a href="http://en.wikipedia.org/wiki/Autocorrelation"&gt;Autocorrelation&lt;/a&gt; 是互相关的一种特殊情况，就是一个序列和它本身做相关，而不是两个序列，它&lt;strong&gt;主要用来衡量一个序列在不同时刻取值的相似程度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在数理统计中，自相关的定义式如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq9" src="http://upload.wikimedia.org/math/3/7/c/37c9812eaf2deca258f5526ac9067aa2.png"&gt;&lt;/p&gt;
&lt;p&gt;如果随机过程是一个宽平稳过程，那么均值和方差都不是时间的函数，所以，自相关定义式变为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq10" src="http://upload.wikimedia.org/math/1/c/c/1cc9b1b80ab17d64568bca15bc7a5a9d.png"&gt;&lt;/p&gt;
&lt;p&gt;在某些学科中，会去掉归一化因子 σ2，使用 自协方差 来代替 自相关。但是归一化因子可以让自相关的取值在 [-1, +1] 之间，不会随着序列的绝对大小而变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在信号处理中，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自相关的定义会去掉归一化，即不用减去均值，也不用除以方差。当除以方差时，一般叫做另外一个名字：自相关系数 &lt;code&gt;autocorrelation coefficient&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于连续函数，自相关的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq11" src="http://upload.wikimedia.org/math/9/8/c/98cd888f0d13972a937f5d37d9f24623.png"&gt;&lt;/p&gt;
&lt;p&gt;对于离散函数，自相关的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq12" src="http://upload.wikimedia.org/math/4/c/2/4c23ef05df69ee440a2bda5a0b1d83bc.png"&gt;&lt;/p&gt;
&lt;p&gt;自相关有很多性质，比如对称性、&lt;a href="http://en.wikipedia.org/wiki/Wiener%E2%80%93Khinchin-theorem"&gt;维纳 - 辛钦定理（Wiener–Khinchin theorem）&lt;/a&gt; 等，就不再重复了。&lt;/p&gt;
&lt;h2 id="matlab-function"&gt;Matlab function&lt;/h2&gt;
&lt;h3 id="xcorr"&gt;xcorr&lt;/h3&gt;
&lt;p&gt;在 Matlab 中，计算自相关和互相关，可以使用同一个函数：&lt;code&gt;xcorr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;自相关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;c = xcorr(x);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;互相关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;c = xcorr(x, y);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为两个长度为 N 的序列进行相关，可以知道最多有 2N - 1 个非 0 的移位相乘结果，所以 xcorr 的返回结果就是长度为 2N - 1 的向量。（如果其中一个序列的长度小于 N，则会先补零再计算相关）&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;help xcorr&lt;/code&gt; 来查看详细的函数说明。&lt;/p&gt;
&lt;p&gt;下面举个使用例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c"&gt;%correlation&lt;/span&gt;
&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;xcorr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;对于序列 x = [1, 2, 3]，移位相乘、求和，可以得到结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于序列 y 类似。&lt;/p&gt;
&lt;p&gt;对于 x、y 的互相关，当两个序列对齐的时候，相关性最高（归一化后为 1，意味着两个序列线性相关）&lt;/p&gt;
&lt;p&gt;xcorr 默认的返回结果是没有经过归一化的，而通常的应用中都要求归一化以得到精确的估计。解决这一问题的方法就是使用 xcorr 函数提供的 &lt;code&gt;option&lt;/code&gt; 选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'biased' 有偏估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'unbiased' 无偏估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'coeff' 归一化，返回到最大值（对齐时）为理想的 1.0（= xcorr(x)./max(xcorr(x)) ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'none' 未经归一化的原始数据，默认的返回结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="corrcoef"&gt;corrcoef&lt;/h3&gt;
&lt;p&gt;可以用 &lt;code&gt;corrcoef&lt;/code&gt; 函数来求两个序列的相关系数，函数的返回值为一个 2×2 的矩阵，对角线上的值为两个序列的自相关系数，非对角线上的值为两个序列的互相关系数。&lt;/p&gt;
&lt;p&gt;在上面的例子中加入下面两句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;corrcoef&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;返回结果为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为 z 是 x 的线性函数，且系数为 -1，所以非对角线上的值为 -1。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Correlation-and-dependence"&gt;correlation wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Pearson-product-moment-correlation-coefficient"&gt;pearson wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cross-correlation"&gt;Cross-correlation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Autocorrelation"&gt;Autocorrelation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog-6ce23c390101c6zc.html"&gt;【总结】matlab 求两个序列的相关性&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="correlation coefficient"></category><category term="matlab"></category></entry><entry><title>关于冒险和毛刺</title><link href="https://qian-gu.github.io/posts/ic/summary-of-hazard-and-glitch.html" rel="alternate"></link><published>2015-03-13T21:44:00+08:00</published><updated>2015-03-13T21:44:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-13:/posts/ic/summary-of-hazard-and-glitch.html</id><summary type="html">&lt;p&gt;总结电路设计中的冒险现象和毛刺，及解决方法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="hazards-glitch"&gt;Hazards &amp;amp; Glitch&lt;/h2&gt;
&lt;p&gt;所谓 “ 冒险 ” &lt;code&gt;Hazard&lt;/code&gt;，是指一种数字电路中由于设计或者是外部因素，造成的数字信号错误的现象，而这个错误的信号就叫做毛刺 &lt;code&gt;Glitch&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard-(logic)"&gt;Hazard on wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In digital logic, a hazard in a system is an undesirable effect caused by either a deficiency in the system or external influences. Logic hazards are manifestations of a problem in which changes in the input variables do not change the output correctly due to some form of delay caused by logic elements (NOT, AND, OR gates, etc.) This results in the logic not performing its function properly. The three different most common kinds of hazards are usually referred to as static, dynamic and function hazards.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据导致冒险的原因，一般将冒险分类如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;静态冒险 &lt;code&gt;Static hazards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;静态冒险，是指输入信号发生变化前后，输出信号保持不变，但是在输入信号变化时，输出信号可能产生瞬间错误输出。&lt;/p&gt;
&lt;p&gt;根据发生的错误的值，可以将静态冒险分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Static-1 Hazard: 输入变化前后，输出应该保持 1，但是在输入变化瞬间输出发生错误，变为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Static-0 Hazard: 输入变化前后，输出应该保持 0，但是在输入变化瞬间输出发生错误，变为 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据导致冒险的原因分类，可以将静态冒险分为以下两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;逻辑冒险 &lt;code&gt;logic hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只有 1 个输入发生变化，导致的静态冒险。&lt;/p&gt;
&lt;p&gt;经分析可知产生逻辑冒险的原因是门的延迟。（参考&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功能冒险 &lt;code&gt;function hazard&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2 个或者 2 个以上的输入发生变化，导致的静态冒险。&lt;/p&gt;
&lt;p&gt;经分析可知产生功能冒险的原因是两个或两个以上的输入不可能同时发生变化，它们的变化总有先有后。参考&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态冒险 &lt;code&gt;Dynamic hazards&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;动态冒险，是指输入信号变化前后，输入信号发生变化，而且在输入信号发生变化时，输出信号会变化 3 次以上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="solution"&gt;Solution&lt;/h2&gt;
&lt;p&gt;首先我们应该尽可能避免存在冒险的设计，这样就不存在解决毛刺的问题。&lt;/p&gt;
&lt;p&gt;比如在数字电路设计中，常常采用格雷码计数器取代普通的二进制计数器，这是因为格雷码计数器的输出每次只有一位跳变，消除了竞争冒险的发生条件，避免了毛刺的产生。&lt;/p&gt;
&lt;p&gt;再比如遵循同步设计原则，即使有毛刺，一般也不会对系统造成危害。（因为同步电路信号的变化都发生在时钟沿，只要毛刺不出现在时钟的沿口并且不满足数据的建立和保持时间，就不会对系统造成危害。一般毛刺很短，多为几纳秒，基本上都不可能满足数据的建立和保持时间）&lt;/p&gt;
&lt;p&gt;设计无冒险的电路，会导致电路变复杂，成本上升。对于简单电路中的冒险，我们可以采用以下的方法来解决。&lt;/p&gt;
&lt;h3 id="static-hazards"&gt;Static hazards&lt;/h3&gt;
&lt;p&gt;首先判断输入信号是否会同时发生变化，可以分为两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只有一个输入变化，对应的就是 logic hazards&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断是否存在冒险（&lt;strong&gt;代数法&lt;/strong&gt; or &lt;strong&gt;卡诺图法&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;代数法比较繁琐，但是适用范围广，对两级以上的电路均适用。注意函数表达式不能化简，否则对应的逻辑电路改变，由电路延迟造成的冒险也随之改变。&lt;/p&gt;
&lt;p&gt;卡诺图法方便直观，但是只适用于两级电路。&lt;/p&gt;
&lt;p&gt;函数表达式中的积项或和项是和卡诺图中的合并圈一一对应的，由此可知，&lt;strong&gt;函数的最简不一定是最佳的，必要的冗余反而可增加电路工作的可靠性。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冒险（&lt;strong&gt;增加冗余项 / 冗余圈&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至少有 2 个输入同时变化，对应的就是 function hazards&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断是否存在冒险&lt;/p&gt;
&lt;p&gt;产生功能冒险的充要条件（同时满足以下 3 个条件）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须有 P （P &amp;gt;= 2) 个变量同时发生变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入变量变化前后函数值相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由变化的 P 个变量组合所构成的 2^P 个格，既有 1 又有 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决冒险（&lt;strong&gt;选通脉冲&lt;/strong&gt; or &lt;strong&gt;滤波电路&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;只要输入信号不是按照循环码的方式变化，就会产生功能冒险。功能冒险是函数的逻辑功能决定的，所以不能在设计中消除，需要加额外的选通脉冲。&lt;/p&gt;
&lt;p&gt;选通脉冲的思路：一般说来，冒险出现在信号发生电平转换的时刻，也就是说在输出信号的建立时间内会发生冒险，而在输出信号的保持时间内是不会有毛刺信号出现的。如果在输出信号的保持时间内对其进行 " 采样 "，就可以消除毛刺信号的影响。&lt;/p&gt;
&lt;p&gt;需要注意的是必须对选通脉冲的宽度及产生时间有严格的要求。加上选通脉冲之后，电路的输出就不再是电平信号，而是变为脉冲信号。&lt;/p&gt;
&lt;p&gt;还有另外一种方法：在对输出波形要求不高的时候，可以在输出端接一个滤波电容来消除冒险，但是这种方法会破坏波形的边沿，所以只适用于低速电路。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较 3 种消除冒险的方法：&lt;/p&gt;
&lt;p&gt;增加冗余只能消除 logic hazards，而不能消除 function hazards；&lt;/p&gt;
&lt;p&gt;增加滤波电路虽然简单，但是会破坏波形；&lt;/p&gt;
&lt;p&gt;加选通脉冲的方法则对两种类型的冒险都有效。&lt;/p&gt;
&lt;p&gt;目前很多中规模集成电路（Medium Scale Integrated, MSI）中都设有使能端，其作用之一就是作为选通脉冲的输入端，待电路稳定之后才使输出有效。&lt;/p&gt;
&lt;h3 id="dynamic-hazards"&gt;Dynamic hazards&lt;/h3&gt;
&lt;p&gt;要解决动态冒险，首先就得知道动态冒险产生的原因：&lt;/p&gt;
&lt;p&gt;产生动态冒险的原因是输入可以有多条变化路径到达输出，而这些路径的时延都各不相同，显然这就会导致输出变化多次，比如一个输出应该从 1 变为 0，但是实际中却先从 1 变为 0，然后又从 0 变回 1，最终返回到正确值 0。&lt;/p&gt;
&lt;p&gt;动态的解决相对比较复杂，但是 &lt;strong&gt;只要消除了静态冒险，那么就不会存在动态冒险。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="in-fpga-design"&gt;in FPGA Design&lt;/h2&gt;
&lt;p&gt;本部分来自：&lt;a href="http://www.fpga.com.cn/advance/glitch/giltch.htm"&gt;关于毛刺问题的探讨&lt;/a&gt; 和 &lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;信号在 FPGA 器件内部通过连线和逻辑单元时，都有一定的延时。延时的大小与连线的长短和逻辑单元的数目有关，同时还受器件的制造工艺、工作电压、温度等条件的影响。信号的高低电平转换也需要一定的过渡时间。由于存在这两方面因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化 , 往往会出现一些不正确的尖峰信号，即毛刺信号。与分立元件不同，由于 PLD 内部不存在寄生电容电感，这些毛刺将被完整的保留并向下一级传递，因此毛刺现象在 PLD、FPGA 设计中尤为突出。&lt;/p&gt;
&lt;p&gt;可以概括的讲，&lt;strong&gt;只要输入信号同时变化，（经过内部走线）组合逻辑必将产生毛刺。将它们的输出直接连接到时钟输入端、清零或置位端口的设计方法是错误的，这可能会导致严重的后果。所以我们必须检查设计中所有时钟、清零和置位等对毛刺敏感的输入端口，确保输入不会含有任何毛刺。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如前所述，优秀的设计方案，如采用格雷码计数器，同步电路等，可以大大减少毛刺，但它并不能完全消除毛刺。 毛刺并不是对所有输入都有危害，例如 D 触发器的 D 输入端，只要毛刺不出现在时钟的上升沿并且满足数据的建立和保持时间，就不会对系统造成危害。因此我们可以说 D 触发器的 D 输入端对毛刺不敏感。但对于 D 触发器的时钟端，置位端，清零端，则都是对毛刺敏感的输入端，任何一点毛刺就会使系统出错，但只要认真处理，我们可以把危害降到最低直至消除。下面我们就对几种具体的信号进行探讨。&lt;/p&gt;
&lt;h3 id="clock"&gt;clock&lt;/h3&gt;
&lt;p&gt;时钟信号是系统中非常关键的信号，参见其他&lt;a href="http://guqian110.github.io/tag/clock-design.html"&gt;几篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="setclear"&gt;set/clear&lt;/h3&gt;
&lt;p&gt;清除和置位信号要求象对待时钟那样小心地考虑它们，因为这些信号对毛刺也是非常敏感的。正如使用时钟那样，最好的清除和置位是从器件的引脚单直接地驱动。有一个主复位 Reset 引脚是常用的最好方法，主复位引脚给设计项目中每个触发器馈送清除或置位信号。几乎所有 PLD 器件都有专门的全局清零脚和全局置位。如果必须从器件内产生清除或置位信号，则要按照 “ 门控时钟 ” 的设计原则去建立这些信号，确保输入无毛刺。 &lt;/p&gt;
&lt;h3 id="combinational-output"&gt;combinational output&lt;/h3&gt;
&lt;p&gt;当 PLD 输出引脚给出系统内其它部分的边沿敏感信号或电平敏感信号时，这些出信号必须象内部时钟、清除和置位信号一样小心地对待。只要可能就应在 PLD 输出端寄存那些对险象敏感的组合输出。如果你不能寄存险象敏感的输出，则应符合 “ 门控时钟 ” 中讨论的门控时钟的条件。决不能用多级逻辑驱动毛刺敏感的输出。&lt;/p&gt;
&lt;h3 id="asynchronous-input"&gt;asynchronous input&lt;/h3&gt;
&lt;p&gt;对于异步输入信号导致的毛刺，解决思想就是 同步化。参见&lt;a href="http://guqian110.github.io/pages/2014/10/09/the-clock-design-in-fpga-3-multiasynchronous-clock-design.html"&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Hazard-(logic)"&gt;Hazard on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3575520/"&gt;数字电路与逻辑设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;Digital Design (4th Edition)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.fpga.com.cn/advance/glitch/giltch.htm"&gt;关于毛刺问题的探讨&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="hazard"></category><category term="glitch"></category></entry><entry><title>OFDM 中的 IFFT/FFT 注意事项</title><link href="https://qian-gu.github.io/posts/telecom/ifft-and-fft-in-ofdm.html" rel="alternate"></link><published>2015-03-10T19:40:00+08:00</published><updated>2015-03-10T19:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-10:/posts/telecom/ifft-and-fft-in-ofdm.html</id><summary type="html">&lt;p&gt;OFDM 中做 IFFT/FFT 时需要注意的一点细节&lt;/p&gt;</summary><content type="html">&lt;h2 id="intro"&gt;Intro&lt;/h2&gt;
&lt;p&gt;在做 OFDM 项目时，发现一个容易犯错的地方：&lt;code&gt;IFFT&lt;/code&gt;/&lt;code&gt;FFT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在很多介绍 OFDM 的书中，给出结论：在发射机，基带信号的复包络采用值正好是待发射序列的 IDFT，所以在 N 是 2 的指数时，可以采用 IFFT 来快速计算；在接收机，将接收的频带信号解调到基带，采样得到基带复包络，然后做 DFT (FFT) 即可得到原始的发射序列。&lt;/p&gt;
&lt;p&gt;这个结论是正确的，但是需要注意的一点是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调制 / 解调所做的运算的形式和 IFFT/FFT 是相同的，但是有一个功率归一化的系数的差别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多书（&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;）都给出了公式推导，然而这些公式并不严谨，这些公式只是为了说明做的变换形式是 IFFT/FFT。&lt;/p&gt;
&lt;p&gt;有的书（&lt;a href="http://book.douban.com/subject/1140934/"&gt;宽带无线通信 OFDM 技术&lt;/a&gt;）则给出了更加详细，严谨的公式推导。&lt;/p&gt;
&lt;h2 id="ifft-fft"&gt;IFFT / FFT&lt;/h2&gt;
&lt;p&gt;&lt;img alt="fft/ifft" src="http://guqian110.github.io/images/xilinx-fft-core-notes/theory.png"&gt;&lt;/p&gt;
&lt;h2 id="ifft-fft-in-ofdm"&gt;IFFT /FFT in OFDM&lt;/h2&gt;
&lt;p&gt;OFDM 中 &lt;strong&gt;功率归一化因子&lt;/strong&gt; 为 1/sqr(N)，而标准的 IFFT 中的系数为 1/N，所以在调用标准 IFFT 函数之后，需要额外乘以一个 sqr(N) ：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1/N × sqr(N) = 1/sqr(N)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而在接收端，也要先除以一个 sqr(N)，然后再进行 FFT 。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1140934/"&gt;宽带无线通信 OFDM 技术&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="IFFT"></category><category term="FFT"></category><category term="OFDM"></category></entry><entry><title>信噪比小结</title><link href="https://qian-gu.github.io/posts/telecom/summary-of-snr-and-noise.html" rel="alternate"></link><published>2015-03-10T19:31:00+08:00</published><updated>2015-03-10T19:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-10:/posts/telecom/summary-of-snr-and-noise.html</id><summary type="html">&lt;p&gt;学而时习之，总结一下信噪比相关的小知识&lt;/p&gt;</summary><content type="html">&lt;p&gt;所谓 &lt;code&gt;信噪比（SNR, Signal-to-noise ratio）&lt;/code&gt; 就是指 信号的功率 和噪声的功率 的比值。我们可以用它来比较信号的和背景噪声的相对大小，如果比值大于 1（0 dB），说明信号功率比噪声功率强。&lt;/p&gt;
&lt;h2 id="snr-def"&gt;SNR Def&lt;/h2&gt;
&lt;p&gt;信噪比的定义式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="def" src="http://upload.wikimedia.org/math/f/0/e/f0e032777062c3f945554f1c63d9c864.png"&gt;&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;P&lt;/code&gt; 表示信号 / 噪声的平均功率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果信号和噪声的方差已知，且两者的均值都为 0，则信噪比可以写为下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq1" src="http://upload.wikimedia.org/math/9/0/9/9098fa286b51274407110dd98832b8b7.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号和噪声是使用相同的阻抗来测量的（功率这个词本来就源于物理，在电子系统中，功率 &lt;code&gt;P = UI = V^2/R&lt;/code&gt;），那么信噪比公式可以用幅度的平方比值来计算：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq2" src="http://upload.wikimedia.org/math/6/9/d/69d4d7d398cf17a0184463ae42b4b18b.png"&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;A&lt;/code&gt; 为信号 / 噪声的 &lt;code&gt;均方根（ root mean square, RMS）&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般信号的动态范围都很大，所以通常采用分贝的方式来表示信噪比&lt;/p&gt;
&lt;p&gt;&lt;img alt="ep3" src="http://upload.wikimedia.org/math/8/e/7/8e7f17468834710c835579e252528515.png"&gt;&lt;/p&gt;
&lt;p&gt;把 均方根 带入，就可以得到下面的公式&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq4" src="http://upload.wikimedia.org/math/6/f/7/6f7dd3340b9b31a3d3afa11532c5480e.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般 SNR 指的是 &lt;strong&gt;平均&lt;/strong&gt; 信噪比，因为通常 SNR  的瞬时值是不同的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信噪比的概念也可以这么理解：将噪声的功率归一化为 1（0 dB），看信号的功率可以达到多大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="snr-in-telecom"&gt;SNR in telecom&lt;/h2&gt;
&lt;p&gt;在物理学中，交流电信号的 平均功率 = ( 电压 × 电流 ) 的均值，如下式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq5" src="http://upload.wikimedia.org/math/b/a/1/ba1615e4d1dc51196247c5a912227dba.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq6" src="http://upload.wikimedia.org/math/c/6/9/c69fbca997fb4cc8a82823fe47c2e47d.png"&gt;&lt;/p&gt;
&lt;p&gt;但是在信号处理和通信中，一般假设电阻的阻值为 1 欧姆，所以在计算能量、功率时，电阻因子会被忽略。这可能会引起一些困扰。&lt;/p&gt;
&lt;p&gt;所以信号的功率表示式简化为下面的公式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq7" src="http://upload.wikimedia.org/math/a/e/7/ae780e83e953d7329de754a42fcddb63.png"&gt;&lt;/p&gt;
&lt;p&gt;（其中，&lt;code&gt;A&lt;/code&gt; 是交流信号的幅度）&lt;/p&gt;
&lt;h3 id="ebn0"&gt;Eb/N0&lt;/h3&gt;
&lt;p&gt;在数字系统中可以使用 SNR 表示噪声的等级，但是更常用的是 &lt;code&gt;Eb/N0 (energy per bit to noise power spectral density ratio)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Eb/N0 是一种归一化的 SNR，称为 “ SNR 每 bit ”，在比较不同的调制方案的 &lt;code&gt;误比特率（BER, bit error rate）&lt;/code&gt; 性能时，因为这种方法不考虑带宽的因素，所以很有效。&lt;/p&gt;
&lt;p&gt;其中 Eb 是平均比特能量，它表示平均每个 bit 包含的能量。&lt;/p&gt;
&lt;p&gt;信号的功率就等于符号中每个比特的功率 Eb × 每个符号所包含的比特数 fb（也就是比特速率）；噪声的能量可以用功率谱密度来计算，N0×B，代入信噪比的定义式，就有下面的换算公式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="eq9" src="http://upload.wikimedia.org/math/3/5/3/353410b95506c2f45e069c58ff3d121b.png"&gt;&lt;/p&gt;
&lt;p&gt;P.S. 上面的公式左边使用的是载噪比 CNR，在抑制载波的调制方式中，等于信噪比 SNR。&lt;/p&gt;
&lt;h2 id="awgn"&gt;AWGN&lt;/h2&gt;
&lt;p&gt;高斯分布（&lt;code&gt;Gaussian distribution&lt;/code&gt;）可以使用 &lt;code&gt;N(μ,σ2 )&lt;/code&gt; 来表示，其中 μ 是均值，σ 是标准差。&lt;/p&gt;
&lt;p&gt;对噪声进行建模，最简单的就是 &lt;strong&gt;加性高斯白噪声 (AWGN, Additive White Gaussian Noise)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加性：叠加在信号之上，而且无论有无信号，噪声都是始终存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;高斯：噪声幅度的取值是随机过程，它的概率密度函数服从高斯分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;白噪声：噪声的功率谱密度函数取值是常数，在坐标系中表现为一条直线，在每个频率点的谱密度都一样，就像白光包含各种频率的光一样，所以叫做白噪声。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时满足这三个的条件的噪声就叫做 加性高斯白噪声。&lt;/p&gt;
&lt;p&gt;高斯白噪声的功率谱函数：&lt;code&gt;P(f) = N0/2&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;N0&lt;/code&gt; 是 &lt;strong&gt;单边噪声功率谱密度&lt;/strong&gt;，&lt;code&gt;N0/2&lt;/code&gt; 是 &lt;strong&gt;双边噪声功率谱密度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为功率谱密度函数的定义域是无穷大的，所以高斯噪声的功率也是无穷大的，它的功率只有在带限时才有意义。&lt;/p&gt;
&lt;p&gt;在计算前面 SNR 时，我们可以使用下面两种方法来得到 Pn：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果均值为 0，&lt;code&gt;Pn = 方差 σ2 = R(0)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果已知功率谱密度函数 P(f)，那么直接对其定积分&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signal-to-noise-ratio"&gt;Signal-to-noise ratio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Eb/N0"&gt;Eb/N0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Gaussian-noise"&gt;Gaussian noise&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.c114.net/thread-663445-1-1.html"&gt;关于白噪声功率谱密度和方差的关系 &lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="SNR"></category></entry><entry><title>学习 Vim 之 BufExplorer、NERDTree、WinManager、Airline 插件</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-bufexplorer-nerdtree-winmanager-airline.html" rel="alternate"></link><published>2015-03-04T22:40:00+08:00</published><updated>2015-03-04T22:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-03-04:/posts/tools/learning-vim-bufexplorer-nerdtree-winmanager-airline.html</id><summary type="html">&lt;p&gt;学习 BufExplorer、NERDTree、WinManager、Airline 插件。&lt;/p&gt;</summary><content type="html">&lt;h2 id="bufexplorer"&gt;BufExplorer&lt;/h2&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;:ls&lt;/code&gt; 命令可以查看打开的 buffer，然后在不同的 buffer 之间切换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;bn&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code&gt;n&lt;/code&gt; 是 buffer 的标号。&lt;/p&gt;
&lt;p&gt;这种内置的方法效率比较低，尤其是当我们打开很多个 Buffer 之后，问题更加明显。所以就有了各种 buf 类的插件，最有名的就是 &lt;a href="http://www.vim.org/scripts/script.php?script_id=42"&gt;BufExplorer&lt;/a&gt; 和 &lt;a href="http://www.vim.org/scripts/script.php?script_id=159"&gt;MiniBufferExplorer&lt;/a&gt;。不同的人使用习惯不同，在 stackoverflow 上有专门讨论两者的优劣的问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1649187/vim-minibufexpl-versus-bufexplorer-plugins"&gt;ViM: minibufexpl versus bufexplorer plugins&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="install"&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;bufexplorer.zip&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;+PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="config"&gt;Config&lt;/h3&gt;
&lt;p&gt;查看 help 文档，简单配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:bufExplorerDetailedHelp     &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;      &lt;span class="c"&gt;&amp;quot; Don&amp;#39;t show detailed help.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:bufExplorerShowRelativePath &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;      &lt;span class="c"&gt;&amp;quot; Show relative paths.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:bufExplorerSortBy           &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;mru&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;&amp;quot; Sort by most recently used.&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:bufExplorerShowUnlisted     &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;      &lt;span class="c"&gt;&amp;quot; Show unlisted buffers.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="nerdtree"&gt;NERDTree&lt;/h2&gt;
&lt;p&gt;NERDTree 是一款可以提供树形目录的 vim 插件，使用它我们可以在 vim 内以树形结构浏览文件目录。&lt;/p&gt;
&lt;h3 id="install_1"&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;The-NERD-tree&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;+PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入 &lt;code&gt;:NERDTree&lt;/code&gt; 打开 NERDTree 窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;o 打开 / 关闭光标所在目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;t 在新 tab 中打开文件，并跳转到该 tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T 在新 tab 中打开文件，并不跳转到该 tab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p 跳转到父节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P 跳转到根节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;q 关闭 NERDTree 窗口&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="airline"&gt;Airline&lt;/h2&gt;
&lt;p&gt;状态栏也是一个非常重要的窗口，可以为我们提供一些文档的基本信息，我们可以自己 DIY，在 .vimrc 文件中添加相关的设置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;statusline&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;%F%&lt;span class="k"&gt;m&lt;/span&gt;%&lt;span class="k"&gt;r&lt;/span&gt;%&lt;span class="k"&gt;h&lt;/span&gt;%&lt;span class="k"&gt;w&lt;/span&gt;\ [FORMAT&lt;span class="p"&gt;=&lt;/span&gt;%{&amp;amp;&lt;span class="nb"&gt;ff&lt;/span&gt;}]\ [TYPE&lt;span class="p"&gt;=&lt;/span&gt;%Y]\ [POS&lt;span class="p"&gt;=&lt;/span&gt;%&lt;span class="k"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;%&lt;span class="k"&gt;v&lt;/span&gt;][%&lt;span class="k"&gt;p&lt;/span&gt;%%]\ %{strftime&lt;span class="p"&gt;(&lt;/span&gt;\&amp;quot;%&lt;span class="k"&gt;d&lt;/span&gt;&lt;span class="sr"&gt;/%m/&lt;/span&gt;%&lt;span class="k"&gt;y&lt;/span&gt;\ &lt;span class="p"&gt;-&lt;/span&gt;\ %H:%M\&amp;quot;&lt;span class="p"&gt;)&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;也可以使用 &lt;a href="https://github.com/vim-ariline/vim-airline"&gt;Airline&lt;/a&gt; 插件，一款可以提供非常漂亮的状态栏的插件。它会覆盖掉 .vimrc 中对状态的配置，删除插件后配置信息可以重新起作用。&lt;/p&gt;
&lt;h3 id="install_2"&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Pulgin &lt;span class="s1"&gt;&amp;#39;vim-airline/vim-airline&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;+PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="config_1"&gt;Config&lt;/h3&gt;
&lt;p&gt;为了保证状态栏始终显示，在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:airline_powerline_fonts             &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:airline#extensions#&lt;span class="nb"&gt;tabline&lt;/span&gt;#enabled  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:airline#extensions#&lt;span class="nb"&gt;tabline&lt;/span&gt;#fnamemod &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;:t&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:airline#extensions#&lt;span class="nb"&gt;tabline&lt;/span&gt;#buffer_idx_mode &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab1
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab2
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab3
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab4
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab5
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;6&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab6
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab7
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab8
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab9
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectTab0
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;-&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectPrevTab
nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;+&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Plug&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;AirlineSelectNextTab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="winmanager"&gt;WinManager&lt;/h2&gt;
&lt;p&gt;我们已经安装很多插件，比如 Taglist，BufExlporer、NERDTree 等，这时候我们就需要一个窗口管理插件来将它们组合起来 —— &lt;a href="http://www.vim.org/scripts/script.php?script-id=95"&gt;WinManager&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="install_3"&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 安装：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;winmanager&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;+PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="bugfix"&gt;bugfix&lt;/h3&gt;
&lt;p&gt;修改 &lt;code&gt;~/.vim/bundle/winmanager/plugin/winmanager.vim&lt;/code&gt; 中的 &lt;code&gt;ToggleWindowsManager&lt;/code&gt; 函数，给 else 分支新增一行 ( 下段代码第 7 行 )：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;&amp;quot; toggle showing the explorer plugins.&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;SID&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;ToggleWindowsManager&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; IsWinManagerVisible&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;call&lt;/span&gt; s:CloseWindowsManager&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;call&lt;/span&gt; s:StartWindowsManager&lt;span class="p"&gt;()&lt;/span&gt;
        exe &lt;span class="s1"&gt;&amp;#39;q&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="config_2"&gt;Config&lt;/h3&gt;
&lt;p&gt;查看 help 文档，我们可以进行简单的设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot; Config Winmanager&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:winManagerWindowLayout&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;NERDTree|TagList&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:NERDTree&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;title&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;[NERDTree]&amp;quot;&lt;/span&gt;

nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;m&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; :WMToggle&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; NERDTree&lt;span class="p"&gt;-&lt;/span&gt;Start&lt;span class="p"&gt;()&lt;/span&gt;
    exec &lt;span class="s1"&gt;&amp;#39;NERDTree&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;

&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; NERDTree&lt;span class="p"&gt;-&lt;/span&gt;IsValid&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;endfunction&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这时候我们按下组合键 Ctrl-m 即可切换是否显示 winmanager 窗口布局。&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-netrw-bufexplorer-winmanager-plugin/"&gt;vi/vim 使用进阶 : 文件浏览和缓冲区浏览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/bokee/article/details/6633193"&gt; 将 Vim 改造为强大的 IDE—Vim 集成 Ctags/Taglist/Cscope/Winmanager/NERDTree/OmniCppComplete（有图有真相）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/chijianqiang/archive/2012/11/06/vim-3.html"&gt;谁说 Vim 不是 IDE？（三）&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category><category term="BufExplorer"></category><category term="NERDTree"></category><category term="WinManager"></category><category term="Airline"></category></entry><entry><title>在 Vim 中写 Markdown 文件</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-markdown.html" rel="alternate"></link><published>2015-02-01T13:46:00+08:00</published><updated>2015-02-01T13:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-02-01:/posts/tools/learning-vim-markdown.html</id><summary type="html">&lt;p&gt;在 Vim 中使用 Markdown 语法写文本。&lt;/p&gt;</summary><content type="html">&lt;p&gt;记录一下最近在 Vim 中摸索使用 Markdown 的经历。&lt;/p&gt;
&lt;h2 id="syntax-hightlight"&gt;Syntax Hightlight&lt;/h2&gt;
&lt;p&gt;Vim 可以通过插件来提供对 Markdown 语法的支持，网上找到很多这类插件，我找到的是下面这个 &lt;a href="https://github.com/preservim/vim-markdown"&gt;preservim/vim-markdown&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="install"&gt;Install&lt;/h3&gt;
&lt;p&gt;使用 Vundle 管理插件，只需要在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;godlygeek/tabular&amp;#39;&lt;/span&gt;
Plugin &lt;span class="s1"&gt;&amp;#39;preservim/vim-markdown&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;然后输入命令即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;+PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="file-extension"&gt;File extension&lt;/h3&gt;
&lt;p&gt;Markdown 文件的后缀名可以是 &lt;code&gt;.markdown&lt;/code&gt;，&lt;code&gt;mkd&lt;/code&gt;，&lt;code&gt;mkdn&lt;/code&gt;，&lt;code&gt;md&lt;/code&gt; 等，但是插件只识别 &lt;code&gt;mkd&lt;/code&gt; 和 &lt;code&gt;markdown&lt;/code&gt; 两种：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim"&gt;Enabling markdown highlighting in Vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为我们已经按照 .md 格式写了很多文本了，这时候更好选择当然是修改设置，让 vim 可以识别这种类型的文件，而不是修改文件后缀名。所以我们需要在 vimrc 中设置一下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;au&lt;/span&gt; &lt;span class="nb"&gt;BufRead&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;BufNewFile&lt;/span&gt; *.md &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;filetype&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;markdown
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这样 .md 文件就可以被识别了。&lt;/p&gt;
&lt;p&gt;经过上面两步，此时再打开 markdown 文件就可以看到语法高亮了。&lt;/p&gt;
&lt;h2 id="preview"&gt;Preview&lt;/h2&gt;
&lt;p&gt;一些专门的 Markdown 软件、网页编辑器都是提供实时预览，Vim 虽然不提供预览窗口，但是配合浏览器，我们也可以实现实时预览的功能，当然还是依靠万能的插件。我使用的是 &lt;a href="https://github.com/iamcco/vim-markdown-preview.nvim"&gt;iamcco/vim-preview.nvim&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="install_1"&gt;Install&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 Vundle 管理插件&lt;/p&gt;
&lt;p&gt;在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;iamcco/vim-markdown-preview&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;打开 vim，输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginInstall
:call&lt;span class="w"&gt; &lt;/span&gt;mkdp#util#install&lt;span class="o"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="use"&gt;Use&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# start preview&lt;/span&gt;
:MarkdownPreview
&lt;span class="c1"&gt;# stop preview&lt;/span&gt;
:MarkdownPreviewStop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/preservim/vim-markdown"&gt;preservim/vim-markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/10964681/enabling-markdown-highlighting-in-vim"&gt;Enabling markdown highlighting in Vim&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/iamcco/vim-markdown-preview.nvim"&gt;iamcco/markdown-preview.nvim&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category><category term="markdown"></category></entry><entry><title>学习 Vim 之 Ctags/Gutentags/Cscope/Taglist</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-ctags-gutentags-cscope-taglist.html" rel="alternate"></link><published>2015-01-25T21:32:00+08:00</published><updated>2015-01-25T21:32:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-25:/posts/tools/learning-vim-ctags-gutentags-cscope-taglist.html</id><summary type="html">&lt;p&gt;总结使用 Ctags/Gutentags/Cscope/Taglist 的使用方法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="background"&gt;Background&lt;/h2&gt;
&lt;p&gt;tags 文件是一种非常有用的文件，本文的内容都是基于 &lt;code&gt;tag&lt;/code&gt; 的，所以首先得了解什么是 tag？&lt;/p&gt;
&lt;p&gt;Vim Manual 里面的简单介绍就足够我们进行下面的内容了。查看 Manual：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;:&lt;/span&gt;help tagsrch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;使用 tags 文件的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先使用 tag 工具（ctags、cscope 等）生成 tags 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，将 tags 文件路径导入到 Vim 中，让 Vim 知道从哪个 tags 文件中查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，使用 Vim 的命令查找 tag。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="universal-ctags"&gt;Universal Ctags&lt;/h2&gt;
&lt;h3 id="intro"&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ctags"&gt;wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ctags&lt;/strong&gt; is a programming tool that generates an index (or tag) file of names found in source and header files of various programming languages. Depending on the language, functions, variables, class members, macros and so on may be indexed. These tags allow definitions to be quickly and easily located by a text editor or other utility. Alternatively, there is also an output mode that generates a cross reference file, listing information about various names found in a set of language files in human-readable form.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;manpage: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;man&lt;span class="w"&gt; &lt;/span&gt;ctags
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;vim Manual：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;:&lt;/span&gt;help &lt;span class="m"&gt;29&lt;/span&gt;.&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;help ctags
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;简而言之，Ctags 是一个可以自动提取源文件和头文件中函数、变量、类成员、宏定义等元素的工具，然后它会建立一个 tags 文件，其他编辑器（比如我们使用的 Vim）可以读取这个 tags 文件，从而快速定位代码的位置。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ctags --list-languages&lt;/code&gt; 可以查看 ctags 支持的语言，使用 &lt;code&gt;ctags --list-maps&lt;/code&gt; 可以查看哪些后缀名对应对应的语言。&lt;/p&gt;
&lt;h3 id="install"&gt;Install&lt;/h3&gt;
&lt;p&gt;ctags 是 Unix 系统自带的一个工具，但是功能比较少，所以一般使用 universal-ctags。我们可以从源码编译安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;https://github.com/universal-ctags/ctags
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ctags
./autogen.sh
./configure
make
make&lt;span class="w"&gt; &lt;/span&gt;install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="gutentags"&gt;Gutentags&lt;/h2&gt;
&lt;p&gt;我们要使用 tags，第一步就是生成 tags 文件。生成 tags 文件时，universal-ctags 提供了很多参数供我们控制生成结果，详细内容可以查看其 manpage。我们可以利用 &lt;a href="https://github.com/ludovicchabant/vim-gutentags"&gt;gutentags&lt;/a&gt; 来帮助我们管理 ctags 的自动调用。&lt;/p&gt;
&lt;h3 id="install_1"&gt;Install&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;ludovicchabant/vim-gutentags&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;+PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="configuare"&gt;Configuare&lt;/h3&gt;
&lt;p&gt;其配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c"&gt;&amp;quot;stop search when match following directory&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_project_root &lt;span class="p"&gt;=&lt;/span&gt; [&lt;span class="s1"&gt;&amp;#39;.root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.git&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.svn&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.project&amp;#39;&lt;/span&gt;]
&lt;span class="c"&gt;&amp;quot; generated tagfile suffix&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_ctags_tagfile &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;.tags&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;&amp;quot; put generated tagfile into cache directory&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; s:vim_tags &lt;span class="p"&gt;=&lt;/span&gt; expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;~/.cache/tags&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_cache_dir &lt;span class="p"&gt;=&lt;/span&gt; s:vim_tags
&lt;span class="c"&gt;&amp;quot; mkdir if cache directory is not exit&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;isdirectory&lt;span class="p"&gt;(&lt;/span&gt;s:vim_tags&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;silent&lt;/span&gt;&lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="k"&gt;call&lt;/span&gt; mkdir&lt;span class="p"&gt;(&lt;/span&gt;s:vim_tags&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;p&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;endif&lt;/span&gt;

&lt;span class="c"&gt;&amp;quot; use universal-ctags to support systemverilog&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot; run `ctags --help` for option descriptions&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot; run `ctags --list-kinds=[language]` for c++, c, verilog, systemverilog kinds description&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_ctags_extra_args  &lt;span class="p"&gt;=&lt;/span&gt; [&lt;span class="s1"&gt;&amp;#39;--fields=+niazS&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;--extra=+q&amp;#39;&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_ctags_extra_args &lt;span class="p"&gt;+=&lt;/span&gt; [&lt;span class="s1"&gt;&amp;#39;--c++-kinds=+pxI&amp;#39;&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_ctags_extra_args &lt;span class="p"&gt;+=&lt;/span&gt; [&lt;span class="s1"&gt;&amp;#39;--c-kinds=+px&amp;#39;&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_ctags_extra_args &lt;span class="p"&gt;+=&lt;/span&gt; [&lt;span class="s1"&gt;&amp;#39;--verilog-kinds=+cefmnprtbi&amp;#39;&lt;/span&gt;]
&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="k"&gt;g&lt;/span&gt;:gutentags_ctags_extra_args &lt;span class="p"&gt;+=&lt;/span&gt; [&lt;span class="s1"&gt;&amp;#39;--systemverilog-kinds=+cfmnprtbiACEIMKPQRSTHLqwloN&amp;#39;&lt;/span&gt;]

&lt;span class="c"&gt;&amp;quot; Open tag in new vertical split window on right&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;] &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;v&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;l&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;]&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="c"&gt;&amp;quot; Add cache directory to tag path for other plugins&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;./&lt;span class="k"&gt;tags&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;+=~&lt;/span&gt;&lt;span class="sr"&gt;/.cache/&lt;/span&gt;&lt;span class="k"&gt;tags&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;Vim 提供了接口可以调用 tags 文件，它使用一个栈来记录我们在文件中跳转的位置。ctags 其 manual page 中有说明如何在 Vi 中使用 ctags：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vi -t tags&lt;/code&gt; 打开 vi，并且将光标停留在 &lt;code&gt;tag&lt;/code&gt; 定义的地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ta tag&lt;/code&gt; 寻找 &lt;code&gt;tag&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-]&lt;/code&gt; 寻找光标处 tag 的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Ctrl-T&lt;/code&gt; 返回到 tag 的前一个位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tnext&lt;/code&gt; 如果某个 tag（比如函数）有多次定义，会匹配到多个结果，本命令跳到下一个结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tprevious&lt;/code&gt; 同上，跳转到前一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tfirst&lt;/code&gt; 跳转到第一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tlast&lt;/code&gt; 跳转到最后一个匹配结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ts tag&lt;/code&gt; 同上，列出所有匹配到 tag 的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:tags&lt;/code&gt; 显示 tagstack 中的内容，即我们的跳转记录&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="cscope"&gt;Cscope&lt;/h2&gt;
&lt;h3 id="intro_1"&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://cscope.sourceforge.net/"&gt;Cscope 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cscope"&gt;cscope wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cscope is a console mode or text-based graphical interface that allows computer programmers or software developers to search C source code (there is limited support for other languages). It is often used on very large projects to find source code, functions, declarations, definitions and regular expressions given a text string. cscope is free and available under a BSD License. The original developer of cscope is Joe Steffen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;man page:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;man&lt;span class="w"&gt; &lt;/span&gt;cscope
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;Vim help:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;:&lt;/span&gt;help &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;cscop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;The following text is taken from a version of the cscope man page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cscope is an interactive screen-oriented tool that helps you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Learn how a C program works without endless flipping through a thick listing.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Locate the section of code to change to fix a bug without having to learn the entire program.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Examine the effect of a proposed change such as adding a value to an enum variable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify that a change has been made in all source files such as adding an argument to an existing function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rename a global variable in all source files.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change a constant to a preprocessor symbol in selected lines of files.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is designed to answer questions like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Where is this symbol used?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is it defined?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where did this variable get its value?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What is this global symbol's definition?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is this function in the source files?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What functions call this function?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What functions are called by this function?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where does the message "out of space" come from?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Where is this source file in the directory structure?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;What files include this header file?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cscope answers these questions from a symbol database that it builds the
 first time it is used on the source files.  On a subsequent call, cscope
 rebuilds the database only if a source file has changed or the list of
 source files is different.  When the database is rebuilt the data for the
 unchanged files is copied from the old database, which makes rebuilding
 much faster than the initial build.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，就是 ctags 的加强版，ctags 只能让我们跳转到某个 tag 的定义之处，但是无法让我们知道这个 tag 还在哪里出现过，或者被哪个函数调用过，这时候就需要 cscope 来大显身手了～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cscope 对 C/C++ 支持比较好，当然我们也可以自己定制来支持其他语言，比如 Java，Python 等。&lt;/p&gt;
&lt;h3 id="install_2"&gt;Install&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;cscope
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="usage_1"&gt;Usage&lt;/h3&gt;
&lt;p&gt;联合使用 Cscope + Vim 的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 cscope 生成数据库文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;cscope&lt;span class="w"&gt; &lt;/span&gt;-Rbkq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;其中参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;-R 递归，对子目录也建立数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-b 只生成数据库，不进入 scope 界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-k 生成数据库时，不搜索 &lt;code&gt;/usr/include&lt;/code&gt; 目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-q 生成 &lt;code&gt;cscope.in.out&lt;/code&gt; 和 &lt;code&gt;cscope.po.out&lt;/code&gt; 文件，加快查找速度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更详细的参数见 man page。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将数据库导入 Vim 中&lt;/p&gt;
&lt;p&gt;cd 到源文件目录下，执行上一步操作，然后打开 vim 输入下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;：&lt;span class="k"&gt;cs&lt;/span&gt; add ./&lt;span class="k"&gt;cscope&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Vim 中查找&lt;/p&gt;
&lt;p&gt;通用格式为 &lt;code&gt;:cs find -option label&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;option 可以有很多种模式，在 Vim 中使用 &lt;code&gt;:help cscope-find&lt;/code&gt; 来查看 option：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;    0 or s: Find this C symbol
    1 or g: Find this definition
    2 or d: Find functions called by this function
    3 or c: Find functions calling this function
    4 or t: Find this text string
    6 or e: Find this egrep pattern
    7 or f: Find this file
    8 or i: Find files #including this file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="config"&gt;Config&lt;/h3&gt;
&lt;p&gt;Vim 的 cscope 接口提供了一些参数，可以让我们更加灵活地使用 cscope，可以用 &lt;code&gt;help if-cscop&lt;/code&gt; 来查看完整的说明，这里有一份前辈翻译的中文版&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/dengxiayehu/article/details/6330200"&gt;Cscope 的使用（领略 Vim + Cscope 的强大魅力）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我找了几个常用的选项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;cscopequickfix&lt;/p&gt;
&lt;p&gt;vim 提供了 &lt;code&gt;cscopequickfix&lt;/code&gt; 选项，让查找结果在 quickfix 的窗口显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时使用 cscope ctags &lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;cst&lt;/code&gt; 选项，可以同时查找 cscope 和 ctags，查找顺序有 &lt;code&gt;csto&lt;/code&gt; 选项来决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:ctags&lt;/code&gt; 等同于 &lt;code&gt;:cs find g&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了省事，我们可以将一些参数设置写在 .vimrc 文件中，Vim help 中有推荐设置，下面是我修改过的配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  &lt;span class="k"&gt;if&lt;/span&gt; has&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cscope&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;csprg&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="sr"&gt;/usr/&lt;/span&gt;&lt;span class="nb"&gt;bin&lt;/span&gt;/&lt;span class="k"&gt;cscope&lt;/span&gt;
      &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;cscopequickfix&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;s&lt;span class="p"&gt;-,&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;&lt;span class="p"&gt;-,&lt;/span&gt;&lt;span class="k"&gt;d&lt;/span&gt;&lt;span class="p"&gt;-,&lt;/span&gt;&lt;span class="k"&gt;i&lt;/span&gt;&lt;span class="p"&gt;-,&lt;/span&gt;&lt;span class="k"&gt;t&lt;/span&gt;&lt;span class="p"&gt;-,&lt;/span&gt;&lt;span class="k"&gt;e&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt;
&lt;span class="c"&gt;    &amp;quot;set cst &amp;quot;keep the regular tag behavior&lt;/span&gt;
&lt;span class="c"&gt;    &amp;quot;set csto=0 &amp;quot;keep the regular tag behavior&lt;/span&gt;
    &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nocsverb&lt;/span&gt;
&lt;span class="c"&gt;    &amp;quot; add any database in current directory&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; filereadable&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cscope.out&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;cs&lt;/span&gt; add &lt;span class="k"&gt;cscope&lt;/span&gt;.out
&lt;span class="c"&gt;    &amp;quot; else add database pointed to by environment&lt;/span&gt;
    &lt;span class="k"&gt;elseif&lt;/span&gt; $CSCOPE&lt;span class="p"&gt;-&lt;/span&gt;DB &lt;span class="p"&gt;!=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;cs&lt;/span&gt; add $CSCOPE&lt;span class="p"&gt;-&lt;/span&gt;DB
    &lt;span class="k"&gt;endif&lt;/span&gt;
    &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;csverb&lt;/span&gt;
  &lt;span class="k"&gt;endif&lt;/span&gt;

  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;s :&lt;span class="k"&gt;cs&lt;/span&gt; find s &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;g&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;g&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;t&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;t&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;e&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;e&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;f&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;f&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;i&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;i&lt;/span&gt; ^&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;$&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;--&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;d&lt;/span&gt; :&lt;span class="k"&gt;cs&lt;/span&gt; find &lt;span class="k"&gt;d&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="c"&gt;  &amp;quot; Using &amp;#39;CTRL-spacebar&amp;#39; then a search type makes the vim window&lt;/span&gt;
&lt;span class="c"&gt;  &amp;quot; split horizontally, with search result displayed in&lt;/span&gt;
&lt;span class="c"&gt;  &amp;quot; the new window.&lt;/span&gt;

  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;s :&lt;span class="k"&gt;scs&lt;/span&gt; find s &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;g&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;g&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;t&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;t&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;e&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;e&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;f&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;f&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;i&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;i&lt;/span&gt; ^&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;$&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;d&lt;/span&gt; :&lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;d&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="c"&gt;  &amp;quot; Hitting CTRL-space *twice* before the search type does a vertical&lt;/span&gt;
&lt;span class="c"&gt;  &amp;quot; split instead of a horizontal one&lt;/span&gt;

  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;s
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find s &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;g&lt;/span&gt;
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;g&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;c&lt;/span&gt;
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;c&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;t&lt;/span&gt;
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;t&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;e&lt;/span&gt;
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;e&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;i&lt;/span&gt;
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;i&lt;/span&gt; ^&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cfile&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;$&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  nmap &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;Space&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;d&lt;/span&gt;
    \:&lt;span class="k"&gt;vert&lt;/span&gt; &lt;span class="k"&gt;scs&lt;/span&gt; find &lt;span class="k"&gt;d&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;C&lt;span class="p"&gt;-&lt;/span&gt;R&lt;span class="p"&gt;&amp;gt;=&lt;/span&gt;expand&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;lt;cword&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="taglist"&gt;Taglist&lt;/h2&gt;
&lt;h3 id="intro_2"&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script-id=273"&gt;Taglist 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用过 VS 的人都知道，在左侧有一个窗口专门显示当前代码文件中的宏、函数、变量定义，并且随着文件切换自动更新。我们这里介绍的 Taglist 完成的就是类似的功能，让我们可以高效地浏览代码。不过要使用 Taglist，首先要安装前面介绍的 Ctags。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The "Tag List" plugin is a source code browser plugin for Vim and provides an overview of the structure of source code files and allows 
you to efficiently browse through source code files for different programming languages. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="install_3"&gt;Install&lt;/h3&gt;
&lt;p&gt;与前面的 ctags、cscope 不同的是，taglist 是一款 Vim 插件。如果使用 Vundle 来管理、安装插件，在 .vimrc 中添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &lt;span class="s1"&gt;&amp;#39;taglist.vim&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;然后打开 vi，然后输入命令 &lt;code&gt;:PluginInstall&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id="config_1"&gt;Config&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;:help taglist&lt;/code&gt; 查看帮助。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;:TlistToggle&lt;/code&gt; 切换是否显示 Taglist 窗口。&lt;/p&gt;
&lt;p&gt;我们可以直接在 .vimrc 中添加以下设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;let&lt;/span&gt; Tlist_Show_One_File&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; Tlist_Exit_OnlyWindow&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; Tlist_SHow_Menu&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;let&lt;/span&gt; Tlist_File_Fold_Auto_Close&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="usage_2"&gt;Usage&lt;/h3&gt;
&lt;p&gt;在 taglist 窗口，我们可以使用下面的一些快捷键：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 折叠所有 tag&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 折叠单个 tag&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 打开一个折叠&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; taglist 窗口放大 / 缩小，方便查看 tag&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 更新 taglist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sapce&lt;/code&gt; 显示光标处 tag 的原型定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配合另外一个窗口管理插件 winmanager，我们可以将我们的 Vim 打造成一个伪 IDE :D&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/alexdboy/article/details/3871707"&gt;ctags 的使用及相关参数介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-use-ctags-tag-file/"&gt;vi/vim 使用进阶 : 使用标签 (tag) 文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cscope.sourceforge.net/"&gt;cscope 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Cscope"&gt;cscope wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/dengxiayehu/article/details/6330200"&gt;Cscope 的使用（领略 Vim + Cscope 的强大魅力）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script-id=273"&gt;Taglist 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-taglist-plugin/"&gt;vi/vim 使用进阶 : 使用 taglist 插件&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category><category term="ctags"></category><category term="gutentags"></category><category term="cscope"></category><category term="taglist"></category></entry><entry><title>针对 Verilog 的 Doxygen</title><link href="https://qian-gu.github.io/posts/ic/doxygen-for-verilog.html" rel="alternate"></link><published>2015-01-21T10:25:00+08:00</published><updated>2015-01-21T10:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-21:/posts/ic/doxygen-for-verilog.html</id><summary type="html">&lt;p&gt;学习 Doxverilog。&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近学习了 Doxygen，它可以帮助我们生成美观的文档。Doxygen 支持的程序语言中包含 VHDL，但是不包含 Verilog。&lt;/p&gt;
&lt;p&gt;那么问题就又来了：&lt;strong&gt;有没有一个支持 Verilog 的类似 Doxygen 的程序？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案当然是：&lt;strong&gt;有， Doxverilog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机智的网友早就遇到了和我一样的问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.edaboard.co.uk/documentation-generator-for-verilog-t241923.html"&gt;Documentation generator for Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sndegroot.blogspot.com/2011/08/documenting-verilog-ams-using.html"&gt;Documenting Verilog (AMS) using Doxygen/Doxverilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://sndegroot.blogspot.com/2014/04/doxverilog-has-been-updated.html"&gt;Doxverilog has been updated&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我搜到了两个工具：一个是 perl 脚本&lt;a href="http://www.burbleland.com/v2html/v2html.html"&gt;v2html&lt;/a&gt;，另一个就是 Doxverilog。前者生成的页面美观性实在不敢恭维，理想工具当然是 Doxverilog。&lt;/p&gt;
&lt;h2 id="doxverilog"&gt;Doxverilog&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxverilog  is a nativ verilog parser (Verilog 2001) for Doxygen. After installing this patch you can documentate your verilog project  similar to VHDL in Doxygen.
Patch against the doxygen-1.7.0 version. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxverilog 基于 Doxygen ，只是额外添加了对 Verilog 语言的支持。它托管在 &lt;a href="http://sourceforge.net/projects/doxverilog.berlios/"&gt;sourceforge&lt;/a&gt; 上的压缩包貌似是损坏的，不能正常解压，幸好在 Github 上的还是好的：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ewa/doxverilog/tree/master/Doxverilog2.7"&gt;Doxverilog on Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Doxverilog 的安装使用方法，github 上已经说的很清楚了，下面只记录一下我遇到的问题。&lt;/p&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;安装步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;patch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;patch -F3 -p0  &amp;lt; linux.patch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compile&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./configure
make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写本文时，Doxverilog 的版本号是 2.7，对应的 Doxygen 的版本号是 1.8.1，而 Doxygen 官网上的版本已经更新到了 1.8.9，如果最新版本可能在编译的时候报错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 patch 时，可能会遇到询问，一路 y 下去即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 compile 时，可能会报错，我遇到的报错是 vhdlparse.cpp 缺少行末分号的小问题，自己添加就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译安装完成之后，我们应该可以使用一个文档来测试一下，如果生成的配置文件中包含 &lt;code&gt;OPTIMIZE-OUTPUT-VERILOG&lt;/code&gt; 这个选项，那么就说明破解安装成功了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="configuration"&gt;Configuration&lt;/h3&gt;
&lt;p&gt;在修改配置文档时，除了常规的配置选项之外，对于 Verilog 我们还需要额外注意一下几个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OPTIMIZE-OUTPUT-VERILOG = YES&lt;/code&gt; 针对 Verilog 进行输出优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FILE-PATTERNS = *.v&lt;/code&gt; 标明选择 verilog 源文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="documenting-verilogvhdl"&gt;Documenting Verilog/VHDL&lt;/h3&gt;
&lt;p&gt;注释规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 Verilog 的注释规则，和 VHDL 类似，唯一的不同之处在于 VHDL 使用 &lt;code&gt;--!&lt;/code&gt; 来开始注释，Verilog 使用 &lt;code&gt;//%&lt;/code&gt; 作为注释的开头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 中使用单行的 &lt;code&gt;--!&lt;/code&gt; 来开始 brief description，使用多行的 &lt;code&gt;--!&lt;/code&gt; 开始 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verilog 使用单行的 &lt;code&gt;//%&lt;/code&gt; 开始 brief description，使用多行的 &lt;code&gt;//%&lt;/code&gt; 开始 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的注释都在对应代码的前面，只有一个例外：端口的 brie description 可以写在代码后，而且不用像 C++ 中一样修改注释的头部&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是 Doxygen 官网是 VHDL 注释的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;--! @file&lt;/span&gt;
&lt;span class="c1"&gt;--! @brief 2:1 Mux using with-select&lt;/span&gt;
&lt;span class="c1"&gt;-------------------------------------------------------&lt;/span&gt;

&lt;span class="c1"&gt;--! Use standard library&lt;/span&gt;
&lt;span class="k"&gt;library&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;ieee&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;--! Use logic elements&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;ieee.std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1164&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--! Mux entity brief description&lt;/span&gt;

&lt;span class="c1"&gt;--! Detailed description of this &lt;/span&gt;
&lt;span class="c1"&gt;--! mux design element.&lt;/span&gt;
&lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;mux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--! Mux first input&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--! Mux Second input&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;--! Select input&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;mux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;--! Mux output&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--! @brief Architecture definition of the MUX&lt;/span&gt;
&lt;span class="c1"&gt;--! @details More details about this mux element.&lt;/span&gt;
&lt;span class="k"&gt;architecture&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;behavior&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;when&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;others&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;architecture&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;生成的 &lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/examples/mux/html/index.html"&gt;结果&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我写的 Verilog 的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//% @file mycounter.v&lt;/span&gt;
&lt;span class="c1"&gt;//% @brief Implementation file of module mycounter.&lt;/span&gt;
&lt;span class="c1"&gt;//% &lt;/span&gt;
&lt;span class="c1"&gt;//% @author Qian Gu&lt;/span&gt;
&lt;span class="c1"&gt;//% @version 1.0&lt;/span&gt;
&lt;span class="c1"&gt;//% @date 2015-01-20&lt;/span&gt;

&lt;span class="c1"&gt;//% This is a test project,&lt;/span&gt;
&lt;span class="c1"&gt;//% it&amp;#39;s a increase counter module 256.&lt;/span&gt;
&lt;span class="c1"&gt;//%&lt;/span&gt;
&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mycounter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Port Declaratiosn&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;//% clock signal&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;//% reset siganl, active high&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;//% count result&lt;/span&gt;

&lt;span class="c1"&gt;// Main Body of Code&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;negedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#vhdlblocks"&gt;doxygen manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/ewa/doxverilog/tree/master/Doxverilog2.7"&gt;doxverilog&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="doxygen"></category><category term="doxverilog"></category><category term="verilog"></category></entry><entry><title>利用 Graphviz 画 FSM 状态图</title><link href="https://qian-gu.github.io/posts/ic/drawing-fsm-state-diagram-using-graphviz.html" rel="alternate"></link><published>2015-01-20T17:55:00+08:00</published><updated>2015-01-20T17:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-20:/posts/ic/drawing-fsm-state-diagram-using-graphviz.html</id><summary type="html">&lt;p&gt;学习使用 Graphviz 画 FSM 的状态转移图&lt;/p&gt;</summary><content type="html">&lt;h2 id="graphviz"&gt;Graphviz&lt;/h2&gt;
&lt;p&gt;Graphviz 是一个由 AT&amp;amp;T 实验室启动的开源工具包，用于绘制 DOT 语言脚本描述的图形。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphviz"&gt;wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Graphviz (short for Graph Visualization Software) is a package of open-source tools initiated by AT&amp;amp;T Labs Research for drawing graphs specified in DOT language scripts. It also provides libraries for software applications to use the tools. Graphviz is free software licensed under the Eclipse Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据介绍，我们知道 Graphviz 基于一种叫做 DOT 的图形描述语言，Graphviz 由一组可以处理 DOT 文件的工具组成，最终生成图形。&lt;/p&gt;
&lt;p&gt;既然是画图，那么问题就来了：很多软件都可以画图，&lt;strong&gt;为什么偏偏要用 Graphviz 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不用鼠标绘制，也不用手动调整坐标。使用 Visio 或者其他的画图工具的人都体验过手动对齐的不便，而且很多时候手动调整根本就对不齐，强迫症患者心中永远的痛 T-T&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改更新方便。手绘的图修改起来很麻烦，而使用 DOT 语言的话，只需要修改脚本就 Ok 了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphviz 的缺点：要想用好，需要投入时间和精力去学习使用方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Graphviz 可以帮助我们画数据结构图、模块图、流程图等，是程序猿的画图利器。这里我们只用它来画简单的 流程图 / 状态图 ，所以只要有基本的图论知识，不涉及高级主题，所以学习起来是很轻松的。&lt;/p&gt;
&lt;p&gt;因为在&lt;a href="http://guqian110.github.io/pages/2015/01/11/how-to-analyse-code-elegantly.html"&gt;前面一篇博客&lt;/a&gt;中我们已经简单介绍了 &lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt; 这个工具软件的安装方法，所以下面直接进入正题：&lt;strong&gt;如何使用 Graphviz 画 FSM 的状态转移图。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;
&lt;p&gt;下面的内容是我精简出来了的最小学习方法，使用方法的详细攻略请看 Graphviz 官网上的 &lt;a href="http://www.graphviz.org/Documentation.php"&gt;Documentation&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id="dot"&gt;DOT&lt;/h3&gt;
&lt;p&gt;DOT 语法在 &lt;a href="http://www.graphviz.org/Documentation.php"&gt;Documentation&lt;/a&gt; 里面有介绍，它的定义方法和 C/C++ 中的 &lt;code&gt;struct&lt;/code&gt; 类似。由图论的基本知识，我们知道描述一个图，只要用节点（&lt;code&gt;node&lt;/code&gt;)、边（&lt;code&gt;edge&lt;/code&gt;） 这两个要素就能描述清楚，而 DOT 语言也就是利用这两个信息来描述一个图的。下面用几个基本的例子来说明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 3 个节点组成的一个无向图。
脚本（example1.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;graph example1 {
    node1 -- node2
    node2 -- node3
    node3 -- node4
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example1" src="/images/drawing-fsm-state-diagram-using-graphviz/example1.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;有向图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还是上面的例子，不过修改为有向图。&lt;/p&gt;
&lt;p&gt;脚本（example2.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;digraph&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;example2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nod31&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example2" src="/images/drawing-fsm-state-diagram-using-graphviz/example2.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;添加属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们还可以控制 node 的属性（节点形状、颜色、边箭头的形状等），来产生不同的结果。&lt;/p&gt;
&lt;p&gt;脚本（example3.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;digraph&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;example3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node1&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;circle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;state1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fillcolor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#123456&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;triangle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;state2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fillcolor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#345678&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;filled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;state3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fillcolor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;#567890&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unfilled&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example3" src="/images/drawing-fsm-state-diagram-using-graphviz/example3.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的结果和我们的状态转移图相比，还差一点就是转移箭头边上的标注，我们可以在 edge 后面加上 &lt;code&gt;label&lt;/code&gt; 属性来标注信息。&lt;/p&gt;
&lt;p&gt;脚本（example4.dot）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;digraph&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;example4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;node3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;node1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;condition3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example4" src="/images/drawing-fsm-state-diagram-using-graphviz/example4.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的 4 个例子就足够我们画 FSM 的状态转移图了。更加详细的说明参考官方文档和一篇文章：&lt;a href="http://www.openfoundry.org/en/foss-programs/8820-graphviz-"&gt;Graphviz - 用指令來畫關係圖吧！&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="command"&gt;Command&lt;/h3&gt;
&lt;p&gt;Graphviz 的命令格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;files&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，cmd 可以是它包含的几个工具 &lt;code&gt;dot&lt;/code&gt;、&lt;code&gt;neato&lt;/code&gt;、&lt;code&gt;circo&lt;/code&gt;、&lt;code&gt;fdp&lt;/code&gt;、&lt;code&gt;osage&lt;/code&gt;、&lt;code&gt;sfdp&lt;/code&gt;、&lt;code&gt;twopi&lt;/code&gt;，我们可以查看 man &lt;cmd&gt; 来看它们的区别，也可以直接运行看结果中的区别。&lt;/p&gt;
&lt;p&gt;其中，flags 可以设置相关属性，比如 &lt;code&gt;-Tformat&lt;/code&gt;，如果我们需要产生 PNG 图片，那么这里就应该是 &lt;code&gt;-Tpng&lt;/code&gt;；再比如 &lt;code&gt;-o&lt;/code&gt; 设置输出目的地。&lt;/p&gt;
&lt;p&gt;所以我们上面 example1 的命令格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dot example1.dot -Tpng -o exampl1.png
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;example2，example3，exampl4 同理。&lt;/p&gt;
&lt;h2 id="example"&gt;Example&lt;/h2&gt;
&lt;p&gt;下面是实际程序中的一个例子：&lt;/p&gt;
&lt;p&gt;dot 脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;digraph&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fsm&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;                                                               &lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;e&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;d&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;e&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;e&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;g&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;g&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0/0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;g&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1/1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用 dot 生成的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fsm-dot" src="/images/drawing-fsm-state-diagram-using-graphviz/fsm-dot.png"&gt;&lt;/p&gt;
&lt;p&gt;使用 circo 生成的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fsm-circo" src="/images/drawing-fsm-state-diagram-using-graphviz/fsm-circo.png"&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/aix/library/au-aix-graphviz/"&gt;使用 Graphviz 生成自动化系统图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.openfoundry.org/en/foss-programs/8820-graphviz-"&gt;Graphviz - 用指令來畫關係圖吧！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.163.com/prevBlogPerma.do?host=lockriver&amp;amp;srl=487232242010101761749383&amp;amp;mode=prev"&gt;Graphviz 使用简介 ( 中文乱码的问题 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://gary-digital.blogspot.com/2006/08/dot.html"&gt;使用 DOT 來描述你的狀態機&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="fsm"></category><category term="graphviz"></category></entry><entry><title>基于 Doxygen 的 C++ 注释风格</title><link href="https://qian-gu.github.io/posts/tools/doxygen-cpp-comment-style.html" rel="alternate"></link><published>2015-01-13T18:00:00+08:00</published><updated>2015-01-13T18:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-13:/posts/tools/doxygen-cpp-comment-style.html</id><summary type="html">&lt;p&gt;总结基于 Doxygen 的 C++ 注释规则&lt;/p&gt;</summary><content type="html">&lt;p&gt;本文内容参考自网上博客内容&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;C++ 标准注释原则 - 基于 doxygen 的 C++ 注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog-6294abe701012pee.html"&gt;Doxygen C++ 注释规范及生成帮助文档配置步骤&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ticktick.blog.51cto.com/823160/188674"&gt;Doxygen 详细介绍（三）（Doxygen 注释风格）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重新整理排版了一下。写本文的主要目的是备忘，当作快速参考来查。&lt;/p&gt;
&lt;h2 id="doxygen"&gt;Doxygen&lt;/h2&gt;
&lt;p&gt;若想用 Doxygen 生成漂亮的文档，我们必须在以下几个地方添加 Doxygen 风格的注释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件头（包括 头文件 .h 和 源文件 .cpp）&lt;/p&gt;
&lt;p&gt;主要用于版权声明，描述本文件的功能，以及作者、版本信息等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的定义&lt;/p&gt;
&lt;p&gt;主要用于描述类的功能，同时也可以包含使用方法、注意事项的 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的成员变量定义&lt;/p&gt;
&lt;p&gt;对该成员变量进行 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类的成员函数定义&lt;/p&gt;
&lt;p&gt;对该成员函数的功能进行 brief description。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数实现&lt;/p&gt;
&lt;p&gt;对函数的功能、参数、返回值、需要注意的问题、相关说明等进行 detailed description。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="c-comment-style"&gt;C++ Comment Style&lt;/h2&gt;
&lt;p&gt;Doxygen 支持多种注释风格，比如 JavaDoc-like 风格，Qt 风格等。在写 C++ 代码时，我们应该遵守 C++ 的行注释风格，所谓行注释风格，是指一般 C++ 程序员避免使用 C 风格的注释符号 &lt;code&gt;/* */&lt;/code&gt;，而是使用 3 个连续的 &lt;code&gt;/&lt;/code&gt; 作为注释的开头。除了这个区别之外，其他部分和 JavaDoc 风格类似：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个对象的 brief description 用单行的 &lt;code&gt;///&lt;/code&gt; 开始，并且写在代码前面。一般 brief 写在头文件中，对象的声明之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个对象的 detailed description 用多于两行的 &lt;code&gt;///&lt;/code&gt; 开始，并且写在代码前面。如果注释长度不足两行，第二行的开头仍要写出。一般 detailed 写在源文件中，对象的定义之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一段代码既是声明也是定义，则 brief 和 detailed 写在一起。使用 &lt;code&gt;\brief&lt;/code&gt; 命令，并且使用空行将两者分开。一般 brief 写在头文件中，对象的声明之前。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 line at least.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是代码模板：&lt;/p&gt;
&lt;h3 id="license"&gt;License&lt;/h3&gt;
&lt;p&gt;使用 DoxygenToolKit 自动生成的 Lisence 即可。&lt;/p&gt;
&lt;h2 id="file-header"&gt;File header&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \file file-name.h&lt;/span&gt;
&lt;span class="c1"&gt;/// \brief Head file for class Ctest.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed file description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \author author-name&lt;/span&gt;
&lt;span class="c1"&gt;/// \version version-number&lt;/span&gt;
&lt;span class="c1"&gt;/// \date xxxx-xx-xx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="namespace"&gt;Namespace&lt;/h3&gt;
&lt;p&gt;namespace 的注释方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \brief A brief namespace description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed namespace description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="class"&gt;Class&lt;/h3&gt;
&lt;p&gt;class 的定义和声明都在头文件中，所以使用下面这种 brief 和 detailed 结合的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \brief A brief class description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed calss description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="member-function"&gt;member function&lt;/h4&gt;
&lt;p&gt;对于成员函数，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若是在头文件的声明处，使用 brief&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是在源文件的定义处，使用 detailed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若是在头文件处，声明和定义重合，使用 brief + detailed&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="member-variable"&gt;member variable&lt;/h4&gt;
&lt;p&gt;对于成员变量，在行末使用 &lt;code&gt;///&amp;lt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="function"&gt;Function&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;brief:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单行的 &lt;code&gt;///&lt;/code&gt; 注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// A brief function description.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;detailed:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;至少两行 &lt;code&gt;///&lt;/code&gt; 的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// This is the detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在 detailed description 中还可以添加一些 &lt;code&gt;structural command&lt;/code&gt;，常用的有 &lt;code&gt;\param&lt;/code&gt;、&lt;code&gt;\return&lt;/code&gt;、&lt;code&gt;\see&lt;/code&gt;、&lt;code&gt;\note&lt;/code&gt;、&lt;code&gt;\warning&lt;/code&gt; 等：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// This is the detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p1 Brief description for p1&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p2 Brief description for p2&lt;/span&gt;
&lt;span class="c1"&gt;/// \return Brief description for return value&lt;/span&gt;
&lt;span class="c1"&gt;/// \note something to note.&lt;/span&gt;
&lt;span class="c1"&gt;/// \warning Warning.&lt;/span&gt;
&lt;span class="c1"&gt;/// \see See-also&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;brief + detailed:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果函数声明和定义重合，则 brief 和 detailed 合在一起，并且使用 &lt;code&gt;\brief&lt;/code&gt; 命令，格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \brief A brief function description.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p1 Description for p1.&lt;/span&gt;
&lt;span class="c1"&gt;/// \param p2 Description for p2.&lt;/span&gt;
&lt;span class="c1"&gt;/// \return Description for return value.&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在 Doxgyen 的 manual 里面有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike most other documentation systems, doxygen also allows you to put the documentation of members (including global functions) in front of the definition. This way the documentation can be placed in the source file instead of the header file. This keeps the header file compact, and allows the implementer of the members more direct access to the documentation. As a compromise the brief description could be placed before the declaration and the detailed description before the member definition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Doxygen 允许注释出现在对象的定义之前，所以我们可以将注释写在源文件中，而不是头文件中。这样做的好处是使头文件更加紧凑、代码的实现者阅读起来也更加直观。所以我们采用的方案是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在函数声明前写 brief，在函数定义前写 detailed。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 inline 函数，使用 brief，尽量保持简洁，不要多于一行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="variable"&gt;Variable&lt;/h3&gt;
&lt;p&gt;变量一般使用 &lt;code&gt;///&amp;lt;&lt;/code&gt; 方式即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;///&amp;lt; brief description for variable m-a&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;///&amp;lt; brief description for variable m-b&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果需要进行详细描述，则采用类似函数注释的方法（brief + detailed）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="enum-struct"&gt;Enum &amp;amp; Struct&lt;/h3&gt;
&lt;p&gt;类似于 Variable 的注释方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \brief A brief description.&lt;/span&gt;
&lt;span class="c1"&gt;/// &lt;/span&gt;
&lt;span class="c1"&gt;/// A detailed description, it&lt;/span&gt;
&lt;span class="c1"&gt;/// should be 2 lines at least.&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Tenum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;em&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;///&amp;lt; enum value em-1&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;em&lt;/span&gt;&lt;span class="mi"&gt;-2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;///&amp;lt; enum value em-2&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;em&lt;/span&gt;&lt;span class="mi"&gt;-3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;///&amp;lt; enum value em-3&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;emVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;///&amp;lt; enum variable.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="others"&gt;Others&lt;/h3&gt;
&lt;p&gt;TODO 命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \todo Task1 to do&lt;/span&gt;
&lt;span class="c1"&gt;/// \todo Task2 to do&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;BUG 命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// \bug Bug1 to be fixed&lt;/span&gt;
&lt;span class="c1"&gt;/// \bug Bug2 to be fixed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从网上找到一个 Doxygen for C 的示例：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://fnch.users.sourceforge.net/doxygen-c.html"&gt;Doxygen usage example (for C)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有一些注释方法很有借鉴意义，可以当作模板来用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.P.S&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又找到一份注释规范的文档，写的挺好，值得一看。&lt;/p&gt;
&lt;p&gt;&lt;a href="/file/cpp-comment-standard.doc"&gt;C++ 注释规范&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;</content><category term="Tools"></category><category term="C++"></category><category term="comment style"></category></entry><entry><title>学习 Vim 插件 DoxygenToolKit.vim</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-doxygentoolkit.html" rel="alternate"></link><published>2015-01-12T15:21:00+08:00</published><updated>2015-01-12T15:21:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-12:/posts/tools/learning-vim-doxygentoolkit.html</id><summary type="html">&lt;p&gt;学习 Vim 插件 DoxygenToolKit。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://qian-gu.github.io/posts/tools/how-to-analyse-code-elegantly.html"&gt;前面一篇博客&lt;/a&gt;已经介绍过 Doxygen 了，Doxygen 的确是一个非常给力的工具，但是为了生成文档，我们必须在注释上花费很大的时间和精力。那么问题又来了：如何才能既享受 Doxygen 的强大功能，同时又避免注释中大量的重复性的输入？&lt;/p&gt;
&lt;p&gt;解决思路是让编辑器来替我们写那些格式和内容固定的部分，我们只负责写真正的有效内容。所以答案就是：&lt;strong&gt;Vim + DoxygenToolKit.vim 插件&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="doxygentoolkit"&gt;DoxygenToolKit&lt;/h2&gt;
&lt;p&gt;DoxygenToolKit 是 Vim 的一款插件，用它可以很方便地添加 Doxygen 风格的注释，可以节省大量时间和精力，提高写代码的效率。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=987"&gt;DoxygenToolKit Official Website&lt;/a&gt; 官网上介绍，目前定义了 5 个功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen license comment.  The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen author skeleton.  The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generates a doxygen comment skeleton for a C, C++ or Python function or class, including @brief, @param (for each named argument), and @return. The tag  text as well as a comment block header and footer are configurable. (Consequently, you can have \brief, etc. if you wish, with little effort.) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore code fragment placed in a block defined by #ifdef ... #endif (C/C++).  The  block name must be given to the function. All of the corresponding blocks 
in all the file will be treated and placed in a new block DOX-SKIP-BLOCK (or any other name that you have configured).  Then you have to update PREDEFINED value in your doxygen configuration file with correct block name. You also have to set ENABLE-PREPROCESSING to YES. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generate a doxygen group (begining and ending). The tag text is configurable. &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;如果我们使用 Vundle 管理插件，安装步骤就非常简单了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 Vundle 中加入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;Plugin &amp;#39;DoxygenToolkit.vim&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Vim，输入命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginInstall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vundle 会自动完成安装 :-D&lt;/p&gt;
&lt;h3 id="configuration-for-c"&gt;Configuration for c++&lt;/h3&gt;
&lt;p&gt;我们有两种方法可以修改设置，方法一是直接在 DoxygenToolKit.vim 脚本文件中修改相关变量；方法二是在 ~/.vimrc 里面修改。显然方法二更加好一点，因为如果用方法一直接改原脚本，可能还得保存备份才能恢复默认值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;loaded_DoxygenToolkit&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; set for C++ style&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_commentType&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;C++&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_briefTag_funcName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yes&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;DoxygenToolkit_authorName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Qian Gu&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="usage"&gt;Usage&lt;/h3&gt;
&lt;p&gt;官网上也给出了使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;License&lt;/p&gt;
&lt;p&gt;将光标放在需要生成 License 的地方，然后输入命令 &lt;code&gt;:DoxLic&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Author&lt;/p&gt;
&lt;p&gt;将光标放在合适的地方，然后输入命令 &lt;code&gt;:DoxAuthor&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function / Class&lt;/p&gt;
&lt;p&gt;将光标放在 function 或者 class 的名字所在的一行，然后输入命令 &lt;code&gt;:Dox&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore code fragment (C/C++ Only)&lt;/p&gt;
&lt;p&gt;如果想忽略调试部分的代码，那么只需要执行命令 &lt;code&gt;:DoxUndoc(DEBUG)&lt;/code&gt; 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Group&lt;/p&gt;
&lt;p&gt;输入命令 &lt;code&gt;DoxBlock&lt;/code&gt; 来插入一个注释块&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便使用，我们可以自定义一些 map，省去输入命令的繁琐。&lt;/p&gt;
&lt;h3 id="example"&gt;Example&lt;/h3&gt;
&lt;p&gt;同样是官网上的例子：&lt;/p&gt;
&lt;p&gt;假设有个函数如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mychar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;myint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;myarray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mask&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DEFAULT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;//... &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;那么执行 &lt;code&gt;:Dox&lt;/code&gt; 命令之后会生成以下内容&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;* @brief &lt;/span&gt;
&lt;span class="cm"&gt;* &lt;/span&gt;
&lt;span class="cm"&gt;* @param mychar &lt;/span&gt;
&lt;span class="cm"&gt;* @param myint &lt;/span&gt;
&lt;span class="cm"&gt;* @param myarray &lt;/span&gt;
&lt;span class="cm"&gt;* @param mask &lt;/span&gt;
&lt;span class="cm"&gt;* &lt;/span&gt;
&lt;span class="cm"&gt;* @return &lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.vim.org/scripts/script.php?script_id=987"&gt;DoxygenToolKit.vim&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category><category term="DoxygenToolKit"></category></entry><entry><title>如何优雅的分析代码</title><link href="https://qian-gu.github.io/posts/tools/how-to-analyse-code-elegantly.html" rel="alternate"></link><published>2015-01-11T18:49:00+08:00</published><updated>2015-01-11T18:49:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-11:/posts/tools/how-to-analyse-code-elegantly.html</id><summary type="html">&lt;p&gt;学习 Doxygen + Graphviz 的使用方法&lt;/p&gt;</summary><content type="html">&lt;p&gt;当我们来接手一个别人的工程时，阅读别人的代码是一件很痛苦的事。成千上百的函数，糟糕的代码风格，不知所云的注释，这些都是让人抓狂。那么，问题就来了：&lt;strong&gt;如何优雅地分析别人的代码？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案就是：&lt;strong&gt;Doxygen + Graphviz&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整个工作流程很简单，我们在写程序时按照 Doxygen 约定的格式注释代码（不注释也可以），Doxygen 会对代码进行分析，然后列出程序中的变量、类定义、数据结构、函数表用关系等，然后调用 Graphviz 将结果用图形化的形式表现出来。&lt;/p&gt;
&lt;p&gt;这个功能在自动生成文档、代码分析时非常强大，下面分别简单介绍一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Linux 环境下，Vim 有插件 &lt;strong&gt;DoxygenToolKIt.vim&lt;/strong&gt; 可以帮助我们很方便地写出 Doxygen 风格的代码。这里只介绍 Doxygen + Graphviz，DoxygenToolKit.vim 在另外一篇中介绍。&lt;/p&gt;
&lt;h2 id="graphviz"&gt;Graphviz&lt;/h2&gt;
&lt;h3 id="what-is-graphviz"&gt;What is Graphviz?&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz official website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Graphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics,  software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="installation"&gt;Installation&lt;/h3&gt;
&lt;p&gt;官方网站上有各个平台（Windows/Unix/Linnux/Mac）的安装文件和源码，在 Ubuntu 13.10 saucy 下，直接使用 apt-get 安装即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo apt-get install graphviz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id="more"&gt;More&lt;/h3&gt;
&lt;p&gt;更多详细的介绍见官网的 About、Documentation、Wiki、FAQ。&lt;/p&gt;
&lt;h2 id="doxygen"&gt;Doxygen&lt;/h2&gt;
&lt;h3 id="what-is-doxygen"&gt;What is Doxygen&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen Official website&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Doxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL, Tcl, and to some extent D.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，Doxygen 是一个程序的文件产生工具，可将程序中的特定批注转换成为说明文件。只要我们在写注释的时候按照它制定的规则写，那么它就可以为我们生成漂亮的文档。&lt;/p&gt;
&lt;h3 id="installation_1"&gt;Installation&lt;/h3&gt;
&lt;p&gt;官网上的 Manual 中有详细的介绍，对于不同平台，采用不同的安装方式（从源码编译安装、二进制文件安装），下面仅记录我在 Ubuntu 下使用源码编码的方式安装过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载源代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git clone https://github.com/doxygen/doxygen.git
cd doxygen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;./configure
make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装成功之后，在 &lt;code&gt;/usr/bin/&lt;/code&gt; 或者 &lt;code&gt;/usr/local/bin&lt;/code&gt; 目录下可以查看到二进制 &lt;code&gt;doxygen&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若 configure 出错，检查依赖关系，安装需要系统中有 GNU 工具（flex, bison, libiconv and GNU make, and strip）和 Perl 支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 Doxygen 要调用 Graphviz，所以先安装 Graphviz，然后编译安装 Doxygen&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="getting-started"&gt;Getting Started&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/starting.html"&gt;Getting Started&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检查 Doxygen 是否支持你项目所使用的语言&lt;/p&gt;
&lt;p&gt;Doxygen 支持  C, C++, C#, Objective-C, IDL, Java, VHDL, PHP, Python, Tcl, Fortran, D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个配置文件&lt;/p&gt;
&lt;p&gt;Doxygen 使用一个配置文件来工作，，每个项目都应该有一个自己对应的配置文件。我们可以使用 &lt;code&gt;doxygen -g&lt;/code&gt; 来让 Doxygen 自动生成一个参考配置文件，然后修改其中个别配置即可 .&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;doxygen -g &amp;lt;config-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;常用配置：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PROJECT-NAME = "Test Project"&lt;/code&gt; 配置项目名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PROJECT-NUMBER = 1.0&lt;/code&gt; 配置项目版本号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUTPUT-DIRECTORY = ./doxygen-output&lt;/code&gt; 配置输出结果目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OPTIMIZE-OUTPUT-FOR-C = YES&lt;/code&gt; 设置针对哪种语言进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;EXTRACT-ALL = YES&lt;/code&gt; 默认是 &lt;code&gt;NO&lt;/code&gt;，即默认只对有标准注释的文件进行分析。如果我们希望对一个没有按照标准格式注释的项目进行分析，那么就要改为 &lt;code&gt;YES&lt;/code&gt;，这在接手一个旧项目，分析代码时尤其有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;HAVE-DOT = YES&lt;/code&gt; 设置 Doxygen 调用 dot 工具（graphviz 的一部分）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DOT-PATH = /usr/local/graphviz&lt;/code&gt; 指定 graphviz 的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 Doxygen&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;doxygen &amp;lt;config-file&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果前一步没有指定配置文件的名字的话，直接运行 &lt;code&gt;doxygen&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;运行完之后，就可以在指定的输出目录中看到结果，用浏览器可以看到 HTML 版本的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照 Doxygen 格式注释代码&lt;/p&gt;
&lt;p&gt;这一步应该在最前面，即先按照 Doxygen 风格格式注释好代码，然后再进行分析。官网上针对不同的编程语言，有详细的举例说明：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html#specialblock"&gt;Documenting the code&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="documenting-the-code"&gt;Documenting the code&lt;/h3&gt;
&lt;p&gt;这部分虽然在最后，事实上应该是第一步，也就是说我们先按照规定添加 Doxygen 风格的注释，然后再配置、调用 Doxygen 来生成文档。&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen 官网&lt;/a&gt;上有详细的注释&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/docblocks.html"&gt;格式说明&lt;/a&gt;，下面是我搬运来学习，自己翻译的。&lt;/p&gt;
&lt;p&gt;我们在 C/C++ 风格注释块中加入一些特殊符号，这样 Doxygen 就知道需要把这段注释分析生成在文档中，这样的注释在官网中叫做 &lt;code&gt;Special comment blocks&lt;/code&gt;。下面详细介绍类 C/C++ 语言（C/C++/C#/Objective-C/PHP/Java）的注释，其他语言（Python, VHDL, Fortran, Tcl）见官网。&lt;/p&gt;
&lt;p&gt;对于代码中的任何实体（&lt;code&gt;entity&lt;/code&gt;），都有两种注释，它们一起工作，完成注释功能，但至少得有一个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a brief description&lt;/code&gt;：单行的简短注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;a detailed description&lt;/code&gt;：多行的详细注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 方法 &lt;code&gt;methods&lt;/code&gt; 和 函数 &lt;code&gt;functions&lt;/code&gt;，还有额外的第三种注释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in body description&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于详细注释（detailed description），可以用以下的几种风格来进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JavaDoc Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在 C 风格注释块开始使用两个星号 &lt;code&gt;*&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/**&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Qt Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即在 C 风格注释块开始处添加一个叹号 &lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/*&lt;/span&gt;!
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C++ Comment Style&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用连续两个以上的 C++ 注释行组成注释块，并且每行要多写一个 &lt;code&gt;/&lt;/code&gt; 或者 &lt;code&gt;!&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;span class="c1"&gt;/// ... text ...&lt;/span&gt;
&lt;span class="c1"&gt;///&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;or&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//!&lt;/span&gt;
&lt;span class="c1"&gt;//! ... text ...&lt;/span&gt;
&lt;span class="c1"&gt;//!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四种格式，有的人喜欢让自己的注释更加醒目一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="c1"&gt;/// ... text ...&lt;/span&gt;
&lt;span class="c1"&gt;/////////////////////////////////////////////////&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于简单注释（brief description），也有以下的几种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可以选用以上其中一种风格，然后加入 &lt;code&gt;\brief&lt;/code&gt; 命令来标明 brief 的开始。这种方式以段落的结尾作为结束。所以在 brief 后要写 detailed 的话，需要空一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;Brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;continued&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;Detailed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;starts&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果选择 JavaDoc 的风格，并且在配置文件中设置 &lt;code&gt;JAVADOC-AUTOBRIEF = YES&lt;/code&gt; 的话，Doxygen 会自动将第一句话作为 brief description，这个句子以 &lt;code&gt;. + 空格 / 空行&lt;/code&gt; 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;which&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ends&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;at&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Details&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;follow&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方式对多行的 C++ 特殊注释风格也有效：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// Brief description which ends at this dot. Details follow&lt;/span&gt;
&lt;span class="c1"&gt;/// here.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种方法是使用不多于一行的特殊 C++ 风格注释，下面是两个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;/// Brief description.&lt;/span&gt;
&lt;span class="o"&gt;/**&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Detailed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者：（这种情况下，必须用空行把 brief 和 detailed 分开，同时 &lt;code&gt;JAVADOC-AUTOBRIEF = NO&lt;/code&gt;）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//! Brief description.&lt;/span&gt;

&lt;span class="c1"&gt;//! Detailed description &lt;/span&gt;
&lt;span class="c1"&gt;//! starts here.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Doxygen 和其他的文档系统的一个不同之处就是它允许把注释写在实体的定义（包括全局函数）之前。这样，就可以把注释直接写在源文件里面而不是头文件中，从而使头文件更加紧凑，而且功能的实现人员也更容易阅读注释。&lt;strong&gt;所以，一个折衷方案就是在声明前写 brief description，在定义前写 detailed description。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="putting-documentation-after-members"&gt;Putting documentation after members&lt;/h4&gt;
&lt;p&gt;在注释结构体、类、枚举类型等时，有时习惯将注释写在代码的后面，而不是前面。因为 Doxygen 默认注释是解释后面的代码，所以这时候就需要在注释中添加一个额外的 &lt;code&gt;&amp;lt;&lt;/code&gt; 来标明是注释前面的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Qt 风格的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/*!&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Detailed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;after&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/**&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Detailed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;after&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//!&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Detailed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;after&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;//!&amp;lt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般来说，我们通常在后面添加的注释都是 brief description 而不是 detailed description，所以更常见的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//!&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;after&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;///&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;after&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种添加 &lt;code&gt;&amp;lt;&lt;/code&gt; 的方法只能用在 成员（&lt;code&gt;member&lt;/code&gt;）和 参数（&lt;code&gt;parameter&lt;/code&gt;）中，不能用在描述文件、类、联合体、名字空间和枚举本身。此外 , 在后面提到的结构化命令（如&lt;code&gt;\class&lt;/code&gt;）在这种注释段中是无效的。&lt;/p&gt;
&lt;h4 id="examples"&gt;Examples&lt;/h4&gt;
&lt;p&gt;官网上提供了一个例子，分别用 Qt 和 JavaDoc 的风格注释一段相同的 C++ 代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Qt style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;
&lt;span class="normal"&gt;59&lt;/span&gt;
&lt;span class="normal"&gt;60&lt;/span&gt;
&lt;span class="normal"&gt;61&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//!  A test class. &lt;/span&gt;
&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;  A more elaborate class description.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! An enum.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*! More detailed enum description. */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;TEnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="n"&gt;TVal1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal1. */&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="n"&gt;TVal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal2. */&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="n"&gt;TVal3&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/*!&amp;lt; Enum value TVal3. */&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;//! Enum pointer.&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="cm"&gt;/*! Details. */&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;enumPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="c1"&gt;//! Enum variable.&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="cm"&gt;/*! Details. */&lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;enumVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! A constructor.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      A more elaborate description of the constructor.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! A destructor.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      A more elaborate description of the destructor.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! A normal member taking two arguments and returning an integer value.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      \param a an integer argument.&lt;/span&gt;
&lt;span class="cm"&gt;      \param s a constant character pointer.&lt;/span&gt;
&lt;span class="cm"&gt;      \return The test results&lt;/span&gt;
&lt;span class="cm"&gt;      \sa Test(), ~Test(), testMeToo() and publicVar()&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;testMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! A pure virtual member.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      \sa testMe()&lt;/span&gt;
&lt;span class="cm"&gt;      \param c1 the first argument.&lt;/span&gt;
&lt;span class="cm"&gt;      \param c2 the second argument.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;testMeToo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! A public variable.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      Details.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;publicVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//! A function variable.&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/*!&lt;/span&gt;
&lt;span class="cm"&gt;      Details.&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/qtstyle/html/class-test.html&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaDoc style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;
&lt;span class="normal"&gt;59&lt;/span&gt;
&lt;span class="normal"&gt;60&lt;/span&gt;
&lt;span class="normal"&gt;61&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *  A test class. A more elaborate class description.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;     * An enum.&lt;/span&gt;
&lt;span class="cm"&gt;     * More detailed enum description.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;TEnum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;TVal1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/**&amp;lt; enum value TVal1. */&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;TVal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/**&amp;lt; enum value TVal2. */&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;TVal3&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/**&amp;lt; enum value TVal3. */&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;enumPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/**&amp;lt; enum pointer. Details. */&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;enumVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="cm"&gt;/**&amp;lt; enum variable. Details. */&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A constructor.&lt;/span&gt;
&lt;span class="cm"&gt;       * A more elaborate description of the constructor.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A destructor.&lt;/span&gt;
&lt;span class="cm"&gt;       * A more elaborate description of the destructor.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * a normal member taking two arguments and returning an integer value.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param a an integer argument.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param s a constant character pointer.&lt;/span&gt;
&lt;span class="cm"&gt;       * @see Test()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see ~Test()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see testMeToo()&lt;/span&gt;
&lt;span class="cm"&gt;       * @see publicVar()&lt;/span&gt;
&lt;span class="cm"&gt;       * @return The test results&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;testMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * A pure virtual member.&lt;/span&gt;
&lt;span class="cm"&gt;       * @see testMe()&lt;/span&gt;
&lt;span class="cm"&gt;       * @param c1 the first argument.&lt;/span&gt;
&lt;span class="cm"&gt;       * @param c2 the second argument.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="k"&gt;virtual&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;testMeToo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/** &lt;/span&gt;
&lt;span class="cm"&gt;       * a public variable.&lt;/span&gt;
&lt;span class="cm"&gt;       * Details.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;publicVar&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;       * a function variable.&lt;/span&gt;
&lt;span class="cm"&gt;       * Details.&lt;/span&gt;
&lt;span class="cm"&gt;       */&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;生成的 HTML 网页：http://www.stack.nl/~dimitri/doxygen/manual/examples/jdstyle/html/class-test.html&lt;/p&gt;
&lt;h4 id="documentation-at-other-places"&gt;Documentation at other places&lt;/h4&gt;
&lt;p&gt;我们之前的例子中注释都是在文件、命名空间、类的声明或者定义之前，或者在它们的成员的前 / 后。虽然一般来说这是很正常的，但是有时候我们需要把代码写在在文档的其他地方。对于文件的注释更是如此，因为对于文件来说，根本就不存在在它之前的地方（"in front of a file"）。&lt;/p&gt;
&lt;p&gt;Doxygen 允许你把注释写在任何地方（例外情况是在函数体内 or 在 C 风格注释块内）。你需要付出的代价就是要在注释块内部多写一些结构化命令（&lt;code&gt;structural command&lt;/code&gt;）来标明。所以，&lt;strong&gt;一般来说，我们应该尽量避免使用结构化命令，除非是有其他的特殊要求这样做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构化命令以一个 &lt;code&gt;\&lt;/code&gt; 或者 &lt;code&gt;@&lt;/code&gt;（JavaDoc 风格）开始，后面接一个命令名字 + 一个（多个）参数。举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/*&lt;/span&gt;!&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;brief&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;more&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;detailed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个例子中的 &lt;code&gt;\class&lt;/code&gt; 指示这个注释块中包含一个 Test 类的文档。其他常用的命名如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\structure&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\union&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;emun&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;def&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\typedef&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\file&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\namespace&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\package&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;\interface&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;完整的命令和说明在这里：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/commands.html"&gt;special commands&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对 C++ 类成员进行注释的时候，必须先注释这个类，对于命名空间来说也是如此。对 C 的全局函数、 typedef、enum、 preprocessor definition 进行注释，必须先注释包含它们的文件（通常是头文件）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Attention:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在重复一下容易出错的地方：&lt;strong&gt;在注释全局对象时，必须先注释它们所在的文件。&lt;/strong&gt;也就是说，必须包含以下两者之一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是官网上的一个 C 头文件的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/*! \file structcmd.h&lt;/span&gt;
&lt;span class="cm"&gt;\brief A Documented file.&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \def MAX(a,b)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A macro that returns the maximum of \a a and \a b.&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \var typedef unsigned int UINT32&lt;/span&gt;
&lt;span class="cm"&gt;    \brief A type definition for a .&lt;/span&gt;

&lt;span class="cm"&gt;    Details.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \var int errno&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Contains the last error code.&lt;/span&gt;
&lt;span class="cm"&gt;    \warning Not thread safe!&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int open(const char *pathname,int flags)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Opens a file descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param pathname The name of the descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param flags Opening flags.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int close(int fd)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Closes the file descriptor \a fd.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to close.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn size-t write(int fd,const char *buf, size-t count)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Writes \a count bytes from \a buf to the filedescriptor \a fd.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to write to.&lt;/span&gt;
&lt;span class="cm"&gt;    \param buf The data buffer to write.&lt;/span&gt;
&lt;span class="cm"&gt;    \param count The number of bytes to write.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cm"&gt;/*! \fn int read(int fd,char *buf,size-t count)&lt;/span&gt;
&lt;span class="cm"&gt;    \brief Read bytes from a file descriptor.&lt;/span&gt;
&lt;span class="cm"&gt;    \param fd The descriptor to read from.&lt;/span&gt;
&lt;span class="cm"&gt;    \param buf The buffer to read into.&lt;/span&gt;
&lt;span class="cm"&gt;    \param count The number of bytes to read.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#define MAX(a,b) (((a)&amp;gt;(b))?(a):(b))&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UINT32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;上面这个例子中的每个注释块都包含了一条结构化命令，所以这些注释可以放在文件的其他位置或者放在其他文件中，不会影响到最终生成的文档。这种方法的坏处在于我们实际上写了两遍原型，当做修改时我们必须同时修改代码和注释。因此，我们在使用前应该仔细考虑是否真的需要结构化命令，并且尽可能避免使用它。一个常见的现象就是在函数前的注释块中包含了 &lt;code&gt;\fn&lt;/code&gt; 命令，显然这是冗余的，除了导致错误，这个命令毫无作用。&lt;/p&gt;
&lt;p&gt;如果我们对以 .dox, .txt, .doc 结尾的文件注释，那么 Doxygen 会自动忽略这些文件。&lt;/p&gt;
&lt;p&gt;如果我们有一个 Doxygen 无法解析的文件，但是仍然像注释它，那么就使用 &lt;code&gt;\verbinclude&lt;/code&gt; 这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;/*&lt;/span&gt;!&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;myscript&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;Look&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;at&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nice&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;srcipt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;verbinlcude&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mycript&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;
&lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;还要确定在配置文件中 &lt;code&gt;INPUT&lt;/code&gt; 变量显式地说明这个脚本文件，或者 &lt;code&gt;FILE-PATTERNS&lt;/code&gt; 变量必须包含&lt;code&gt;.sh&lt;/code&gt; 文件扩展名并且可以通过 &lt;code&gt;EXAMPLE-PATH&lt;/code&gt; 变量寻找到这个文件。&lt;/p&gt;
&lt;h4 id="anatomy-of-a-comment-block"&gt;Anatomy of a comment block&lt;/h4&gt;
&lt;p&gt;前面介绍了如何对代码进行注释，并且讨论了两种不同的注释：brief 和 detailed，还讨论了如何使用结构化命令。&lt;/p&gt;
&lt;p&gt;下面我们分析注释块本身。&lt;/p&gt;
&lt;p&gt;Doxygen 支持很多种格式的注释，最简单的就是文本文件，适用于比较短的注释。对于比较长的注释，我们需要清单、表格等更加结构化的元素，对于这种情况，Doxygen 支持 Markdown 语法，可以直接读取 Markdown 文件，详细内容看这里：&lt;a href="http://www.stack.nl/~dimitri/doxygen/manual/markdown.html"&gt;Markdown Support&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;(Markdown 源自邮件的文本格式，语法非常简洁，并且功能很强大，这篇文章本书就是用 Markdown 语法写的，语法细节见官网，这里不再赘述。)&lt;/p&gt;
&lt;p&gt;P.S.&lt;/p&gt;
&lt;p&gt;找到一篇博客，详细介绍了基于 Doxygen 的 C++ 注释风格：&lt;a href="http://blog.csdn.net/czyt1988/article/details/8901191"&gt;C++ 标准注释原则 - 基于 doxygen 的 C++ 注释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后展示一张我的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/how-to-analyse-code-elegantly/result.png"&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref.&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/blood008/article/details/6567169"&gt;linux doxygen 的安装和使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.stack.nl/~dimitri/doxygen/index.html"&gt;Doxygen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/wishma/archive/2008/07/24/1250339.html"&gt;doxygen 使用简介（C,C++ 为代码作注释）&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="doxygen"></category><category term="code"></category></entry><entry><title>LTE 咬尾卷积编码器的 Matlab 、C 语言及 FPGA 实现</title><link href="https://qian-gu.github.io/posts/telecom/tail-bitting-convolutional-code-implementation-in-matlab-and-c-and-fpga.html" rel="alternate"></link><published>2015-01-07T00:00:00+08:00</published><updated>2015-01-07T00:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2015-01-07:/posts/telecom/tail-bitting-convolutional-code-implementation-in-matlab-and-c-and-fpga.html</id><summary type="html">&lt;p&gt;总结咬尾卷积编码的 Matlab 及 FPGA 实现方法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="tail-bitting"&gt;Tail Bitting&lt;/h2&gt;
&lt;p&gt;咬尾卷积编码是一种特殊的卷积编码，它通过将编码器的移位寄存器的初始值设置为输入流的尾比特值，使得移位寄存器的初始和最终状态相同。和普通的卷积编码相比，咬尾的方案最大的优点是克服了编码时的码率损失，并且适合迭代译码，不过付出的代价是译码复杂度的增加。在 LTE 的标准中，咬尾卷积编码是一种备选的信道编码方案。&lt;/p&gt;
&lt;p&gt;通常以 (n, k, K) 来描述卷积编码，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;k&lt;/code&gt; 表示编码器的 &lt;em&gt;输入码元数&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt; 表示编码器的 &lt;em&gt;输出码元数&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;K&lt;/code&gt; 表示编码器的 &lt;em&gt;约束长度&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由输入的 k 个信息比特，得到 n 个编码结果，所以 &lt;em&gt;编码效率&lt;/em&gt; = k/n&lt;/p&gt;
&lt;p&gt;约束长度 &lt;code&gt;K&lt;/code&gt; 的意思是，编码结果不仅取决于当前输入的 k 比特信息，还取决于前 (K-1) 段时间内的信息位。在 k = 1 的条件下，编码器需要的 &lt;em&gt;移位寄存器级数&lt;/em&gt; m = K - 1。&lt;/p&gt;
&lt;p&gt;LTE 标准中编码器的结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="coder" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/coder.jpg"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设输入的比特流为 c1, c2, c3, ... 得到的编码结果为 d1, d2, d3, ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中移位寄存器 D 从左到右一次是 S0, S1, ... S5。对其初始化时，S0 = Ck-1, S1 = Ck-2, ... S5 = Ck-6。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行编码时，有抽头的寄存器之间进行模 2 加法（即异或）运算。每次对一个输入信息完成编码之后，移位寄存器右移一位，抛弃最右端的移位结果，采用前一个输入作为最左端的信息位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当最后的比特进行编码完之后，寄存器又回到了设定的初始状态，就像一条蛇咬住了自己的尾巴，所以称为 咬尾 Tail Bitting。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图中的 G1，G2, G3 是 &lt;em&gt;生成式&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的内容已经提供了足够的信息供我们实现，关于更多的卷积编码、LTE 标准等请查阅 wiki 和专业书籍。&lt;/p&gt;
&lt;h2 id="matlab-implementation"&gt;Matlab Implementation&lt;/h2&gt;
&lt;p&gt;Matlab 的 &lt;code&gt;Communications System Toolbox&lt;/code&gt; 中提供了大量的常用函数，其中就有卷积编码函数 &lt;code&gt;convenc&lt;/code&gt;。我们就是基于这个函数实现 LTE 中的咬尾卷积编码。&lt;/p&gt;
&lt;p&gt;通过&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;help convenc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;和 hlep browser，可以查到这个函数的用法，简单解释如下 :&lt;/p&gt;
&lt;p&gt;convenc 函数有几种方式来调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;CODE = convenc(MSG, TRELLIS)

CODE = convenc(MSG, TRELLIS, PUNCPAT)

CODE = convenc(..., INIT-STATE)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个参数 &lt;code&gt;MSG&lt;/code&gt; 是待编码的信息比特&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数 &lt;code&gt;TRELLIS&lt;/code&gt; 是编码器的栅格描述&lt;/p&gt;
&lt;p&gt;TRELLIS 是 Matlab 内部定义的一种数据结构，它的值可以按照语法定义，更方便的方法是通过 &lt;code&gt;poly2trellis&lt;/code&gt; 这个函数，由多项式描述方式转化得到。&lt;/p&gt;
&lt;p&gt;查阅 poly2trellis 的 help 就可以看到它的用法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;trellis = poly2trellis(ConstraintLength, CodeGenerator)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;code&gt;ConstraintLength&lt;/code&gt; 是个 1×k 维的向量，表示编码器的约束长度；&lt;code&gt;CodeGenerator&lt;/code&gt; 是个 k×n 维的向量，表示编码器中各个寄存器的抽头。&lt;/p&gt;
&lt;p&gt;help 中以一个 2/3 码率的编码器为例，其结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="exmaple" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/example.png"&gt;&lt;/p&gt;
&lt;p&gt;两组寄存器的长度分别为 4 和 3，所以 constraintlength 的取值为 [5, 4]；将每路输出的抽头用 8 进制来表示，即可得到 codegenerator 的取值 [27, 33, 0; 0, 5, 13]，表示第一路输出由第一组寄存器的 27 组合方式 + 第二组寄存器的 0 组合方式得到，第二路输出由第一组寄存器的 33 组合方式 + 第二组寄存器的 5 组合方式得到，第三路同理。&lt;/p&gt;
&lt;p&gt;应用到我们的编码器中，很容易写出其栅格描述&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tre = poly2trellis(7, [133, 171, 165]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数 INIT-STATE 是移位寄存器的初始值&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INIT-STATE&lt;/code&gt; 用来设定寄存器的初始状态，其取值就是寄存器的值。&lt;/p&gt;
&lt;p&gt;在下面的程序中，我们的测试向量的最后 6 bit 为 010110，所以对应的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;init = 22;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，可以写出 matlab 程序来实现咬尾卷积编码，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="c"&gt;% using a to test coder&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c"&gt;% describe the coder&lt;/span&gt;
&lt;span class="n"&gt;tre&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;poly2trellis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;133&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;171&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;165&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="c"&gt;% init state is depend on a&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c"&gt;% encode&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;convenc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tre&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;得到的编码结果是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;数据的格式是将 3 位并行结果串行输出： d00, d01, d02, d10, d11, d12, ...&lt;/p&gt;
&lt;h2 id="c-implementation"&gt;C Implementation&lt;/h2&gt;
&lt;p&gt;C 的实现很简单 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;coded&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// initialize the LSR&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;coded&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;coded&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;coded&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// shift the regs&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LSR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="verlog-implementation"&gt;Verlog Implementation&lt;/h2&gt;
&lt;p&gt;用 verilog 来实现编码器就相对简单直观的多，毕竟只有一组移位寄存器和一些抽头的异或运算。&lt;/p&gt;
&lt;h3 id="module-testbench"&gt;module &amp;amp; testbench&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tbce.v"&gt;module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/guqian110/guqian110.github.io/blob/master/files/tb-tbce.v"&gt;testbench&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="simulation"&gt;simulation&lt;/h3&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim1" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/sim1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="sim2" src="/images/tail-bitting-convolutional-code-implementation-in-matlab-and-fpga/sim2.png"&gt;&lt;/p&gt;
&lt;p&gt;和 matlab 中结果对比，结果是一致的。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;一个简单的咬尾卷积编码花费了一上午的时间才搞定，最大的收获就是：心态很重要，欲速则不达。没有认真看 help 就写程序，本来想节省时间，结果却相反 =.=&lt;/p&gt;
&lt;p&gt;戒骄戒躁！！！&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;通信原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/24784764/"&gt;无线通信新协议与新算法&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="tail bitting convolution"></category></entry><entry><title>FPGA 中的延时</title><link href="https://qian-gu.github.io/posts/ic/delay-in-fpgas.html" rel="alternate"></link><published>2014-11-23T14:03:00+08:00</published><updated>2014-11-23T14:03:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-11-23:/posts/ic/delay-in-fpgas.html</id><summary type="html">&lt;p&gt;总结电路中的时延及其 FPGA 中的实现&lt;/p&gt;</summary><content type="html">&lt;h2 id="delay-in-circuits"&gt;Delay in circuits&lt;/h2&gt;
&lt;p&gt;从模拟电路的知识，我们可以知道 &lt;strong&gt;电路中存在很多类型不同的延时。&lt;/strong&gt; 比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;propagation delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们通常假设信号在电平之间变化时瞬间完成的，但是实际情况并不是瞬间完成，电路需要花费一段时间才能完成电平的转化。晶体管的开关特性对于不同的变化有不同的表现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上升延时 (&lt;code&gt;rising delay&lt;/code&gt;)，输出变为 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下降延时 (&lt;code&gt;falling delay&lt;/code&gt;)，输出变为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭延时 (&lt;code&gt;turn-off delay&lt;/code&gt;)，输出变为高阻 Z&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出变为 X 的时延&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因就是（&lt;a href="http://www.amazon.cn/Digital-Design-An-Embedded-Systems-Approach-Using-Verilog-Ashenden-Peter-J/dp/0123695279"&gt;Digital Design (Verilog): An Embedded Systems Approach Using Verilog&lt;/a&gt;）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One factor that causes signal changes to occur over a nonzero time
interval is the fact that the switches in the output stage of a digital component, illustrated in Figure 1.15, do not open or close instantaneously. Rather, their resistance changes between near zero and a very large value over some time interval. However, a more significant factor, especially in CMOS circuits, is the fact that logic gates have a significant amount of capacitance at each input.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个答案也解释了为什么在设计中要避免大扇出信号：因为大扇出意味着输出端并联着很多电容，电容负载较大时造成连接信号转换相对较慢的原因。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The total capacitive load is thus the sum of the individual capacitive loads. The effect is to make transitions on the connecting signal correspondingly slower. For CMOS components, this effect is much more significant than the static load of component inputs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以把对晶体管的讨论推广到其他的数字元件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A similar argument regarding time taken to switch transistors on and off and to charge and discharge capacitance also applies within a digital component. Without going into the details of a component’s circuit, we can summarize the argument by saying that, due to the switching time of the internal transistors, it takes some time for a change of logic level at an input to cause a corresponding change at the output. We call that time the &lt;code&gt;propagation delay&lt;/code&gt;, denoted by &lt;code&gt;tpd&lt;/code&gt;, of the component.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;wire delay&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外一种延时是信号在导线上传播时产生的延时，一般我们都把这种延时假设也 0，也就是说导线时理想的导体，信号经由导线的传输没有任何延迟。如果导线很短，或者芯片上不超过 1mm 的导线来说，这种假设是合理的。但是当设计高速电路时，不能忽略这种导线存在的寄生电容和电感，这时候导线应该被视为传输线，必须精心设计。&lt;/p&gt;
&lt;p&gt;至于如何设计应该属于模拟电路的部分，这里不讨论。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于上面的两种延时，&lt;a href="http://www.amazon.com/FPGA-Based-System-paperback-Prentice-Semiconductor/dp/0137033486"&gt;FPGA-Based System Design&lt;/a&gt; 里面有详细讨论如何建模、如何计算具体时延的值。&lt;/p&gt;
&lt;p&gt;即使对于同一种信号跳变，延时也分为不同的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最小值 (&lt;code&gt;minimum&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型值 (&lt;code&gt;typical&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大值 (&lt;code&gt;maximum&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="models-in-verilog-hdl"&gt;Models in Verilog HDL&lt;/h2&gt;
&lt;p&gt;为了对电路中的时延现象进行建模，Verilog HDL 定义了延时语法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于上升、下降、关闭时延，可以使用逗号按照顺序将三者分开：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;xor&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eq0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;xor&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eq0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;第一句表示一个异或门上升时延为 1，下降时延为 2，关闭和 X 时延为两者中的最小值，即 1；&lt;/p&gt;
&lt;p&gt;第二句表示一个异或门的上升、下降、关闭时延分别是 1，2，3，X 时延为 3 者中的最小值，即 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于最小值、典型值、最大值可以使用分号按照 min:typ:max 的顺序，将 3 者分开：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;assgin&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;xor&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eq0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;eq1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;表示上升时延的 min:typ:max = 2:3:4，下降时延的 min:typ:max = 3:4:5。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意到一点是，&lt;strong&gt;当延时出现在 wire 信号的定义处时，会和普通的赋值语句中的延时稍有不同。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;wireA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这个叫做 &lt;code&gt;net delay&lt;/code&gt;，它是和 wireA 绑定的，对 wireA 进行的任何赋值必须延迟 10 个时间单位之后才有效。当在连续赋值语句中，延时是属于连续赋值语句的一部分，而不属于 net，所以只在这一句中有效，对其他赋值语句没有影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般来说，assign 语句中的延时特性会被综合工具忽略。&lt;/strong&gt;因为综合工具需要完成的功能就是将代码描述映射为逻辑电路，而逻辑电路中的延时是由最基本的单元库和走线延时决定的，用户是无法对逻辑单元指定延时长度的，只能在综合、实现时添加时序约束条件，使工具尽量满足要求。&lt;/p&gt;
&lt;h2 id="implement"&gt;Implement&lt;/h2&gt;
&lt;p&gt;Verilog HDL 中的延时语法不可综合并不代表就不能在实际电路中实现延时。&lt;/p&gt;
&lt;p&gt;在实际电路中，不同的情况下需要采用不同的方法来实现延时：一般来说，异步电路的时延通过门延时来完成，比较难预测，而同步电路的时延通过触发器或者计数器来实现。&lt;/p&gt;
&lt;h3 id="in-asics"&gt;in ASICs&lt;/h3&gt;
&lt;p&gt;在早期的逻辑电路图设计阶段，有且设计者养成了手工加入 Buffer 或者非门调整数据
延时的习惯，以保证本级模块的时钟对上级模块数据的建立及保持时间的要求。这些做法目
前主要应用于两种场合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分离电路&lt;/p&gt;
&lt;p&gt;使用分立逻辑单元（如 74 系列）搭建数字电路一般为复杂度比较低、系统灵活性比较低的场合。使用分立元件时，由于可以使用的元件比较少，而且一般设计频率比较低，时序裕量比较大，所以采用 Buffer、非门等单元来调整时延时可以接受的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ASIC 领域&lt;/p&gt;
&lt;p&gt;在 ASIC 中采用这种方法，是以严格的仿真和时序约束为前提的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="in-fpgas"&gt;in FPGAs&lt;/h3&gt;
&lt;p&gt;在 ASIC 中采用的添加 Buffer、非门的设计方法并不适合 FPGA/CPLD 等可编程逻辑，在 FPGA 中应该尽量避免这种设计。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Delay chains occur when two or more consecutive nodes with a single fan-in and a single fan-out are used to cause delay. Often inverters are chained together to add delay. Delay chains generally result from asynchronous design practices, and are sometimes used to resolve race conditions created by other combinational logic. In both FPGA and ASIC, delays can change with each place-and-route. Delay
chains can cause various design problems, including an increase in a design’s sensitivity to operating conditions, a decrease in a design’s reliability, and difficulties when migrating to different device architecture. &lt;strong&gt;Avoid using delay chains in a design, rely on synchronous practices instead.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结下来主要就是 3 个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计的可靠度低&lt;/p&gt;
&lt;p&gt;Buffer、非门都是组合逻辑，组合逻辑最大的问题就是容易出现毛刺，电路可靠度不高，这种方法的时序裕量小，对环境敏感（特别是温度），一旦外界环境发生变化，时序可能就会完全紊乱、导致电路瘫痪。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设计的移植难度大&lt;/p&gt;
&lt;p&gt;一旦芯片换代，或者需要将设计移植到不同的器件上时，就必须对延时进行重新调整，电路的可维护性和扩展性差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号通过多级非门时，综合器可能会将其优化掉。&lt;/p&gt;
&lt;p&gt;虽然可以在代码中添加约束，防止综合器将其优化掉，但是不推荐这种方法，理由见前两条。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Xilinx-FPGA%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%B1%A4%E7%90%A6/dp/B007TLVUT8"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt; 介绍了 FPGA 中应该采用的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;专门的延时器件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 FPGA/CPLD 内部延时电路结构由一种标准的宏单元描述。虽然各家芯片的宏单元描述不同，但总的来说都是 &lt;strong&gt;一些逻辑 + 一个 / 两个触发器构成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Altera FPGA 中可以对信号加一个或多个 LCELL 来产生一个延时。（Xilinx 的没有查到 ...）&lt;/p&gt;
&lt;p&gt;虽然厂家提供了延时单元，但是这种延时并不稳定，会随着外界环境（比如温度）的变化而变化，所以并不提倡这种方法。&lt;/p&gt;
&lt;p&gt;网上有人讨论这种方法的应用：&lt;a href="http://bbs.eccn.com/viewthread.php?tid=181856"&gt;fpga 内部的延时单元&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;触发器 or 计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果延时相对较小，可以使用高频时钟来驱动一个移位寄存器，将待延时的信号当作输入，按照需要的延时来设置移位寄存器的级数，最后的输出即延时的结果。&lt;/p&gt;
&lt;p&gt;如果延时相对较大，可以使用计数器来延时输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;====================== Update 01/31/2015 ========================&lt;/p&gt;
&lt;h2 id="simulation"&gt;Simulation&lt;/h2&gt;
&lt;p&gt;我们知道，仿真器使用 “ 事件 ” (&lt;code&gt;event&lt;/code&gt;) 来模拟实际的电路行为，但是毕竟软件和硬件还是不同的，而 Verilog 语言又是很灵活的，如果不加注意，很可能不能对电路进行正确的建模。Clifford E. Cummings 大神写了一篇 paper 介绍了 Verilog HDL 中应该如何正确使用延时，才能保证建模的正确性：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON1999-BehavioralDelays-Rev1-1.pdf"&gt;Correct Methods For Adding Delays To Verilog Behavioral Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我的笔记，摘录一部分内容和结论：&lt;/p&gt;
&lt;p&gt;要讨论正确的延时的代码风格，首先要了解仿真器在对延时进行建模时，通常使用的两种不同类型的 Delay 模型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Inertial delay&lt;/code&gt; 模型 
    惯性时延，专门描述一些特殊信号传播到输出端口所耗费的时延，这部分信号特殊在于：输入信号必须保持稳定一段时间（等于或大于传播时延）。如果输入信号的变化时间间隔小于过程赋值延时 / 连续赋值延时 / 门延时（也就是说在计算出一个结果并且还没有来得及输出，输入信号又发生了变化），那么前一时刻值的旧事件会被新值的事件代替，重新触发计算，并输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Transport delay&lt;/code&gt; 模型&lt;/p&gt;
&lt;p&gt;传播时延，用来描述当任何一个输入信号一旦发生变化后，所有信号到输出的延时。所有的输出变化值会按照顺序排队输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;有了上面两个延时的概念之后，我们就可以分类讨论下面三种情况下应该如何添加延时了。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="blocking-assignment"&gt;Blocking assignment&lt;/h3&gt;
&lt;p&gt;在阻塞赋值中，通常添加延时的方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;left-hand-side&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right-hand-side&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是这两种方法都有可能存在问题：&lt;/p&gt;
&lt;p&gt;以描述一个输出延迟为 12ns 的加法器，如果我们在左边添加延时，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在下图时序中可以看到，当 t = 15 时，a 发生变化，触发 always 块，模块计算新的求和结果。但是，在接下来的 t = 15 ~ 24 内，a、b、ci 分别发生了变化，所以当从触发开始，到 12ns 过后该输出结果时，计算结果的值使用的是当前最新的值（可以看到，ci 的变化和输出之间仅仅有 3ns &amp;lt; 12ns），而非触发时刻的值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing1" src="/images/delay-in-fpgas/timing1.png"&gt;&lt;/p&gt;
&lt;p&gt;事实上，在任何阻塞赋值的左边添加延时都会存在类似的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the LHS of blocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; placing delays on the LHS of blocking assignments in a testbench is reasonable since the delay is just being used to time-space sequential input stimuls events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我们在右边添加延时，同样也会有问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;假设在 t = 15 时刻，a 发生变化，触发 always 块，模块会对当前的值进行采样，并且在 12ns 之后将采样结果输出，而在这 12ns 期间，输入端的任何变化都会被忽略，这意味着错误的旧值会一直保持下去，直到有新的变化重新触发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the RHS of blocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; do not place delays on the RHS of blocking assignments in a testbench.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;General Guideline:&lt;/strong&gt; placing a delay on the RHS of any blocking assignment is both confusing and a poor coding style. This Verilog coding practice should be avoided.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="non-blocking-assignment"&gt;Non-blocking assignment&lt;/h3&gt;
&lt;p&gt;在非阻塞赋值中，同样有两种方法来添加延时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;left-hand-side&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right-hand-side&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;仍然使用上面加法器的例子，如果我们在左边添加延时，会和阻塞赋值存在一样的问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;当 t = 15 时，触发 always 块，但是输出时结果时，使用的是最新时刻的值。&lt;/p&gt;
&lt;p&gt;事实上，在任何非阻塞赋值的左边添加延时都会存在类似的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; do not place delays on the LHS of nonblocking assignments to model combinational logic. This is a bad coding style.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; nonblocking assignments are less efficient to simulate than blocking assignments; therefore, in general, placing delays on the LHS of nonblocking assignments for either modeling or testbench generation is discouraged.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在非阻塞赋值的右边添加延时，会准确地描述前面介绍的 &lt;code&gt;transport delays&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;当 t = 15 时刻，a 发生变化触发 always 块，此时会立刻对输入进行采样，然后等待 12ns 之后输出；在将这一时间存放在时间队列之后，always 块会被下一个变化时间重新触发，这意味着输出会随着输入的变化在 12ns 之后变化，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing2" src="/images/delay-in-fpgas/timing2.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recommended Application:&lt;/strong&gt; Use this coding style to model behavioral delay-line logic.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; place delays on the RHS of nonblocking assignments only when trying to model transport output-prapagation behavior. This coding style will accurately model delay lines and combinational logic with pure &lt;code&gt;transport delays&lt;/code&gt;; however, this coding style generally causes slower simulations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; This coding style is ofen used in testbenches when stimulus must be scheduled on future clock edges or after a set delay, while not blocking the assignment of subsequent stimulus events in the same procedural blocks,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guideline:&lt;/strong&gt; in general, do not place delays on the RHS of nonblocking assignments to model &lt;em&gt;combinational logic&lt;/em&gt;. This coding style can be confusing and is not very simulation efficient. It is a common and sometimes useful practice to palce delays n the RHS of nonblocking assignments to model clock-to-output behavior on &lt;em&gt;sequential logic&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; there are some multi-clock design verification suites that benefit from using multiple nonblocking assignments with RHS delays; however, this coding style can be confusing, therefore placing delays on the RHS of nonblocking assignments in testbenches is not generally recommended.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="continuous-assignment"&gt;Continuous assignment&lt;/h3&gt;
&lt;p&gt;连续赋值语句中，只能在左侧添加延时，在右边添加延时是非法的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在连续赋值语句的左边添加延时，会准确描述惯性延时（&lt;code&gt;inertial delay&lt;/code&gt;），一般推荐使用这种方式。&lt;/p&gt;
&lt;p&gt;以上面的加法器为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如下图，在 t = 15 时刻，a 发生变化触发 assign 语句，应该在 t = 27 时刻输出结果，但是在 t = 17, 19, 21 时刻，a，b 分别发生了变化，这会导致有 3 个新的值，最终会只输出最后一个值（在 t = 21 + 12 = 33 时刻）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing3" src="/images/delay-in-fpgas/timing3.png"&gt;&lt;/p&gt;
&lt;p&gt;因为连续赋值语句不会排队输出这个概念，它只会跟踪输出结果，所以，连续赋值语句中的延时是对惯性延时（&lt;code&gt;inertial delay&lt;/code&gt;）的建模。&lt;/p&gt;
&lt;p&gt;混合方式：无延时的 always 块 + 连续赋值语句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ci&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;co&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;仍然会准确描述组合逻辑中的 inertial delay。在每个输入变化时，tmp 的值都会改变，在 tmp 改变的 12ns 之后，连续赋值的输出发生变化。tmp 一旦发生变化，assign 会重新赋值，重新延时，所以这种方式会准确描述组合逻辑的 inertial delay。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guide:&lt;/strong&gt; Use continuous assignments with delays to model simple combinational logic. This coding style will accurately model combinational logic with inertial delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Modeling Guide:&lt;/strong&gt; Use always blocks with no delays to model complex combinational logic that are more easily rendered sing Verilog behavroral constructs such as "case-casez-casex", "if-else", etc. The outputs from the no-delay always blocks can be driven into continuous assignments to apply behavioral delays to the models. This coding style will accurately model complex combinational logic with inertial delays.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testbench Guideline:&lt;/strong&gt; Continuous assignments can be used anywhere in a testbench to drive stimulus values onto input port and bi-directional port and bi-directional ports of instantiated models.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusions"&gt;Conclusions&lt;/h3&gt;
&lt;p&gt;always 块中的任何延时都无法准确对真实硬件的行为进行准确建模，应该避免这种延时建模。有一个例外：在非阻塞复制的右边添加延时，来描述 transport delay，但是这种方式是以仿真性能的下降为代价的。&lt;/p&gt;
&lt;p&gt;在 连续赋值语句 / 无延时的 always + 连续赋值语句 中添加延时，这两种方式都会对 inertial delays 建模，推荐使用这种方式来对组合逻辑建模。&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Digital-Design-An-Embedded-Systems-Approach-Using-Verilog-Ashenden-Peter-J/dp/0123695279"&gt;Digital Design (Verilog): An Embedded Systems Approach Using Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Based-System-paperback-Prentice-Semiconductor/dp/0137033486"&gt;FPGA-Based System Design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1882474/"&gt;设计与验证 Verilog HDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Xilinx-FPGA%E9%AB%98%E7%BA%A7%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%BA%94%E7%94%A8-%E6%B1%A4%E7%90%A6/dp/B007TLVUT8"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture: Design Methods and Techniques for Digital Circuits&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="delay"></category></entry><entry><title>计数器设计小结</title><link href="https://qian-gu.github.io/posts/ic/counter-design-summary.html" rel="alternate"></link><published>2014-11-04T20:40:00+08:00</published><updated>2014-11-04T20:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-11-04:/posts/ic/counter-design-summary.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的计数器设计&lt;/p&gt;</summary><content type="html">&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;计数器 在数字电路设计 和 计算机程序设计 中都应用非常广泛，其功能顾名思义，就是用来计数。这里只讨论数字电路设计中的计数器。&lt;/p&gt;
&lt;p&gt;通常，将包含触发器 flip-flop 的电路（即使含有组合电路部分）认为是时序电路。时序电路通常不以电路命名，而是以功能进行分类，分别是 &lt;strong&gt;寄存器&lt;/strong&gt; 和 &lt;strong&gt;计数器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;计数器 &lt;a href="http://en.wikipedia.org/wiki/Counter"&gt;counter&lt;/a&gt; 从本质上来说也是寄存器，不过它是在预先设定好的状态序列中转移，尽管计数器是寄存器的一种特殊形式，通常还是以不同的名称来加以区分。&lt;/p&gt;
&lt;h2 id="type"&gt;Type&lt;/h2&gt;
&lt;p&gt;按照不同的标准来划分，计数器可以有不同的划分方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;触发方式&lt;/p&gt;
&lt;p&gt;同步 / 异步 计数器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数增减&lt;/p&gt;
&lt;p&gt;加法 / 减法 / 可逆计数器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为第二种方法没有明确显示计数器的计数方式，所以一般使用第一种方法。&lt;/p&gt;
&lt;p&gt;这里总结了一些常见的计数器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Basic Binary Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BCD Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ring Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Johnson Counter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ripple Counter&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;计数器在数字电路中的用途非常广，可以作为定时器、实用计数器、状态机等。在具体实现时，有前面总结的不同的计数器类型可供选择，每种计数器由其特点决定了适用场合，我们要做到就是在不同计数器类型和配置之间进行权衡，选择正确的设计，以节省大量逻辑资源，并提高性能。&lt;/p&gt;
&lt;p&gt;下面分别讨论各种计数器的特点和 HDL 实现。&lt;/p&gt;
&lt;h2 id="implement"&gt;Implement&lt;/h2&gt;
&lt;h3 id="binary-counter"&gt;Binary Counter&lt;/h3&gt;
&lt;p&gt;最简单、最基本的计数器就是 二进制计数器 Binary Counter。它的计数方式就是从 0 开始每个脉冲进行 “+1” 操作，直到最大值，然后重新从 0 开始。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Prototyping-Verilog-Examples-Spartan-3/dp/0470185325"&gt;FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version&lt;/a&gt; 里面有个例子，这里稍作修改就可以当作通用模块，供其他模块调用了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// count&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// max-tick&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;}})&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="bcd-counter-mod-m-counter"&gt;BCD Counter (mod-m counter)&lt;/h3&gt;
&lt;p&gt;人类更习惯使用十进制进行计数，十进制一共有 10 个符号，我们只需要从 4 bit 的二进制计数器中选取 10 个数字，只使用这 10 个数字进行计数即可，通常去掉 1010 ~ 1111 这 6 个数字，即使用 8421BCD 码 来对十进制数进行编码、计数，即 BCD Counter。&lt;/p&gt;
&lt;p&gt;将十进制进行推广，我们就可以写出任意的 模 m 的计数器，在下面的例子中，M 表示计数器的模值（默认为 10），N 表示计数器需要的位数（默认为 4）。在例化时如果要修改，则需要手动计算这两个参数进行赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bcd&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// number of bits in counter&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// mod-M&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="ring-counter"&gt;Ring Counter&lt;/h3&gt;
&lt;p&gt;基于线性移位寄存器 &lt;a href="http://en.wikipedia.org/wiki/Linear-feedback-shift-register"&gt;&lt;code&gt;LFSR&lt;/code&gt; (Linear feedback shift register) &lt;/a&gt; 可以衍生出两种计数器：&lt;a href="http://en.wikipedia.org/wiki/Ring-counter"&gt;环形计数器 (ring counter)&lt;/a&gt; 和 扭环计数器（约翰逊计数器）。&lt;/p&gt;
&lt;p&gt;将 LFSR 中存储的数字设置为独热码的形式，即只有一位为 1，其他位为 0。然后把最后一级的输出直接反馈到第一级的输入，这样，输入和输出组成了一个环形，所以称为 环形计数器。4 bit 的环形计数器电路图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ring counter" src="/images/counter-design-summary/ring-counter.png"&gt;&lt;/p&gt;
&lt;p&gt;(ref: http://electronics-course.com/ring-counter)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相比于 binary counter，ring counter 不需要后者必需的加法器来实现计数，所以它在电路上占用的资源要更少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为没有额外的加法器，所以 ring counter 也不存在加法器带来的进位时延，它的最大时延是固定值，和计数器的模值无关。所以它的时序性能也比 binary counter 好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 ring counter 的汉明距离为 2，所以它可以检查单比特翻转的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ring counter 最大的缺点就是它的低密度码，同样适用 N 个寄存器，binary counter 可以计数到 2^N，而 ring counter 只能计数到 N，经过改良后的 Johnson counter 也才能到 2N。所以，如果寄存器比组合逻辑更加珍贵的情况下，不适合使用 ring counter。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ring&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;                 &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]};&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// right shift&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="johnson-counter"&gt;Johnson Counter&lt;/h3&gt;
&lt;p&gt;在 ring counter 的反馈链路中加入一个反相器，就好象把一个环扭了一下，所以称为 扭环计数器 (Johnson Counter)&lt;/p&gt;
&lt;p&gt;4 bit 的 Johnson Counter 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="johnson counter" src="http://upload.wikimedia.org/wikipedia/commons/e/e8/JohnsonCounter2.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大的优点就是它可以计数的范围和 ring counter 相比，扩大了一倍，达到了 2N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disadv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大的缺点就是一旦它进入了错误状态，则永远无法返回到正确状态，除非外界干预。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，将前面例子第 行的反馈语句修改一下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]};&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// right shift&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;同时，计数器的终点也要进行相应的修改，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="ripple-counter"&gt;Ripple Counter&lt;/h3&gt;
&lt;p&gt;前面总结的这些计数器都是同步计数器，组成它们的 flip-flop 是由同一个脉冲信号触发的。还有一种计数器是异步计数器，它内部的 flip-flop 不是由同一个脉冲信号触发的。由于 FPGA 特殊的结构原因，在 FPGA 中应该使用同步设计，所以一般 FPGA 不会使用这种计数器。&lt;/p&gt;
&lt;p&gt;ripple counter 的每个 flip-flop 使用前一级的 flip-flop 的输出信号作为触发信号，所以后一级的触发器必须等到前一级的触发器输出之后才能工作，所以对于一个长度为 N 的触发器链，从输入时间开始，要等 N 个触发器依次工作完之后才能输出有效结果。&lt;/p&gt;
&lt;p&gt;示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ripple counter" src="/images/counter-design-summary/ripple-counter.png"&gt;&lt;/p&gt;
&lt;p&gt;(ref: http://www.eecs.tufts.edu/~dsculley/tutorial/flopsandcounters/flops6.html)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Adv&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积小（不需要电路来实现 “+1” 功能）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;功率少（因为面积小）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以在一些对面积、成本、功率敏感的应用中，ripple counter 很有用。比如：一个电子时钟，因为秒 s 对于纳秒 ns 来说是很缓慢的，所以可以忍受这种累积误差的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的 flip-flop 不是同时触发的，每个 flip-flop 的时延会累积到输出，当所有的时延累积到一起，有时候（很长的 flip-flop 级联在一起）相对于时钟信号而言，就不能忽略这种时延了，严重时会导致系统出错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码在&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Hdl-Chip-Design-Synthesizing-Simulating/dp/0965193438"&gt;Hdl Chip Design: A Practical Guide for Designing, Synthesizing &amp;amp; Simulating Asics &amp;amp; Fpgas Using Vhdl or Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面有介绍。&lt;/p&gt;
&lt;h3 id="gray-code-counter"&gt;Gray Code Counter&lt;/h3&gt;
&lt;p&gt;Gray 码和普通的二进制编码相比，优势就是它相邻数字之间只有一位不同，这样在计数时，就避免的多位不是同时变化导致的毛刺。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Gray-code"&gt;Gray Code wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A typical use of Gray code counters is building a FIFO (first-in, first-out) data buffer that has read and write ports that exist in different clock domains. The input and output counters inside such a dual-port FIFO are often stored using Gray code to prevent invalid transient states from being captured when the count crosses clock domains.[10] The updated read and write pointers need to be passed between clock domains when they change, to be able to track FIFO empty and full status in each domain. Each bit of the pointers is sampled non-deterministically for this clock domain transfer. So for each bit, either the old value or the new value is propagated. Therefore, if more than one bit in the multi-bit pointer is changing at the sampling point, a "wrong" binary value (neither new nor old) can be propagated. By guaranteeing only one bit can be changing, Gray codes guarantee that the only possible sampled values are the new or old multi-bit value. Typically Gray codes of power-of-two length are used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在大神 Clifford E. Cummings 的论文 &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;synthesis and scripting techniques for designing multi-asynchronous clock designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中有详细介绍如何设计一个 Gray Code Counter 的过程，其基本思想就是利用一个 binary counter 来实现目的，计数器的计数功能由内部的 binary counter 实现，将 binary 的计数结果通过一个 binary2gray 的转换电路转化为 gray code 后再输出；输出的 gray code 反馈回计数器之前，再通过一个 gray2bianry 的电路转化回 binary 形式，以供内部的 binary counter 使用。模块示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gray code counter" src="/images/counter-design-summary/gray-code-counter.png"&gt;&lt;/p&gt;
&lt;p&gt;代码略 ...&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/FPGA-Prototyping-Verilog-Examples-Spartan-3/dp/0470185325"&gt;FPGA Prototyping By Verilog Examples: Xilinx Spartan-3 Version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Hdl-Chip-Design-Synthesizing-Simulating/dp/0965193438"&gt;Hdl Chip Design: A Practical Guide for Designing, Synthesizing &amp;amp; Simulating Asics &amp;amp; Fpgas Using Vhdl or Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;synthesis and scripting techniques for designing multi-asynchronous clock designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Design-Recipes-FPGAs-Embedded-Technology/dp/0750668458/ref=sr-1-1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1415197345&amp;amp;sr=1-1&amp;amp;keywords=design+recipes+for+fpgas"&gt;Design Recipes for FPGAs: Using Verilog and VHDL (Embedded Technology) &lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category></entry><entry><title>番茄工作法 总结 + 实践</title><link href="https://qian-gu.github.io/posts/book/the-pomodoro-technique-practices.html" rel="alternate"></link><published>2014-11-02T21:46:00+08:00</published><updated>2014-11-02T21:46:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-11-02:/posts/book/the-pomodoro-technique-practices.html</id><summary type="html">&lt;p&gt;总结 番茄工作法 的方法和实践。&lt;/p&gt;</summary><content type="html">&lt;p&gt;忙里偷闲，学习一下大名鼎鼎的 &lt;strong&gt;番茄工作法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="intro"&gt;Intro&lt;/h2&gt;
&lt;p&gt;番茄工作法 (&lt;a href="http://en.wikipedia.org/wiki/Pomodoro-Technique"&gt;Pomodoro Technique&lt;/a&gt;) 是由 Francesco Cirillo 创建的一种时间管理方法。他自己上大学时为了克服无法集中精力认真学习这个问题而发明了这种方法，后来他整理完成了一本书来介绍这种方法：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pomodorotechnique.com/book/"&gt;The Pomodoro Technique&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;"Pomodoro Technique" 这个名字起源于一种厨房用的、番茄形状的计时器，其中 &lt;code&gt;Pomodoro&lt;/code&gt; 是意大利语，意思是番茄。&lt;/p&gt;
&lt;p&gt;至于为什么是番茄工作法，而不是白菜工作法呢？这是因为 Francesco Cirillo 当时在厨房找到的那个计时器是番茄形状的 :P&lt;/p&gt;
&lt;p&gt;还有另外一本书，是另外一个人自己实践番茄工作法总结出来的经验，而且自己画了一些生动的插图和脑图在里面，很有帮助：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.pomodoro-book.com/"&gt;Pomodoro Technique Illustrated&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;首先，网上贴张别人总结好的 Mind Map ( 出处见水印 )：&lt;/p&gt;
&lt;p&gt;&lt;img alt="mm" src="/images/the-pomodoro-technique-practices/mind-map.jpg"&gt;&lt;/p&gt;
&lt;p&gt;番茄工作法非常简单，具有非常强的可操作性，这也是它能风靡世界的原因吧。&lt;/p&gt;
&lt;p&gt;番茄工作法一共包含 5 个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img alt="five stage" src="/images/the-pomodoro-technique-practices/five-stages.png"&gt;&lt;/p&gt;
&lt;p&gt;其中有一些必须遵守的法则：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rules" src="/images/the-pomodoro-technique-practices/rules.png"&gt;&lt;/p&gt;
&lt;p&gt;也可以用一张图总结出什么是番茄工作法：&lt;/p&gt;
&lt;p&gt;&lt;img alt="flow" src="/images/the-pomodoro-technique-practices/workflow.png"&gt;&lt;/p&gt;
&lt;p&gt;综上，找一只笔和几张纸，列出要完成的工作，然后设定计时器，开始工作！就这么简单。&lt;/p&gt;
&lt;h2 id="my-practice"&gt;My Practice&lt;/h2&gt;
&lt;p&gt;GTD 和 pomodoro 可以相互补充，达到最好的效果：&lt;/p&gt;
&lt;p&gt;GTD 侧重项目之间的管理，通过收集、处理、组织，使我们胸有成竹，做到 mind like water；Pomodoro 则侧重时间管理，每天到底应该如何提高效率，通过和自己约定的倒计时，把一个个行动落实，把握生命中的每一分钟，全力以赴我们心中的梦，不经历风雨怎么能见彩虹（不对 ...）&lt;/p&gt;
&lt;h3 id="tools"&gt;Tools&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;番茄法的工具（5 个）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A pen&lt;/li&gt;
&lt;li&gt;A Kitchen Timer&lt;/li&gt;
&lt;li&gt;Activity Inventory Sheet&lt;/li&gt;
&lt;li&gt;Todo Today Sheet&lt;/li&gt;
&lt;li&gt;Record&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;GTD 的工具：（6 个）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Project List&lt;/li&gt;
&lt;li&gt;Next Action List&lt;/li&gt;
&lt;li&gt;Waiting For List&lt;/li&gt;
&lt;li&gt;Someday / Maybe List&lt;/li&gt;
&lt;li&gt;Calendar&lt;/li&gt;
&lt;li&gt;Reminder / Memo&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，综合一下两者的优势，就有了下面的组合：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Project List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运用 GTD 的收集、整理的优势，把我们的长期目标放在这里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Someday / Maybe List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里放目前不紧急，将来某个时候会做的事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Activity Inventory List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;短期目标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Todo Today List&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计划每天做的事，一定要尽力完成（因为这是我们作出的承诺）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Calendar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有日历帮助，我们可以更好地计划、实现一件复杂的事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reminder / Memo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录生活中的小事、杂事，某时的突发奇想。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;A Pomodoro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置一个番茄时间，开始做！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="tips"&gt;Tips&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;番茄的大小，根据我们自己的实际情况而定，不过一开始可以用默认的 25 mins，过一段时间后如果真的不适合自己再进行修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Todo Today List 内容一定要实际可行，根据自己平时完成的番茄总量、预估计任务量来安排，尽最大努力完成清单，因为这是我们对自己的承诺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按时休息。有时候我们可能正在起劲的时候，番茄钟响了，这时候最好停下手头的工作（即使你正在编程的紧要关头，文思如泉涌，有个新想法正想试试），原因很简单，避免长时间的工作，现在的休息是为了之后更长时间、更有效率地工作。即使有个好点子，先把它写下来，等休息好了再来评估、实现这个想法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一定要严格遵守约定。类似 “ 破窗效应 ”，一旦我们有某次打破了番茄的规定，那么就很容易打破第二次、第三次。失去了约束力，这个方法也就没有作用了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考研的苦逼日子最大的收获就是学会了用 calendar + checklist 来规划自己的学习生活。计划好一个长期目标，精确到每天的任务，这样每天结束时，如果完成了心情真是不要太开心，如果没有完成则对第二天也是一个激励，要提高效率把前一天的补上。我的这个 “ 土 ” 方法现在看来就是 GTD + Pomodoro 的简化版，是时候好好改进一下了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="todo"&gt;TODO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Self Observation 非常重要！每天坚持完，留一个番茄来回顾自己这一天的收获和效率情况，这样我们会对自己有个清楚的认识。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回顾收获&lt;/li&gt;
&lt;li&gt;制定第二天的计划&lt;/li&gt;
&lt;li&gt;分析、提高自己的效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="Book"></category></entry><entry><title>GTD 书评 + 总结</title><link href="https://qian-gu.github.io/posts/book/getting-things-done-review.html" rel="alternate"></link><published>2014-10-30T12:51:00+08:00</published><updated>2014-10-30T12:51:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-10-30:/posts/book/getting-things-done-review.html</id><summary type="html">&lt;p&gt;总结 GTD 方法。&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近了解学习了 GTD，总结一下。&lt;/p&gt;
&lt;h2 id="intro"&gt;Intro&lt;/h2&gt;
&lt;p&gt;所谓 GTD 就是 &lt;a href="http://en.wikipedia.org/wiki/Getting-Things-Done"&gt;Getting Things Done&lt;/a&gt; 的缩写。最早有一个叫做 David Allen 的美国人写的一本书，名字就是 :&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/Getting-Things-Done-The-Art-of-Stress-Free-Productivity-%E6%88%B4%E7%BB%B4%C2%B7%E8%89%BE%E4%BC%A6/dp/0142000280/ref=sr-1-2?ie=UTF8&amp;amp;qid=1414465590&amp;amp;sr=8-2&amp;amp;keywords=getting+things+done"&gt;Getting Things Done: The Art of Stress-Free Productivity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他是 GTD 系统的发明人，主要介绍了时间和任务管理的相关方法，后来这套系统越来越流行，于是大家就把相关的方法、工具统称为 GTD。&lt;/p&gt;
&lt;p&gt;网上有很多介绍 GTD 方法论的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gtdlife.com/"&gt;小强的时间管理博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gtdstudy.com/"&gt;学无止境 @ 一点一滴&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mifengtd.cn/"&gt;褪墨・时间管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这些大多是专业的培训师之类的人写的博客，里面的内容很全面也很详细（总共可能有 100+ 的文章），但是阅读体验却不好。我想主要原因是他们作为培训师、讲师身份，只有复杂、系统地介绍才能衬托出他们的专业。而作为一个普通人，我相信很多人都体验都是：好大一碗成功学鸡汤 =.=&lt;/p&gt;
&lt;p&gt;所以，作为一个普通的学生、总结一下我在一周的空余时间内学习 GTD 的心得，保证简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阅读 &lt;a href="http://www.amazon.cn/Getting-Things-Done-The-Art-of-Stress-Free-Productivity-%E6%88%B4%E7%BB%B4%C2%B7%E8%89%BE%E4%BC%A6/dp/0142000280/ref=sr-1-2?ie=UTF8&amp;amp;qid=1414465590&amp;amp;sr=8-2&amp;amp;keywords=getting+things+done"&gt;Getting Things Done: The Art of Stress-Free Productivity&lt;/a&gt;，还是英文版靠谱，网上的翻译质量实在无法恭维。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阅读几篇博客即可，主要是吸收、了解别人和自己的理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结（形式随意，如写 blog、画 mind map），实践应用！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="gtd"&gt;GTD&lt;/h2&gt;
&lt;h3 id="reason"&gt;Reason&lt;/h3&gt;
&lt;p&gt;现在的人的生活、工作压力都很大，如果没有一个有效的方法来组织管理自己的事物，会越忙越乱。&lt;/p&gt;
&lt;p&gt;比如作为一个学生，一想到自己的论文还没有头绪，项目也看不到希望，还有码农的编程技能没有完全 get，眼看就要毕业了，找工作的压力也逐渐越来越大，着急却越忙越乱，总有一些事盘旋在脑袋里，不经意间提醒你 “ 还有没有做好的事！”&lt;/p&gt;
&lt;p&gt;这时候，各种管理的方法就出现了，而 GTD 就是其中一种。&lt;/p&gt;
&lt;h3 id="aim"&gt;Aim&lt;/h3&gt;
&lt;p&gt;GTD 书里面最终目的就是帮助我们达到所谓的 “ 黑带 ” &lt;code&gt;black belt&lt;/code&gt; 级别，标志就是做到 “ 心静如水 ”  &lt;code&gt;Mind Like Water&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓心静如水，是从武学中借鉴过来的词（也就是功夫熊猫里面浣熊师父教给胖纸的武术家的追求 —— &lt;code&gt;inner peace&lt;/code&gt;），GTD 的目的就是通过这一套系统方法让我们达到这种境界：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;掌控一切，不慌不忙，全身心投入到每一件事中。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="workflow"&gt;Workflow&lt;/h3&gt;
&lt;p&gt;&lt;img alt="workflow" src="/images/getting-things-done-review/workflow.png"&gt;&lt;/p&gt;
&lt;h3 id="methodology"&gt;Methodology&lt;/h3&gt;
&lt;p&gt;GTD 的方法其实并不高深，它实际上主要就是解决了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;很多事之间该如何处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某一件事该如何进行下去&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="horizontal-focus"&gt;Horizontal Focus&lt;/h4&gt;
&lt;p&gt;为了解决第一个问题，GTD 提出了 5 个横向管理方法 &lt;code&gt;horizontal five-stage method&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Collect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把所有的 “ 原始材料 ”（&lt;code&gt;stuff&lt;/code&gt;）都收集（&lt;code&gt;collcet&lt;/code&gt;）到一个地方，比如一个货真价实的篮子，或者是文件夹、电脑上的某个文件夹中（或者它们的组合），这个地方就称为 &lt;code&gt;in-basket&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;关键：一定要保证把所有的事全部收集起来，不能漏掉一个，这样我们就可以只专注于这个 in-basket，而不用考虑其他乱七八糟的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Process&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收集到 in-basket 之后，按照前面的 workflow 对其中的内容进行处理（&lt;code&gt;process&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;关键：按照顺序，一次一件事地进行分类处理，处理完之后不要放回 in-basket 中，有条理地进行可以避免重复工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Organize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前一步只是将 in-basket 中的内容进行了分类，但结果仍然是一堆事情的集合，这时候就需要我们将其组织管理（&lt;code&gt;organize&lt;/code&gt;）成各种有序的清单（&lt;code&gt;list&lt;/code&gt;），比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;项目清单（&lt;code&gt;project list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日历（&lt;code&gt;calendar&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一步行动清单（&lt;code&gt;next action list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待清单（&lt;code&gt;waiting for list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将来某时清单（&lt;code&gt;someday/may list&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键：建立一个 完备正交的分类集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Review&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在建立起各种清单之后，我们需要对其进行跟踪维护。根据事件的重要程度，每天、每周、每月、每年地不断坚持更新我们的清单。虽然简单，但也是最难做到的地方。或许 3 分钟热情可以持续一段时间，但是大多数人都没有恒心将一件事坚持下去。&lt;/p&gt;
&lt;p&gt;关键：恒心！！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Do&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们清单都列好了，但是当我们每天在确切的某个时间做什么确切的事呢？GTD 并没有给出答案，毕竟某件事重不重要只有我们自己才知道。但是它给出了 3 个模型来对一件事情的重要、紧急情况进行评估，以便我们安排工作顺序。安排工作顺序可以按照不同的属性进行排序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;地点：宿舍、实验室、教室&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间：早中晚、工作日、周末&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;花费的精力：看书、编程、发邮件、整理文档&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重要程度：人生目标、工作计划、当前工作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，我觉得在 do 这个方面，或许其他的方法更有效，比如 “ 番茄工作法 ” 等可以帮助我们有效地安排工作时间，提高注意力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;p&gt;就是这么简单，和我们平时自己琢磨出来的方法没有太大差别，这几个步骤的目的就是管理我们的工作，让我们不再是乱糟糟一团的感觉，而是 “ 清单在手，天下我有 ” 的掌控全局的感觉，这也是我们能进入 mind like water 状态的前提。&lt;/p&gt;
&lt;h4 id="vertical-focus"&gt;Vertical Focus&lt;/h4&gt;
&lt;p&gt;为了解决第二个问题，GTD 提出了 5 个纵向管理方法 &lt;code&gt;vertical five-phase method&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Defining purpose &amp;amp; principles&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Outcoming &amp;amp; visioning&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Brainstorming&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Organizing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Identifying next actions&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几个步骤其实就是很自然而然的从上到下（&lt;code&gt;top to down&lt;/code&gt;）的方法：&lt;/p&gt;
&lt;p&gt;首先确定目标（&lt;code&gt;purpse &amp;amp; principles&lt;/code&gt;），避免盲目努力，然后再展望做完时的美好景象（&lt;code&gt;outcoming &amp;amp; visioning&lt;/code&gt;），这时候我们干劲十足，通过头脑风暴（&lt;code&gt;brainstorming&lt;/code&gt;）找到合适的工作方法，之后就是确切地组织（&lt;code&gt;organizing&lt;/code&gt;）人员，确认如何下手（&lt;code&gt;identifying next action&lt;/code&gt;），开始干活了了。&lt;/p&gt;
&lt;p&gt;步骤说起来空洞无味，但是在实际中面对不知如何下手的事情，可以参考这个步骤。关于如何做好一件事，涉及到不同的人和不同的工作类型，所以我认为这里的方法只能作为一个参考吧。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;h3 id="tools"&gt;Tools&lt;/h3&gt;
&lt;p&gt;书里面还介绍了一些小技巧，就不再重复了。不过根据我的实践来看，工具其实也是一个至关重要的因素。&lt;/p&gt;
&lt;p&gt;选择标准：&lt;strong&gt;选择合适的而不是功能最全的工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在有很多 GTD 类的软件，比如 thinkrock、remember the milk、any.do 等等，功能很全很强大，但是我最终还是选择了简单的 &lt;em&gt;Google xxx + Evernote&lt;/em&gt; 的组合。&lt;/p&gt;
&lt;p&gt;什么是合适的工具呢，我认为只要满足&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;够用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个条件就好。&lt;/p&gt;
&lt;p&gt;简单的功能可以帮助我们集中注意力，Google 的很多产品都遵循这个原则，比如 Calendar、Task、Keep、Translate 等，而 Evernote 虽然功能强大，但是有时候让我无从下手，不想打开；当然关键功能必须要有，比如最近很火的一款应用 Todist，作为一款 todo list 类型的软件，免费版本却没有提醒功能，他们是有多想挣钱啊 =.=&lt;/p&gt;
&lt;h2 id="review"&gt;Review&lt;/h2&gt;
&lt;p&gt;这年头不可避免地看了一些成功学的书，喝了不少鸡汤，这本久负盛名，最近越来越火的书，从我的体验来说，比其他同类的书要好很多，还是有干货的。虽然没有给我非常的大的质的改变，但是也解决了不少我的疑惑。书里没有提出多么惊天动地的方法，很多都是我们日常生活中在使用的技巧，这本书把这些总结整理成一套系统方法，也算是一大成就吧。&lt;/p&gt;
&lt;p&gt;毕竟，实践才是检验真理的唯一标准，等过段时间再评价吧。&lt;/p&gt;
&lt;h2 id="my-gtd"&gt;My GTD&lt;/h2&gt;
&lt;p&gt;作为学生党的 GTD 实践：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Tools&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Project List&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Daily Plan&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Waiting For List&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Someday/Mayble List&lt;/td&gt;
&lt;td&gt;Evernote&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calendar&lt;/td&gt;
&lt;td&gt;Google Calendar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reminder &amp;amp; Memo&lt;/td&gt;
&lt;td&gt;Google Keep&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;说明一下选择 EN 的最大的理由：它的跨平台性，Windows + *nix + Andriod，基本涵盖了我校园（宿舍 + 实验室）的生活，至于 Google 就不用说了，Gmail + Calendar + Keep + Drive 的组合别说有多舒服了～&lt;/p&gt;
&lt;p&gt;关于 “Next Action List”，我个人觉得并不是特别适合我，就平时的事（学习 + 项目 + 杂事）而言，学习和项目很难用 Next Action 来做计划，而杂事都是一些鸡毛蒜皮的小事，用不着分步骤来完成。我每天都活动基本上是固定的，哪个时间段干什么早就形成了一种模式，所以我将 “Next Action List” 改为 “Daily Plan”。&lt;/p&gt;
&lt;h2 id="mind-map"&gt;Mind Map&lt;/h2&gt;
&lt;p&gt;最后贴上一张我总结的 MM：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtd mm" src="/images/getting-things-done-review/gtd-mm.jpg"&gt;&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://snownow.cn/?p=1838"&gt;GTD | snow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://picasaweb.google.com/gudaost/MindMapper#5073109143800914274"&gt;MindMapper&lt;/a&gt;&lt;/p&gt;</content><category term="Book"></category><category term="GTD"></category><category term="review"></category></entry><entry><title>时钟分频器</title><link href="https://qian-gu.github.io/posts/ic/clock-dividers.html" rel="alternate"></link><published>2014-10-13T22:26:00+08:00</published><updated>2014-10-13T22:26:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-10-13:/posts/ic/clock-dividers.html</id><summary type="html">&lt;p&gt;总结常用的时钟分频方法&lt;/p&gt;</summary><content type="html">&lt;p&gt;在 &lt;a href="http://guqian110.github.io/pages/2014/09/12/the-clock-design-in-fpga-2-clock-design.html"&gt;时钟设计&lt;/a&gt; 中提到过：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Guideline：&lt;/strong&gt; 尽量避免使用分频时钟&lt;/p&gt;
&lt;p&gt;如果要进行分频，可以使用 PLL/DLL 来实现，但是对于时钟要求不高的基本设计，通过语言进行时钟的分频相移仍然非常流行，首先这种方法可以节省芯片内部的锁相环资源，再者，消耗不多的逻辑单元就可以达到对时钟操作的目的。另一方面，通过语言设计进行时钟分频，可以看出设计者对设计语言的理解程度。&lt;/p&gt;
&lt;p&gt;如果一定要使用分频时钟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于资源比较丰富的 FPGA&lt;/p&gt;
&lt;p&gt;使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频 / 分频）和相位，这样的分频时钟是最稳定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法使用 PLL/DLL 的 FPGA&lt;/p&gt;
&lt;p&gt;对于这些情况，首先检查是否可以用 &lt;code&gt;CE&lt;/code&gt; (clock enable) 来代替分频时钟，如果不行，则使用下面讨论的分频方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="counter"&gt;Counter&lt;/h2&gt;
&lt;p&gt;时钟分频一般都是通过计数器 counter 来实现的，计数器是分频的基础。&lt;/p&gt;
&lt;p&gt;计数器可以分为很多种，&lt;a href="http://en.wikipedia.org/wiki/Counter"&gt;Counter on wiki&lt;/a&gt;，这里不再跑题展开了，关于计数器的讨论见：&lt;a href="http://guqian110.github.io/pages/2014/11/04/counter-design-summary.html"&gt;Counter in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="clock-divider"&gt;Clock divider&lt;/h2&gt;
&lt;h3 id="even-clock-divider"&gt;even clock divider&lt;/h3&gt;
&lt;p&gt;偶数分频是最简单的情况，使用计数器就可以完成。比如，产生一个分频系数为 N（偶数）的 50% 占空比的分频器一般有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计数器计数到 (N/2-1) 时，将输出翻转，同时将计数器复位到 0，重新开始计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计数器从 0 计数到 (N/2-1) 时，输出 1/0，从 N/2 计数到 (N-1) 时，输出 0/1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方案一只能实现固定的 50% 占空比，方案二则可以实现可以有限调整占空比。&lt;/p&gt;
&lt;h3 id="odd-clock-divider"&gt;odd clock divider&lt;/h3&gt;
&lt;p&gt;如果对占空比没有要求，那么使用和偶数分频类似的方法，一个计数器就可以解决；如果要求占空比是 50%，则可以使用以下的方法：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Conceptually, the easiest way to create an odd divider with a 50% duty cycle is to  generate two clocks at half the desired output frequency with a quadrature-phase relationship (constant 90° phase difference between the two clocks).&lt;/p&gt;
&lt;p&gt;The output frequency can then be generated by exclusive-ORing the two waveforms together.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Steps&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建 ref-clk 上升沿触发的 0 ~ (N - 1) 的计数器 cnt（N 为奇数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用两个 T flip-flop，分别产生各自的 enable&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tff1-en: 当 cnt = 0 时，使能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tff2-en: 当 cnt = (N + 1) / 2 时，使能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产生以下信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;div1：在 ref-clk &lt;em&gt;上升沿&lt;/em&gt; 触发 tff1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;div2：在 ref-clk &lt;em&gt;下降沿&lt;/em&gt; 触发 tff2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异或 div1 和 div2，得到输出 clk-out&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中，举例介绍了 3 分频的情况：&lt;/p&gt;
&lt;p&gt;Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic" src="/images/clock-dividers/divide-3-sch.png"&gt;&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="timing" src="/images/clock-dividers/divide-3-timing.png"&gt;&lt;/p&gt;
&lt;h3 id="half-integer-clock-divider"&gt;half integer clock divider&lt;/h3&gt;
&lt;p&gt;这种分频系数为 (N+1/2)，应该归类到小数分频中，但是因为它的小数部分是特殊的 1/2，所以可以在前面的讨论的基础上得到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中分类讨论了半整数分频：&lt;/p&gt;
&lt;h4 id="50-duty-cycle"&gt;50% Duty Cycle&lt;/h4&gt;
&lt;p&gt;以 1.5 分频为例，&lt;/p&gt;
&lt;p&gt;Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="1.5 sch" src="/images/clock-dividers/divide-1-5-sch.png"&gt;&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="1.5 timing" src="/images/clock-dividers/divide-1-5-timing.png"&gt;&lt;/p&gt;
&lt;p&gt;这种方法在仿真的时候是没有问题的，但是综合时可能会产生致命的问题：在切换时钟时，如果两路时钟信号的时延不相等，那么切换的时候就会产生毛刺。&lt;/p&gt;
&lt;p&gt;(Xilinx 提供的原语 &lt;code&gt;BUFGMUX&lt;/code&gt; 有去除切换时钟时候的毛刺的功能，但是它只适用于全局时钟网络 )&lt;/p&gt;
&lt;h4 id="non-50-duty-cycle"&gt;Non 50% Duty Cycle&lt;/h4&gt;
&lt;p&gt;如果占空比不是 50%，则可以通过以下的方法得到：&lt;/p&gt;
&lt;p&gt;从&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;N + 1/2 = (2N + 1) / 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可知，N+1/2 分频也就是要求在 (2N+1) 个时钟周期内产生两个脉冲即可，这两个脉冲必须是等间隔分布的。&lt;/p&gt;
&lt;p&gt;首先，可以采用长度为 (2N+1) 的移位寄存器，这些寄存器中只有一个是 1，其他都是 0，然后在时钟的驱动下循环移位，则就有了 (2N+1) 个时钟周期的计数。&lt;/p&gt;
&lt;p&gt;其次，两个脉冲可以从这个移位寄存器中选取两个作为输出，但是不能简单地直接使用，因为无论怎样选择，这两个脉冲都不是等间隔分布的（一共 2N+1 个计数，抽取 2 个，剩余 2N-1 个计数，那么 2N-1 是个奇数，无法平分为两部分，所以不是等间隔的）。所以难点就在于如何得到两个等间隔的分布。The Art 的解决方法如下，以 4.5 分频为例：&lt;/p&gt;
&lt;p&gt;Timing:&lt;/p&gt;
&lt;p&gt;&lt;img alt="4.5 timing" src="/images/clock-dividers/divide-4-5-timing.png"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，当选择了两个连续的寄存器 (A, B) 相或作为第一个脉冲输出之后，再选取相隔 N 的两个连续的寄存器 (C, D)，把它们移动半个时钟周期后，和原始的 D 相或，作为第二个脉冲输出，容易分析，它们是等间隔的。&lt;/p&gt;
&lt;h3 id="fraction-divider"&gt;fraction divider&lt;/h3&gt;
&lt;p&gt;大概有两种方法吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数逼近法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多次分频&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小数分频，最普通的方法是采用整数分频逼近法，比如 50 MHz 的时钟分频为 880 Hz，那么分频计数器 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;50000000&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;880&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;56818.18182&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么就用 56818 来近似，但是这种方法只有在分频系数很大时才比较好，分频系数越小，则误差越大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考一篇博文：&lt;a href="http://blog.sina.com.cn/s/blog-6840802c0100izey.html"&gt;verilog 实现小数分频（小数分频器）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过可变分频和多次平均的方法，然后通过控制单位时间内两种分频比出现的不同次数来获得所需要的小数分频值。&lt;/p&gt;
&lt;p&gt;假设分频系数为 N+A/B，其中 N, A, B 都是整数，N 代表整数部分，A/B 表示小数部分。&lt;/p&gt;
&lt;p&gt;由&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NB+A = N*(B-A) + (N+1)*A
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可知，通过 (B-A) 次 N 分频 + A 次 (N+1) 分频即可得到 N+A/B 分频。&lt;/p&gt;
&lt;p&gt;到此还没有结束，还需要对这两种分频方式进行均匀的放置。可以借助一个计数器到达这个目的：每进行一次分频，计数值为 10 减去分频系数的小数部分，各次计数值累加。若累加结果小于 10，则进行 N +1 分频，若大于或等于 10，则进行 Ｎ 分频。&lt;/p&gt;
&lt;p&gt;不同时钟分频组合时，“ 按照累积量和 10 比较 ” 原理： 当采用一种分频比，小数部分累积量大于 10，则表示小数部分累积达到了可以向整数部分进位的大小，这时候就应该插入另外一种分频比将小数部分积累的误差去掉，否则结果就不是均匀周期的时钟信号了。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;比如 8.7 分频&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mf"&gt;87&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;8&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;9&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以可以用 3 次 8 分频 + 7 次 9 分频得到 8.7 分频。因为 &lt;code&gt;10 -7 = 3&lt;/code&gt;，前 3 次累积之和都小于 10，所以前 3 次进行 9 分频，第四次累积值为 12，去除进位后余 2，待下次继续累积，第四次结果 12 &amp;gt; 10，所以进行 8 分频。分频方案如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="/images/clock-dividers/example.png"&gt;&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;本文总结了一些常用的时钟分频技术，虽然不推荐使用逻辑来对时钟信号进行分频，但是在一些要求比较的的情况下，使用逻辑分频不仅可以满足要求，还能降低资源消耗，不失为一种好方法。而且时钟分频也可以训练我们的设计能力。&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://read.pudn.com/downloads126/sourcecode/embed/533229/VHDL%E5%88%86%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1.pdf"&gt;使用 VHDL 进行分频器设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog-6840802c0100izey.html"&gt;verilog 实现小数分频（小数分频器）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetop.cn/blog/html/11/317611-13680.html"&gt;任意分频的 verilog 语言实现&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category><category term="clock dividers"></category></entry><entry><title>FPGA 时钟设计 3 —— 跨时钟域设计</title><link href="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-3-multiasynchronous-clock-design.html" rel="alternate"></link><published>2014-10-09T23:01:00+08:00</published><updated>2014-10-09T23:01:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-10-09:/posts/ic/the-clock-design-in-fpga-3-multiasynchronous-clock-design.html</id><summary type="html">&lt;p&gt;总结 FPGA 中跨时钟域的设计&lt;/p&gt;</summary><content type="html">&lt;h2 id="problem"&gt;Problem&lt;/h2&gt;
&lt;p&gt;在前面一篇总结 &lt;a href="http://guqian110.github.io/pages/2014/09/23/latch-versus-flip-flop.html"&gt;Latch V.S. Flip-flop&lt;/a&gt; 的博文中，已经解释了 flip-flop 的一些参数：建立时间 &lt;code&gt;setup time&lt;/code&gt;、保持时间 &lt;code&gt;hold time&lt;/code&gt;、恢复时间 &lt;code&gt;recovery time&lt;/code&gt;、撤销时间 &lt;code&gt;removal time&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果不满足这些参数的要求，则会发生所谓的 亚稳态 &lt;code&gt;Metastability&lt;/code&gt; 的问题。下面是 Altera 官方的一篇关于亚稳态的 white paper，详细介绍了亚稳态的产生原因、它是如何导致设计出现问题、以及描述它的参数 MTBF (Mean Time Between Failures) 如何计算。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们知道，一般只涉及单时钟域的设计并不多见，尤其是对于一些复杂的应用，FPGA 往往需要和多个时钟域的信号进行通信，而这些时钟之间的关系一般都是频率不同、相位也不同，也就是不同频不同相的多异步时钟域设计 &lt;code&gt;Mulit-Asynchronous Clock Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为这些时钟信号之间的关系一般既不同频也不同相，所以一个时钟域的信号对于另外一个时钟域来说是异步信号，那么就无法保证进入新时钟域的信号和新的时钟信号之间满足 setup/hold time 的要求，自然就会引起亚稳态的问题。&lt;/p&gt;
&lt;p&gt;在 Clifford E. Cummings 大神的 paper：&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 里面就举例说明了这种现象：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"When sampling a changing data signal with a clock ... the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;**Illustation 1: **&lt;/p&gt;
&lt;p&gt;&lt;img alt="failure" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronization-failure.png"&gt;&lt;/p&gt;
&lt;p&gt;**Illustation 2: **&lt;/p&gt;
&lt;p&gt;如果不加处理，亚稳态产生的错误值将会传播到设计的其他部分，导致更加严重的问题&lt;/p&gt;
&lt;p&gt;&lt;img alt="propagatetion" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/propagation.png"&gt;&lt;/p&gt;
&lt;h2 id="synchronous-design"&gt;Synchronous Design&lt;/h2&gt;
&lt;p&gt;多时钟域导致的亚稳态的问题的根本原因就是：信号和时钟是异步的，也就是设计不是同步设计 &lt;code&gt;Synchronous Design&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步化设计思想&lt;/strong&gt; 是 FPGA 中非常重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asynchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 组合逻辑 &lt;code&gt;combination logic&lt;/code&gt; 实现的，比如异步 FIFO/RAM 读写信号、地址译码等电路。电路的主要信号、输出信号不依赖任何一个时钟信号，不是由时钟信号驱动 flip-flop 产生的。&lt;em&gt;异步电路最大的缺点就是容易产生毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous Circuits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步电路的核心逻辑是用 时序逻辑 &lt;code&gt;sequential logic&lt;/code&gt; 实现的。电路的主要信号、输出信号是由某个时钟沿驱动 flip-flop 产生的。&lt;em&gt;同步电路可以很好的避免毛刺。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous V.S. Asynchronous&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从 ASIC 设计的角度来看，大约需要 7 个门来实现一个 D 触发器，而一个门即可实现一个 2 输入与非门，所以一般来说，在 ASIC 设计中，同步时序电路比异步电路占用更大的面积。但是，由于 FPGA 是定制好的底层单元，对于 Xilinx 器件，一个底层可编程单元 Slice 包含两个触发器（FF）和一个查找表（LUT）。其中触发器用以实现同步电路，查找表用以实现组合电路。FPGA 最终使用率用 Slice 来衡量。所以对于某个选定器件，其可实现的同步电路和异步电路的资源数量和比例是固定的，这点造成了过度使用查找表会浪费触发器资源，反之亦然。因而对于 FPGA，同步时序设计不一定比异步设计多消耗资源。单从节约资源的角度考虑，应该按照芯片配置的资源比例实现设计，但是设计者还要时刻权衡同步设计没有毛刺、信号稳定等优点，&lt;strong&gt;所以对于 FPGA 设计推荐采用同步设计。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是用离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字逻辑，为了成功操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为，FPGA 同步设计中最好的时钟解决方案是由专用全局时钟输入引脚驱动单个主时钟去控制设计项目中的每一个触发器。系统中各个功能模块使用同一同步复位信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FPGA 同步设计中，时序电路应尽量采用同步电路，尽可能使用同步器件，尽量减小或不使用门控时钟（为了降低系统功耗以外）。设计中不用系统主时钟经过逻辑运算得到控制信号，避免使用非时钟信号作为触发器的时钟输入。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面提到的所有方法，就是同步化思想的应用，其核心目的就是将本时钟域外的 &lt;strong&gt;异步信号同步化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="solution"&gt;Solution&lt;/h2&gt;
&lt;h3 id="solution-1-daul-rank-synchronizer"&gt;Solution 1: Daul Rank Synchronizer&lt;/h3&gt;
&lt;p&gt;通常使用 &lt;code&gt;MTBF (Mean Time Between Failures)&lt;/code&gt; 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。&lt;/p&gt;
&lt;p&gt;以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×109 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。&lt;/p&gt;
&lt;p&gt;理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer.png"&gt;&lt;/p&gt;
&lt;p&gt;通常，同步器 synchronizer 由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。&lt;/p&gt;
&lt;p&gt;为了让 synchronizer 正常工作，从某个 时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入 synchronizer。之所以这样要求，是因为 synchronizer 的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过 synchronizer，给新时钟域后续逻辑一个虚假的信号。&lt;/p&gt;
&lt;p&gt;synchronizer 有很多设计方法，因为一种方法不能满足所有的应用需求。synchronizer 的类型基本上分为 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;level synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge-detecting synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pulse synchronizer&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面分别讨论：&lt;/p&gt;
&lt;h4 id="level-synchronizer"&gt;level synchronizer&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;paper&lt;/a&gt; 中有更详细的图解说明：&lt;/p&gt;
&lt;p&gt;&lt;img alt="level" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LVLSYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// source time domain&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// destination time domain&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// using two level DFF to synchronize the din-q&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="level rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/lvl-rtl.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 level synchronizer 的要求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的 synchronizer 的第一级 DFF。这样做的&lt;/p&gt;
&lt;p&gt;这么做到原因是：synchronizer 的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么 synchronizer 会将其放行，产生一个虚假的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨域时钟域的这个信号持续时间 &amp;gt;= 2 个新时钟域时钟周期。&lt;/p&gt;
&lt;p&gt;虽然 &lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt; 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。level synchronizer 的最低条件应该和 edge-detecting synchronizer 相同：&lt;/p&gt;
&lt;p&gt;输入信号的宽度 &amp;gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。&lt;/p&gt;
&lt;p&gt;首先，待同步到信号宽度 &amp;gt; 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出；&lt;/p&gt;
&lt;p&gt;其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 &amp;gt; 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。&lt;/p&gt;
&lt;p&gt;所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;level synchronizer 是其他两种同步器的基础：&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="edge-detecting-synchronizer"&gt;edge-detecting synchronizer&lt;/h4&gt;
&lt;p&gt;边沿检测同步器 是在 level synchronizer 的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="edge-detecting" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge-detecting.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;EDGESYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// source time domain&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;/////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// destination time domain&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// AND to get the output&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 edge-detecting synchronizer 的要求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入信号的宽度 &amp;gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。&lt;/p&gt;
&lt;p&gt;实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 &amp;gt; 目标时钟周期的，因为 edge-detecting synchronizer 只能工作在慢时钟域到快时钟域的情况下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;edge-detecting synchronizer 在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用 pusle synchronizer。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="pulse-synchronizer"&gt;pulse synchronizer&lt;/h4&gt;
&lt;p&gt;脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。&lt;/p&gt;
&lt;p&gt;源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。&lt;/p&gt;
&lt;p&gt;而在目的时钟域，翻转电路的输出先通过一个 level synchronizer，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果：&lt;/p&gt;
&lt;p&gt;源时钟域每有一个单时钟脉冲（源时钟），synchronizer 的输出端产生一个单时钟宽度（目的时钟）的脉冲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pusle" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/pulse.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Code:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PULSESYNC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;pulse&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;pulse&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// source time domain&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;toggle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;toggle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pulse&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;toggle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;toggle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// destination time domain&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;///////////////////////////////////////////////////&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;toggle&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// XOR to generate the pusle-dst&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pulse&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sync&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RTL:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Restriction:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 pusle synchronizer 的要求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输入脉冲之间的最小间隔 &amp;gt;= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。&lt;/p&gt;
&lt;p&gt;实际上，在一些情况下，少于 2 个时钟周期（&amp;gt; 1 个时钟周期）也是可以同步上的。只要 synchronizer 的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。&lt;/p&gt;
&lt;p&gt;一般为了保险起见，要求其保持至少两个时钟宽度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="timing"&gt;Timing&lt;/h4&gt;
&lt;p&gt;synchronizer 需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为 synchronizer 会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑 synchronizer 对时序产生的影响。&lt;/p&gt;
&lt;h4 id="summary"&gt;Summary&lt;/h4&gt;
&lt;p&gt;总结 3 种同步器的特点，有下表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronizer sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer-sum.png"&gt;&lt;/p&gt;
&lt;p&gt;虽然还有其他类型的 synchronizer，但是这 3 种基本上就可以解决设计中遇到的多数问题了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;synchronizer 仅适用于简单的数据跨时钟域传输的同步，除了简单的信号之外，还有数据、地址、控制总线信号等也要跨时钟域。对于这些需求，可以使用其他的工具，比如握手协议、FIFO 等。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="solution-2-handshaking"&gt;Solution 2: Handshaking&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Handshaking allows digital circuits to effectively communicate with each other when the response time of one or both circuits is unpredictable. For example, an arbitrated bus allows more than one circuit to request access to a single bus, such as PCI or AMBA (Advanced Microcontroller Bus Architecture), using arbitration to determine which circuit gains access to the bus. Each circuit signals a request, and the arbitration logic determines which request “wins.” This winning circuit receives an acknowledgment indicating that it has access to the bus. It then discontinues its request and begins the bus transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大意就是：对于（单边 / 双边）电路响应时间不确定的应用，握手协议可以有效地传输信号。比如（PCI、AMBA）总线仲裁电路，有多个电路申请访问总线时，每个电路都发出请求，由仲裁电路来决定哪个有访问权。“ 获胜 ” 的电路会收到确认信号，然后才可以访问总线。&lt;/p&gt;
&lt;p&gt;这种交互方式就是握手协议，简而言之就是双方首先要握手达成一致，然后才能传输数据。&lt;/p&gt;
&lt;p&gt;有两种基本握手协议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Full-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partial-handshaking&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种握手协议都要用到 synchronizer，每种都有各自的优缺点，下面分别讨论：&lt;/p&gt;
&lt;h4 id="full-handshaking"&gt;full handshaking&lt;/h4&gt;
&lt;p&gt;&lt;img alt="full" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/full.png"&gt;&lt;/p&gt;
&lt;p&gt;如图所示，全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路 A 声明它的请求信号，然后接收方电路 B 检测到该请求有效后，声明它的效应信号；当电路 A 检测到响应信号有效之后，中止自己的请求信号；最后，当电路 B 检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非 A 检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路 A 必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。&lt;/p&gt;
&lt;p&gt;这种类型的握手使用了 level synchronizer。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端 A 需要 5 个周期，接收端 B 需要 6 个周期。&lt;/p&gt;
&lt;p&gt;全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。&lt;/p&gt;
&lt;h4 id="partial-handshaking"&gt;partial handshaking&lt;/h4&gt;
&lt;p&gt;另一中类型是部分握手。部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。&lt;/p&gt;
&lt;p&gt;部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。&lt;/p&gt;
&lt;p&gt;有两种类型的部分握手：&lt;/p&gt;
&lt;p&gt;第一种握手方法中，电路 A 以有效电平声明其请求信号，电路 B 以一个单时钟宽度脉冲作为响应。此时，电路 B 并不关心电路 A 何时中止它的请求。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial-1.png"&gt;&lt;/p&gt;
&lt;p&gt;但是为了这种方法成立，电路 A 中止请求信号至少要 1 个时钟周期长度，否则，电路 B 就不能区别前一个和后一个新的请求。&lt;/p&gt;
&lt;p&gt;在这种握手方式下，电路 B 为请求信号使用一个 level synchronizer；电路 A 为响应信号使用一个 pusle synchronizer。只有当电路 B 检测到请求信号时才发出响应脉冲，这样电路 A 控制请求信号的时序，就能控制自己 synchronizer 接收到的脉冲间隔。&lt;/p&gt;
&lt;p&gt;同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路 A 需要花费 3 个时钟周期，接收端 B 需要花费 5 个时钟周期。&lt;/p&gt;
&lt;p&gt;第二种握手方法中，电路 A 使用一个单时钟宽度脉冲发出它的请求，电路 B 也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。&lt;/p&gt;
&lt;p&gt;&lt;img alt="partial-2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial-2.png"&gt;&lt;/p&gt;
&lt;p&gt;这种握手使用的是 pusle synchronizer。完整的时序是：电路 A 需要花费 2 个时钟周期，电路 B 需要花费 3 个时钟周期。&lt;/p&gt;
&lt;h4 id="summary_1"&gt;summary&lt;/h4&gt;
&lt;p&gt;&lt;img alt="handshaing sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/handshaking-sum.png"&gt;&lt;/p&gt;
&lt;p&gt;因为 handshaking 内部采用了 synchronizer，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的 synchronizer 和握手信号，就有了前面介绍的 3 种不同的 handshaking：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;full handshaking
是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial handshaking 是对 full 的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的 partial shandshaking。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial I 精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了 1 次半的握手。而且修改了 full 中 level synchronizer 的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路 A 则必须使用 pusle synchronizer 来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的 synchronizer，partial I 就比 full 方式节约了很多时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial II 则更进一步，在 partial I 的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成 1 次握手。而且两部分电路的 synchronizer 同时修改为 pusle 方式。这样子进一步减少了握手花费的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;partial 和 full 的本质区别不在于 synchronizer 的类型和握手信号的多少，而在于握手的方式。 partial 不用再等待对方的回答，就继续进行自己的下一步操作，而 full 必须等到对方的回复才进行下一步的操作，所以从某种意义上，full 方式才是真正的 “ 握手 ”，而 partial 并不符合 “ 握手 ” 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手 =.=&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;在许多应用中，跨时钟域传送的不只是简单的信号，数据总线、地址总线、控制总线都会同时跨域传输。因为 synchronizer 需要花费的时间是不确定的（1 or 2 个时钟周期），所以对于这些多 bit 的数据，synchronizer 无法完成同步功能，通常采用其他的方法，比如使用 FIFO。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="solution-3-datapath-design"&gt;Solution 3: Datapath Design&lt;/h3&gt;
&lt;p&gt;在进行信号同步时，有一个重要的原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不应该在设计中的多个地方对同一信号进行同步，即禁止单个信号扇出至多个同步器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 synchronizer 要花 1~2 个时钟周期，设计者不能确切预测到每个信号何时跨越时钟域，此外，在新时钟域中一组经过同步后的信号其时序是不定的，因为 synchronier 的延迟可以是 1～2 个时钟周期，这种情况下各个同步信号间形成一种 “ 竞争状况 ”，这种竞争状况在需要跨域时钟域传输的多组信号间也会发生，例如数据总线、地址总线、控制总线等。因此，&lt;strong&gt;不能对组中的每个信号单独使用 synchronizer，也不能对数据 / 地址总线的每一位单独使用同步器&lt;/strong&gt;，因为在新的时钟域中，要求每个信号同时有效。&lt;/p&gt;
&lt;h4 id="problem_1"&gt;problem&lt;/h4&gt;
&lt;p&gt;Clifford E. Cummings 在他的文章中举例说明了几种常见的错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. &lt;strong&gt;Simply using synchronizers on all control signals is not always good enough&lt;/strong&gt; as will be shown in the following examples. &lt;/p&gt;
&lt;p&gt;If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two simultaneously required control signals&lt;/strong&gt;
 a register in the new clock domain requires both a load signal and an
enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem-1.png"&gt;&lt;/p&gt;
&lt;p&gt;** Solution - Consolidating control signals before passing**&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution-1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Problem - Two phase-shifted sequencing control signals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;img alt="problem 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem-2.png"&gt;&lt;/p&gt;
&lt;p&gt;** Solution - Logic to generate the proper sequencing signals**&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution-2.png"&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="solution_1"&gt;solution&lt;/h4&gt;
&lt;p&gt;有一种解决这个问题的方法是：&lt;strong&gt;使用一个保持寄存器 + 一个握手信号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="solution" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath.png"&gt;&lt;/p&gt;
&lt;p&gt;保持寄存器保持信号总线的数据，握手信号指示目标时钟域何时可以对总线进行采样，源时钟域何时可以更换当前寄存器中保存的内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In this design, the transmitting circuit stores the data (signal bus) in the holding register as it asserts the request signal. These two actions can happen at once because the request signal takes at least one clock cycle before the receiving circuit detects it (the minimum handshake-synchronization delay). When the receiving circuit samples the data (signal bus), it asserts the acknowledgment signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细分析一下，其实这里采用的原理类似于握手协议。&lt;/p&gt;
&lt;p&gt;当有一组新的数据出现在数据总线上需要跨时钟域时，额外添加一对握手信号 request/acknowledge，这对信号对于两个时钟域来说分别是异步信号（接收电路不知道何时会收到 request，发送电路也不知道何时会获得 acknowledge），可能会产生亚稳态的问题，所以在两个时钟域对它们分别用 synchronizer 进行同步。&lt;/p&gt;
&lt;p&gt;和 request 一起送过来的还有数据总线 上的数据信号，但是对于数据信号，不能简单地对每一位使用 synchronizer 来同步（原因前面已经说过了）。虽然对于接收电路来说，数据总线上的数据也是异步的，但是我们可以强制要求在握手过程中，数据保持不变，这样虽然数据是异步的，只要发送端满足保持寄存器数据在握手过程中不变化这一条件，那么即使数据总线上的数据到达接收时钟域有一些小的偏差 skew，但是不会超出 1 个时钟周期，在 synchronizer 最好的状态下，只花费了 1 个时钟周期就同步到了握手请求 request，这时候数据总线上的数据已经是稳定不变的有效数据了，所以可以采样到正确的有效数据，不会存在亚稳态的问题。&lt;/p&gt;
&lt;p&gt;采用这种方法可以避免亚稳态的出现的原因就是它规定了异步信号（保持寄存器）什么时候可以变化，虽然是异步信号，但是在采样的时候人为地确保了它保持稳定，满足 setup/hold time 的要求，所以不会有亚稳态的问题。&lt;/p&gt;
&lt;p&gt;这里的握手机制可以采用 full handshaking，也可以采用 partial handshaking，设计者应该根据实际需求来选择。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt; 这本书中，有详细的时序图来说明了一种握手机制下，这种机制采用了 full handshaking 中等待对方的方法，但是对握手信号进行了精简（partial II 类型）。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="datapath timing" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath-timing.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果发送端的数据速率很快 / 无法控制发送端发送数据的速度，那么就有可能无法满足握手机制中要求数据保持稳定这一要求，这时候这种方法就不再适用，而应该采用其他的方法，比如 FIFO。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="solution-4-advanced-datapath-design"&gt;Solution 4: Advanced Datapath Design&lt;/h3&gt;
&lt;p&gt;有时候，数据在跨时钟域时需要 “ 堆积 ” 起来，这时候只使用单个的寄存器就无法完成工作。比如某个传输电路突发式地发送数据，接收电路来不及采样，为了保持数据不丢失，就必须先把数据存储起来；还有一种情况是接收电路的采样速率比发送速度快，但是位宽却不够，仍然需要将没有采样的数据先暂存起来，这时候就需要使用 FIFO。&lt;/p&gt;
&lt;p&gt;基本上，使用 FIFO 的目的有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;速度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宽度匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FIFO 的实现可以直接使用 IP core，也可以自己写代码实现。&lt;/p&gt;
&lt;p&gt;如果是自己写代码实现，那么异步信号的问题还是需要我们在实现 FIFO 是仔细考虑的；如果是采用 IP core 的方式，那么可以很大程度地缓解我们的压力，因为事实上我们是把异步信号的问题交给了设计 IP core 的人来处理 ... 这些 IP core 在内部针对异步数据读写的问题作了非常严谨复杂的设计，对外提供了非常简单的接口。采用这种方式虽然轻松，但是相应的地也有缺点：耗费更多的资源。&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt; 和 &lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt; 两篇 paper 和 &lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art&lt;/a&gt; 中都有一些实现 FIFO 使用的相关技术的介绍，比如指针逻辑的处理，内部 gray code 计数器的实现等。这里就偷懒不细说了（以后再补） :P&lt;/p&gt;
&lt;p&gt;=============Update March/12/2015===========================&lt;/p&gt;
&lt;p&gt;FIFO 的目的在于解决数据跨时钟域传输的问题，但是在实现 FIFO 本身时，一些内部的握手信号也需要跨时钟域，这时候需要用到之前讨论过的 dual rank synchronizer 等技术。&lt;/p&gt;
&lt;p&gt;比如 FIFO 内部的地址计数器，如果使用 dual rank synchronizer 来同步，计数器的不同的 bit 可能会在不同的时钟周期内传递过去，这时接收到的数据就是错误的，对导致致命性的问题。&lt;/p&gt;
&lt;p&gt;而对应这个问题的解决方法就是使用 gray code。&lt;/p&gt;
&lt;p&gt;==============end of update==================================&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于跨时钟域 &lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;papaer1&lt;/a&gt; 中还有一些其他方面的技巧，可以帮助我们更好的实现设计。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="design-partitioning"&gt;Design Partitioning&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only allow one clock per module.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Static timing analysis and creating synthesis scripts is more easily accomplished on single-clock modules or groups of single-clock modules.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Create a synchronizer module for each set of signals that pass from just one clock domain into another clock domain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is given that any signal passing from one clock domain to another clock domain is going to have setup and hold time problems. No worst-case (max time) timing analysis is required for synchronizer modules. Only best case (min time) timing analysis is required between first and second stage flip-flops to ensure that all hold times are met. Also, gate-level simulations can more easily be configured to ignore setup and hold time violations on the first stage of each synchronizer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;采用这种设计方式的原因如上所示，可以减少不必要的时序验证，而且脚本也更容易写，总之可以使时序验证工作更容易。&lt;/p&gt;
&lt;p&gt;举例如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="partitioning" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partitioning.png"&gt;&lt;/p&gt;
&lt;h3 id="clock-name-conventions"&gt;Clock Name Conventions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use a clock naming convention to identify the clock source of every signal in a design.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reason:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A naming convention helps all team members to identify the clock domain for every signal in a design and also makes grouping of signals for timing analysis easier to do using regular expression "wild-carding" from within a synthesis script.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者还举例说明了一个这样的例子：1995 年为 In Focus projectors 设计 video ASIC 时，他们就采用了这样的方法，对于 mircroprocessor 的时钟命名为 uClk，对于 video 的时钟则命名为 vClk。对应的时钟域中的信号的名字也添加了对应的前缀，比如 udata，uwrite，uadder 等。&lt;/p&gt;
&lt;p&gt;使用了这样的策略后，整个设计团队的攻城狮们都可以很方便地确定某个信号是否为异步信号，如何处理。当时有个攻城狮没有按照这种策略，使用了自己的命名方式，在一次会议之后，大家墙裂建议他修改命名，结果也证明修改之后遇到的问题、出错的概率都小了很多。&lt;/p&gt;
&lt;h2 id="gated-clock"&gt;Gated Clock&lt;/h2&gt;
&lt;p&gt;虽然 FPGA 可以用来为 ASIC 搭建原型，但是一些 ASIC 中的技术并不适用于 FPGA，比如 gated clock。一般也没有必要在 FPGA 中模拟 ASIC 的低功耗优化。事实上，由于 FPGA 时钟资源的的粗颗粒度性，并不是总能模拟成功。&lt;/p&gt;
&lt;p&gt;下面简单讨论一下 ASIC 中 gated clock 的问题。（更详细的内容见 gated clock 文章，未写）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;dedicated clock module&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;guideline&lt;/strong&gt;: 将全部的 gated clock 时钟放在一个专门的时钟模块中，并将其从功能模块中分离出来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reason&lt;/strong&gt;: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;约束更加容易处理&lt;/li&gt;
&lt;li&gt;FPGA 设计修改起来更容易（比如通过 #define 来选择编译 ASIC 还是 FPGA 设计，选择两者各自的实现代码）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gating removal&lt;/p&gt;
&lt;p&gt;在 FPGA 上建立模型时，有很多巧妙的方法去除 gated clock。比如下面这个例子就是最直观，但也是最繁琐的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;`define FPGA&lt;/span&gt;
&lt;span class="c1"&gt;// `define ASIC&lt;/span&gt;

&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;blocks&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`ifdef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ASIC&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`else&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这种方法的缺点是当做出改动时，需要对 FPGA 和 ASIC 代码都作出修改。很多人对这种方式很不爽，因为他们必须写两种不同的 RTL 代码。&lt;/p&gt;
&lt;p&gt;一种更加高级的方法是依靠工具，现代的很多综合工具都可以通过适当的约束，通过将条件并到数据通路，来自动消除 gated clock。&lt;/p&gt;
&lt;p&gt;比如下面的这段代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clockstest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;oDat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;iClk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;iEnable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;iDat&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;wire&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;gated&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iClk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iEnable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;gated&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;clock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;oDat&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iDat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果不打开自动消除的开关，产生的 gated clock 电路如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="circuit1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit1.png"&gt;&lt;/p&gt;
&lt;p&gt;如果打开自动消除的开关，产生的没有 gated clock 电路如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="circuit2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit2.png"&gt;&lt;/p&gt;
&lt;p&gt;现在大多数器件都提供了一个时钟使能（clock enable）端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果器件提供了这种接口，那么就没有必要使用上述方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件没有提供这种端口，那么使用这种技术虽然可以消除 gated clock，但是付出的代价是增加了 data path 的 delay。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary_2"&gt;Summary&lt;/h2&gt;
&lt;p&gt;以上，就是一些在多时钟域设计中处理异步数据的常用方法，总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于简单的单比特的数据，根据实际情况选择对应的 synchronizer 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于其他的信号，比如数据总线、地址总线、控制总线等数据，可以使用握手协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总线上的数据要求同时到达新的时钟域，所以不要对总线上的信号分别进行同步，而要采用一个保持寄存器 + 握手信号的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还可以采用 FIFO 来处理异步数据的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分块设计，尽可能保证一个模块只有一个时钟域，对于跨时钟域信号，写独立的同步模块，这样可以减轻时序验证的工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用良好的命名习惯，如前缀的方式，可以帮助设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意 ASIC 和 FPGA 中对时钟信号的不同处理方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf"&gt;Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf"&gt;Crossing the abyss: asynchronous signals in a synchronous world&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG-ARTICLE-174906.HTM"&gt;ASIC 中的异步时序设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.ednchina.com/BLOG-ARTICLE-175526.HTM"&gt;跨越鸿沟：同步世界中的异步信号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf"&gt;Understanding Metastability in FPGAs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960"&gt;The Art of Hardware Architecture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2878096/"&gt;Advanced FPGA Design: Architecture, Implementation, and Optimization&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category></entry><entry><title>锁存器 Latch v.s. 触发器 Flip-Flop</title><link href="https://qian-gu.github.io/posts/ic/latch-versus-flip-flop.html" rel="alternate"></link><published>2014-09-23T23:02:00+08:00</published><updated>2014-09-23T23:02:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-09-23:/posts/ic/latch-versus-flip-flop.html</id><summary type="html">&lt;p&gt;总结 Latch 和 Flip-Flop&lt;/p&gt;</summary><content type="html">&lt;p&gt;根据 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop-(electronics"&gt;Wiki: Flip-flop (electronics)&lt;/a&gt; 上的介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In electronics, a &lt;code&gt;flip-flop&lt;/code&gt; or &lt;code&gt;latch&lt;/code&gt; is a circuit that has two stable states and can be used to store state information. A flip-flop is a &lt;code&gt;bistable multivibrator&lt;/code&gt;. The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in sequential logic. Flip-flops and latches are a fundamental building block of digital electronics systems used in computers, communications, and many other types of systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区别一下名字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or opaque) or clocked (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term flip-flop exclusively for discussing clocked circuits; the simple ones are commonly called latches.&lt;/p&gt;
&lt;p&gt;Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以按照现在的约定习惯区分，latch 指的是电平触发的触发器，翻译为 “ 锁存器 ”；flip-flop 指边沿触发的触发器，就叫 “ 触发器 ”。&lt;/p&gt;
&lt;div class="toc"&gt;&lt;span class="toctitle"&gt;Table of Contents&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#history"&gt;History&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#implementation"&gt;Implementation&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#latch"&gt;Latch&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sr-latch"&gt;SR Latch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#d-latch"&gt;D Latch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#flip-flop"&gt;Flip-Flop&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#d-flip-flop"&gt;D flip-flop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#jk-flip-flop"&gt;JK flip-flop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#t-flip-flop"&gt;T flip-flop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#timing-considerations"&gt;Timing considerations&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#metastability"&gt;Metastability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#setup-hold-recovery-removal-times"&gt;Setup, hold, recovery, removal times&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#propagation-delay"&gt;Propagation delay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#in-fpga"&gt;in FPGA&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#reason-solution-to-unexpected-latch"&gt;Reason &amp;amp; Solution to unexpected latch&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#reason"&gt;Reason&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#solution"&gt;Solution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#application"&gt;Application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusion"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#reference"&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="history"&gt;History&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;翻译自 &lt;a href="http://en.wikipedia.org/wiki/Flip-flop-(electronics"&gt;wiki&lt;/a&gt;:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;第一个电子触发器 (electronic flip-flop) 由  William Eccles 和 F. W. Jordan 于 1918 年发明的。它最早被称为 ：  &lt;code&gt;Eccles–Jordan trigger circuit&lt;/code&gt;，由两个真空管组成。虽然现在由逻辑门 (logic gates) 组成的触发器很常见，但是在集成电路 (intergrated circuits) 中，这种元件及它的晶体管版本仍然也很常见。早期的触发器常用来构成触发电路或者多谐振荡器 (multivibrators)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="flip-flop" src="http://upload.wikimedia.org/wikipedia/commons/9/98/Eccles-Jordan-trigger-circuit-flip-flip-drawings.png"&gt;&lt;/p&gt;
&lt;p&gt;根据一个 JPL 的工程师，P. L. Lindley 介绍，Montgomery Phister 于 1954 年在 UCLA 的 computer design 的课程上第一次对触发器进行了分类的讨论（RS、D、T、JK），然后在他的书 Logical Design of Digital Computers 中也进行了讨论。Lindley 当时在 Hughes Aircraft 的 Eldred Nelson 手下工作，而 Nelson 命名了 JK 触发器。其他的名字则是 Phister 命名的。Lindley 解释说他是从 Nelson 口中得知 JK 触发器的故事的，当时 Hughes Aircraft 使用的触发器都是 JK 触发器。在设计逻辑系统时，Nelson 给触发器的输入命名为 A&amp;amp;B、C&amp;amp;D、E&amp;amp;F、G&amp;amp;H、J&amp;amp;K。在 1953 年 Nelson 申请专利时，采用了 J&amp;amp;K 的命名方案。&lt;/p&gt;
&lt;h2 id="implementation"&gt;Implementation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches. The word latch is mainly used for storage elements, while clocked devices are described as flip-flops.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不会翻译了 ... 大意就是说 flip-flop 可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;simple&lt;/p&gt;
&lt;p&gt;也可以说是 透明的 (transparent) 或者是 异步的 (asynchronous)，通常称为 &lt;code&gt;锁存器 Latch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clocked&lt;/p&gt;
&lt;p&gt;也可以说是 同步的 (synchronous)，称为 &lt;code&gt;触发器 flip-flop&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分类讨论：&lt;/p&gt;
&lt;h3 id="latch"&gt;Latch&lt;/h3&gt;
&lt;p&gt;Latch 可以由一对真空管、三极管、场效应管组成，在实际应用中也可以用逻辑门组成 latch。&lt;/p&gt;
&lt;h4 id="sr-latch"&gt;SR Latch&lt;/h4&gt;
&lt;p&gt;当使用逻辑门搭建模块时，最基本的 latch 就是 &lt;code&gt;SR latch&lt;/code&gt; (set-reset latch)，所有的 latch 和 flip-flop 都是建立在它的基础之上。&lt;/p&gt;
&lt;p&gt;SR latch 的实现可以有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SR NOR Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用或非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="http://upload.wikimedia.org/wikipedia/commons/c/c6/R-S-mk2.gif"&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor" src="/images/latch-versus-flip-flop/nor.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;S'R' NAND Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用与非门搭建：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/92/SR-Flip-flop-Diagram.svg/500px-SR-Flip-flop-Diagram.svg.png"&gt;&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand" src="/images/latch-versus-flip-flop/nand.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="d-latch"&gt;D Latch&lt;/h4&gt;
&lt;p&gt;Latch 是 &lt;code&gt;透明的 (transparent)&lt;/code&gt;，就是说输入的变换立即就能传递到输出端口，当几个透明的 latch 级联时，输入端的信号也能立即传递到输出端。当给 latch 添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 &lt;code&gt;不透明的 (non-transparent)&lt;/code&gt;。下面的 D latch 就是这样的例子。&lt;/p&gt;
&lt;p&gt;仔细观察 SR latch 的功能表，就可以发现，R 的取值为 S 的补。D latch 利用了这一特点，而且避免了 SR latch 中的禁止状态的出现。&lt;/p&gt;
&lt;p&gt;因为 SR latch 的实现有两种，所以 &lt;code&gt;D latch&lt;/code&gt; 的实现也对应有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NOR D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nor d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/D-type-Transparent-Latch-%28NOR%29.svg/500px-D-type-Transparent-Latch-%28NOR%29.svg.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NAND D Latch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="nand d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/D-Type-Transparent-Latch.svg/500px-D-Type-Transparent-Latch.svg.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;D latch 的功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="d latch" src="/images/latch-versus-flip-flop/d-latch.png"&gt;&lt;/p&gt;
&lt;p&gt;D latch 也称为  non-transparent、data latch、gated latch。它有一个数据输入端和一个使能端 enable(clock、control)。之所以叫透明，是因为当它使能时，输入端口的信号立刻就能传递到输出端口。&lt;/p&gt;
&lt;h3 id="flip-flop"&gt;Flip-Flop&lt;/h3&gt;
&lt;p&gt;如果 D latch 的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CP = 1，则触发器就会受到触发，当 CP 保持为 1 时，数据输入端口的任何变化都将影响到 latch 的状态。&lt;/p&gt;
&lt;p&gt;latch 的这个特点应用到 时序电路中，就会出现比较严重的问题：&lt;/p&gt;
&lt;p&gt;一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，latch 的输出通过组合电路反馈到 latch 的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致 latch 的输出变为新的值。在时钟信号有效的期间内，latch 的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。&lt;/p&gt;
&lt;p&gt;latch 的&lt;strong&gt;问题&lt;/strong&gt;就在于：&lt;em&gt;它在时钟有效期间内一直在被触发，这种触发时间过长。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个问题的&lt;strong&gt;解决方法&lt;/strong&gt;就是：&lt;em&gt;将触发条件变为时钟沿触发，这样就得到了触发器 &lt;code&gt;flip-flop&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="d-flip-flop"&gt;D flip-flop&lt;/h4&gt;
&lt;p&gt;将 latch 改造为边沿敏感的触发器，最简单的就是 &lt;code&gt;D flip-flop&lt;/code&gt; (data or delay)，搭建电路最经济有效的方法就是使用 DFF，因为它需要的门电路最少，其他类型的触发器都是在 DFF 的基础上得到的。&lt;/p&gt;
&lt;p&gt;实现 DFF 可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Classical positive-edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="classical" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Edge-triggered-D-flip-flop.svg/500px-Edge-triggered-D-flip-flop.svg.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Master–slave edge-triggered D flip-flop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="master-slave" src="http://upload.wikimedia.org/wikipedia/en/thumb/5/52/Negative-edge-triggered-master-slave-D-flip-flop.svg/500px-Negative-edge-triggered-master-slave-D-flip-flop.svg.png"&gt;&lt;/p&gt;
&lt;p&gt;clk = 1 时，master D-latch 使能，D 传递到输出端 Q；&lt;/p&gt;
&lt;p&gt;clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q；&lt;/p&gt;
&lt;p&gt;可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/latch-versus-flip-flop/dff.png"&gt;&lt;/p&gt;
&lt;h4 id="jk-flip-flop"&gt;JK flip-flop&lt;/h4&gt;
&lt;p&gt;在 DFF 的基础上，可以得到 JK FF。&lt;/p&gt;
&lt;p&gt;JK FF 的特点和 SR latch 类似，可以将 J 看作是 S，K 看作是 R，它和 SR latch 的区别在于它是边沿触发，并且将 S = R = 1 状态设置为 &lt;code&gt;翻转 (toggle)&lt;/code&gt;，也就是在下一个时钟边沿，输出取反。当 J = K = 0 时，得到的并不是 DFF，而是保持输出不变。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="jk" src="/images/latch-versus-flip-flop/jk.png"&gt;&lt;/p&gt;
&lt;h4 id="t-flip-flop"&gt;T flip-flop&lt;/h4&gt;
&lt;p&gt;将 JK FF 的输入端 J 和 K 连接到一起，就可以得到 &lt;code&gt;T FF&lt;/code&gt; (toggle flip-flop)。&lt;/p&gt;
&lt;p&gt;当 T = 0 (J = K = 0) 时，输出保持不变，时钟边沿不影响状态；当 T = 1 (J = K = 1) 时，在时钟边沿输出反相，也就是翻转。&lt;/p&gt;
&lt;p&gt;功能表：&lt;/p&gt;
&lt;p&gt;&lt;img alt="tff" src="/images/latch-versus-flip-flop/tff.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看到 TFF 有 1/2 分频的作用，这一特点在很多电路中得到了应用。&lt;/p&gt;
&lt;h2 id="timing-considerations"&gt;Timing considerations&lt;/h2&gt;
&lt;h3 id="metastability"&gt;Metastability&lt;/h3&gt;
&lt;p&gt;伴随着 flip-flop 的一个问题是 &lt;code&gt;亚稳态 Metastability&lt;/code&gt;。当两个输入端口 ( 比如 data 和 clk，或者 reset 和 clk) 同时变化时，就会发生亚稳态的问题，需要消耗更长的时间来使输出达到稳定状态，而且这个稳定状态是不可预测的，有可能是 1，也有可能是 0。&lt;/p&gt;
&lt;p&gt;在计算机系统中，如果发生亚稳态，如果在下一个时钟使用数据时，还没有达到稳定状态，会导致数据传输错误或者程序崩溃。如果有两条路径同时用到了这个数据，有可能一条将它当作 1，另一条把它当作 0，这样会导致系统进入不一致的状态。&lt;/p&gt;
&lt;h3 id="setup-hold-recovery-removal-times"&gt;Setup, hold, recovery, removal times&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Setup time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;before&lt;/strong&gt; the clock event so that the data are reliably sampled by the clock. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hold time&lt;/strong&gt; is the minimum amount of time the data signal should be held steady &lt;strong&gt;after&lt;/strong&gt; the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop.&lt;/p&gt;
&lt;p&gt;Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="meta" src="http://upload.wikimedia.org/wikipedia/en/thumb/d/d9/FF-Tsetup-Thold-Toutput.svg/500px-FF-Tsetup-Thold-Toutput.svg.png"&gt;&lt;/p&gt;
&lt;p&gt;如图所示，对于同步信号 ( 同步信号的意思是想对于时钟信号而言，它的变化和时钟是同步的，比如 data)，必须满足 &lt;code&gt;setup time&lt;/code&gt; 和 &lt;code&gt;hold time&lt;/code&gt; 要求。&lt;/p&gt;
&lt;p&gt;在有效时钟沿到来之前的 setup time 时间段内，同步信号必须保持稳定，在有效时钟沿到来之后的 hold time 时间段内，同步信号也必须保持稳定，也就是说从 setup time 到 hold time 之间，它必须保持稳定不变化，这样才能让时钟信号采样到正确的值。&lt;/p&gt;
&lt;p&gt;同理，对于异步信号，有类似的要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到一个更清晰的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Recovery time&lt;/strong&gt; is the minimum length of time an asynchronous control signal, for example, and preset, must be stable &lt;strong&gt;before&lt;/strong&gt; the next active clock edge. The recovery slack time calculation is similar to the clock setup slack time calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Removal time&lt;/strong&gt; is the minimum length of time an asynchronous control signal must be stable &lt;strong&gt;after&lt;/strong&gt; the active clock edge. The TimeQuest analyzer removal time slack calculation is similar to the clock hold slack calculation, but it applies asynchronous control signals.&lt;/p&gt;
&lt;p&gt;recovery time specifies the time the inactive edge of the asynchronous signal has to arrive before the closing edge of the clock.&lt;/p&gt;
&lt;p&gt;Removal time specifies the length of time the active phase of the asynchronous signal has to be held after the closing edge of the clock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 Recovery / Removal time 类似于 Setup / Hold Time，不过是用于异步信号，比如 set，reset 信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="recovery-removal" src="/images/latch-versus-flip-flop/recovery-removal.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如图所示，在时钟沿到来之前的 recovery time 之前，异步信号必须释放 ( 变无效 )，在时钟沿到来之后的 removal time 之后，异步信号才能变有效，也就是说在从 recovery time 到 removal time 这段时间内，异步信号是不能有效的。&lt;/p&gt;
&lt;p&gt;如果使 flip-flop 的输入满足 setup time 和 hold time，那么就可以避免亚稳态的出现，一般器件的手册上都会标明这些参数，从几 ns 到几百 ps 之间。根据 flip-flop 内的组织情况而定，有时候可以将 setup time 或者 hold time 两者中的一个（只能是其中之一）变为 0 甚至是负数。&lt;/p&gt;
&lt;p&gt;但是，并不是总能满足这一标准，因为有可能 flip-flop 的输入端连到了外界的，设计者无法控制的一个不断变化的信号，这时候设计者所能做的事就是根据电路要求，将发生错误的概率降低到一个确定的水平。通常使用的方法就是将信号通过一条链在一起的 flip-flop 组，这样子可以将发生亚稳态的概率降低到一个可以忽略的程度，但是还是不等于 0。链中的 flip-flop 越多，这个概率就越趋近于 0，通常的情况是采用 1 个或者两个 flip-flop。&lt;/p&gt;
&lt;p&gt;即使现在出现了所谓的 &lt;code&gt;metastable-hardened flip-flops&lt;/code&gt;，它可以尽可能地减小 setup time 和 hold time，但是仍然无法完全避免问题的出现。&lt;strong&gt;这是因为亚稳态并不是简单的设计方法上的问题。&lt;/strong&gt;当时钟信号和其他信号在相隔很近的时间内变化，flip-flop 必须判断哪一个先发生变化，哪一个后发生变化，无论我们的器件速度有多快，仍然有可能出现两者相隔的太近，以至于无法判断。所以理论上是不可能造出一个完美避免亚稳态的 flip-flop。&lt;/p&gt;
&lt;h3 id="propagation-delay"&gt;Propagation delay&lt;/h3&gt;
&lt;p&gt;flip-flop 还有一个参数叫做 clock-to-output delay (common symbol in data sheets: &lt;code&gt;tco&lt;/code&gt;) 或者是 propagation delay (&lt;code&gt;tp&lt;/code&gt;)，表示的是 flip-flop 从有效时钟沿开始到输出发生变化所消耗的时间。有时候从高电平变为低电平的时间 (high-to-low transition, tPHL)) 和从低电平变为高电平的时间 (low-to-high transition, tPLH) 不相等。&lt;/p&gt;
&lt;p&gt;当用同一时钟来驱动级联的 flip-flop ( 比如移位寄存器 shift register) 时，必须保证前一级的 tco 要大于后一级的 th。这是因为必须要保证前一级的数据能够正确移位到后一级中。当有效时钟沿到来时，前后两级的 ff 在同时变化，采样前一级的输出作为本级的输入，然后经过 tco 输出更新的值。当后一级 ff 在 tsu 到 th 段内采样时，必须保证前一级的输出保持不变，也就是说前一级 ff 的响应速度不能太快，至少要等后一级正确采样完成之后才能变化，即 &lt;code&gt;tco &amp;gt; th&lt;/code&gt;。如果采用物理构造完全相同的 ff，那么通常是可以保证这一条件的。&lt;/p&gt;
&lt;h2 id="in-fpga"&gt;in FPGA&lt;/h2&gt;
&lt;p&gt;latch 和 flip-flop 的特点决定了它们各自的应用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;latch 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面积比 ff 小&lt;/p&gt;
&lt;p&gt;门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管 -&amp;gt; 门电路 -&amp;gt; 锁存器 -&amp;gt; 触发器，前一级是后一级的基础。latch 完成同一个功能所需要的门较触发器要少，所以在 asic 中用的较多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度比 ff 快&lt;/p&gt;
&lt;p&gt;用在地址锁存是很合适的，不过一定要保证所有的 latch 信号源的质量，锁存器在 CPU 设计中很常见，正是由于它的应用使得 CPU 的速度比外部 IO 部件逻辑快许多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;latch 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;latch 将静态时序分析变得极为复杂&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;边沿触发，同步设计，不容易受毛刺的印象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析简单&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;flip-flop 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面积比 latch 大，消耗的门电路比 latch 多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前 latch 只在极高端的电路中使用，如 intel 的 P4 等 CPU。而在 PLD / FPGA 中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现 latch，反而需要更多的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般的设计规则是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 DFF 的地方，就不用 latch。&lt;/p&gt;
&lt;h3 id="reason-solution-to-unexpected-latch"&gt;Reason &amp;amp; Solution to unexpected latch&lt;/h3&gt;
&lt;p&gt;在电路设计中，要对 Latch 特别谨慎，如果综合出和设计意图不一致的 Latch，会导致设计错误，包括仿真和综合。因此，要避免产生意外的 Latch。&lt;/p&gt;
&lt;h4 id="reason"&gt;Reason&lt;/h4&gt;
&lt;p&gt;如果组合逻辑完全不使用 always 语句，那么就不会产生 latch，比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;电路不需要保存 dout 的前一个值，所以不会产生 latch。&lt;/p&gt;
&lt;p&gt;如果组合逻辑使用了 always 语句，那么就有可能产生 Latch ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-latch" src="/images/latch-versus-flip-flop/if-latch.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不完整的 case&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case-latch" src="/images/latch-versus-flip-flop/case-latch.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="solution"&gt;Solution&lt;/h4&gt;
&lt;p&gt;知道了原因，那么解决方法也就显而易见了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 if-else&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;RTL Schematic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/latch-versus-flip-flop/if-else.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用完整的 case，添加 default 分支&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;RTL Schemtatic:&lt;/p&gt;
&lt;p&gt;&lt;img alt="case-default" src="/images/latch-versus-flip-flop/case-default.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="application"&gt;Application&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;《Verilog HDL 程序设计与实践》&lt;/a&gt; 笔记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;latch 作为一种电路单元 , 必然有其存在的理由以及应用场景 , 并不像目前的很多书籍简单地将锁存器列为 “ 头等敌人 ”。其实在实际中 , 有些设计是不可避免地要用到锁存器 , 特别是在总线应用上 , 锁存器能提高驱动能力、隔离前后级。例如 , 常见的应用包括地址锁存器、数据锁存器以及复位信号锁存器等。但在更多的情况下 , 很容易在代码中产生未预料到的锁存器 , 使得逻辑功能不满足要求 , 浪费了大量的调试时间 , 从而使得大多数设计人员 “ 闻虎色变 ”。&lt;/p&gt;
&lt;p&gt;因此较好的应用规则是 :&lt;strong&gt;要学会分析是否需要锁存器以及代码是否会产生意想不到的锁存器。只有这样才能灵活运用锁存器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面通过实例来给予说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example1&lt;/strong&gt;: 通过 Verilog HDL 实现序列最大值搜索程序，并保持检测到的最大值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;latch&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;demo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码在 ISE 中的综合结果会给出设计中包含 Latch 的警告。但实际上，abmax-tmp 锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的 if 语句补全：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;abmax&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;tmp&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nv"&gt;abmax&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="c1"&gt;;  &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="nv"&gt;abmax&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;abmax&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;tmp&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;经过综合后，仍然有 Latch 的警告。无论 Latch 是否是用户需要的，ISE 都会给出警告，主要原因就是 Latch 对整个设计的时序性能影响较大。所以，在设计中要尽量避免 Latch，但是确实需要使用的情况，也可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example2:&lt;/strong&gt; 用 Verilog HDL 实现一个锁存器，当输入数据大于 127 时，将输入数据输出，否则输出 0&lt;/p&gt;
&lt;p&gt;不期望的 latch 指的是与设计意图不符，产生的 Latch。主要问题在于设计人员没有合理使用 Verilog HDL 语言，常见的原因是对条件语句（if、casse）的分支描述不完整，导致电路的功能不是预期的，发生了错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;latch&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;demo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;127&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;综合后的结果，在比较器后面级联了锁存器，这是因为 if 语句缺少 else 分支造成的。查看仿真结果，当输入小于 127 时，输出保持了上次的 127，不是 0，没有达到设计要求。修改方法很简单，就是将 if-else 补全。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;din&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;127&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="nv"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;din&lt;/span&gt;&lt;span class="c1"&gt;;  &lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="nv"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 ISE 中综合后的结果中，可以看到补全 if-else 后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;锁存器 latch 是一种基本电路单元 , 会影响到电路的时序性能 , 应该尽量避免使用 , 但出现锁存器造成设计和原始意图不符的情况 , 则是由于设计人员代码输入不正确造成的。&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Flip-flop-(electronics"&gt;Flip-flop (electronics) --wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/2883561/"&gt;数字设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3522845/"&gt;Verilog HDL 程序设计与实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/surgeddd/article/details/4683657"&gt;锁存器、触发器、寄存器和缓冲器的区别&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="latch"></category><category term="flip-flop"></category></entry><entry><title>VHDL 笔记 2 —— 系统设计</title><link href="https://qian-gu.github.io/posts/ic/vhdl-notes-2-system-design.html" rel="alternate"></link><published>2014-09-16T20:18:00+08:00</published><updated>2014-09-16T20:18:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-09-16:/posts/ic/vhdl-notes-2-system-design.html</id><summary type="html">&lt;p&gt;VHDL 笔记，系统设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;总结 &lt;code&gt;packege&lt;/code&gt;, &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的相关知识。&lt;/p&gt;
&lt;p&gt;这些组成部分添加到代码主体部分，目的是为了实现常用代码共享。通常这些代码被放在 &lt;code&gt;library&lt;/code&gt; 中，我们可以将自己设计的一些常用代码添加到 &lt;code&gt;library&lt;/code&gt; 中，这有利于使一个复杂设计具有更清晰的结构。&lt;/p&gt;
&lt;p&gt;总之，经常使用的代码可以以 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 的形式放到 &lt;code&gt;package&lt;/code&gt; 中，然后被编译到目标 &lt;code&gt;library&lt;/code&gt; 中。&lt;/p&gt;
&lt;h2 id="packages-and-components"&gt;Packages and Components&lt;/h2&gt;
&lt;h3 id="package"&gt;Package&lt;/h3&gt;
&lt;p&gt;除了 &lt;code&gt;component&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 之外，package 中还可以包含 &lt;code&gt;TYPE&lt;/code&gt;, &lt;code&gt;CONSTANT&lt;/code&gt; 的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;PACKAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;PACKAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;BODY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;FUNCTION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PROCEDURE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;descriptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;可以看到，语法包括两部分，&lt;code&gt;PACKAGE&lt;/code&gt; 和 &lt;code&gt;PACKAGE BODY&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE&lt;/code&gt; 是必需的，包括所有的声明语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PACKAGE BODY&lt;/code&gt;：可选，当第一部分包含一个 / 多个  FUNCTION，PROCEDURE 声明时，这部分必须包含相应的描述代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--------- package define-------------&lt;/span&gt;
&lt;span class="n"&gt;LIRRARY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;IDEE.STD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LOGIC&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1164&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;PACKAGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;st1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;st2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;st3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;st4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;STD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LOGIC&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;VECTOR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;DOWNTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;11111111&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;--------- main code ------------------&lt;/span&gt;

&lt;span class="k"&gt;LIBRARY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;IEEE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;IEEE.STD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LOGIC&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1164&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;work.my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;-- declaration&lt;/span&gt;

&lt;span class="k"&gt;ENTITY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;ARCHITECTURE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;--------------------------------------&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="componet"&gt;Componet&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;component&lt;/code&gt; 和 Verilog HDL 中的 &lt;code&gt;module&lt;/code&gt; 类似：&lt;/p&gt;
&lt;p&gt;一个 component 是一段完整的代码（包括 library, entity, architecture 这些组成部分），如果将这些代码声明为一个 component，那么就可以被其他电路调用，从而使代码具有了层次化的结构。&lt;/p&gt;
&lt;p&gt;使用 component 必须先声明这个元件，然后再例化这个元件（类似 C++，变量先声明，在定义）。声明和例化都必须在 architecture 中进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;declaration syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;COMPONENT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;component&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;COMPONENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;instantiation syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;component&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;MAP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明时，component 和 entity 相似，必须声明端口的模式和类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例化时，必须添加一个标号，就像 Verilog HDL 中例化 module 必须给个名字一样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;声明元件时，可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上面的方法，先声明再例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 package 进行声明，将 component 的声明放在 package 中，则可以避免每次元件例化都要重复声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方法的区别类似于使用 C++ 中的 namespace 时的不同方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法一：每次使用 STL 都添加作用域&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法二：声明一次作用域&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="port-map"&gt;port map&lt;/h3&gt;
&lt;p&gt;同 Verilog HDL 一样，两种端口映射的方法：位置映射、名字映射。&lt;/p&gt;
&lt;p&gt;位置映射书写简单，但是容易出错；名字映射书写繁琐，但是不易出错，端口连接也更清晰，未连接的端口要使用关键词 &lt;code&gt;open&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-- positional&lt;/span&gt;
&lt;span class="n"&gt;U1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inverter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;MAP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;-- nominal&lt;/span&gt;
&lt;span class="n"&gt;U1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inverter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;MAP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="generic-map"&gt;generic map&lt;/h3&gt;
&lt;p&gt;generic 功能类似于 Veriog HDL 中的 parameter，所以在例化时 component 时，可以重载参数，使设计更方便灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;component&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;GENERIC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;MAP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;MAP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;也就是说，在例化时，添加一段 &lt;code&gt;GENERIC MAP (param.list)&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;h2 id="functions-and-procedure"&gt;Functions and Procedure&lt;/h2&gt;
&lt;p&gt;function 和 procedure 统称为 子程序，它们和 process 相似，内部包含的都是顺序描述的代码，通常使用相同的顺序描述语句。但是，function 和 procedure 的存在主要是为了建库，以达到代码重用和共享的目的，当然它们也可以直接建立在主代码中。&lt;/p&gt;
&lt;h3 id="function"&gt;Function&lt;/h3&gt;
&lt;p&gt;一个 function 就是一段顺序描述的代码。&lt;/p&gt;
&lt;p&gt;在写代码的过程中，我们通常会遇到一些有共性的问题，我们希望实现这些功能的代码可以被共享和重用，从而使代码变得简洁，易于理解，function 的建立和使用就能达到这个目睹。
function 中可以使用 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 等语句，但是不能有 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;component&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;function 的使用方法：先创建函数体本身，再调用函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Body&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;FUNCTION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;RETURN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;parameter list&gt; 指函数的输入参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CONSTANT&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;constant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数可以是 constant, signal，但是不能是 variable；参数的个数可以是任意个，类型也任意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以单独构成表达式，也可以作为表达式的一部分。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--example&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;conv&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;integer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;maximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Function Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数可以存放在两个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Package 中，这时候，函数声明在 package 中，函数定义在 package body 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Main Code 中，既可以在 entity 中，也可以在 architecture 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="procedure"&gt;Procedure&lt;/h3&gt;
&lt;p&gt;procedure 和 function 类似，目的也相同，不同之处在于 procedure 可以有多个返回值。&lt;/p&gt;
&lt;p&gt;与 function 类似，procedure 也需要定义和调用两个过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Body&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;PROCEDURE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;procedure&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarations&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;procedure&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;parameter list&gt; 指出了 procedure 的输入输出参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;constant&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SIGNAL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;参数可以有任意多个，可以是 in, out, inout 模式的 signal, variable, constant。&lt;/p&gt;
&lt;p&gt;和 function 一样，procedure 内部的 wait 语句，signal 声明，component 调用都是不可综合的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Procedure Call&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的调用就是它自己。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--example&lt;/span&gt;
&lt;span class="n"&gt;compute&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;in2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;in3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;out1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;out2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;divide&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dividend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;divisor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;quotient&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;remainder&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Procedure Location&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;procedure 的存放和 function 类似，通常放在 package 中，当然也可以放在主代码中。&lt;/p&gt;
&lt;h3 id="function-versus-procedure-summary"&gt;FUNCTION versus PROCEDURE Summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;function 有任意个输入参数和一个返回值，输入参数只能是 constant, signal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;procedure 有任意个输入 / 输出 / 双向参数，可以是 signal, variable, constant&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 可以作为表达式的一部分，procedure 直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 内部，wait 和 component 都不可综合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;function 和 procedure 的存放位置相同，经常位于 package 中，也可以在主代码中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>VHDL 笔记 1 —— 电路设计</title><link href="https://qian-gu.github.io/posts/ic/vhdl-notes-1-circuit-design.html" rel="alternate"></link><published>2014-09-16T14:56:00+08:00</published><updated>2014-09-16T14:56:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-09-16:/posts/ic/vhdl-notes-1-circuit-design.html</id><summary type="html">&lt;p&gt;VHDL 笔记, 电路设计&lt;/p&gt;</summary><content type="html">&lt;h2 id="code-structure"&gt;Code Structure&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一段独立的 VHDL 代码一般至少由 3 部分组成：&lt;code&gt;LIBRARY declarations&lt;/code&gt;、&lt;code&gt;ENTITY&lt;/code&gt;、&lt;code&gt;ARCHITECTURE&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Library 用来设计重用和代码共享，使代码结构更清晰&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;LIBRARY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;library&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;USE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;library&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;parts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常用的 3 个 Library：&lt;code&gt;ieee&lt;/code&gt;、&lt;code&gt;std&lt;/code&gt;、&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中 std 和 work 是默认可见的，不需声明，ieee 需要明确的声明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Entity 描述电路的输入 / 输出引脚&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ENTITY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;entity&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="nc"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;singal-mode 可以是 4 种类型： &lt;code&gt;in&lt;/code&gt; &lt;code&gt;out&lt;/code&gt; &lt;code&gt;inout&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;OUT&lt;/code&gt; 模式无法回读到电路内部，&lt;code&gt;Buffer&lt;/code&gt; 模式可以，但是 buffer 不能连接到其他类型的端口，即不能把该模块作为子模块例化，一般使用中间缓冲信号，解决回读问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Architecture 描述电路的行为和实现的功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Architecture 包含两部分：声明部分和代码部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;声明部分（可选）用来声明信号、常量等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码部分（begin ... end）描述电路行为&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释行用 &lt;code&gt;--&lt;/code&gt; 开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VHDL 不区分大小写&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="data-types"&gt;Data Types&lt;/h2&gt;
&lt;p&gt;前面的 Entity 中的端口定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;port&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;还有其它地方声明的信号 &lt;code&gt;signal&lt;/code&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;还有 常量 &lt;code&gt;constant&lt;/code&gt; 声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;constant&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;还有 变量 &lt;code&gt;variable&lt;/code&gt; 声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;variable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这些声明中都包含了数据类型字段。一个信号 / 常量 / 变量的数据类型决定了它能取到什么样的值，还有可以进行什么样的操作。&lt;/p&gt;
&lt;h3 id="pre-defined-data-types"&gt;Pre-defined Data Types&lt;/h3&gt;
&lt;p&gt;IEEE 1164 标准中包含了一些预先定义的数据类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std&lt;/code&gt; 库中的 &lt;code&gt;standard&lt;/code&gt; 包集 (package) 定义了：&lt;code&gt;bit&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;、&lt;code&gt;real&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std-logic-1164&lt;/code&gt; 包集定义了：&lt;code&gt;std-logic&lt;/code&gt;、&lt;code&gt;std-ulogic&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std-logic-arith&lt;/code&gt; 包集定义了：&lt;code&gt;signed&lt;/code&gt;、&lt;code&gt;unsigned&lt;/code&gt; 类型，还有一些数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std-logic-signed&lt;/code&gt; 和 &lt;code&gt;std-logic-unsigned&lt;/code&gt; 包集：包含一些函数，可以使 &lt;code&gt;std-logic-vector&lt;/code&gt; 类型的数据可以像 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 一样进行运算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="bit-bit-vector"&gt;&lt;code&gt;bit&lt;/code&gt; &amp;amp; &lt;code&gt;bit-vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用 '0' 和 '1' 赋值&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bit&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;downto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0011&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="std-logic-std-logic-vector"&gt;&lt;code&gt;std-logic&lt;/code&gt; &amp;amp; &lt;code&gt;std-logic-vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中引入的 8 逻辑值系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同于 bit 类型，可以取 8 种不同的值，但只有 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;Z&lt;/code&gt; 是可综合的，其他 5 种用来仿真&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="std-ulogic-std-ulogic-vector"&gt;&lt;code&gt;std-ulogic&lt;/code&gt; &amp;amp; &lt;code&gt;std-ulogic-vector&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee 1164&lt;/code&gt; 标准中定义的具有 9 种逻辑值的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std-logic&lt;/code&gt; 是 &lt;code&gt;std-ulogic&lt;/code&gt; 的子集&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="boolean"&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只有两种取值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="integer"&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;32 位的整数 (-2 147 483 647 ~ +2 147 483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="natural"&gt;&lt;code&gt;natural&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;非负整数 (0 ~ +2 147483 647)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="real"&gt;&lt;code&gt;real&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;实数，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="physical-literal"&gt;&lt;code&gt;physical literal&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;表示物理量，不可综合&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="character"&gt;&lt;code&gt;character&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单一 / 一串 ASCII 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="signed-unsigned"&gt;&lt;code&gt;signed&lt;/code&gt; &amp;amp; &lt;code&gt;unsigned&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std-logic-arith&lt;/code&gt; 包中定义的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 &lt;code&gt;std-logic-vector&lt;/code&gt; 类似，但是可以支持与整数类似的算术运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="user-defined-data-types"&gt;User-defined Data Types&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;-- integer&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;student&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;grade&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;RANGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;-- enumerated&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;idle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;backward&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;green&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;white&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="subtypes"&gt;Subtypes&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;SUBTYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;RANGE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;blue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- my-color = (red, green, blue);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="arrays"&gt;Arrays&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以认为 VHDL 预定义的数据类型只有 &lt;code&gt;scalar&lt;/code&gt;(single bit) 和 &lt;code&gt;vector&lt;/code&gt;(one-dimensional array of bits) 两种类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这两种类型中只有一下类型是可综合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scalars: bit, std-logic, std-ulogic, boolean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vectors: bit-vector, std-logic-vector, std-ulogic-vector, integer, signed, unsigned&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ARRAY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;specification&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;OF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;--1D array&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ARRAY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;OF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;STD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LOGIC&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;VECTOR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;DOWNTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;--2D array&lt;/span&gt;
&lt;span class="k"&gt;TYPE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;matrix2D&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ARRAY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;DOWNTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;OF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;STD&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;LOGIC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="port-array"&gt;Port Array&lt;/h3&gt;
&lt;p&gt;有时在定义端口时，需要把端口定义为矢量阵列。但是在 &lt;code&gt;Entity&lt;/code&gt; 中不允许使用 &lt;code&gt;type&lt;/code&gt; 定义，所以我们必须自己定义包集 (package)，然后使用 &lt;code&gt;use&lt;/code&gt; 声明使用该用户自定义的包集，最后才能在 Entity 中使用这种新定义的类型。&lt;/p&gt;
&lt;h3 id="signed-and-unsigned-data-types"&gt;Signed and Unsigned Data Types&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ieee&lt;/code&gt; 库中的 &lt;code&gt;std-logic-arith&lt;/code&gt; 包中定义了有符号数 (&lt;code&gt;signed&lt;/code&gt;) 和无符号数 (&lt;code&gt;unsigned&lt;/code&gt;) 两种数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有先声明使用这个库下的包，才能在代码中使用 signed/unsigned&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;ieee.std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;arith&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;downto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用它们主要是为了进行算术运算，但是它们不支持逻辑运算。( std-logic-vector 不支持算术运算，但是支持逻辑运算 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果信号的类型只能是 std-logic-vector，那么通过其他方法也是可以进行算术运算的，解决方案就是声明使用 &lt;code&gt;ieee&lt;/code&gt; 的 &lt;code&gt;std-logic-unsigned&lt;/code&gt; 和 &lt;code&gt;std-logic-signed&lt;/code&gt; 两个包集，声明之后，std-logic-vector 就可以像 signed/unsigned 一样进行算术运算了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;ieee.std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="k"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;-- use ieee.std-logic-unsigned.all;&lt;/span&gt;

&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;downto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;downto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;out&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;std&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;logic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;downto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;--legal, arithmetic&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;--legal, logiccal&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;需要注意的是，这两个包不能同时存在于同一份代码中，因为这样会引入二义性。比如上面例子中的 “+” 运算，如果我们同时包含了这两个包集，那么编译器不知道我们定义的运算到底应该重载哪一个，综合时会报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="data-conversion"&gt;Data Conversion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 VHDL 中，不同类型的数据是不能直接进行算术 / 逻辑运算的，所以必要时必须进行类型转换操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有两种方法实现类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用包中预定义的数据类型转换函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手动写一段专门用于数据类型转换的代码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std-logic-arith&lt;/code&gt; 中包含了很多数据类型转换函数，可以实现不同数据之间的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="operators-and-attributes"&gt;Operators and Attributes&lt;/h2&gt;
&lt;p&gt;VHDL 语法虽然枯燥无味，但是只有对数据类型、运算操作符及其属性有了深刻认识，才能写出高质量和高效率的代码。&lt;/p&gt;
&lt;h3 id="opreators"&gt;Opreators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;VHDL 提供了 6 种预定义的预算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;赋值 assignment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑 logical&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;算术 arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关系 relational&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移位 shift&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并置 concatenation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="assignment"&gt;&lt;code&gt;assignment&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 用于给 &lt;code&gt;signal&lt;/code&gt; 对象赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;:=&lt;/code&gt; 用于给 &lt;code&gt;variable&lt;/code&gt;, &lt;code&gt;constant&lt;/code&gt;, &lt;code&gt;generic&lt;/code&gt; 赋值，还可用于赋初值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt; 用于给矢量 (vector) 对象的某些位赋值，常和 &lt;code&gt;others&lt;/code&gt; 一起使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="logical"&gt;&lt;code&gt;logical&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;进行逻辑运算，操作数必须是 &lt;code&gt;bit&lt;/code&gt;, &lt;code&gt;std-logic&lt;/code&gt;, &lt;code&gt;std-ulogic&lt;/code&gt; 类型或者它们的扩展，即&lt;code&gt;bit-vector&lt;/code&gt;, &lt;code&gt;std-logic-vector&lt;/code&gt;, &lt;code&gt;std-ulogic&lt;/code&gt; 类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOT&lt;/code&gt;, &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, &lt;code&gt;NAND&lt;/code&gt;, &lt;code&gt;NOR&lt;/code&gt;, &lt;code&gt;XOR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="arithmetic"&gt;&lt;code&gt;arithmetic&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数是 &lt;code&gt;signed&lt;/code&gt;, &lt;code&gt;unsigned&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;real&lt;/code&gt;，其中 &lt;code&gt;real&lt;/code&gt; 类型是不可综合的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果声明了 &lt;code&gt;std-logic-signed&lt;/code&gt; 或者 &lt;code&gt;std-logic-unsigned&lt;/code&gt;，则 &lt;code&gt;std-logic-vector&lt;/code&gt; 类型也可以进行加减运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;MOD&lt;/code&gt;, &lt;code&gt;REM&lt;/code&gt;, &lt;code&gt;ABS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="comparison"&gt;&lt;code&gt;comparison&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;一共有 6 种：&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="shift"&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;VHDL93 中引入的操作，语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;shift&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;operand&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;left operand 必须是 &lt;code&gt;bit-vector&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right operand 必须是 &lt;code&gt;integer&lt;/code&gt; 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shift operator 有：&lt;code&gt;sll&lt;/code&gt;, &lt;code&gt;srl&lt;/code&gt;, &lt;code&gt;sla&lt;/code&gt;, &lt;code&gt;sra&lt;/code&gt;, &lt;code&gt;rol&lt;/code&gt;, &lt;code&gt;ror&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="concatenation"&gt;&lt;code&gt;concatenation&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;用于位的拼接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作数：任何支持逻辑运算的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符：&lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;(, , ,)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="attributes"&gt;Attributes&lt;/h3&gt;
&lt;p&gt;VHDL 中的属性语句可以获得相关数据 / 对象 的信息，使代码更加灵活。&lt;/p&gt;
&lt;h4 id="pre-defined"&gt;Pre-defined&lt;/h4&gt;
&lt;p&gt;内置的预定义属性可以分为两大类：数值类属性 和 信号类属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;data attributes&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;signal attributes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数信号类属性都是不可综合的，只有 &lt;code&gt;s'event&lt;/code&gt; 和 &lt;code&gt;s'stable&lt;/code&gt; 是可综合的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="user-defined"&gt;User-defined&lt;/h4&gt;
&lt;p&gt;也可以用户自己定义一个新的属性，并描述某个对象的这个属性的值是多少，之后就可以使用这个属性了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;attribute&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;attribute&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- declaration&lt;/span&gt;
&lt;span class="n"&gt;ATTIRBUTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;attribute&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;OF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;-- specification&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;example：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;INTEGER&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ATTRIBUTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;OF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SIGNAL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;nand3&lt;/span&gt;&lt;span class="na"&gt;&amp;#39;number&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;首先定义了一个新的属性，名字叫 &lt;code&gt;number-of-inputs&lt;/code&gt;，表示输入端口的个数，然后针对对象 nand3 (3 输入的与非门 ) 这个对象，描述它的这个属性的类型为 signal 类型，取值为 3；最后，使用这个属性，将 nand3 的这个属性的值赋值给 input 对象。&lt;/p&gt;
&lt;h3 id="operator-overloading"&gt;Operator Overloading&lt;/h3&gt;
&lt;p&gt;用户不仅可以自定义属性，还可以自定义操作符。预定义的操作符的操作数必须是特定的类型，对于某些类型，我们可以自定义操作符对应的操作。&lt;/p&gt;
&lt;p&gt;VHDL 中的自定义操作符作用和 C++ 中的操作符重载 方法、目的都很类似。首先构造一个函数，然后调用这个函数即可。&lt;/p&gt;
&lt;h3 id="generic"&gt;GENERIC&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;generic&lt;/code&gt; 必须在 ENTITY 中声明，它可以指定常规参数，所指定的参数是&lt;strong&gt;静态的&lt;/strong&gt;，&lt;strong&gt;全局的&lt;/strong&gt;。感觉类似于 Verilog 中的 &lt;code&gt;define&lt;/code&gt; 吧，但是显然 Verilog 中的 &lt;code&gt;parameter&lt;/code&gt; 是更好的设计，因为全局变量 / 常量很不安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;GENERIC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;ENTITY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;GENERIC&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;INTEGER&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;PORT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(...);&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my&lt;/span&gt;&lt;span class="err"&gt;-&lt;/span&gt;&lt;span class="k"&gt;entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="concurrent-code"&gt;Concurrent Code&lt;/h2&gt;
&lt;p&gt;从本质上讲，HDL 是 描述 (Description) 语言，对应的是硬件电路，而硬件电路是时刻工作的，所以，它的代码是并发执行的。只有 &lt;code&gt;process&lt;/code&gt;，&lt;code&gt;function&lt;/code&gt;，&lt;code&gt;procedure&lt;/code&gt; 中的代码是顺序执行的，而且当这些模块作为一个共同的整体时，它们之间也是并行的。&lt;/p&gt;
&lt;p&gt;在并发代码中可以使用下列各项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;when&lt;/code&gt; 语句（when/else 和 with/select/when）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;generate&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 语句&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔细观察可以发现，其实 when, generate, block 语句和运算语句相比，只是添加了一些条件判断，它们主要的核心还是运算操作符组成的运算，所以，并行代码的核心就是这些并行的运算语句。&lt;/p&gt;
&lt;h3 id="when"&gt;&lt;code&gt;when&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;When/else syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ELSE&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ELSE&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;with/select/when syntax:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WITH&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="generate"&gt;&lt;code&gt;generate&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;功能类似于 Verilog HDL 中的 generate，它常和 for/if 一起使用。
因为描述的对象是电路，最终的电路是固定的，功能也是静态的，所以，对于 generate，它的循环操作的上下界必须是静态的，否则代码是不可综合的。&lt;/p&gt;
&lt;p&gt;实际上，引入 generate 的主要目的是为了写出更加通用的代码，达到修改最少代码，实现不同设计的目的，也就是动态编译。而引入 for 循环，只是为了减少代码量。&lt;/p&gt;
&lt;h3 id="block"&gt;&lt;code&gt;block&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中存在两种类型的块 block：简单块 (simple block) 和 卫式块 (guarded block):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;simple block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simple block 只是对原有代码进行了区域分割，目的也仅仅是为了增强代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;BLOCK&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;BLOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;guarded block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;guarder block 是一种特殊的 block，它比 simple block 多了一个表达式，叫做 &lt;code&gt;guard expression&lt;/code&gt;，只有当这个表达式为 True 时，这个 block 才会执行。&lt;/p&gt;
&lt;p&gt;syntax:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;BLOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;declarative&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;part&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;concurrent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;guarded&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unguarded&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;BLOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="sequential-code"&gt;Sequential Code&lt;/h2&gt;
&lt;p&gt;VHDL 本质是并发执行的代码，但是在 &lt;code&gt;process&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;procedure&lt;/code&gt; 内部的代码是顺序执行的，当它们作为一个整体时，相互之间也是并发执行的。&lt;/p&gt;
&lt;p&gt;顺序代码并非只能与时序逻辑 (&lt;code&gt;sequential logic&lt;/code&gt;) 对应，同样也可以用它们来实现组合逻辑 (&lt;code&gt;combinational logic&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;顺序代码也称为描述代码 (&lt;code&gt;behavioral code&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这里主要讨论顺序代码，也就是这 3 个块中的代码，包括 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;wait&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; 语句。&lt;/p&gt;
&lt;h3 id="process"&gt;&lt;code&gt;process&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;作用类似于 Verilog HDL 中的 always 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;lable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PROCESS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sensitivity&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;]]&lt;/span&gt;
&lt;span class="k"&gt;BEGIN&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PROCESS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="if"&gt;&lt;code&gt;if&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;IF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;conditions&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;THEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;ELSIF&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;conditions&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;THEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;ELSE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assignments&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="wait"&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果在 process 中使用了 wait 语句，那么 process 就不能含有敏感信号列表了，所以此时 wait 必须是 process 的第一条语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax1&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UNTILL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;syntax2&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signal1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;signal2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;syntax3&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;WAIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FOR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;--simulation only&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="case"&gt;&lt;code&gt;case&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;case 和 when 的区别在于，case 允许在每个测试条件下执行多个赋值操作，而 when 只能执行一个赋值操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;CASE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IS&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;assignment&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;CASE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="loop"&gt;&lt;code&gt;loop&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;syntax1: FOR/LOOP repeat a fix number of times&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FOR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOOP&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOOP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;syntax: WHILE/LOOP&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHILE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOOP&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequential&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;END&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOOP&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;syntax3: EXIT&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;EXIT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;syntax4: NEXT&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;NEXT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;loop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;label&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;WHEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="signals-variables"&gt;Signals &amp;amp; Variables&lt;/h2&gt;
&lt;p&gt;VHDL 提供了 &lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;variable&lt;/code&gt; 两种对象来处理非静态数据；提供了 &lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;generic&lt;/code&gt; 来处理静态数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constant&lt;/code&gt; 和 &lt;code&gt;signal&lt;/code&gt; 是全局的，可以在顺序执行的代码中，也可以在并发执行的代码中；&lt;code&gt;variable&lt;/code&gt; 是局部的，只能值顺序代码中，并且它们的值是不能向外传递的 ( 如果想传递出去，必须先把这个变量值传递给一个信号，再由这个信号传递出去 )。&lt;/p&gt;
&lt;h3 id="constant"&gt;&lt;code&gt;constant&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;constant 可以定义在 package, entity, architecture 中，对应的作用域也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义在 package 中的 constant 是真正的全局的，可以被所有调用该 package 的 entity 使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 entity 中的 constant 对于该 entity 的所有 architecture 而言是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义在 architecture 中的 constant 仅在该 architecture 中是全局的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;CONSTANT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="signal"&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;VHDL 中的 &lt;code&gt;signal&lt;/code&gt; 代表的是逻辑电路中的 “ 硬 ” 连线，既可以用于电路的输入输出端口，也可以用于 内部单元之间的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;SIGNAL&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和 Verilog HDL 的 always 中的 reg 类似，VHDL 的 process 中的 signal 也是在进程结束时更新值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对同一个信号多次重复赋值，结果取决于编译器。(Xilinx XST 不报错，认为最后一次赋值是有效的 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="variable"&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;相比于 signal 是局部的，variable 只能在 process，function，procedure 中使用，而且对它的赋值是立即更新的，新的值可以在下一行代码中立即使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;VARIABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;range&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;initial&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Circuit-Design-VHDL-Volnei-Pedroni/dp/0262162245"&gt;Circuit Design with VHDL&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="VHDL"></category><category term="syntax"></category></entry><entry><title>FPGA 时钟设计 2 —— 时钟设计</title><link href="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-2-clock-design.html" rel="alternate"></link><published>2014-09-12T12:45:00+08:00</published><updated>2014-09-12T12:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-09-12:/posts/ic/the-clock-design-in-fpga-2-clock-design.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的时钟设计方案&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;无论是离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字设计，为了成功地操作，可靠的时钟是非常关键的。&lt;/p&gt;
&lt;p&gt;设计不良的时钟在极限的温度、电压或者制造工艺的偏差情况下将导致错误的行为，并且调试困难、花销很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下 FPGA 中的时钟设计原则。&lt;/p&gt;
&lt;h2 id="clock-design"&gt;Clock Design&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 FPGA/CPLD 中通常采用几种时钟类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级逻辑时钟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;波动式时钟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多时钟系统能够包括上述 4 种时钟类型的任意组合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是 &lt;a href="http://book.douban.com/subject/10593491/"&gt;《Xiliinx FPGA 高级设计及应用》&lt;/a&gt; 中的分类方法，个人觉得并不是很清晰，我总结了一下，大概可以分为下面的这 4 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;全局时钟 Global Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;门控时钟 Gated Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑时钟 Logic Clock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分频 / 倍频时钟 Divied/Multiplied Clock&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="gloabl-clock"&gt;Gloabl Clock&lt;/h3&gt;
&lt;p&gt;关于全局时钟，前面一篇 blog  &lt;a href=""&gt;FPGA 时钟设计 1 —— 时钟资源总结&lt;/a&gt; 中有总结。&lt;/p&gt;
&lt;p&gt;对于一个项目来说，全局时钟是 &lt;strong&gt;最简单&lt;/strong&gt;、&lt;strong&gt;最可预测&lt;/strong&gt; 的时钟。&lt;/p&gt;
&lt;p&gt;在 PLD/FPGA 项目中 &lt;strong&gt;最好的时钟方案&lt;/strong&gt; 是：由专用的全局时钟输入引脚驱动的单个主时钟去钟控设计项目中的每一个触发器。只要可能就应该尽量在设计中采用全局时钟&lt;/p&gt;
&lt;p&gt;PLD/FPGA 都具有专门的全局时钟引脚，它直接连接到器件中的每一个寄存器，这种全局时钟提供最短的时钟到输出的延时。&lt;/p&gt;
&lt;h3 id="gated-clock"&gt;Gated Clock&lt;/h3&gt;
&lt;p&gt;门控时钟的意思是通过组合逻辑，控制、禁止或允许时钟输入到寄存器和其他同步原件上的一种方法。因为它能够有效地降低功耗，所以被广泛地应用于 ASIC 设计中。但是，它不符合 &lt;code&gt;同步设计&lt;/code&gt; 的思想，可能会影响系统设计的实现和验证，所以，&lt;strong&gt;在 FPGA 设计中应该避免使用门控时钟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 ASIC 和 FPGA 结构设计上的区别，两者对待门控时钟的态度是完全不同的：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://electronics.stackexchange.com/questions/73398/gated-clocks-and-clock-enables-in-fpga-and-asics"&gt;Gated clocks and clock enables in FPGA and ASICS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;往往可以将门控时钟转化为全局时钟以改善项目设计的可靠性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;就是使用寄存器 &lt;code&gt;时钟使能 (clock enable, CE)&lt;/code&gt; 端口。&lt;/p&gt;
&lt;p&gt;单纯从功能来看，使用使能时钟代替门控时钟是一个不错的选项，但是使能时钟在使能信号关闭时，时钟信号仍然工作，它无法像门控时钟那样降低系统的功耗。&lt;/p&gt;
&lt;p&gt;推译带使能端的触发器的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;din&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dout&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;得到的结果就是原语 &lt;code&gt;FDCE&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/p&gt;
&lt;p&gt;//       Clock Enable (posedge clk).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;多路选择器（mux）&lt;/code&gt; 将组合逻辑从时钟通路搬移到数据通路。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="mux" src="/images/the-clock-design-in-fpga-2-clock-design/mux.png"&gt;&lt;/p&gt;
&lt;p&gt;如果在设计中无法避免门控时钟，那么只要保证满足下面两个条件就可以使门控时钟和全局时钟一样可靠地工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;驱动时钟的逻辑必须只包含一个与门（或门），而且这个与门（或门）必须只有两个输入端。如果采用任何附加逻辑，则会出现竞争产生的毛刺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逻辑门的一个输入端为实际时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些条件的目的就是为了避免组合逻辑中的竞争带来的毛刺。&lt;/p&gt;
&lt;p&gt;根据数字电路的知识，我们知道可以通过添加 “ 冗余逻辑 ” 的方法来消除组合逻辑的冒险，但是，FPGA 的编译器在 综合时会去掉这些冗余逻辑，所以不能采用这种方法。&lt;/p&gt;
&lt;h3 id="logic-clock"&gt;Logic Clock&lt;/h3&gt;
&lt;p&gt;有时候会用到组合逻辑的输出作为时钟信号或者复位信号，但是这种时钟信号有两个非常重要的缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的信号不可避免地会出现毛刺，会导致系统运行失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合逻辑产生的时钟信号使用的是通用布线资源，和专用时钟布线相比，延迟长、时钟偏移大，满足时序要求会更加困难。如果大量的逻辑使用了这种时钟，这个问题会更加突出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（看到书上提出一个解决方案是：使用系统专用的时钟信号，将组合逻辑的输出打一拍，避免组合逻辑的直接输出，达到同步的效果。但是我个人认为这个方案不是非常好。）&lt;/p&gt;
&lt;p&gt;综上，对于 FPGA 来说，还是应该&lt;strong&gt;尽量避免使用组合逻辑的输出作为时钟&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="dividemultiplied-clock"&gt;Divide/Multiplied Clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Guideline：&lt;/strong&gt; 尽量避免分频时钟&lt;/p&gt;
&lt;p&gt;在我们的设计中，一般都不止一个时钟频率。如果不加注意，随意使用分频时钟，这叫做时钟满天飞，是非常不好的设计风格。&lt;/p&gt;
&lt;p&gt;如果一定要使用分频时钟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于资源比较丰富的 FPGA&lt;/p&gt;
&lt;p&gt;使用内部提供的 PLL/DLL，输出时钟信号可以配置成不同的频率（倍频 / 分频）和相位，这样的分频时钟是最稳定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法使用 PLL/DLL 的 FPGA&lt;/p&gt;
&lt;p&gt;对于这些情况，首先检查是否可以用 &lt;code&gt;CE&lt;/code&gt; (clock enable) 来代替分频时钟，如果不行，则使用 &lt;a href="http://guqian110.github.io/pages/2014/10/13/clock-dividers.html"&gt;时钟分频器&lt;/a&gt; 中讨论的分频方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="other-tips"&gt;Other Tips&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只使用时钟的单个边沿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了一些特殊的电路（如 DDR）外，设计应该只使用单个边沿（上 / 下边沿）。使用两个边沿的问题是时钟占空比不一定是 50%，这会对电路的正常工作产生影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用差分时钟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常认为频率高于 100 MHz 就属于 &lt;code&gt;高频&lt;/code&gt;。建议在高频下使用差分时钟，因为差分时钟的抗噪声性能更好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;检测时钟缺失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 DCM/MMCM 的 &lt;code&gt;locked&lt;/code&gt; 输出，在使用时钟前先检查时钟是否锁定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发实用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category></entry><entry><title>数字信号处理和相关matlab函数总结</title><link href="https://qian-gu.github.io/posts/telecom/digital-signal-processing-and-matlab.html" rel="alternate"></link><published>2014-09-03T23:16:00+08:00</published><updated>2014-09-03T23:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-09-03:/posts/telecom/digital-signal-processing-and-matlab.html</id><summary type="html">&lt;p&gt;总结信号处理和matlab相关应用&lt;/p&gt;</summary><content type="html">&lt;p&gt;学了这么多年的通信，却还是对信号处理的知识一知半解，应付考试还可以，但在实际应用中还是感到力不从心，很多知识都忘了。翻了一下午的 《信号与系统》、《数字信号处理》，简单总结一下。&lt;/p&gt;
&lt;p&gt;《信号与系统》算是通信专业最基础的专业课了。&lt;/p&gt;
&lt;p&gt;信号部分主要介绍信号的相关定义、分类、常用信号和三大变换：傅立叶变换、拉普拉斯变换和 z 变换。&lt;/p&gt;
&lt;p&gt;系统部分主要从时域和频域使用不同的方法分析线性时不变系统（LTI）的性质。&lt;/p&gt;
&lt;p&gt;《数字信号处理》算是前一门课的深入，现在利用计算机处理信号，首先就是要将模拟信号数字化，然后进行处理。这门课也就是讲相关的知识。&lt;/p&gt;
&lt;p&gt;一般教材就讲两大部分：第一部分首先承接《信号与系统》，时域的连续信号要在计算机中处理就必须采样，变为时域离散信号，这部分就讲离散时间信号的处理，比如 z 变换 和离散傅立叶变换。第二部分讲数字滤波器的设计，包括 FIR 和 IIR 两种。&lt;/p&gt;
&lt;h2 id="signal-processing"&gt;Signal Processing&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;这部分是我串联的这两本书中很小的一部分知识，算是一个备忘的笔记吧，作为一名学渣，一个月不看也会忘记不少 =.=&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从 《信号与系统》 中我们可以知道：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号 （连续）傅立叶级数 （CFS）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，由高数知识可以知道：只要满足 Dirichlet 条件，周期信号就可以进行傅立叶级数分解，可以得到幅度频谱和相位频谱。&lt;/p&gt;
&lt;p&gt;时域信号是周期的、连续的，频域信号是离散的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非周期信号 （连续）傅立叶变换 （CFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周期信号的周期无限增大，就可以将周期信号转化为非周期信号，从而得到非周期信号的傅立叶变换。&lt;/p&gt;
&lt;p&gt;得到的频率域的结果为连续信号，计算结果为时域信号的频谱密度函数，简称频谱函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周期信号 （连续）傅立叶变换 （CFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于周期信号，因为它不满足绝对可积的条件，所以从非周期信号无法直接推广。但是借助 &lt;em&gt;奇异函数&lt;/em&gt;（如冲激函数）的概念，可以使许多不满足绝对可积的信号（如周期信号）存在傅立叶变换。&lt;/p&gt;
&lt;p&gt;周期信号的傅立叶变换结果由一些冲激函数组成，冲激函数的强度是对应的傅立叶级数的 2pi 倍，频谱是离散的。&lt;/p&gt;
&lt;p&gt;这样，周期信号和非周期信号的傅立叶分析得到了统一。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接下来，就要进入《数字信号处理》部分了：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散时间信号傅立叶变换 （DTFT)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时域连续信号经过采样，得到离散时间信号，对于离散时间信号，可以从 z 变换中引出 DTFT 的定义。&lt;/p&gt;
&lt;p&gt;DTFT 是一种特殊的傅立叶变换（FT），它满足所有的傅立叶变换的性质。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离散傅立叶变换 （DFT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 DTFT 解决了信号在时域的连续问题，但是变换结果仍然是连续信号，也就是说在频域仍然是连续的，这样计算机仍然是无法处理的。所以，就引出了离散傅立叶级数（DFS) 和离散傅立叶变换（DFT）。&lt;/p&gt;
&lt;p&gt;时域信号的周期性对应着频域的离散化，而且时域信号的离散化对应着频域的周期性。由这两点，可以知道周期的离散信号具有离散的、周期的频谱，也就是离散傅立叶级数（DFS）。&lt;/p&gt;
&lt;p&gt;把时域和频域的数据长度都限定在主周期，那么就得到了标准的离散傅立叶变换（DFT）。&lt;/p&gt;
&lt;p&gt;经过分析，可以知道，DFT 是 z 变换的取样，也是 DTFT 的取样结果。&lt;/p&gt;
&lt;p&gt;DFT 因为是离散的，长度有限，所以很适合计算机计算，而且人们发明了高效地计算 DFT 的方法 —— FFT 。&lt;/p&gt;
&lt;p&gt;知乎上还有一篇专栏的文章，得到了非常多人的赞同，可以进一步参考。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zhuanlan.zhihu.com/wille/19763358"&gt;傅里叶分析之掐死教程（完整版）更新于 2014.06.06&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="matlab"&gt;Matlab&lt;/h2&gt;
&lt;h3 id="basic"&gt;basic&lt;/h3&gt;
&lt;p&gt;分析各种变化，可以得到以下的关系：&lt;/p&gt;
&lt;p&gt;N 点的 DFT（FFT），其结果对应的&lt;/p&gt;
&lt;p&gt;数字角频率 w 为 [0, 2pi)&lt;/p&gt;
&lt;p&gt;模拟角频率 Ω 为 [0, Ωs)&lt;/p&gt;
&lt;p&gt;模拟频率 f 为 [0, fs)&lt;/p&gt;
&lt;p&gt;所以对于 N 点 FFT 的结果，对应的横坐标频率的范围为 [0, fs)。&lt;/p&gt;
&lt;p&gt;matlab 提供了函数 fft 和 fftshift 直接完成变换。&lt;/p&gt;
&lt;h3 id="adv"&gt;adv&lt;/h3&gt;
&lt;p&gt;我们在对一个信号进行采样分析时，首先需要确定两个参数：参数有采样频率 &lt;code&gt;Fs&lt;/code&gt;，采样点数 &lt;code&gt;N&lt;/code&gt;，这两个因素决定了之后可以得到的时频域效果。&lt;/p&gt;
&lt;p&gt;假设我们的采样频率为 Fs （采样周期为 T = 1/Fs），一共采了 N 个点，那么相当于对信号进行了截断，截断长度为 L = N * T 秒。这 3 个参数就决定了我们的最终结果。&lt;/p&gt;
&lt;p&gt;在信号处理中存在下面的 3 个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;频谱混叠。如果信号不是带限的，那么为了减小频谱混叠的影响，我们应该&lt;strong&gt;尽可能提高采样频率 Fs&lt;/strong&gt;，而且 Fs 越大，时频域分辨率也越高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;频率分辨率和栅栏效应。因为 DFT 是 DTFT 的等间隔采样，那么 N 越大，采样点数越多，栅栏就越小。为了提高频率分辨率 &lt;code&gt;f0 = Fs/N&lt;/code&gt;，我们应该&lt;strong&gt;尽可能增大 N&lt;/strong&gt;，而且为了提高计算效率，N 等于 2 的 M 次方）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;截断效应和频谱泄漏。如果信号是无限长的，那么必须把它截断到长度 &lt;code&gt;L = N*T = N/Fs&lt;/code&gt;。截断会带来吉布斯效应，并且引入窗函数的频谱，造成频谱泄漏。应该&lt;strong&gt;使得 L 包含信号的绝大部分&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面举例说明非周期信号和周期信号的分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非周期信号&lt;/p&gt;
&lt;p&gt;假设我们要分析 tau = 1 的矩形窗函数，我们知道它的频谱，且取第一零点 1/tau = 1 为最高频，假设 8 倍采样，即 Fs = 8 Hz，假设频谱分辨率小于 0.1 Hz 即达到需求，则可以得到 N = 128，此时验证 L = 16 满足条件。由 tau 和 Fs 得到采样点包含 8 个 1 和 120 个 0，所以：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;zeors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f / Hz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Amplitude Response&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;tau = 1 rectangle window&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rect" src="/images/digital-signal-processing-and-matlab/rect-window.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;周期信号&lt;/p&gt;
&lt;p&gt;假设信号为 x = 1 + 1/2&lt;em&gt;cos(2&lt;/em&gt;pi&lt;em&gt;15&lt;/em&gt;t) + 2&lt;em&gt;sin(2&lt;/em&gt;pi&lt;em&gt;40&lt;/em&gt;t)，包含一个直流分量和 f1 = 15, f2 = 40 Hz 的分量，fm = f2 = 40 Hz，若 8 倍采样，有 Fs = fm*8，若 fdelta &amp;lt; 0.1 hz，有 N = 4096，所以：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;w1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;w2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;fftshift&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Fs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;grid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;on&lt;/span&gt;
&lt;span class="nb"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f / Hz&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Amplitude Response&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;x = 1 + 1/2*cos(w1*n) + 2*sin(w2*n)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital-signal-processing-and-matlab/period.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上，我们就有分析一个信号的&lt;strong&gt;通用步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;首先确定 Fs&lt;/strong&gt;：信号的频率信息对于我们是未知的，我们最多只知道信号的带宽，根据信号带宽，我们就可以确定一个采样率 Fs，比如 8 倍采样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定了 Fs，实际上的 w 就已经确定了，只是我们是不知道它的具体值（因为不知道 fm）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;下一步应该确定 N&lt;/strong&gt;：由公式 1 和公式 2 可以推出 &lt;code&gt;N = Fs/fm*k&lt;/code&gt;。当 Fs 最小为奈奎斯特采样速率，k = 1 时，N 取到最小值 2，这种情况下虽然没有混叠，但是 fdelta 太大了，不利于观察频谱，应该由 &lt;code&gt;fdelta = Fs/N&lt;/code&gt; 决定 N 的最小值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;====================================== 补充一下 FFT 补零 ========================================&lt;/p&gt;
&lt;p&gt;验证程序：假设一个 sin 信号，f = 125， 8 倍采样有 Fs = 1000，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;N = 8，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital-signal-processing-and-matlab/N-8.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N = 8，补零到 64 点，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital-signal-processing-and-matlab/padding.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N = 64，结果如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="period" src="/images/digital-signal-processing-and-matlab/N-64.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接给结论（上面的图也证明了这些结论）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在时域的采样序列后面添加后缀 0 ，等效在频域内插。频域内插只能从已有的样点推算，因为采样点数不够丢失的原始信号的信息无法通过内插来补偿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时域补零实际上改变了采样序列的，所以频域结果和原始信号不同，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补零无法提高频率分辨率，内插出的新分量不是真正物理意义上的频率，是 “ 假频 ”，真正的频率分辨率并没有提高。频率分辨率只能由提高采样点数来提高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3712794/"&gt;信号与系统引论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4025528/"&gt;数字信号处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/24868505/"&gt;数字信号处理教程 ——MATLAB 释义与实现&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="digital procesing"></category><category term="matlab"></category></entry><entry><title>Xilinx FFT IP core 笔记</title><link href="https://qian-gu.github.io/posts/ic/xilinx-fft-core-notes.html" rel="alternate"></link><published>2014-09-02T23:12:00+08:00</published><updated>2014-09-02T23:12:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-09-02:/posts/ic/xilinx-fft-core-notes.html</id><summary type="html">&lt;p&gt;使用 Xilinx FFT IP core (xfft v7.1) 的笔记&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于 FFT 的背景介绍就不再赘述，通原书和网上的教程、课件很多；关于这个 IP 核的介绍也就不再粘贴复制了，原版的 datasheet 必然是最全面的，仅记录我的使用时遇到的问题和需要注意到细节。&lt;/p&gt;
&lt;p&gt;IP 核的接口示意图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="schematic symbol" src="/images/xilinx-fft-core-notes/symbol.png"&gt;&lt;/p&gt;
&lt;h2 id="timing"&gt;Timing&lt;/h2&gt;
&lt;h3 id="start-rfd-port"&gt;&lt;code&gt;START / RFD&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;datasheet 中没有专门描述 &lt;code&gt;start&lt;/code&gt; 信号和其他信号的时序关系，只是简单介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;FFT start signal (Active High): START is asserted to begin the data loading and transform calculation (for the Burst I/O architectures). For Streaming I/O, START begins data loading, which proceeds directly to transform calculation and then data unloading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我最开始的测试小程序中，是先判断 &lt;code&gt;rfd&lt;/code&gt; 信号，根据 rfd 来给 start 赋值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;思路是：首先必须等 IP core 准备好接收新数据时，才能开始&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rfd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;但是仿真出来的结果显示 IP core 根本就没有工作，后来改了这两个信号的先后关系，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;新思路：程序将输入 start 置有效，通知 IP core 需要调用，然后 IP core 根据自己的状态给出标识信号（rfd / busy），外部电路等到 rfd 有效时才输入需要变换的信号。&lt;/em&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;busy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这样子程序就可以正常运行了。&lt;/p&gt;
&lt;h3 id="rfd-dv-port"&gt;&lt;code&gt;RFD / DV&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;在 datasheet 中给出的时序图如下所示（Burst I/O Solutions with Natural Order Output）&lt;/p&gt;
&lt;p&gt;&lt;img alt="Burst I/O Solution" src="/images/xilinx-fft-core-notes/burst-io-solution.png"&gt;&lt;/p&gt;
&lt;p&gt;实际仿真图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rfd-dv-sim" src="/images/xilinx-fft-core-notes/rfd-dv.png"&gt;&lt;/p&gt;
&lt;p&gt;实际仿真结果和示意图有一点点小差别：datasheet 中的时序图显示 rfd 必须在等 unload 阶段结束之后才能变有效，输入新的数据；但是实际的仿真图显示，在 unload 的后半段时间，rfd 已经变有效了，开始载入新的数据。&lt;/p&gt;
&lt;p&gt;从理论上分析，采用 Burst I/O with Natural Order Output 方案，总共需要 3N 个时钟周期，load 阶段需要 N 个周期载入数据，processing 阶段需要 N 个时钟变换，unload 阶段需要 N 个周期来输出数据。&lt;/p&gt;
&lt;p&gt;从仿真结果来看，unload 阶段和下一帧的 load 阶段有部分是重叠的，这样实际上的周期是少于 3N 个时钟的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然功能上是不影响下一帧的数据的，毕竟和预期的时序不同，不知道是否会影响时序设计，有待继续观察。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="port"&gt;Port&lt;/h2&gt;
&lt;h3 id="nfft-port"&gt;&lt;code&gt;NFFT&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 是可以设置为 动态重配置的，可以在运行时改变做运算的点数，非常方便，不过有一点需要注意到是重配置的点数是有范围限制的，比如我测试时设置的最大点数为 4096 点，那么运行重配置时，最小的点数为 64。可以选择 64 ~ 4096 之间的任何一个 2 的指数。&lt;/p&gt;
&lt;p&gt;由于我一开始忽略了这一点，重配置为 16 点，迷糊了半天，重新打开 IP core 设置时才发现是自己看文档不够仔细 =.=&lt;/p&gt;
&lt;h3 id="cp-port"&gt;&lt;code&gt;CP&lt;/code&gt; port&lt;/h3&gt;
&lt;p&gt;这个 FFT core 专门提供了一个端口可以设置循环前缀的长度，循环前缀 (cyclic prefix) 在通信中（尤其是 OFDM）是很有用的。&lt;/p&gt;
&lt;p&gt;在向导中设置了 cyclic prefix insertion，并且在程序重配置时设置了 CP length = 10，但是仿真结果却没有出现 CP，和 CP = 0 时的结果相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;仔细看了两遍程序和 datasheet，没有发现问题 ... 待解决！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 09/03/2014&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又仔细看了两遍 datasheet，终于发现了原因所在。在关于 CP length 部分，最有一小段话一直被我匆匆忽略了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The initial value and reset value of CP-LEN is 0 (no cyclic prefix). The core uses the log2(point size) MSBs of CP-LEN for the cyclic prefix length. So, when the point size decreases, the leftover LSBs are ignored. This effectively scales the cyclic prefix length with the point size, keeping them in approximately constant proportion. However, all bits of CP-LEN are latched into the core on CP-LEN-WE and are used in later transforms if the point size increases.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细读了一遍才明白，CP-LEN 起作用的是高位的数据 —— 从 MSB 起共 log2(point size) 位。比如我测试程序设置的最大点数为 4096，这是 CP-LEN 的位宽为 12 比特，但是在程序运行过程中，我重配置为 64 点，所以这时候应该从 CP-LEN 的最高位数起，共 log2(64) = 6 比特数据起作用。如果我想设置 CP 的长度为 8 点，则应该如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;cp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b001000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这时候，如下图所示，结果与预期相符。&lt;/p&gt;
&lt;p&gt;&lt;img alt="cp" src="/images/xilinx-fft-core-notes/cp.png"&gt;&lt;/p&gt;
&lt;h3 id="fft-ifft"&gt;FFT/ IFFT&lt;/h3&gt;
&lt;p&gt;在 FFT 的测试程序中，一切都正常工作，但是切换为 IFFT 模式，却出现了问题。&lt;/p&gt;
&lt;p&gt;datasheet 中介绍，控制正反变换的信号一共有两个：&lt;code&gt;fwd-inv&lt;/code&gt; 和 &lt;code&gt;fwd-inv-we&lt;/code&gt;。前者取 1 时为 FFT，取 0 为 IFFT；后者是前者的写使能信号。&lt;/p&gt;
&lt;p&gt;因为 FFT 的程序可以正常工作，说明程序逻辑是没有问题的。但是只配置这两个端口，就是有问题。自己研究无果，只能 Google，还真的找到以前有人也遇到同样的问题，并且给出了解决方法（不得不说，还是 Google 好，某度搜出来的结果都是广告和没有用的链接）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://forums.xilinx.com/t5/Digital-Signal-Processing-IP-and/IFFT-of-FFT-module-does-not-work/td-p/71555"&gt;IFFT of FFT module does not work&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://myfpgablog.blogspot.com/2009/11/ifft-in-system-generator.html"&gt;IFFT in System Generator (blogspot 需翻墙 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转原博客部分内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, the FFT block is configured to calculate DFT. The setup and timing of control/data signals for IDFT are the same as DFT except for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FFT block needs to be set up for IDFT by setting fwd-inv-we signal to 1 and fwd-inv signal to 0 before the start of the transform.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The FFT output needs to be manually scaled to account for the factor 1/N in Equation 2 above. The scaling can be done either by using the scaling schedule input or shifting the FFT output if the FFT block is set to "unscaled".&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题关键就在于第二条，需要手动设置数据缩放，给结果乘以 1/N。&lt;/p&gt;
&lt;p&gt;原因就是这个 IP core 在计算 FFT 和 IFFT 时，利用两者表达式上的相似点，使用相同的结构，但是却缺少给 IFFT 的结果乘以 1/N 的步骤，需要用户自己添加。&lt;/p&gt;
&lt;p&gt;在 datasheet 中介绍说&lt;/p&gt;
&lt;p&gt;&lt;img alt="theory" src="/images/xilinx-fft-core-notes/theory.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The inverse FFT (IFFT) is computed by conjugating the phase factors of the corresponding forward FFT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是却没有提到这个额外的 1/N 需要用户自己手动设置，应该算是 Xilinx 的坑。修正这个倍数关系以后，结果就与预期相符了～&lt;/p&gt;
&lt;p&gt;（其实如果仔细分析对比 FPGA 和 Matlab 的结果，就能发现两者的差别就是这个 1/N 的倍数关系，只是自己对数字不敏感，又懒得仔细观察 =.=）&lt;/p&gt;
&lt;h2 id="ps-test-program"&gt;P.S. Test program&lt;/h2&gt;
&lt;h3 id="fft-ip-core"&gt;FFT IP core&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;page1: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel = 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transform Length = 4096&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Radix-4, Burst I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run time configurable transform length&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Fix Point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Input data width  = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase factor width = 24&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block floating point&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;natural output&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cyclic prefix insertion&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;input data timing - no offset&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;page3:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;use 3-multiplier structer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use CLB logic to implement butterfly arithmetic&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;运行时重配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变换长度为 64 点，cp 长度为 10&lt;/p&gt;
&lt;h3 id="matlab"&gt;Matlab&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;fft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;real&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;imag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;%f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;%f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;im&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;FFT IP core 仿真结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="fft core sim" src="/images/xilinx-fft-core-notes/fft-core-sim.png"&gt;&lt;/p&gt;
&lt;p&gt;对比 Matlab 中的结果，可以看到 IP core 的计算结果是正确的（除了 CP 的问题）。&lt;/p&gt;</content><category term="IC"></category><category term="FFT"></category><category term="IP core"></category></entry><entry><title>FPGA 时钟设计 1 —— 时钟资源总结</title><link href="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-1-summary-of-clock-resource.html" rel="alternate"></link><published>2014-08-28T22:45:00+08:00</published><updated>2014-08-28T22:45:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-08-28:/posts/ic/the-clock-design-in-fpga-1-summary-of-clock-resource.html</id><summary type="html">&lt;p&gt;总结 Xilinx FPGA 中的时钟资源&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于一款芯片，最权威、最新的资料当然是厂家的官方文件。很多大牛都推荐直接阅读原厂的 datasheet 和 user guide。根据我的体验，这确实是最好的途径。原因有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，市面上的书一般都落后业界的步伐，我们看到的很多书上的资料都是过时的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，市面上书（尤其是国内）很多都是简单的翻译手册而来的，而且虽然作者标的是某某大学的教授，事实上都是教授手下的研究生替老师干活翻译的，不能保证翻译的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实验室有的芯片是 Xilinx 的 Virtex-5 系列，Virtex-5 的 User Guide 是 &lt;a href="http://www.xilinx.com/support/documentation/user-guides/ug190.pdf"&gt;UG190&lt;/a&gt;，以下内容都是从中摘抄的笔记。&lt;/p&gt;
&lt;h2 id="three-types-of-clock-resource"&gt;Three Types of clock resource&lt;/h2&gt;
&lt;h3 id="global-clocks"&gt;Global Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了时钟目的，每个 Virtex-5 系列的器件内部都被分成不同的区域（regions），随着器件的尺寸不同，最小的有 8 个区域，最大的有 24 个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源（Global I/O）和局部时钟资源可以完成所有的复杂的 / 简单的时钟要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不推荐使用其他的非时钟资源（比如局部布线资源）来完成时钟功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 系列的器件都有 32 条全局时钟线 （global clock line），可以驱动片上的所有时序资源（CLB、BRAM、CMTs、I/O），也可以驱动其他的逻辑信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些全局时钟线可以用在任何一个区域中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟线只能由全局时钟缓冲器（global clock buffer）驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器一般由时钟管理块（Clock Management Tile, CMT）驱动，以减少时钟布线延时或者调整和另外一个时钟的相对延时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟的个数比 CMTs 多，但是一个 CMT 可以驱动多个全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regional-clocks"&gt;Regional Clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个区域（region）含有 2 个局部时钟缓冲器（regional clock buffer）和 4 个局部时钟树（regional clock tree）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了处于芯片中心列的组（bank）外，一个 Virtex -5 I/O bank 恰好横跨一个区域。大小和区域完全相同的每个组含有 4 个 clock-capable 的时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个输入可以差分驱动或单端驱动同一组或区域中的四个 I/O 时
钟（I/O clocks）和两个区域时钟（regional clock）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="io-clocks"&gt;I/O clocks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第三种时钟资源是 I/O clocks，可以达到非常高的速度，用于局部的 I/O 串行器 / 解串器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="global-clocking-resources"&gt;Global Clocking Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局时钟（global clocks）是个专用网络，是专为覆盖对 FPGA 中各种资源的所有时钟输入设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟资源包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Global Clock Buffers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Tree and Nets-GCLK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Regions&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="global-clock-inputs"&gt;Global Clock Inputs&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 FPGA 包含专用的全局时钟输入位置，这些输入位置即使不用作时钟输入，也可用作常规用户 I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个器件有 20 个全局时钟输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟输入可以按任意 I/O 标准配置，包括差分 I/O 标准。每个时钟输入可以是单端输入，也可以是差分输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Input Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IBUFG，单端输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IBUFGDS，差分输入全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="global-clock-buffers"&gt;Global Clock Buffers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个 Virtex-5 器件有 32 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每半个晶片 （上半 / 下半）包含 16 个全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器允许各种时钟源 / 信号源接入全局时钟树和网。可以输入全局时钟缓冲器的源包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Global clock inputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clock Management Tile (CMT) outputs including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Digital Clock Managers (DCMs)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phase-Locked Loops (PLLs)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Other global clock buffer outputs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;General interconnect&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局时钟缓冲器只能由同半个晶片 （上半 / 下半）中的源驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在一个时钟区域中仅能驱动十个不同的时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域 （20 个 CLB）是由上十个 CLB 行和下十个 CLB 行组成的时钟树的一个
枝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域仅横跨器件的一半。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Global Clock Buffer Primitives&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;BUFGCTRL、BUFG、BUFGCE、BUFGCE-1、BUFGMUX、BUFGMUX-1、BUFGMUX-CTRL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他所有原语均出自 &lt;strong&gt;BUFGCTRL&lt;/strong&gt; 的软件预设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFG&lt;/strong&gt; 全局缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGCE&lt;/strong&gt; 带有时钟使能（CE）的全局缓冲（BUFG）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGMUX&lt;/strong&gt; 全局时钟选择缓冲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGP&lt;/strong&gt; = IBUFG + BUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFGDLL&lt;/strong&gt; 全局缓冲延迟锁相环（舍，被 DCM 代替）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="clock-tree-and-nets-gclk"&gt;Clock Tree and Nets - GCLK&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟树是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有全局时钟线和缓冲器都以差分形式实现，这有助于大大改善占空比和共模噪声抑制能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Virtex-5 架构中，全局时钟线的引脚接入不仅限于逻辑资源的时钟引脚。全局时钟线不用局部互连即可接入 CLB 中的其他引脚。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="clock-regions"&gt;Clock Regions&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 器件通过使用时钟区域改善时钟控制分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟区域最多可有十个全局时钟域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这十个全局时钟可以由 32 个全局时钟缓冲器的任意组合驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="how-to-use-global-clock"&gt;How to use global clock&lt;/h3&gt;
&lt;p&gt;Xilinx 芯片全局时钟资源的使用方法主要有 5 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最基本的全局时钟资源使用方法，也称为 “ BUFGP 法 ”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFGDS + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时钟信号为差分形式时，需要用 IBUFGDS 代替 IBUFG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IBUFG + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最灵活的使用方法（一般外部提供的时钟都需要倍频、分频、移相等操作以后才可以使用，所以中间需要 DCM）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BUFG 的输入可以是普通信号，当某个信号（时钟、使能、快速路径）的扇出非常大、要求抖动延迟最小时，可以使用 BUFG 来驱动这个信号，使这个信号利用全局时钟资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logic + DCM + BUFG&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的输入也可以是普通信号，所以上面的例子中的信号需要倍频、分频等操作时，需要在中间添加 DCM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在具体使用这些组合方式时，有两种例化方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在设计中直接例化全局时钟资源&lt;/p&gt;
&lt;p&gt;比较简单，按照需求例化上面 5 种组合方式即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在综合阶段 / 实现阶段通过约束文件的方式实现&lt;/p&gt;
&lt;p&gt;随着综合工具 / 布局布线工具的不同而变化，大多数综合工具会自动分析时钟信号的扇出数目，在全局时钟资源富裕的情况下，使扇出数目最大的信号自动指定使用全局时钟资源。这时候我们必须保证满足下面的原则，否则会报错。如果不能满足，则必须在约束文件中明确声明该信号不使用全局时钟资源。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NET&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CLK&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CLOCK&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;DEDICATED&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ROUTE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="principle-in-using-global-clock"&gt;Principle in Using global clock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;原则：&lt;/strong&gt; 使用 IBUFG / IBUFGDS 的必要条件是信号从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;也就是说，如果某个信号从全局时钟引脚输入，不管它是否为时钟信号，必须使用 IBUFG/IBUFGDS；如果对某个信号使用了 IBUFG/IBUFGDS，则这个信号必须从全局时钟引脚输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt; 由 Xilinx FPGA 内部结构决定的，IBUFG/IBUFGDS 的输入端仅和芯片的全局时钟引脚有物理连接，与普通的 I/O 和其他内部 CLB 等没有物理连接。&lt;/p&gt;
&lt;h3 id="ps"&gt;P.S. 第二全局时钟资源&lt;/h3&gt;
&lt;p&gt;在看其他资料时，看到一种新的时钟资源 —— 第二全局时钟资源。官方的文档我还没有找到，所以就直接摘抄书上的笔记了 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第二全局时钟资源属于长线资源，长度和驱动能力仅次于全局时钟资源，也可以驱动芯片内部的任何一个逻辑，抖动和延时仅次于全局时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在设计中，一般将高频率、高扇出的时钟使能信号以及高速路径上的关键信号指定为全局第二时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用全局时钟资源并不占用逻辑资源，也不影响其他布线资源；第二时钟资源占用的是芯片内部的资源，占用部分逻辑资源，各个部分的布线会相互影响，所以建议在设计中逻辑占用资源不超过 70% 时使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在约束编辑器中的专用约束 Misc 选项中，指定所选信号使用低抖动延迟资源 “Low Skew” 来指定，也可以在 ucf 文件中添加 “USELOWSKEWLINES" 约束命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NET&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;s1&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;NET&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;s2&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;NET&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;s3&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;USELOWSKEWLINES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="regional-clocking-resources"&gt;Regional Clocking Resources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网络是一组独立于全局时钟网络的时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与全局时钟不同，区域时钟信号 (BUFR) 的跨度限于三个时钟区域，而 I/O 时钟信号只驱动一个区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 时钟控制资源和网络由以下通路和组件构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Clock Capable I/O&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I/O Clock Buffer (BUFIO)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Buffer (BUFR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Regional Clock Nets&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="clock-capable-io"&gt;Clock Capable I/O&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;典型时钟区域中有四个 clock-capable I/O 引脚对 （中心列有例外）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有些全局时钟输入也是 clock capable I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个组中有四个专用 clock capable I/O 区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当用作时钟输入时，clock-capable 引脚可以驱动 BUFIO 和 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些引脚不能直接连接到全局时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="io-clock-buffer-bufio"&gt;I/O Clock Buffer - BUFIO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O 时钟缓冲器 (BUFIO) 是可以在 Virtex-5 器件中使用的一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 驱动 I/O 列内一个独立于全局时钟资源的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 只能由位于同一时钟区域的 clock capable I/O 驱动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域中有四个 BUFIO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFIO 不能驱动逻辑资源 （CLB、Block RAM 等），因为 I/O 时钟网络只能覆盖同一组或时钟区域内的 I/O 列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFIO Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFIO 其实就是一个时钟输入和时钟输出缓冲器。输入与输出之间有一个相位延迟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regional-clock-buffer-bufr"&gt;Regional Clock Buffer - BUFR&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;区域时钟缓冲器 (BUFR) 是可以在 Virtex-5 器件中使用的另一种时钟缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BUFR 将时钟信号驱动到时钟区域内一个独立于全局时钟树的专用时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 BUFR 可以驱动其所在区域中的四个区域时钟和相邻区域 （最多三个时钟区域）中的四个时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与 BUFIO 不同，BUFR 不仅可以驱动其所在时钟区域和相邻时钟区域中的 I/O 逻辑，还可以驱动其中的逻辑资源 （CLB、Block RAM 等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型的时钟区域 （四个区域时钟网络）中有两个 BUFR。中心列没有 BUFR。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BUFR Primitive&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BUFR 是一个具有输入时钟分频功能的时钟输入 / 时钟输出缓冲器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="regional-clock-nets"&gt;Regional Clock Nets&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除了全局时钟树和网（global clock trees and nets），Virtex-5 器件还包含区域时钟网（Regional Clock Nets）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些时钟树也是为低歪斜和低功耗操作设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未用分枝都不连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当所有逻辑资源都使用时，时钟树还管理负载 / 扇出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域时钟网的传播并非遍及整个 Virtex-5 器件，而是仅限于一个时钟区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个时钟区域包含四个独立的区域时钟网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要接入区域时钟网，BUFR 必须例化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 BUFR 最多可以驱动两个相邻时钟区域中的区域时钟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="clock-management-technology"&gt;Clock Management Technology&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 系列的芯片内部含有的时钟管理模块（Clock Management Tiles，CMTs）可以提供灵活的、高性能的时钟信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 CMT 由 2 个 DCM 和 1 个 PLL 组成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="dcm"&gt;DCM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DCM 原语有两个：DCM-BASE、DCM-ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM-BASE 提供基本的功能，比如去歪斜、频率合成、固定相移；DCM-ADV 提供更高级的功能，比如动态重配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个原语都有各自的输入输出端口、属性设置和状态标识&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DCM 可以连接到芯片上的其他时钟资源，包括专用时钟 I/O，时钟缓冲器和 PLL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;==================Update (09/12/2014) 看到一篇介绍 DCM 的&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;文章&lt;/a&gt;，很有意思 =================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;About DCM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DCM 的内部是 DLL (Delay Lock Loop) 结构，对时钟偏移量的调节是通过长达延时线形成的。&lt;/p&gt;
&lt;p&gt;DCM 会把输入时钟 &lt;code&gt;clkin&lt;/code&gt; 和 反馈时钟 &lt;code&gt;clkfb&lt;/code&gt; 相比较，调节 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clk-1x&lt;/code&gt; 之间的延时线的数目，直到 &lt;code&gt;clkin&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 之间的相位差等于所设置的参数 &lt;code&gt;PHASESHIFT&lt;/code&gt;。如果 &lt;code&gt;clk-1x&lt;/code&gt; 和 &lt;code&gt;clkfb&lt;/code&gt; 不相关的话，那么就永远不能锁定了。&lt;/p&gt;
&lt;p&gt;这个从一开始的不等于到等于所花费的时间就是输出时钟锁定的时间，锁定之后，&lt;code&gt;locked&lt;/code&gt; 信号才会变高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 的常用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dcm-usage" src="/images/the-clock-design-in-fpga-1-summary-of-clock-resource/dcm-usage.jpg"&gt;&lt;/p&gt;
&lt;p&gt;将其输出 &lt;code&gt;clk-1x&lt;/code&gt; 连接到 &lt;code&gt;BUFG&lt;/code&gt; 的输入，通过 BUFG 之后的输出一条支路是反馈到 DCM 的反馈时钟引脚 &lt;code&gt;clkfb&lt;/code&gt; 上，另外一条支路则输出驱动其他单元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DCM 消除 skew&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;DCM 的输出开始走线到达寄存器，这段路程导致的 skew 是永远存在的，DCM 为什么可以消除呢？&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为说明方便起见 , 我们将 BUFG 的输出引脚叫做 &lt;code&gt;clk-o&lt;/code&gt;, 从 clk-o 走全局时钟布线到寄存器时叫做 &lt;code&gt;clk-o-reg&lt;/code&gt;, 从 clk-o 走线到 DCM 的反馈引脚 CLKFB 上时叫 &lt;code&gt;clkfb&lt;/code&gt;, 如上图所示。实际上 clk-o, clk-o-reg, clkfb 全部是用导线连在一起的。&lt;/p&gt;
&lt;p&gt;所谓时钟 skew, 指的就是 clk-o 到 clk-o-reg 之间的延时。如果打开 FPGA-Editor 看底层的结构 , 就可以发现虽然 DCM 和 BUFG 离得很近 , 但是从 clk-o 到 clkfb 却绕了很长一段才走回来 , 从而导致从 clk-o 到 clk-o-reg 和 clkfb 的延时大致相等。&lt;/p&gt;
&lt;p&gt;总之就是 clk-o-reg 和 clkfb 的相位应该相等。所以当 DCM 调节 clkin 和 clkfb 的相位相等时 , 实际上就调节了 clkin 和 clk-o-reg 相等。而至于 clk-1x 和 clk-o 的相位必然是超前于 clkin, clkfb, clk-o-reg 的 , 而 clk-1x 和 clk-o 之间的延时就很明显 , 就是经过那个 BUFG 的延迟时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对时钟 skew 的进一步讨论&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后 , 说一说时钟 skew 的概念。&lt;/p&gt;
&lt;p&gt;时钟 skew 实际上指的是时钟驱动不同的寄存器时 , 由于寄存器之间可能会隔得比较远 , 所以时钟到达不同的寄存器的时间可能会不一样 , 这个时间差称为 &lt;code&gt;时钟 skew&lt;/code&gt; 。这种时钟 skew 可以通过 &lt;code&gt;时钟树&lt;/code&gt; 来解决 , 也就是使时钟布线形成一种树状结构 , 使得时钟到每一个寄存器的距离是一样的。很多 FPGA 芯片里就布了这样的时钟树结构。也就是说 , 在这种芯片里 , 时钟 skew 基本上是不存在的。&lt;/p&gt;
&lt;p&gt;说到这里 , 似乎有了一个矛盾 , 既然时钟 skew 的问题用时钟树就解决了 ,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;那么为什么还需要 DCM + BUFG 来解决这个问题？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外 , 既然时钟 skew 指的时时钟驱动不同寄存器之间的延时 , 那么上面所说的 clk-o 到 clk-o-reg 岂非不能称为时钟 skew？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先说后一个问题。在一块 FPGA 内部 , 时钟 skew 问题确实已经被 FPGA 的时钟方案树解决 , 在这个前提下 clk-o 到 clk-o-reg 充其量只能叫做 &lt;code&gt;时钟延时 delay&lt;/code&gt;, 而不能称之为时钟 skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于第一个问题，个人不认同原博主的答案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可惜的是 FPGA 的设计不可能永远只在内部做事情 , 它必然和外部交换数据。例如从外部传过来一个 32 位的数据以及随路时钟 , 数据和随路时钟之间满足建立保持时间关系 (Setup Hold time), 你如何将这 32 位的数据接收进来？如果你不使用 DCM, 直接将 clkin 接在 BUFG 的输入引脚上 , 那么从你的 clk-o-reg 就必然和 clkin 之间有个延时 , 那么你的 clk-o-reg 还能保持和进来的数据之间的建立保持关系吗？显然不能。相反 , 如果你采用了 DCM, 接上反馈时钟 , 那么 clk-o-reg 和 clkin 同相 , 就可以利用它去锁存进来的数据。可见 ,DCM
+ BUFG 的方案就是为了解决这个问题。而这个时候 clk-o 到 clk-o-reg 的延时 , 我们可以看到做内部寄存器和其他芯片传过来的数据之间的时钟 skew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这个答案有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;外部数据和芯片不同源，算是异步问题，应该用同步化来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随路失踪一般不驱动芯片的整个时钟网络。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，我认为答案应该是：&lt;/p&gt;
&lt;p&gt;要使用全局时钟网络，必须通过 BUFG 才行，所以才会用到 BUFG；而之所以用到 DCM 是因为它可以实现时钟的闭环控制，而且可以把时钟映射到 PCB 上，用于同步外部芯片，减少了对外部芯片的要求，将时钟控制一体化，利于系统设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在一片 FPGA 中使用两个 DCM，需要注意两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置 DCM 使用的时钟输入 &lt;code&gt;clk-in&lt;/code&gt; 是源自 FPGA 内部的，此时不能直接连接引脚的信号，需要加入缓冲器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该手动例化一个 IBUFG，然后把 IBUFG 的输出连接到两个 DCM 的输入端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果没有这么做，而是完全按照单个 DCM 的流程使用，那么因为时钟引脚和两个 DCM 的路径长短不同，无法做到输入时钟、两个 DCM 的输出信号的相位对齐，输入时钟只能和其中一个对其，如果对相位有要求，则必须手动调整 DCM 在芯片中的位置。&lt;/p&gt;
&lt;h3 id="pll"&gt;PLL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Virtex-5 芯片最多包含了 6 个 CMT 模块，每个 CMT 模块包含一个 PLL，PLL 主要用来广谱频率的合成，并且与 DCM 配合最为外部 / 内部时钟的抖动滤波器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL 也有两个原语：PLL-BASE、PLL-ADV&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PLL-BASE 提供基本的功能，比如时钟去歪斜、频率合成、精确相移、占空比调整；PLL-ADV 提供更高级的功能，比如时钟切换、动态重配置等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mmcm"&gt;MMCM&lt;/h3&gt;
&lt;p&gt;不同系列的芯片内部的时钟管理模块是不同的，比如在 Virtex-5 系列后的芯片就含有了 混合模式时钟管理器 MMCM 。&lt;/p&gt;
&lt;p&gt;具体实现时该如何选择 DCM、DLL、PLL、MMCM ？找到一篇介绍 Xilinx 时钟资源的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART-8800512846-18-20010-TA-25f01c24.HTM"&gt;如何正确使用 FPGA 的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="other-tips"&gt;Other Tips&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般来说，外部提供的时钟信号都需要进行倍频 / 分频才可以使用，这时候需要组合各种时钟缓冲器和 DCM、PLL 等模块，我们有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;代码中例化原语，手动组合各种时钟缓冲器和 DCM、PLL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 IP core 向导，创建时钟管理器（可以发现 IP core 生成的代码就是上面 5 种组合方式）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人感觉使用第二种方法应该更加简洁、方便，不容易出错吧。（如果在代码中没有明确声明使用 buffer，ISE 综合属性、IP core 属性设置里面默认会给所有的输入输出自动加上缓冲器）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对 FPGA 设计而言，全局时钟是最简单最可预测的时钟，最好的时钟方案是：由专用的全局时钟输入引脚驱动单个全局时钟，并用后者去控制设计中的每个触发器。全局时钟资源是专用布线资源，存在与全铜布线层上，使用全局时钟资源不影响芯片的其他布线资源，因此在可以使用全局时钟的时候尽可能使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;虽然各个芯片都不尽相同，但是了解相关的基本知识有利于我们快速掌握芯片的时钟资源、快速上手。&lt;/p&gt;
&lt;p&gt;Xilinx 的所有器件上的时钟资源可以分为前面说的 3 类：全局时钟（global clock）、局部时钟（regional clock）、I/O 时钟（I/O clock），但是不同的器件内部含有的时钟管理模块是不同的，具体到每一款芯片，应该以对应的 User Guide 为准。&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/user-guides/ug190.pdf"&gt;Virtex 5 User Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/11523088/"&gt;Xilinx FPGA 开发使用教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10593491/"&gt;Xilinx FPGA 高级设计及应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG"&gt;FPGA 高手设计实战真经 100 则&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ednchina.com/ART-8800512846-18-20010-TA-25f01c24.HTM"&gt;如何正确使用 FPGA 的时钟资源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;amp;tid=88967&amp;amp;page=1"&gt;FPGA DCM 时钟管理单元的理解&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="clock design"></category><category term="clock resource"></category></entry><entry><title>Verilog 中的参数化建模</title><link href="https://qian-gu.github.io/posts/ic/parameterization-modeling-in-veriog.html" rel="alternate"></link><published>2014-07-09T23:03:00+08:00</published><updated>2014-07-09T23:03:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-07-09:/posts/ic/parameterization-modeling-in-veriog.html</id><summary type="html">&lt;p&gt;总结 Verilog 模块化建模的技术&lt;/p&gt;</summary><content type="html">&lt;p&gt;和写软件程序一样，我们也希望 Verilog 的模块也可以重利用。要使模块可以重复利用，关键就在于避免硬编码 (hard literal)，使模块参数化。参数化建模的好处是可以使代码清晰，便于后续维护和修改。&lt;/p&gt;
&lt;p&gt;Verilog 的参数化建模是有一定限制的，它的参数值是编译时计算的，不会引入任何实际的硬件电路。参数必须在编译时确定值。也就是说只能达到动态编译，固态运行，而非软件的动态编译，动态运行。这主要是因为它是描述 (Description) 硬件的语言，而非软件设计 (Design) 语言。&lt;/p&gt;
&lt;p&gt;比如一个计数器，我们可以设置一个参数来指定它的计数周期 ( 动态编译 )，但是这个计数周期在综合之后就是固定值了 ( 固态运行 )，不能在运行的时候动态地改为另外一个值 ( 除非电路综合时同时产生了多个计数器，这种情况不算真正意义上的动态运行，而且也达不到真正意义上的动态运行，因为不可能把所有可能的计数器都实现了备用，耗费资源而且没有实际意义 )。&lt;/p&gt;
&lt;p&gt;参数化建模的主要目的是：&lt;strong&gt;提高模块的通用性，只需要修改参数，不用修改其他代码就可以适用于不同的环境中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下我找到的资料，具体的参数化建模方法一共就 3 种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 宏定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parameter&lt;/code&gt; 模块参数化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;`ifdef&lt;/code&gt; 等 条件编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="define-macro-substitution"&gt;Define Macro Substitution&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;`define&lt;/code&gt; 是编译器指令，功能是全局宏定义的文本代替。它类似于 C 语言中的 &lt;code&gt;#define&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// define&lt;/span&gt;
&lt;span class="cp"&gt;`define     WORD_REG    reg     [31:0]&lt;/span&gt;

&lt;span class="c1"&gt;// using&lt;/span&gt;
&lt;span class="no"&gt;`WORD_REG&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;reg32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;define 定义的宏的作用域是全局的，这种机制会导致两个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;可能会有在不同文件中发生重定义的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译顺序有要求 file-order dependent，必须确保使用前，宏定义有效，所以每个使用到宏定义的源文件必须包含这个头文件，这会导致多重包含的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于第一个问题，尽可能把所有的宏定义放在同一个头文件中，比如 "global_define.vh"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于第二个问题，和 C++ 类似，头文件应该使用头文件保护符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// global_define.vh head file&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GLOBAL_DEFINE_VH&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`define&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;MAX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="no"&gt;`define&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="no"&gt;`enif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="guideline"&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于那些只限于模块内的常量，不要使用 define&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="parameter"&gt;Parameter&lt;/h2&gt;
&lt;h3 id="parameter_1"&gt;Parameter&lt;/h3&gt;
&lt;p&gt;应该避免硬编码设计 &lt;code&gt;hard literal&lt;/code&gt;，使用参数 &lt;code&gt;parameter&lt;/code&gt; 来代替。举个例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// use parameter&lt;/span&gt;
&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;MAX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// DO NOT use hard literal&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="n"&gt;din_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="localparam"&gt;Localparam&lt;/h3&gt;
&lt;p&gt;Verilog-2001 中添加了一个新的关键字 &lt;code&gt;localparam&lt;/code&gt;，用来定义模块内部的、不能被其他模块修改的局部常量，概念类似于 C++ 中 class 的 protect 成员。&lt;/p&gt;
&lt;p&gt;虽然 localparam 不能被外部模块修改，但是它可以用 parameter 来初始化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;localparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="parameter-redefinition"&gt;Parameter Redefinition&lt;/h3&gt;
&lt;p&gt;在 Verilog-2001 出现之前，Verilog-1995 中只有两种方法实现参数重定义：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 # 符号，顺序列表重定义&lt;/li&gt;
&lt;li&gt;使用 defparam&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;逐个讨论&lt;/p&gt;
&lt;h4 id="1-uisng"&gt;1. Uisng &lt;code&gt;#&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个栗子，模块 myreg&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;Trst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;Tclk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在上一层的模块中传递参数例化这个模块&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;bad&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;warpper&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// legal parameter passing&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// illegal parameter passing&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// myreg #(,,8) r1(.q(q), .d(d), .clk(clk), .rst(rst) );&lt;/span&gt;
&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然每次例化都要说明所有的参数值，但是比第二种方法好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次例化都要说明所有的参数值。&lt;/p&gt;
&lt;h4 id="2-using-defparam"&gt;2. Using &lt;code&gt;defparam&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;defparam&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;比如在上面的例子中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;defparam&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以放在任何文件的任何地方，不用再重复没有修改的参数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为 defparam 有这么 " 强 " 的功能，反而会导致一系列的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Hierarchical deparam. &lt;/p&gt;
&lt;p&gt;比如顶层模块使用 defparam 修改子模块的参数，子模块中又使用 defparam 修改顶层模块要传递进来的参数，形成一个环，这样子可能导致综合时不提示错误，但是结果与预期不符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiple defparams&lt;/p&gt;
&lt;p&gt;在 单个文件 / 多个文件 中重复定义 defparam，会有微妙的问题，Verilog-1995 中没有定义这种现象，实际结果依赖于使用的综合工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 defparam 有这么多缺点，所以在 2001 年之前，Synopsys 是不支持 defparam 的，网上很多转载的博客都说 defparam 是不可综合的，实际上在后来，Synopsys 在压力之下添加了对其的支持。而我用 XST 也证明是支持 defparam 可综合。&lt;/p&gt;
&lt;p&gt;综上原因，Verilog Standards Group (VSG) 倡议大家抵制使用 defparam，大神 Clifford E. Cummings 在论文中建议综合工具如果用户坚持使用 defparam 语句，必须添加以一个参数 &lt;code&gt;+Iamstupid&lt;/code&gt;...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"The Verilog compiler found a defparam statement in the source code at
(file-name/line#).
To use defparam statements in the Verilog source code, you must include the switch
+Iamstupid on the command line which will degrade compiler performance and introduce
potential problems but is bug-compatible with Verilog-1995 implementations.
Defparam statements can be replaced with named parameter redefinition as define by
the IEEE Verilog-2001 standard."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下，可以发现 Verilog-1995 中的两种方法都不怎么好，显然 VSG 也发现了这个问题，所以在 Verilog-2001 中，出现了第三种方法，并且墙裂推荐使用这种新方法。&lt;/p&gt;
&lt;h4 id="3-using-named-parameter-redefinition"&gt;3. Using named parameter redefinition&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似于模块例化时端口连接的方式，比如上例中只想改变 SIZE 的值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;myreg&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;#(.&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pro&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合了前两种方法的有点，既显示说明了哪个参数值改变了，也将参数传递放在了实例化的语句中。这种方法是最干净的 (cleanest) 方法，不依赖于任何综合工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Con&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;貌似没有～&lt;/p&gt;
&lt;h3 id="guideline_1"&gt;Guideline&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="example"&gt;Example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;clock cycle definition&lt;/p&gt;
&lt;p&gt;因为时钟是一个设计中最基本的常量，它不会在随着模块变化，所以应该用 &lt;code&gt;`define&lt;/code&gt; 来定义，并且将它放在顶层的头文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FSM&lt;/p&gt;
&lt;p&gt;在一个设计中可能有不止一个 FSM，而通常 FSM 有一些共同的状态名字，比如 IDLE、READY、READ、WRITE、ERROR、DONE 等，所以应该用 &lt;code&gt;localparam&lt;/code&gt; 来定义这些常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="conditional-compilation"&gt;Conditional Compilation&lt;/h2&gt;
&lt;p&gt;Verilog 的条件编译和 C 也十分类似。前面介绍 define 时，已经用到了条件编译中的 &lt;code&gt;`ifdef&lt;/code&gt;。条件编译一共有 5 个关键字，分别是：&lt;code&gt;ifdef&lt;/code&gt;，&lt;code&gt;else&lt;/code&gt;，&lt;code&gt;elsif&lt;/code&gt;，&lt;code&gt;endif&lt;/code&gt;，&lt;code&gt;ifndef&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;条件编译一般在以下情况中使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择一个模块的不同部分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的时序和结构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择不同的仿真激励&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// example1&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text_macro&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example2&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text_macro&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example3&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text_macro&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`elsif&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;

&lt;span class="c1"&gt;// example4&lt;/span&gt;
&lt;span class="no"&gt;`ifndef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;text_macro&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;条件编译是一个非常好的技术，它可以帮助我们更好的管理代码。&lt;/p&gt;
&lt;p&gt;举个栗子，比如我们写了一个程序，在 debug 阶段，在程序中添加了很多显示中间变量的语句，到最后 release 时，当然要去掉这些语句。最差的方法当然是删掉这些代码，但是如果以后我们还想 debug 时，又得手动写，而且时间长了，我们自己都记不清该加哪些语句了。稍微好点的方法是把它们注释起来，但是同样，时间长了，哪些该注释，那些不该注释又混淆了。最好的方法就是用条件编译。我们可以定义一个宏 DEBUG&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;`define DEBUG&lt;/span&gt;

&lt;span class="c1"&gt;// conditional compilation&lt;/span&gt;
&lt;span class="no"&gt;`ifdef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// debug&lt;/span&gt;
&lt;span class="no"&gt;`else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// release&lt;/span&gt;
&lt;span class="no"&gt;`endif&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这样，我们只需要选择是否注释第一行的宏定义就可快速在 debug 和 release 之间切换。&lt;/p&gt;
&lt;p&gt;再比如在 Verilog 的模块中，针对不同的应用环境，我们要实现不同的模块，这时候也可以使用条件编译选择具体综合哪段代码。&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;总结一下，就是以下几点：&lt;/p&gt;
&lt;div class="admonition important"&gt;
&lt;p class="admonition-title"&gt;Important&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只有那些要求有全局作用域、并且在其他地方不会被修改的常量才用 define 来定义&lt;/li&gt;
&lt;li&gt;对于那些只限于模块内的常量，不要使用 define&lt;/li&gt;
&lt;li&gt;尽可能将所有的 define 都放在同一个文件中，然后在编译时先读取这个文件&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;`undef&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;不要使用 defparam，应该使用 named parameter redefinition。&lt;/li&gt;
&lt;li&gt;需要时使用条件编译&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;IEEE Std 1364-1995&lt;/p&gt;
&lt;p&gt;IEEE Std 1364-2001&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsHDLCON2002-Parameters-rev1-2.pdf"&gt;New Verilog-2001 Techniques for Creating Parameterized Models&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/oomusou/archive/2008/07/09/verilog-parameter.html"&gt;( 原创 ) 如何使用参数式模组 ? (SOC) (Verilog) (C/C++) (template)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.chinaaet.com/detail/14875"&gt;艾米电子 - 参数与常量，Verilog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/ilove314/blog/2012-03/231583-52a1d.html"&gt;Verilog 代码可移植性设计&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="parameterization"></category></entry><entry><title>FPGA 数字处理基础 (2)</title><link href="https://qian-gu.github.io/posts/ic/fpga-digital-processing-basic-2.html" rel="alternate"></link><published>2014-07-07T23:28:00+08:00</published><updated>2014-07-07T23:28:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-07-07:/posts/ic/fpga-digital-processing-basic-2.html</id><summary type="html">&lt;p&gt;总结 FPGA 处理数字信号的基础知识 (2)&lt;/p&gt;</summary><content type="html">&lt;p&gt;讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。&lt;/p&gt;
&lt;h2 id="basic-knowledge"&gt;Basic Knowledge&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;整数的分类：&lt;/strong&gt; 无符号数 &lt;code&gt;unsigned&lt;/code&gt; 和 有符号数 &lt;code&gt;signed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数制：&lt;/strong&gt; 10、2、8、16 进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;机器数：&lt;/strong&gt; 机器数的意思是数字在机器中的表示方式。主要有 3 种&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原码 sign-magnitude&lt;/code&gt;、&lt;code&gt;反码 one's complement&lt;/code&gt;、&lt;code&gt;补码 two's complement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以前写过的一篇总结： &lt;a href="http://qian-gu.github.io/posts/cs/signed-number-representations.html"&gt;原码、反码、补码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机系统：&lt;/strong&gt; 采用二进制、补码系统。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;FPGA 中是如何表示数字的呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以前写过一篇总结，&lt;a href="http://qian-gu.github.io/posts/ic/fpga-digital-processing-basic-1.html"&gt;FPGA 数字处理基础 (1)&lt;/a&gt;，本文算是续。&lt;/p&gt;
&lt;h2 id="unsigned-in-verilog"&gt;(un)signed in Verilog&lt;/h2&gt;
&lt;h3 id="integer"&gt;Integer&lt;/h3&gt;
&lt;p&gt;标准格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;null|+|-&amp;gt;&amp;lt;size&amp;gt;&amp;lt;sign:s|S&amp;gt;&amp;lt;base:d|D|h|H|o|O|b|B&amp;gt;&amp;lt;0~9|0～f|0~7|0~1|x|z&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中 size 和 base 可选。&lt;/p&gt;
&lt;p&gt;所以就有两个格式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一串 0～9 组成的数字，前面可能有 +/- 符号，默认解释为有符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;size&amp;gt;'&amp;lt;s&amp;gt;&amp;lt;base&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt;，默认是无符号数，除非明确使用 &lt;code&gt;s&lt;/code&gt; 字段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个参数 size 表示用多少个 bit 来存储这个整数，这个参数的取值应该是一个非 0 的无符号十进制数。若没有给出，默认最小是 32 bit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数 s 表示这个数是有符号数，这个字段只影响编译器如何解释这个数。若没有这个字段，则将这个数解释为无符号数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数 base 表示使用什么进制来表示这个数，若没有给出，默认是十进制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四个参数 value 表示这个数的大小，取值应该是一个无符号的符合 base 的数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;在 FPGA 也采用补码系统&lt;/strong&gt;，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d5&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// 占用 4 bit，存储的值为无符号数  5 的原码 0101，综合工具将其视为无符号数 5&lt;/span&gt;
&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 占用 4 bit，存储的值为无符号数  5 的原码 0101，综合工具将其视为有符号数 +5&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d5&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 占用 4 bit，存储的值为有符号数 -5 的补码 1011，综合工具将其视为无符号数 11&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// 占用 4 bit，存储的值为 1011&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="register"&gt;Register&lt;/h3&gt;
&lt;p&gt;Verilog 中数据的基本类型： &lt;code&gt;wire&lt;/code&gt;、&lt;code&gt;reg&lt;/code&gt;、&lt;code&gt;integer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的 ( 与宿主机的字是一样的，最小为 32 位 )，这样子，造成了很大的不方便和浪费。&lt;/p&gt;
&lt;p&gt;在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;以变量类型为准&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 &lt;code&gt;-5&lt;/code&gt;(&lt;code&gt;-4’d5&lt;/code&gt;) 时，综合出来的结果为 reg 存储的是 &lt;code&gt;-5&lt;/code&gt; 的补码 &lt;code&gt;1011&lt;/code&gt;, 但是解释为 unsigned 类型的 &lt;code&gt;+11&lt;/code&gt;。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。( 应该避免这种情况 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下为详细的分类讨论。&lt;/p&gt;
&lt;p&gt;编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;module: &lt;a href="/files/test-signed.v"&gt;test-signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;testbench: &lt;a href="/files/tb-test-signed.v"&gt;tb_test_signed.v&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id="1-unsigned-reg-unsigned-value"&gt;1. unsigned reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4 id="2-unsigned-reg-signed-value"&gt;2. unsigned reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;那么综合出来的比较器是 unsigned 类型。&lt;/p&gt;
&lt;h4 id="3-signed-reg-signed-value"&gt;3. signed reg &amp;amp; signed value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;赋值为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sd10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4 id="4-signed-reg-unsigned-value"&gt;4. signed reg &amp;amp; unsigned value&lt;/h4&gt;
&lt;p&gt;定义 reg 为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;赋值为 unsigned 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;那么综合出来的比较器是 signed 类型。&lt;/p&gt;
&lt;h4 id="5-signed-reg-unsigned-reg"&gt;5. signed reg &amp;amp; unsigned reg&lt;/h4&gt;
&lt;p&gt;如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的）&lt;/p&gt;
&lt;p&gt;定义 i 为 unsigned 类型，flag 为 signed 类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// unsigned&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="k"&gt;signed&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// signed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;给 flag 赋值为 signed 的 -5&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// sigend&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;综合出来的比较器为 unsigned 类型。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具 (XST) 也是支持的。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;以前只知道硬件上最基本的一些运算单元，比如加法器 (adder)、减法器 (subtractor)、比较器 (comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元 ( 比如加法器 )，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。&lt;/p&gt;
&lt;p&gt;所以可以推断出 &lt;strong&gt;对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？&lt;/p&gt;
&lt;p&gt;答案是肯定的，即&lt;strong&gt;综合器足够智能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 &lt;a href="http://www.xilinx.com/support/documentation/sw-manuals/xilinx14-7/xst.pdf"&gt;UG627(v14.5): XST User Guide&lt;/a&gt;，才发现里面已经非常清楚地写着&lt;/p&gt;
&lt;p&gt;Chapter 3: Signed and Unsigned Support in XST&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When using Verilog or VHDL in XST, some macros, such as adders or counters, can be implemented for signed and unsigned values.&lt;/p&gt;
&lt;p&gt;To enable support for signed and unsigned values in Verilog, enable Verilog-2001 as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ISE® Design Suite
  Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite Help&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST Command Line
  Set -verilog2001 to yes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.=&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;说了这么多，总结下来就是下面这几句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;知识：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合时的原则是按照寄存器的类型进行综合 ( 即上面的分类讨论的结论 )。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 “ 理论上硬件电路是应该不一样 ” 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="IC"></category><category term="digital processing"></category></entry><entry><title>扩展 ST2 Verilog 插件的 snippet</title><link href="https://qian-gu.github.io/posts/tools/extend-verilog-snippet-in-st2.html" rel="alternate"></link><published>2014-07-04T23:31:00+08:00</published><updated>2014-07-04T23:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-07-04:/posts/tools/extend-verilog-snippet-in-st2.html</id><summary type="html">&lt;p&gt;给 Sublime Text 插件添加新的 snippet&lt;/p&gt;</summary><content type="html">&lt;p&gt;ST2 常用的插件，比如括号匹配、智能补全、自动对齐、Tags、注释生成、Terminal、Build、Git 等插件就不再赘述了，说一下网上介绍的比较少，但我自己使用比较多的关于 Verilog 的插件。&lt;/p&gt;
&lt;p&gt;可以通过 Package 下载到两个插件，&lt;code&gt;Verilog&lt;/code&gt; 和&lt;code&gt;Verilog-Automatic&lt;/code&gt;。第一个插件主要功能是支持 Verilog 的代码高亮和补全，第二个插件可以帮助我们自动生成模块例化、端口添加连接等功能。&lt;/p&gt;
&lt;p&gt;其中，第一个插件的 snippet 并不太让人满意，在原 snippet 的基础上，我添加了一些我常用到的 snippet。&lt;/p&gt;
&lt;h2 id="always"&gt;always&lt;/h2&gt;
&lt;p&gt;因为插件作者只添加了异步高有效复位方式的 &lt;code&gt;always&lt;/code&gt; 块，而我们同步和异步两种方式都可能会用到，所以，我添加同步复位的 Snippet&lt;/p&gt;
&lt;p&gt;ST 2 的 Package 都存放在 &lt;code&gt;/home/.config/sublime-text-2/Packages&lt;/code&gt; 目录下面，我们需要修改的就是这个目录下的 &lt;code&gt;Verilog/Snippets&lt;/code&gt; 下的 &lt;code&gt;.tmSnippet&lt;/code&gt; 文件。修改后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;always-async.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always&lt;span class="w"&gt; &lt;/span&gt;@(posedge&lt;span class="w"&gt; &lt;/span&gt;clk&lt;span class="w"&gt; &lt;/span&gt;or&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;posedge&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;    &lt;/span&gt;if&lt;span class="w"&gt; &lt;/span&gt;($2)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;reset
&lt;span class="w"&gt;        &lt;/span&gt;$3
&lt;span class="w"&gt;    &lt;/span&gt;end
&lt;span class="w"&gt;    &lt;/span&gt;else&lt;span class="w"&gt; &lt;/span&gt;if&lt;span class="w"&gt; &lt;/span&gt;($4)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$0
&lt;span class="w"&gt;    &lt;/span&gt;end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always-async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always-async&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;always-sync.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always&lt;span class="w"&gt; &lt;/span&gt;@(posedge&lt;span class="w"&gt; &lt;/span&gt;clk)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;    &lt;/span&gt;if&lt;span class="w"&gt; &lt;/span&gt;(&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;reset
&lt;span class="w"&gt;        &lt;/span&gt;$2
&lt;span class="w"&gt;    &lt;/span&gt;end
&lt;span class="w"&gt;    &lt;/span&gt;else&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$0
&lt;span class="w"&gt;    &lt;/span&gt;end
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always-sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;always-sync&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改之后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="always" src="/images/extend-verilog-snippet-in-st2/always.gif"&gt;&lt;/p&gt;
&lt;h2 id="if-else"&gt;if-else&lt;/h2&gt;
&lt;p&gt;原来的 if snippet 没有 else 分支，所以，添加了一个有 else 分支的 if 语句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="w"&gt; &lt;/span&gt;($1)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;    &lt;/span&gt;$0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;if-else.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if&lt;span class="w"&gt; &lt;/span&gt;($1)&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;    &lt;/span&gt;$2
end
else&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;    &lt;/span&gt;$0
end&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if-else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;if-else&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改后的结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="if-else" src="/images/extend-verilog-snippet-in-st2/if_else.gif"&gt;&lt;/p&gt;
&lt;h2 id="parameter"&gt;parameter&lt;/h2&gt;
&lt;p&gt;原来是没有 parameter 的 snippets 的，拷贝一份其他的 snippet，修改其中的一些设置，即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parameter.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="w"&gt;   &lt;/span&gt;$1&lt;span class="w"&gt; &lt;/span&gt;=&lt;span class="w"&gt; &lt;/span&gt;$2,
&lt;span class="w"&gt;            &lt;/span&gt;$3&lt;span class="w"&gt; &lt;/span&gt;=&lt;span class="w"&gt; &lt;/span&gt;$0
&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;parameter&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;1ADE2F84-DDB8-4878-8BFC-B7FC2F391C6C&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改后的结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="parameter" src="/images/extend-verilog-snippet-in-st2/parameter.gif"&gt;&lt;/p&gt;
&lt;h2 id="case"&gt;case&lt;/h2&gt;
&lt;p&gt;原来是没有 case 的 snippet，方法同上，可以修改出我们想要的 case snippet&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;case.tmSnippet&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/Prop    ertyList-1.0.dtd&amp;quot;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;content&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="w"&gt; &lt;/span&gt;($1)
&lt;span class="w"&gt;    &lt;/span&gt;$2:&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$3
&lt;span class="w"&gt;    &lt;/span&gt;end
&lt;span class="w"&gt;    &lt;/span&gt;$4:&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$5
&lt;span class="w"&gt;    &lt;/span&gt;end
&lt;span class="w"&gt;    &lt;/span&gt;$6:&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$7
&lt;span class="w"&gt;    &lt;/span&gt;end
&lt;span class="w"&gt;    &lt;/span&gt;$8:&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$9
&lt;span class="w"&gt;    &lt;/span&gt;end
&lt;span class="w"&gt;    &lt;/span&gt;default:&lt;span class="w"&gt; &lt;/span&gt;begin
&lt;span class="w"&gt;        &lt;/span&gt;$10
&lt;span class="w"&gt;    &lt;/span&gt;end
endcase&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;source.verilog&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;tabTrigger&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;case&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;026B3DA6-E1B4-4F09-B7B6-9485ADEF34DC&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="case" src="/images/extend-verilog-snippet-in-st2/case.gif"&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="Sublime Text"></category><category term="verilog"></category></entry><entry><title>FPGA 中的复位设计</title><link href="https://qian-gu.github.io/posts/ic/the-art-of-reset-design-in-fpga.html" rel="alternate"></link><published>2014-06-20T00:22:00+08:00</published><updated>2014-06-20T00:22:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-06-20:/posts/ic/the-art-of-reset-design-in-fpga.html</id><summary type="html">&lt;p&gt;总结 FPGA 中的复位设计&lt;/p&gt;</summary><content type="html">&lt;p&gt;复位信号在系统中的地位和时钟信号几乎同等重要，我们想尽量把系统设计为可控，那么最基本的控制信号就是复位信号了。&lt;/p&gt;
&lt;p&gt;复位信号的设计需要考虑的因素，各种书刊、论文、白皮书、网上论坛都有相关讨论，但是至今对于给定 FPGA 设计中使用哪种复位方案仍然没有明确答案。本文总结了一些大神的经典论文和网上的许多博客，尽可能用简单的图说明选择某种设计方案及其理由，涉及的更深入的原理请自行 Google :-P&lt;/p&gt;
&lt;h2 id="understanding-the-flip-flop-reset-behavior"&gt;Understanding the flip-flop reset behavior&lt;/h2&gt;
&lt;p&gt;在开始详细讨论之前，首先得理解 FPGA 的基本单元 Slice 中的 FF 的复位方式。Xilinx 的 Virtex 5 系列的芯片中的 FF 的类型都是 DFF (D-type flip flop)，这些 DFF 的控制端口包括一个时钟 CLK，一个高有效的使能 CE，一个高有效的置位 / 复位 SR。这个 SR 端口可以配置为同步的置位 / 复位，也可以配置为异步方式的置位 / 复位。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="dff" src="/images/the-art-of-reset-design-in-fpga/dff.jpg"&gt;&lt;/p&gt;
&lt;p&gt;例化（&lt;code&gt;instantiation&lt;/code&gt;）和 推译（&lt;code&gt;inference&lt;/code&gt;）是在 FPGA 设计中使用元件的两种不同方法。综合器是通过 HDL 代码 推译（&lt;code&gt;infer&lt;/code&gt;） 最终的电路，所以我们写的 RTL 代码风格会影响最终综合出来的 FF 类型。&lt;/p&gt;
&lt;p&gt;如果代码的敏感列表中包含复位信号，那么就会综合出一个异步复位的 DFF，SR 端口将被配置为置位或者复位端口 (FDPE &amp;amp; FDCE primitive)。当 SR 变高时，FF 的输出值立即变为代码中的复位时设定的值 SRVAL。&lt;/p&gt;
&lt;p&gt;同理，如果代码的敏感列表中不包含复位信号，那么就会综合出一个同步复位的 DFF，SR 端口将被配置为置位 / 复位端口 (FDSE &amp;amp; FDRE primitive)。当 SR 变高时，FF 的输出值在下一个时钟的上升沿变为 SRVAL。&lt;/p&gt;
&lt;p&gt;虽然 FPGA 的 FF 可以配额为 preset/clear/set/reset 等不同的结构，但是在实现时，只能配置为其中的一种，如果在代码中多于一个 preset/clear/set/reset，那么就会产生其他的逻辑，消耗 FPGA 资源。&lt;/p&gt;
&lt;p&gt;另外，基于 SRAM 的 FPGA 可以设定上电初始化的值：如果我们在定义 reg 变量时给它一个初始值，那么 FPGA 在上电配置 (GSR 变高 ) 时，载入这个值。&lt;/p&gt;
&lt;h2 id="active-low-vs-active-high"&gt;Active low  V.S.  Active high&lt;/h2&gt;
&lt;p&gt;大多数书籍和博客都推荐使用 “ 低电平有效 ” 的复位方案，却没有明确说明为什么使用 “ 低电平有效 ”。&lt;/p&gt;
&lt;p&gt;目前大多数书籍中都使用 低电平复位，网上给出的理由是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ASIC 设计大多数是低电平复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大多数厂商使用低电平复位多一些 (Xilinx 基本全是高电平复位，这也叫大多数？)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低电平复位方式，在上电时系统就处于复位状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3919870/"&gt;Verilog Verilog 嵌入式数字系统设计教程&lt;/a&gt; 说明了原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One reason for using active-low logic is that some kinds of digital circuits are able to sink more current when driving an output low than they can source when driving the output high. If such an output is used to activate some condition for which current flow is required, it would be better to use a low logic level rather than a high logic level.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说目前推荐的 “ 低电平有效 ” 更多的是 IC 设计的传统，然而根据我查到资料来看，对于 Xilinx FPGA 这条传统并不适用。Xilinx 的器件全部是高电平复位端口，他们的 white paper 中的例子也都是高电平复位方式。而且，从综合结果来看，如果非要使用低电平复位，那么就会额外添加一个反相器，然后将反向得到的高电平连接到 FF 的复位端口，从而导致复位信号的传输时延增加，芯片的利用率下降，同时会影响到时序和功耗。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc-id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 中也证实了这一点，文中提到对于 Xilinx 器件，尽可能使用高有效复位，如果实在没有办法控制系统的复位极性，那么最好在系统的顶层模块中将输入的低有效复位翻转极性，这样做的好处是反向器将被吸收到 IO logic 中，不会消耗 FPGA 内的逻辑和布线资源。&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="synchronous-vs-asynchronous"&gt;Synchronous V.S. Asynchronous&lt;/h2&gt;
&lt;p&gt;因为 DFF 有两种复位端口，所以对应的有两种复位方式：同步复位 和 异步复位。两种复位方式各有特点，适用于不同的应用场景。下面先分别总结两种方案的优劣，最后总结当前流行的的主流复位方案。&lt;/p&gt;
&lt;h3 id="synchronous-reset"&gt;Synchronous Reset&lt;/h3&gt;
&lt;h4 id="coding-style"&gt;Coding Style&lt;/h4&gt;
&lt;p&gt;同步复位的假设前提：只有在时钟信号的有效沿，复位信号才能影响寄存器的状态。&lt;/p&gt;
&lt;p&gt;通常把 reset 信号作为组合逻辑的一部分连接到寄存器输入端口 D，从而对寄存器起作用。因此同步复位的 coding style 应该是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块的 &lt;code&gt;sensitivity list&lt;/code&gt; 中不包含 &lt;code&gt;rst&lt;/code&gt; 信号，并且 reset 信号应该在 if-else 的最前面（if 分支），以便于优先考虑，其他组合逻辑位于后面（else 分支）。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;对应的 RTL Schematic 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sync reset" src="/images/the-art-of-reset-design-in-fpga/sync_reset.png"&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdr&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Singal Data Rate D Flip-Flop with Synchronous Reset and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// FDRE: Single Data Rate D Flip-Flop with Synchronous Reset and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="n"&gt;FDRE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FDRE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Synchronous reset input&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDRE-inst instantiation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;有时候，有些器件不带同步复位专用端口，那么综合器一般会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;h4 id="problem"&gt;Problem&lt;/h4&gt;
&lt;p&gt;如果没有遵守这样的 coding style，可能会引起下面的两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在一些基于逻辑表达式计算的仿真器上，一些逻辑可能会阻止复位信号作用到寄存器上&lt;/p&gt;
&lt;p&gt;注意：只存在于仿真器的问题，硬件上没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于时钟信号而言，因为复位树（reset tree）上有着非常高的扇出，所以复位信号可能是一个晚到底信号（late arriving signal）&lt;/p&gt;
&lt;p&gt;明智之举是：即使在复位树上加入 buffer，一旦复位信号进入到局部逻辑区域（local logic），那么就要限制复位信号到达寄存器所经历的逻辑数量，以减少延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用同步复位还有一个问题是：&lt;/p&gt;
&lt;p&gt;综合工具无法很轻松地从其他逻辑信号中识别出复位信号。（这可能导致一些仿真的问题，注意只是仿真问题，实际电路会正常工作，正确复位）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;solution:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;synposys 提供了综合指令 &lt;code&gt;sync-set-reset&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// synposys sync-set-reset &amp;quot;rst&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这个指令的作用是告诉综合工具指定的信号是同步 set/reset，那么综合工具就会尽量把这个信号放在靠近寄存器的位置，以防前面说仿真问题。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通常，只有在综合指令是不许的而且是紧要的时候，我们才使用它们。&lt;/strong&gt;我们应该遵守这一原则，因为综合指令的使用可能导致前后仿真的不一致。&lt;/p&gt;
&lt;p&gt;但是 &lt;code&gt;sync-set-reset&lt;/code&gt; 是个例外情况，因为它不会影响逻辑行为，只影响设计的功能实现。&lt;/p&gt;
&lt;p&gt;所以明智的设计者在项目开始的时候就把 &lt;code&gt;sync-set-reset&lt;/code&gt; 添加到 RTL 代码中，以避免以后的多次综合。由于每个模块对这条指令只要求使用一次（模块只有一个复位信号），所以推荐为每个模块添加这条指令。&lt;/p&gt;
&lt;p&gt;如果觉得每个模块都添加这种方式太繁琐，还有另外一种方法：在读取 RTL 代码前，设置综合变量 &lt;code&gt;hdlin-ff-always-sync-set-reset&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;，可以达到同样的效果。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="advantage"&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证设计是 100% 同步，有利于时序分析，也利于仿真&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低亚稳态出现的几率，时钟起到过滤毛刺的作用 ( 如果毛刺发生在时钟沿附近，那么仍然会出现亚稳态的问题 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些设计中，复位信号是由内部逻辑产生的，推荐使用同步复位，因为这样可以避免逻辑产生的毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="disadvantage"&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;并不是所有的 ASIC 库里面都有带同步复位端的寄存器，不过这个问题并不严重，因为同步复位信号只是另外一个数据输入信号，所以综合工具很容易把复位信号综合到寄存器外部的逻辑中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步复位需要保证复位信号具有一定的脉冲宽度 (pulse stretcher)，使其能被时钟沿采样到，尤其是多时钟域的设计中。这是需要重点考虑到，可以使用一个小岛计数器，以保证复位脉冲信号保持一定数量的时钟周期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在仿真过程中，同步复位信号可能被 X 态掩盖 (? 不懂 ...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步复位信号需要时钟信号正常工作。在一些设计中这个条件可能不是问题，但是在一些设计中就比较让人恼火了。比如，为了节省功耗使用了门控时钟（gated clock），在复位信号有效时，时钟信号还处于禁止状态（disabled），而在时钟恢复时，复位信号已经被撤销了。这种情况就会导致电路无法复位（异步复位则无此问题）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设计中含有三态总线，为了防止三态总线的竞争，同步复位的芯片必须有一个上电异步复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果逻辑器件的目标库内的 FF 只有异步复位端口，那么使用同步复位的话，综合器会将复位信号综合为输入信号的使能信号，这时候就需要额外的逻辑资源了。&lt;/p&gt;
&lt;p&gt;有很多教材和博客都直接说 “ 同步复位会产生额外的逻辑资源 ”，可能他们是基于 Altera 的 FPGA 这么做的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="extra logic" src="/images/the-art-of-reset-design-in-fpga/extra_logic.png"&gt;&lt;/p&gt;
&lt;p&gt;但是根据我实际的测试结果，对于 Virtex 5 系列的芯片，它的原语里面已经含有各种带同步、异步复位端口的 FF，ISE 自带的 XST 也已经很智能了，它会根据代码分析，自动选择合适的 FF。所以上面同步复位综合出来的 RTL Schematic 中没有所谓的 “ 多余的逻辑资源 ”。&lt;/p&gt;
&lt;p&gt;所以，是否占用多余的资源，还得针对具体的芯片分析。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="asynchronous"&gt;Asynchronous&lt;/h3&gt;
&lt;h4 id="coding-style_1"&gt;Coding Style&lt;/h4&gt;
&lt;p&gt;虽然异步复位信号是电平有效，但是敏感列表必须在异步复位信号的前沿激活：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;对应的 RTL Schematic 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="aync reset" src="/images/the-art-of-reset-design-in-fpga/async_reset.png"&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;fdc&lt;/code&gt; 是 Xilinx 的原语，表示 &lt;code&gt;Single Data Rate D Flip-Flop with Asynchronous Clear and Clock Enable (posedge clk)&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// FDCE: Single Data Rate D Flip-Flop with Asynchronous Clear and&lt;/span&gt;
&lt;span class="c1"&gt;//       Clock Enable (posedge clk).&lt;/span&gt;
&lt;span class="c1"&gt;//       All families.&lt;/span&gt;
&lt;span class="c1"&gt;// Xilinx HDL Language Template, version 13.3&lt;/span&gt;

&lt;span class="n"&gt;FDCE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;#(&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;// Initial value of register (1&amp;#39;b0 or 1&amp;#39;b1)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FDCE&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Q&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Data output&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Clock input&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CE&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Clock enable input&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CLR&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Asynchronous clear input&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// 1-bit Data input&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// End of FDCE-inst instantiation&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="problem_1"&gt;Problem&lt;/h4&gt;
&lt;p&gt;由于复位信号相对于时钟信号来说是异步的，所以可能导致两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;复位信号违反 recovery time&lt;/p&gt;
&lt;p&gt;recovery time 是复位信号撤销的沿到时钟有效沿之间最小的时间间隔（类似于同步信号中的 setup time），如果违反 recovery time，寄存器的输出会出现亚稳态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于不同的寄存器，复位信号的撤销（removal）可能发生在不同的时钟周期内 &lt;/p&gt;
&lt;p&gt;由于复位信号和时钟在传输延迟的轻微差别，导致有的寄存器的复位信号早于时钟信号，在时钟沿之前寄存器就被先复位；有些复位信号晚于时钟信号，在时钟沿之后寄存器才复位，从而有些寄存器先于其他寄存器退出复位状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;异步复位和同步复位是互补关系，一个的优点（缺点）即使另外一个的缺点（优点）。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id="advantage_1"&gt;Advantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单元库中肯定是包含异步复位的寄存器的，所以异步复位最大的优点是不需要额外的逻辑，可以保持数据路径（data path）的干净。这在数据路径时序很紧张的情况下非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脉冲宽度没有限制，可以快速复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有时钟的时候也可以将电路复位 ( 使用 gated clock，同步复位无法工作，而异步复位是可以的 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDA 工具 route 起来更容易，对于大型设计，能显著减少编译时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="disadvantage_1"&gt;Disadvantage&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不是同步电路，不利于时序分析，设计者要正确约束异步复位信号比同步复位复杂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复位信号容易收到毛刺的干扰，板上或者系统复位上的噪声或者毛刺会导致假的复位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步复位最大的问题是容易在复位信号的起效（assert）和失效（deassert）是异步的，起效异步没有问题，但是失效异步可能导致亚稳态。( 撤销的时候 (release) 不满足 &lt;code&gt;removal time&lt;/code&gt; 时序要求，从而产生亚稳态 )&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="reset-synchronizer"&gt;Reset Synchronizer&lt;/h3&gt;
&lt;p&gt;两种复位方式各有优缺点，设计者应该根据实际情况选择合适的复位方法。目前，很多文献书籍中都推荐一种 “ 异步复位，同步释放 ” 的方法。这种方法可以将两者结合起来，取长补短。&lt;/p&gt;
&lt;p&gt;它的原理如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer.png"&gt;&lt;/p&gt;
&lt;p&gt;需要注意到是，上图的复位是传统的低电平有效方式，对于 Xilinx 器件，原理图稍有不同，其复位按钮接到了 FF 的置位端，第一级 FF 的输入也由 &lt;code&gt;Vcc&lt;/code&gt; 变为 &lt;code&gt;GND&lt;/code&gt;。 &lt;a href="http://www.eetimes.com/document.asp?doc-id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 介绍了对应的 RTL Schematic ：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset-synchronizer-xilinx" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_xilinx.jpg"&gt;&lt;/p&gt;
&lt;p&gt;对于 Xilinx 器件，用代码具体实现&lt;/p&gt;
&lt;h4 id="coding-style_2"&gt;Coding Style&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SYSRST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sys_rst&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst_pb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;sys_rst&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst_r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;对应的 RTL Schematic 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset synchronizer" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_rtl.png"&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;rst_pb&lt;/code&gt; 是系统的复位按钮，&lt;code&gt;sys_rst&lt;/code&gt; 是同步化的结果。可以看到综合结果和上图是一致的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Simulation:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="simulation" src="/images/the-art-of-reset-design-in-fpga/reset_synchronizer_simulation.png"&gt;&lt;/p&gt;
&lt;p&gt;所谓 “ 异步复位 ”，如上图 ( 由于连接到了置位端，叫 “ 异步置位 ” 更合适 )，一旦复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 有效，那么输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 立即被置为 &lt;code&gt;1&lt;/code&gt;，否则输出为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所谓 “ 同步释放 ”。如上图，当复位信号 &lt;code&gt;rst_pb&lt;/code&gt; 释放时 ( 从有效变为无效 )，输出端口 &lt;code&gt;sys_rst&lt;/code&gt; 不是立即变化，而是被 FF 延迟了一个时钟输出，从而使其和时钟同步化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是否存在亚稳态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案：不存在。&lt;/p&gt;
&lt;p&gt;分析：第一个寄存器的输入和输出在复位变有效前后是不一致的，当复位信号很靠近时钟信号时，可能违反 recovery time，其输出可能存在亚稳态。但是到了第二个寄存器，因为它的输入和输出在复位信号有效前后是一致的，所以它的输出没有机会在两个电平之间抖动，所以不存在亚稳态。&lt;/p&gt;
&lt;p&gt;可以看到，这种 “ 异步复位，同步释放 ” 的方法既解决了同步复位对脉冲宽度的要求，又解决了异步复位可能导致的亚稳态问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Guideline:&lt;/strong&gt; Every ASIC using an asynchronous reset should include a reset synchronizer circuit!!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="conclusion_1"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;知道了这点，选择复位信号的策略就很明显了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 “ 同步化 ”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了 (CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步 / 异步复位端口 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要异步复位时，必须包含同步器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;在详细讨论了复位的有效电平、复位方式之后，我们开始讨论稍微复杂一点的复位设计：包括系统的复位方案、多时钟域的复位方案、复位信号的去除毛刺等。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="think-local-vs-think-global"&gt;Think Local V.S. Think Global&lt;/h2&gt;
&lt;p&gt;我们使用复位信号的一个目的就是为了使电路可控，当上电时或者系统出错时，可以通过复位的方式回到正常状态。为了达到完全可控，传统的做法是对系统内的每个 FF 都连接复位信号，这样就造成了复位信号的高扇出，而高扇出会导致一系列的问题。&lt;/p&gt;
&lt;p&gt;Xilinx 有个 White Paper，&lt;a href="http://www.xilinx.com/support/documentation/white-papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;，提出一种新的复位思路： 能不用全局复位时，尽量不要使用，这样可以降低复位信号的扇出。&lt;/p&gt;
&lt;p&gt;这个原则和我们平时的理解和习惯是相反的，它不使用全局复位的原因主要有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;随着时钟速率的提高，GSR 逐渐变为时序关键路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果电路中没有反馈环路，那么上电初始化已经足够了，很多设计中的 reset 信号都可以省去&lt;/p&gt;
&lt;p&gt;如果没有反馈环路，比如移位寄存器，即使开始状态是错误的，当数据流进入到一段时间，错误数据将被冲刷出去，所以没有必要保留 reset 信号。如果系统中有反馈环路，比如状态机，当初始状态不对或者状态跑飞时，无法回到正常状态，那么 reset 信号是有必要保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码中简单的添加一个 reset 端口，在底层实现时要消耗很多我们想不到的资源。&lt;/p&gt;
&lt;p&gt;全局复位会和设计中的其他单元竞争布线资源，全局复位一般来说肯定有非常高的扇出，因为它需要连接到设计中的每一个 FF。这样，它会消耗大量的布线资源，使芯片利用率下降，同时也会影响时序性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，有必要使用其他的不依靠全局复位的方法。&lt;/p&gt;
&lt;p&gt;如图所示，Xilinx FPGA 在配置 / 重配置的时候，每个 FF 和 BRAM 都会被初始化一个预先设定的值 ( 大部分器件的默认值是 0, 也有例外 )，所以，上电配置和全局复位有着类似的功能，将每个存储单元配置为一个已知的状态。&lt;/p&gt;
&lt;p&gt;&lt;img alt="configuration" src="/images/the-art-of-reset-design-in-fpga/configuration.jpg"&gt;&lt;/p&gt;
&lt;p&gt;系统在上电配置时，内部有个信号叫 &lt;code&gt;GSR&lt;/code&gt; (Global Set/Reset)，它是一种特殊的预布线的复位信号，能够在 FPGA 配置的过程中让设计保持初始状态。在配置完成后，GSR 会被释放，所有的触发器及其它资源都加载的是 INIT 值。除了在配置进程中自动使用 GSR，用户设计还可以通过实例化 STARTUP 模块并连接到 GSR 端口的方法来访问 GSR 网。使用该端口，设计者可以重新断言 GSR ，相应地 FPGA 中的所有存储元件将返回到它们的 INIT 属性所规定的状态。&lt;/p&gt;
&lt;p&gt;设定初值的语法很简单，只需要在定义变量时给它初始值就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;和 reg 类似，BRAM 也可以在配置的时候初始化，随着嵌入式系统的 BRAM 逐渐增大，BRAM 初始化非常有用：因为预先定义 RAM 的值可以使仿真更容易，而且无需使用引导序列为嵌入式设计清空内存。&lt;/p&gt;
&lt;p&gt;使用 GSR 的好处是 &lt;strong&gt;可以解决复位信号高扇出的问题&lt;/strong&gt;，因为 GSR 是预布线的资源，它不占用每个 FF 和 Latch 的 set/reset 端口，如下图所示。很多资料都推荐将设计中的 reset 按钮连接到 GSR，以利用它比较低的 skew。&lt;/p&gt;
&lt;p&gt;&lt;img alt="gsr rset" src="/images/the-art-of-reset-design-in-fpga/gsr_reset.gif"&gt;&lt;/p&gt;
&lt;p&gt;既然 GSR 这么好，那么是不是只使用 GSR 就可以了，不必再用 FF 和 Latch 的 set/reset 端口了呢？&lt;/p&gt;
&lt;p&gt;答案当然是否定的。由于 GSR 的释放是异步方式，所以，如果我们只使用 GSR 作为系统的唯一复位机制，那么可能导致系统不可靠。所以还是需要显式地使用同步复位信号来复位状态机、计数器等能自动改变状态的逻辑。&lt;/p&gt;
&lt;p&gt;所以，应该使用 &lt;strong&gt;GSR + explict reset&lt;/strong&gt; 的解决方案：&lt;/p&gt;
&lt;p&gt;给系统中的 reg 赋初值，对于没有环路的电路节省 reset，利用 GSR 实现复位的功能；对于有环路的电路，使用显示的复位信号。&lt;/p&gt;
&lt;h3 id="upate-07012014"&gt;Upate: 07/01/2014&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关于 initialize 代替 reset&lt;/p&gt;
&lt;p&gt;这几天看 resest 相关问题时，又在 &lt;code&gt;stackoverflow&lt;/code&gt; 上发现一个关于&lt;a href="http://stackoverflow.com/questions/6363130/is-there-a-reason-to-initialize-not-reset-signals-in-vhdl-and-verilog"&gt;是否应该使用 initialize 代替 reset 的问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;支持用 initialize 代替 reset 的人提出的方案是尽量不要使用全局复位信号，使用初始化值代替复位，对于一些必须要求复位的模块，使用 &lt;em&gt;local&lt;/em&gt; 的复位信号。&lt;/p&gt;
&lt;p&gt;反对者认为，用 initialize 代替 reset 的想法只是学院派的不切实际的想法。一般只有基于 SRAM 的 FPGA 才会使用到初始化。而这样做的目的只是为了节省布线资源，降低时序要求，但是现代 FPGA 有很多布线资源和没有使用的全局网络，所以，复位信号一般不是时序关键路径。即使遇到问题，可以通过手动例化一个时钟 BUF 来解决。使用这种无复位的设计虽然在某些情况是可行的，但是当你把你的设计和其他系统连接起来时，通常会感到非常痛苦，因为大多数系统都会要求有个复位信号。在由 FPGA 转 ASIC 时也比较方便，因为只有基于 SRAM 的 FPGA 才可以使用这种 initialize 代替 reset 的技术，而 ASIC 不行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于 GSR&lt;/p&gt;
&lt;p&gt;网上有很多人都推荐将我们用户定义的复位信号连接到 GSR 信号上，以便利用 GSR 提供的低抖动性，包括 &lt;a href="http://www.eetimes.com/document.asp?doc-id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 也推荐使用 GSR 信号。但是在 Xilinx 的另一份文档 &lt;a href="http://www.xilinx.com/support/documentation/sw-manuals/xilinx14-7/sim.pdf"&gt;UG626: Synthesis and Simulation Design Guide&lt;/a&gt; 中说不推荐使用 GSR 来作为系统的复位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although you can access the GSR net after configuration, Xilinx does not recommend using the GSR circuitry in place of a manual reset. This is because the FPGA devices offer high-speed backbone routing for high fanout signals such as a system reset. This backbone route is faster than the dedicated GSR circuitry, and is easier to analyze than the dedicated global routing that transports the GSR signal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个矛盾早就有人在 Xilinx Forum 上提问了 &lt;a href="http://forums.xilinx.com/t5/Virtex-Family-FPGAs/What-does-GSR-signal-really-mean-and-how-should-I-handle-the/td-p/35610"&gt;What does GSR signal really mean and how should I handle the reset signal properly&lt;/a&gt;，还有 &lt;a href="http://forums.xilinx.com/t5/Archived-ISE-issues/FPGA-Power-On-Reset/m-p/7027?query.id=134602#M2035"&gt;FPGA Power On Reset!&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="conclusion_2"&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;p&gt;P.S. 事实上没有一个通用的、适合所有器件的复位方案，我们应该首先了解所使用的器件和工具，针对它们的特点进行复位方案的设计。&lt;/p&gt;
&lt;h3 id="shift-register-reset"&gt;Shift Register Reset&lt;/h3&gt;
&lt;p&gt;并不是每一个设计，器件中的每一个寄存器都需要复位的。最好的做法是只将复位连接到那些需要复位的寄存器。一个典型特例就是移位寄存器的复位。&lt;/p&gt;
&lt;p&gt;如果一个模块内部含有一组触发器 ( 移位寄存器 )，这些寄存器可以分为两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;resetable flip-flops&lt;/p&gt;
&lt;p&gt;第一个 ff，它是需要复位信号的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;follower flip-flops&lt;/p&gt;
&lt;p&gt;后续的 ff，仅作为简单的数据移位寄存器，不含复位端&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么在设计时应该只复位第一个触发器，后续的触发器仅作为数据寄存器使用，不能对它们进行复位。
这里体现出来的一个原则就是：能节省 reset 时，尽量节省。&lt;/p&gt;
&lt;p&gt;原因就是 reset 作为一个实际存在的物理信号，需要占用 FPGA 内部的 route 资源，往往 reset 的 fanout 又多得吓人。这就很容易造成 route 难度上升，性能下降，编译时间增加。因此，在 FPGA 设计中能省略的复位应尽量省略。&lt;/p&gt;
&lt;p&gt;比较好的设计风格，不同类型的 FF 不应该组合进单个 alway 块中。也就是说，不要把这两种 FF 写在同一个 always 块中，而应该每个 &lt;code&gt;always&lt;/code&gt; 模块只对一种 FF 建模。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bad Style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BADSTYLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于第二个 ff 来说，是一个片选信号 &lt;code&gt;ce&lt;/code&gt;，这样的设计产生额外的逻辑，是不好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="bad style" src="/images/the-art-of-reset-design-in-fpga/bad_style.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Good Style:&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;GOODSTYLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;         &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;RTL Schematic:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，复位信号 &lt;code&gt;rst&lt;/code&gt; 对于两个 ff 来说，都是复位信号，不需要额外的逻辑，这样的设计是比较好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="good style" src="/images/the-art-of-reset-design-in-fpga/good_style.png"&gt;&lt;/p&gt;
&lt;h2 id="reset-distribution-tree"&gt;Reset Distribution Tree&lt;/h2&gt;
&lt;p&gt;复位信号的 &lt;code&gt;reset distribution tree&lt;/code&gt; 和 时钟信号的 &lt;code&gt;clock distribution tree&lt;/code&gt; 差不多同等重要，因为在设计中，几乎每个器件都有时钟端口和复位端口 ( 同步 / 异步 )。&lt;/p&gt;
&lt;p&gt;reset distribution tree 和 clock distribution tree 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree" src="/images/the-art-of-reset-design-in-fpga/reset_tree.png"&gt;&lt;/p&gt;
&lt;p&gt;系统中的主复位信号经过 reset distribution tree 达到每个元件，实现复位。&lt;code&gt;reset distribution tree&lt;/code&gt; 和 &lt;code&gt;clock distribution tree&lt;/code&gt; 最大的区别就是它们对 &lt;code&gt;skew&lt;/code&gt; 的要求不同。由上面的讨论可知，复位信号和时钟的关系最好是 “ 同步释放 ”，不像时钟信号的要求那么严格，复位信号之间的 skew 不需要那么严格，只要复位信号的延迟足够小，满足能在一个时钟周期内到达所有的复位负载端，并且满足各个 reg 和 flip-flop 的 &lt;code&gt;recovery time&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id="in-asic"&gt;in ASIC&lt;/h3&gt;
&lt;p&gt;在 ASIC 设计中，两种 tree 的关系有以下两种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;驱动 reset tree 最安全的方法就是使用 clock tree 的叶子节点的时钟信号来驱动，如下图所示。如果采用这种方法且时序分析是满足的，那么就没有问题。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_delayed_clock.png"&gt;&lt;/p&gt;
&lt;p&gt;分析以下情况：clock tree 中的一路叶子时钟信号驱动 &lt;code&gt;reset synchroinzer&lt;/code&gt;，得到的复位信号 masterrst-n 穿过 reset tree，输入到 DFF 的复位端口；clock tree 的另外一路叶子时钟信号直接连接 DFF 的时钟端。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;理想情况下（时钟速率不高），reset 支路即使经过 reset synchronizer 和 reset tree，仍然满足 slack 为正，满足时序，电路可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是，在大多数情况下，时钟信号的频率都比较高，这些操作产生的延时太大，无法在一个时钟周期内完成，导致 slack 为负，此时无法满足时序要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了加速 reset 信号到达系统内的 DFF，使用进入 clock tree 之前的时钟信号来驱动 reset synchronizer，如图所示。这时候 reset 和 clock 是异步的，所以必须在 &lt;code&gt;PAR&lt;/code&gt; 之后进行 &lt;code&gt;STA&lt;/code&gt;，以保证&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;若系统使用异步复位方式，则经过 reset tree 的复位信号释放 (release) 满足 &lt;code&gt;恢复时间 (recovery time)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若系统使用同步复位方式，则经过 reset tree 的复位信号满足&lt;code&gt;建立时间 (setup time)&lt;/code&gt; 和 &lt;code&gt;保持时间 (hold time)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，只有最后完成布局布线之后，才能根据具体情况进行分析调整 clock tree 和 reset tree。&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset tree driven delayed clock" src="/images/the-art-of-reset-design-in-fpga/reset_tree_parallel_clock.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;对于 synchronou/asynchronous 两种 tree，可以用两种技术来进行优化：&lt;/em&gt;&lt;/p&gt;
&lt;h4 id="synchronous-reset-distribution-tree"&gt;synchronous reset distribution tree&lt;/h4&gt;
&lt;p&gt;如下图所示，在 reset tree 中嵌入 DFF，在每个模块中，输入的 reset 信号首先经过一个 DFF，然后把经过 DFF 延迟输出的复位信号用作复位信号来复位逻辑、驱动子模块。这样 reset 信号就不必在一个时钟周期内到达每一个 DFF 的复位端口，从而可以把 reset 信号的时序要求降得很低。&lt;/p&gt;
&lt;p&gt;&lt;img alt="synchronous reset" src="/images/the-art-of-reset-design-in-fpga/synchronous_reset_distribution.png"&gt;&lt;/p&gt;
&lt;p&gt;通过这种技巧，复位信号就被当作了普通的数据信号，而且时序分析要简单的多（因为 reset tree 的每一部分 stage 都有合理的扇出）。&lt;/p&gt;
&lt;p&gt;所以每个 module 里面都含有以下代码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;code&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;reset_raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synposys sync-set-reset &amp;quot;reset&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;reset_raw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;reset_raw 是本模块的输入复位信号，reset 为经过 DFF 后的本地（local）复位信号，同时也连接子模块 reset_raw 的输入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advantage&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;降低 reset 的时序要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降低 reset 的扇出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利于时序工具分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Disadvantage&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要多个时钟周期才能复位&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="asynchronous-reset-distribution-tree"&gt;asynchronous reset distribution tree&lt;/h4&gt;
&lt;p&gt;和同步复位类似，异步复位也可以采用相同的策略，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="asynchronous reset" src="/images/the-art-of-reset-design-in-fpga/asynchronous_reset_distribution.png"&gt;&lt;/p&gt;
&lt;p&gt;利用前面讨论过的 reset synchronizer 将异步复位信号同步到每个子模块当中。&lt;/p&gt;
&lt;p&gt;和 synchronous reset 一样，在 reset tree 中加入 synchronizer 之后，复位功能需要多个时钟周期才能完成。&lt;/p&gt;
&lt;h4 id="problem_2"&gt;Problem&lt;/h4&gt;
&lt;p&gt;因为不同的子模块深度不同，所以不同模块可能不是同时复位的（同一个时钟周期）。这种情况是否会引起问题，依应用情况而定，大多数设计都没有问题，但是如果要求一定要在同一时钟周期复位，那么就要平衡不同子模块内的 synchronizer 数量，无论是 synchronous 还是 asynchronous 都是一样的。&lt;/p&gt;
&lt;h4 id="advantage_2"&gt;Advantage&lt;/h4&gt;
&lt;p&gt;前面讨论的 reset tree 和 clock tree 主要问题就是两者是异步的，一定要保证 reset 的释放满足 recovery time，在 P&amp;amp;R 之后，时序分析如果不满足的话，设计者需要手动调整时序，然后重新 P&amp;amp;R，时序分析直到满足为止。&lt;/p&gt;
&lt;p&gt;作为对比，如果采用这里插入 synchronizer 的方法，则免去了手动调整的工作，让综合工具完成时序分析和调整工作。经过调整之后，全局（global）复位信号就变为本地（local）复位信号了。（synchronous 也一样，变为 local reset）&lt;/p&gt;
&lt;h3 id="in-fpga"&gt;in FPGA&lt;/h3&gt;
&lt;p&gt;对于 FPGA，因为系统的 clock tree 是预先布线好的，而全局主复位信号一般也使用时钟布线资源，所以不存在两棵 tree 之间关系的调整问题，所以只需要采用上面的 synchronou/asynchronous reset distribution tree 即可。&lt;/p&gt;
&lt;h2 id="multi-clock-reset"&gt;Multi-clock Reset&lt;/h2&gt;
&lt;p&gt;在一个系统中，往往有多个时钟，每个时钟域都应该有独立的 synchronizer 和 reset tree，这么做的目的是为了保证每个时钟域的每个寄存器都能满足 removal time。&lt;/p&gt;
&lt;p&gt;因为只有一个全局复位的话，它与系统的时钟都没有关系，是异步复位信号，要求这个信号满足所有时钟域的 recovery 和 removal 时序不是一件容易的事情，因此为每个时钟域分配复位是有必要的。&lt;/p&gt;
&lt;p&gt;根据实际情况的不同，有两种方案可以采用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-coordinated reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于多时钟域的设计，很多时候不同时钟域之间复位信号的先后顺序没有要求，尤其是在有 &lt;code&gt;request-acknowledge&lt;/code&gt; 这样握手信号的系统中，不会引起硬件上的错误操作，这时候下图所示的方法就足够了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="non coordinated reset" src="/images/the-art-of-reset-design-in-fpga/non_coordination.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sequenced coordination of reset removal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些设计，要求复位信号的释放顺序有一定顺序，这时候应该使用下图所示的方法&lt;/p&gt;
&lt;p&gt;&lt;img alt="sequenced rcoordination" src="/images/the-art-of-reset-design-in-fpga/sequenced_coordination.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc-id=1278998"&gt;How do I reset my FPGA&lt;/a&gt; 在文中提供了一张图来说明典型的系统复位方案，图中 &lt;code&gt;MMCM&lt;/code&gt; 的 &lt;code&gt;lock&lt;/code&gt; 和外部输入的复位信号相与，目的是为了保证提供给后面的同步器的时钟信号是稳定的；每个时钟域都有一个同步器来同步复位信号。&lt;/p&gt;
&lt;p&gt;&lt;img alt="typical reset implementation in FPGA" src="/images/the-art-of-reset-design-in-fpga/typical_reset.jpg"&gt;&lt;/p&gt;
&lt;h2 id="reset-glitch-filtering"&gt;Reset Glitch Filtering&lt;/h2&gt;
&lt;p&gt;最后讨论一下复位信号毛刺的问题。&lt;/p&gt;
&lt;p&gt;使用异步复位信号时，考虑到异步复位信号对毛次比较敏感，所以在一些系统中需要处理毛次，下图显示了一种简单但是比较丑陋的方法 ( 时延不是固定的，会随温度、电压变化 )&lt;/p&gt;
&lt;p&gt;&lt;img alt="reset glitch filtering" src="/images/the-art-of-reset-design-in-fpga/reset_glitch_filtering.png"&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;毛刺 Glitch&lt;/code&gt; 是一个很重要的问题，不论是对于时钟、复位信号还是其他信号，详细讨论待续&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是所有的系统都需要过滤毛刺，设计者要先研究需求，再觉得是否使用延时来过滤毛次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;本文是读书笔记，总结了参考资料中的复位信号的设计方法和需要注意的问题，包含了底层的 DFF 复位方式、高 / 低电平有效、同步 / 异步复位、和系统级的复位方案选择、设计。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;应该参考器件决定使用那种方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于 Xilinx 器件，应该使用高电平复位方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用同步复位，保持设计 “ 同步化 ”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果器件本身是带有同步复位端口的，那么在写代码时就直接使用同步复位就可以了 (CummingsSNUG2002SJ 也说了如果如果生产商提供同步复位端口，那么使用异步复位是毫无优点的。Xilinx 就是个例子，它所有的芯片都带有同步 / 异步复位端口 )&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不带有同步复位端口，那么就需要使用异步复位同步化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应该优先选择有全局复位的设计方案，并且这个全局复位信号是用户定义的，不要使用 GSR 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;采用 synchronou/asynchronous reset distribution tree 可以降低 reset 信号的时序要求，减小扇出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个时钟域都应该有一个同步器来同步复位信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总而言之，一句话：我们想象中的，简单、统一的复位方案是 ... 不存在的 =.=&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2002SJ-Resets.pdf"&gt;Synchronous Resets? Asynchronous Resets? I am so confused! How will I ever know which to use?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG2003Boston-Resets.pdf"&gt;Asynchronous &amp;amp; Synchronous Reset Design Techniques - Part Deux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.xilinx.com/support/documentation/white-papers/wp272.pdf"&gt;Get Smart About Reset: Think Local, Not Global&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eetimes.com/document.asp?doc-id=1278998"&gt;How do I rest my FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eefocus.com/coyoo/blog/13-12/301045-9c39f.html"&gt;FPGA 复位电路的实现及其时序分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4893454/"&gt;深入浅出玩转 FPGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://item.jd.com/11337565.html"&gt;100 Power Tips for FPGA Designers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379"&gt;Advanced FPGA Design by Steve Kilts&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="reset"></category></entry><entry><title>学习 Arduino #3 Intel Galileo Linux</title><link href="https://qian-gu.github.io/posts/embedded/learn-arduino-series-3-intel-galileo-linux.html" rel="alternate"></link><published>2014-06-13T20:31:00+08:00</published><updated>2014-06-13T20:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-06-13:/posts/embedded/learn-arduino-series-3-intel-galileo-linux.html</id><summary type="html">&lt;p&gt;学习 Arduino，#3 通过 Ethernet &amp;amp; Serial Port 登录到 Galileo 上的 Linux 系统&lt;/p&gt;</summary><content type="html">&lt;h2 id="linux-on-galileo-board"&gt;Linux on Galileo Board&lt;/h2&gt;
&lt;p&gt;Galileo 不是简单的 Arduino 板子，实际上它运行着一个 Linux 操作系统。把它看作是 “ 兼容 Arduibo 接口的板子 ” 或许更合适一些。&lt;/p&gt;
&lt;p&gt;Galileo 板子上容量为 8 MB 的 SPI Flash 中已经烧写了一个精简版的 Linux 系统，因为容量的限制，这个系统去掉了一些不常用的模块，比如 wi-fi 驱动，python 支持等。&lt;/p&gt;
&lt;p&gt;Galileo 也支持从 SD 卡启动系统，并且 Intel 提供了一个基于 Yocto 项目，已经制作好的完整版 Linux 系统。当精简版系统不能满足我们的要求时（添加外设等），我们可以下载这个完整版系统镜像，烧录到 SD 卡中，并从 SD 卡中启动即可。（也可以自己基于 Yocto 项目按照自己的需求制作系统镜像）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们并不仅仅满足于通过 Arduino IDE 对 Galileo 进行操作，放着一个操作系统，为什么不去使用呢：-P 那么怎么才能登录到这个 Linux 系统中呢？&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="using-ethernet"&gt;Using Ethernet&lt;/h2&gt;
&lt;p&gt;Intel 论坛的一个帖子列举了几种登录到 Galileo Linux 的方法&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the UART connector&lt;/li&gt;
&lt;li&gt;Use the LAN connection direct to your PC&lt;/li&gt;
&lt;li&gt;Use the LAN connection and connect to your local network &lt;/li&gt;
&lt;li&gt;You can also connect using WiFi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑到我们目前有的材料&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Galileo 开发板&lt;/li&gt;
&lt;li&gt;Galileo 电源&lt;/li&gt;
&lt;li&gt;micro USB 线&lt;/li&gt;
&lt;li&gt;5 类网线&lt;/li&gt;
&lt;li&gt;运行着 Linux (Ubuntu) 的 PC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为没有串口线，所以我们采用第 2 种方案，即直接连接 PC 和 Galileo，通过 Ethernet 登录。&lt;/p&gt;
&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;
&lt;p&gt;Galileo 默认是不开启 &lt;code&gt;Lan&lt;/code&gt; 的，也不开启 &lt;code&gt;Telnet&lt;/code&gt; 服务，所以我们需要做的事就是写一个 &lt;code&gt;sketch&lt;/code&gt;，启动 Lan 连接服务和 Telnet 服务，然后分别给 PC 和 Galileo 一个属于同一子网的静态 IP 地址，这样就可以使用 PC 通过 Telnet 协议登录到 Galileo 上的 Linux 系统中。&lt;/p&gt;
&lt;h3 id="setp-1-write-sketch"&gt;Setp 1: Write sketch&lt;/h3&gt;
&lt;p&gt;代码需要完成的功能一共有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启 telnet 服务&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;telnetd -l /bin/sh&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 IP 地址&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将板子的以太网配置状态显示在 serial monitor 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;system&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ifconfig eth0 &amp;gt; /dev/ttyACM0&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全部代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kr"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// put your setup code here, to run once:&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Initial serial prot&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;Serial&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9600&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Start telnet service on board&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;telnetd -l /bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Assign the IP address &amp;#39;169.254.1.1&amp;#39; to it&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 169.254.1.1 netmask 255.255.0.0 up&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// put your main code here, to run repeatedly: &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// Show the IP detial in the serial monitor of IDE&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ifconfig eth0 &amp;amp;&amp;gt; /dev/ttyGS0 &amp;amp;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="step-2-connectupload"&gt;Step 2: Connect，Upload&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网线直连 PC 和 Galileo，设置 PC 的 IP 地址为 &lt;code&gt;link-local only&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc-ethernet-config" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_config.png"&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给 Galileo 供电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接 USB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 Arduino IDE，&lt;code&gt;Upload&lt;/code&gt; 上面的 sketch&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="step-3-login"&gt;Step 3: Login&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;打开 IDE 的 serial monitor，可以看到 Galileo 的 ethernet 配置信息&lt;/p&gt;
&lt;p&gt;&lt;img alt="galileo-ethernet-quary" src="/images/learning-arduino-series-3-intel-galileo-linux/galileo_ethernet_quary.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 PC 的网络配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;ifconfig&lt;span class="w"&gt; &lt;/span&gt;eth0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;查询结果&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc-ethernet-quary" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_ethernet_quary.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开 PC 的终端 Terminal，使用 telnet 登录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;telnet&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;169&lt;/span&gt;.254.1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;登录结果，如图&lt;/p&gt;
&lt;p&gt;&lt;img alt="pc-ethernet-login" src="/images/learning-arduino-series-3-intel-galileo-linux/pc_telnet_login.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这个精简版的 Linux 系统是不支持 Python 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="using-uart"&gt;Using UART&lt;/h2&gt;
&lt;h3 id="about-serial-port"&gt;About serial port&lt;/h3&gt;
&lt;p&gt;如果有串口线的话，我们也可以通过串口来登录，包括 SPI 和 SD 卡上的系统。&lt;/p&gt;
&lt;p&gt;关于串口线，说明一下。估计是为了节省板子的面积，Intel 在板子上设置的是音频接口 (AV jack)，所以，这里需要额外的一个将音频接口转接为串口的器件。有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上网买一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自己 DIY 一个&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果上网买的话，注意 Galileo 用的是 RS232 电平，不要买错成 TTL 电平的。如果是自己 DIY 的话，Intel Galileo Get Started 里面有介绍串口线的接法，他们的论坛上也有相关的讨论：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208448#208448"&gt;UART cable pin-out&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pinouts.ru/SerialPorts/Serial9-pinout.shtml"&gt;RS 232 DE-9 port&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="linux-platform"&gt;Linux Platform&lt;/h3&gt;
&lt;p&gt;我在 Ubuntu 下使用的终端软件是 &lt;code&gt;gtkterm&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="step-1-burn-the-full-linux-sytem"&gt;Step 1: Burn the full-linux sytem&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Intel 官网提供的完整版 Linux 镜像是基于 &lt;code&gt;Yocto&lt;/code&gt; 项目裁剪出来的，取名叫 &lt;code&gt;Claton&lt;/code&gt;，目前 (2014-6-13) 的版本号为 &lt;code&gt;1.0.0&lt;/code&gt;，但是这个版本在我的 SD 卡中是无法启动的，浪费了大量时间，最后终于发现 &lt;code&gt;0.7.5&lt;/code&gt; 版本可以 ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有就是 Get Started 中推荐不要使用 PC 操作系统提供的格式化功能，更好的选择应该是专业格式化软件，比如 &lt;code&gt;SDFormatter&lt;/code&gt;。但是我实际使用时，发现反而是 &lt;code&gt;SDFormatter&lt;/code&gt; 制作的不能启动 ...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="step-2-connect"&gt;Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;选择正确的端口（因为我使用的串口线是 &lt;code&gt;AV-RS232-USB&lt;/code&gt;，所以下面选择的端口是 &lt;code&gt;ttyUSB0&lt;/code&gt;）；&lt;code&gt;Baud Rate = 115200&lt;/code&gt;，&lt;code&gt;Bits =8&lt;/code&gt;，&lt;code&gt;Stopbits = 1&lt;/code&gt;，&lt;code&gt;Parity = none&lt;/code&gt;，&lt;code&gt;Flow control = none&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="step-3-login_1"&gt;Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_boot_information.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_grub.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_spi.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/gtkterm_login_sd_card.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="windows-platform"&gt;Windows Platform&lt;/h3&gt;
&lt;p&gt;我在 Windows 下使用的终端软件是 &lt;code&gt;Putty&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="step-1-burn-the-full-linux-system"&gt;Step 1: Burn the full-linux system&lt;/h4&gt;
&lt;p&gt;与 Linux 平台下相同。&lt;/p&gt;
&lt;h4 id="step-2-connect_1"&gt;Step 2: Connect&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入 SD 卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置串口&lt;/p&gt;
&lt;p&gt;同样，选择正确的端口和波特率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先不要接 USB 下载线，给板子上电&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="step-3-login_2"&gt;Step 3: Login&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这时候我们应该就可以从串口看到板子上电后 &lt;code&gt;grub&lt;/code&gt; 程序和系统启动的相关信息了。&lt;/p&gt;
&lt;p&gt;上电后，&lt;code&gt;grub&lt;/code&gt; 引导启动哪个系统&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm boot information" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_boot_information.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm grub" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_grub.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 SPI Flash 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，这个精简版的系统不支持 &lt;code&gt;python&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_spi.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;登录到 mirco-SD card 中的 Linux 中&lt;/p&gt;
&lt;p&gt;如图，SD 卡中的系统是支持 &lt;code&gt;python&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img alt="gtkterm login spi" src="/images/learning-arduino-series-3-intel-galileo-linux/putty_login_sd_card.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="another-method"&gt;Another method&lt;/h2&gt;
&lt;p&gt;如果你觉得插网线、配置 IP 地址太麻烦，甚至懒得自己 DIY 串口线，也没有钱去买一个，别担心，因为 “ 天空飘来五个字，这都不是事～” 因为你可以借鉴下面这位大神的方法，只需要像下载普通 sketch 一样，将他提供的 sketch 下载到 Galileo 中就可以了，然后通过 IDE 的 serial monitor 就可以登录到 Linux 系统中：&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;他的 sketch 的原理就是使用 &lt;code&gt;system()&lt;/code&gt; 函数将我们在 serial monitor 中的命令传到到 Linux shell 中 ，并将命令的结果返回到 serial monitor 中 。&lt;/p&gt;
&lt;p&gt;不过这种方法的缺点是每个命令传递到 Galileo 后会开辟一个新的进程，当命令执行完返回结果时，这个进程自动结束，所以会产生一些 “ 问题 ”：当我们 &lt;code&gt;cd&lt;/code&gt; 到某个子目录后，返回结果之后，我们又回到的之前的目录，举例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;home
$&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;

//&lt;span class="w"&gt; &lt;/span&gt;result&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;dirctory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;解决方法就是将命令写在一行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;home&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt;

//&lt;span class="w"&gt; &lt;/span&gt;result&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;home&lt;span class="w"&gt; &lt;/span&gt;directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/thread/46335"&gt;Connecting to Galileo via Linux Console&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/docs/DOC-22293"&gt;Tutorial 3: Connecting to Linux through telnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/message/208564#208564"&gt;Using Galileo Linux over Ethernet(Telnet)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="(https://communities.intel.com/message/222211)"&gt;Poor man's telnet for Galileo&lt;/a&gt;&lt;/p&gt;</content><category term="Embedded"></category><category term="Arduino"></category><category term="Linux"></category></entry><entry><title>有限状态机 FSM 设计</title><link href="https://qian-gu.github.io/posts/ic/fsm-design.html" rel="alternate"></link><published>2014-06-05T17:55:00+08:00</published><updated>2014-06-05T17:55:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-06-05:/posts/ic/fsm-design.html</id><summary type="html">&lt;p&gt;博客搬家，温故而知新。&lt;/p&gt;</summary><content type="html">&lt;p&gt;有限状态机是数字电路中经常出现、非常重要的电路，设计一个安全、高效的状态机有一套程序化的方法，我们在数字电路课中就学习过了。总结一下相关知识，温故而知新～&lt;/p&gt;
&lt;h2 id="what-is-fsm"&gt;What is FSM&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Finite-state-machine"&gt;FSM on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有限状态机 (Finite State Machine, FSM)&lt;/strong&gt; 有时候也简称为&lt;strong&gt;状态机 (state machine)&lt;/strong&gt;，它是一种数学模型，通常用来设计电脑程序或者时序电路。它被构思设计为一个抽象的机器，并且某个时刻只能处于一个有限数字代表的状态之下。&lt;/p&gt;
&lt;p&gt;有限状态自动机在很多不同领域中是重要的，包括电子工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机是在自动机理论和计算理论中研究的一类自动机。在计算机科学中，有限状态机被广泛用于建模应用行为、硬件电路系统设计、软件工程，编译器、网络协议、和计算与语言的研究。( 这里讨论的只限于电子工程里的状态机 )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组成元素：&lt;/strong&gt;输入、状态、状态转移条件、输出&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态转移图&lt;/li&gt;
&lt;li&gt;状态转移表&lt;/li&gt;
&lt;li&gt;HDL 描述&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;状态机的框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/fsm.png"&gt;&lt;/p&gt;
&lt;p&gt;按照输出的产生方式，可以将状态机分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Moore-machine"&gt;Moore&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它的输出只取决于当前状态，而与输入无关。Moore 状态机最重要的特点就是将输入与输出信号隔离开来，而且输出与时钟信号同步的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Mealy-machine"&gt;Mealy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;它的输出不仅和当前状态有关，而且和输入也有关。Mealy 有限状态机对输入的响应发生在当前时钟周期，比 Moore 有限状态机对输入信号的响应要早一个周期。因此，输入信号的噪声可能影响在输出的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="how-to-design-a-fsm"&gt;How to Design a FSM&lt;/h2&gt;
&lt;p&gt;关于如何设计一个状态机，这在数字电路和逻辑设计的书里有详细介绍。简单地总结一下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑抽象，建立原始状态转移图：确定输入、输出、状态变量、画状态转移图&lt;/li&gt;
&lt;li&gt;状态简化，得到最简的状态转移图 ( 卡诺图 )&lt;/li&gt;
&lt;li&gt;状态分配，选择编码方案 (Binary、Gray、One-Hot)&lt;/li&gt;
&lt;li&gt;画逻辑图，检查能否自启动，得到了最终的状态机模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="how-to-implement-a-fsm"&gt;How to implement a FSM&lt;/h2&gt;
&lt;p&gt;当设计好之后，就要使用 HDL 语言来实现这个 FSM 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言：&lt;/strong&gt; Verilog HDL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综合工具：&lt;/strong&gt; XST (Xilinx Synthesis Tools)&lt;/p&gt;
&lt;h3 id="coding-goals"&gt;Coding goals&lt;/h3&gt;
&lt;p&gt;我们的代码需要达到的目的应该是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The FSM coding style should be easily modified to change state encodings and FSM styles&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should be compact&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should be easy to code and understand&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should facilitate debugging&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The coding style should yield efficient synthesis results&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id="template"&gt;Template&lt;/h3&gt;
&lt;p&gt;为了达到目的，总结出了下面的这个三段式的模板（使用 index one-hot + reverse case + synopsys FSM 语法）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;
&lt;span class="normal"&gt;59&lt;/span&gt;
&lt;span class="normal"&gt;60&lt;/span&gt;
&lt;span class="normal"&gt;61&lt;/span&gt;
&lt;span class="normal"&gt;62&lt;/span&gt;
&lt;span class="normal"&gt;63&lt;/span&gt;
&lt;span class="normal"&gt;64&lt;/span&gt;
&lt;span class="normal"&gt;65&lt;/span&gt;
&lt;span class="normal"&gt;66&lt;/span&gt;
&lt;span class="normal"&gt;67&lt;/span&gt;
&lt;span class="normal"&gt;68&lt;/span&gt;
&lt;span class="normal"&gt;69&lt;/span&gt;
&lt;span class="normal"&gt;70&lt;/span&gt;
&lt;span class="normal"&gt;71&lt;/span&gt;
&lt;span class="normal"&gt;72&lt;/span&gt;
&lt;span class="normal"&gt;73&lt;/span&gt;
&lt;span class="normal"&gt;74&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synopsys state-vector state&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// synopsys full-case parallel-case&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// default output&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是 synopsys FSM 的语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;parameter 定义的两端都要定义位宽，不能省略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释 &lt;code&gt;// synopsys ...&lt;/code&gt; 的位置不能随意改变&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即使改用其他的综合工具，前面的 FSM 定义的综合指令不影响，需要修改的只有 case 综合指令（如 XST 改为 &lt;code&gt;// synthesis full-case parallel-case&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;下面逐个讨论为什么这么写，以及需要注意的问题。&lt;/p&gt;
&lt;h3 id="always-block"&gt;Always Block&lt;/h3&gt;
&lt;p&gt;状态机一般有三种写法，他们在速度、面积、代码可维护性等各个方面互有优劣。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一段式：&lt;/strong&gt; 只有一个 always block，把所有的逻辑（输入、输出、状态）都在一个 always block 中实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：看起来很简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：不利于维护，如果状态复杂一些就很容易出错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不推荐这种方法，但是在简单的状态机可以使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二段式：&lt;/strong&gt; 有两个 always block，把时序逻辑和组合逻辑分隔开来。时序逻辑里进行当前状态和下一状态的切换，组合逻辑实现各个输入、输出以及状态判断。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：便于阅读、理解、维护，而且利于综合器优化代码，利于用户添加合适的时序约束条件，利于布局布线器实现设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：输出是组合逻辑，可能含有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决输出毛刺的问题，最简单的方法就是用寄存器打一拍，但很多情况不允许插入寄存器节拍，此时使用三段式描述。其优势在于能够根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而不需要额外插入时钟节拍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三段式：&lt;/strong&gt; 有三个 always block，一个时序逻辑采用同步时序的方式描述状态转移，一个采用组合逻辑的方式判断状态转移条件、描述状态转移规律，第三个模块使用同步时序的方式描述每个状态的输出。这 3 个 always block 正好对应图示的 3 个子模块，更加容易理解。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：代码容易维护，时序逻辑的输出解决了两段式组合逻辑的毛刺问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点： 代码量大、资源消耗多一些&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一段 or 三段？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般来说，三段式的效果更好，唯一的缺点是占用的资源稍微多一点 ( 对于拥有丰富的触发器资源的 FPGA 来说，这个缺点可以忽略吧 )。所以除非是非常简单的状态机用一段式实现，其他情况下三段式更简单。&lt;/p&gt;
&lt;h3 id="localparam"&gt;localparam&lt;/h3&gt;
&lt;p&gt;尽量使用 &lt;code&gt;localparam&lt;/code&gt; 而不是 &lt;code&gt;define&lt;/code&gt; 和 &lt;code&gt;parameter&lt;/code&gt;。这个原则不仅仅限于 FSM，其他模块也应该遵守。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reason&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;define&lt;/code&gt;：在设计中很可能有多个 FSM，而且它们很可能包含有相同的状态名，使用 &lt;code&gt;define&lt;/code&gt; 定义的状态名是全局可见的，那么这些 FSM 之间会相互影响（C++ 解决这个问题的方法是 namespace）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不使用 &lt;code&gt;parameter&lt;/code&gt;：虽然 &lt;code&gt;parameter&lt;/code&gt; 定义的参数是局部的，但是它可以被其他模块通过参数修改。FSM 中的状态定义应该是内部可见的，外部模块应该是不能修改的（类似于 C++ 中 class 的 private 成员）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上，使用 &lt;code&gt;localparam&lt;/code&gt; 是更好的选择。&lt;/p&gt;
&lt;h3 id="reset"&gt;Reset&lt;/h3&gt;
&lt;p&gt;FPGA 上电时，GSR(Global Set/Reset) 拉高，对所有 寄存器 /RAM 进行复位，此时配置于 FPGA 的逻辑并未生效，所以不能保证 FSM 进入正确的初始化状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般，FSM 使用用户定义的复位 ( 同步 or 异步 )。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// Synchronous Reset&lt;/span&gt;
&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;还有一种方法，是将初始状态编码为全 0 ( 带 0 的 One-Hot 编码方式 )，这样当 GSR 复位后，状态机自动进入初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="state-encode"&gt;State encode&lt;/h3&gt;
&lt;p&gt;状态机的状态的编码，通常有 &lt;code&gt;Binary&lt;/code&gt;、&lt;code&gt;One-Hot&lt;/code&gt;、&lt;code&gt;Gray&lt;/code&gt; 码等几种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用最简单的递增的编码方式对状态进行编码，对于 n 个状态的状态机，共需要 log2(n) 个触发器表示所有的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：在状态很多的情况下，可以大大减少触发器的数量，对设计的面积有积极的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：但是在状态跳转过程中，很可能出现多位同时变化的情况，容易在 next state 的生成逻辑上产生毛刺。同时，输出也是所有状态位的译码，译码逻辑多数很复杂，往往成为整个设计的关键路径。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Gray 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似 Binary，但是采用了格雷码的编码方式，每两个相邻的状态只有一位信号变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：避免了 next state 上毛刺的产生。同时两个相邻状态的输出译码变得简单了，避免了复杂组合逻辑的产生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点；格雷码的这些优点都是建立在状态跳转是顺序执行的基础上的。如果状态机有很多随机跳转和分支，格雷码的实际效果和二进制码相差无几，优势荡然无存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;One-Hot 码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前设计中最常用的状态机编码方式。One-Hot 编码在一组 0 中只有一个 1，对一个 n 个状态的 FSM 设计，需要 n 个触发器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：在任意两个状态之间跳转都只有两位状态位变化，不会产生非常复杂的组合逻辑。各个状态之间的译码也相对简单。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：对状态编码需要的寄存器比其他方式多，不过这个缺点基本可以忽略吧 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Binary、Gray 编码使用最少的触发器，较多的组合逻辑。而 One-Hot  编码反之。由于 CPLD 更多的提供组合逻辑资源，而 FPGA 更多的提供触发器资源，所以 CPLD 多使用 Gray，而 FPGA  多使用 One-Hot 编码。另一方面，对于小型设计使用 Gray 和 Binary 编码更有效，而大型状态机使用 One-Hot 更高效。&lt;/p&gt;
&lt;p&gt;(XST 的选项 &lt;code&gt;FSM encoding algorithm&lt;/code&gt; 值默认为 &lt;code&gt;auto&lt;/code&gt;，编写程序测试发现，它会根据代码中状态的多少，FSM 的复杂度，自动选择合适的编码方式对状态进行编码。)&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;one-hot 和 reverse case 相结合，可以得到一种更加简洁的电路（如模板所示的 index one-hot），这种方式和传统的 one-hot 相比，它不再是对比整个状态向量的值，而是逐 bit 对比，从而简化了状态译码电路。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;利用前面的模板和结尾附录的模板，对参考文章 &lt;a href="http://www.trilobyte.com/pdf/golson-snug94.pdf"&gt;Steve Golson State machine design techniques for Verilog and VHDL&lt;/a&gt; 中的状态机例子进行综合测试，实际结果证实了 index 方式要更加节省资源（如果状态机更加复杂一些的话，两者的差别应该更大）。&lt;/p&gt;
&lt;p&gt;index one-hot style:&lt;/p&gt;
&lt;p&gt;&lt;a href="/files/fsm_index.v"&gt;index.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="indx style" src="/images/fsm-design/index_summary.png"&gt;&lt;/p&gt;
&lt;p&gt;non-index one-hot style:&lt;/p&gt;
&lt;p&gt;&lt;a href="/files/fsm_non_index.v"&gt;non-index.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="non-index" src="/images/fsm-design/non_index_summary.png"&gt;&lt;/p&gt;
&lt;p&gt;使用 XST 综合上面的 index one-hot + reverse case 风格的 FSM，结果 XST 并没有识别出 FSM，而 Synplify 我没有破解版本，只能作罢 =.=&lt;/p&gt;
&lt;p&gt;虽然 XST 没有识别出 non-index 的 FSM，但是 Modelsim 是可以识别出来的，可以在 Modelsim 中查看最终综合出来的 FSM 如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/state_diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;补上普通的 one-hot + case 的模板，这个模板是可以被 XST 识别出来的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;
&lt;span class="normal"&gt;44&lt;/span&gt;
&lt;span class="normal"&gt;45&lt;/span&gt;
&lt;span class="normal"&gt;46&lt;/span&gt;
&lt;span class="normal"&gt;47&lt;/span&gt;
&lt;span class="normal"&gt;48&lt;/span&gt;
&lt;span class="normal"&gt;49&lt;/span&gt;
&lt;span class="normal"&gt;50&lt;/span&gt;
&lt;span class="normal"&gt;51&lt;/span&gt;
&lt;span class="normal"&gt;52&lt;/span&gt;
&lt;span class="normal"&gt;53&lt;/span&gt;
&lt;span class="normal"&gt;54&lt;/span&gt;
&lt;span class="normal"&gt;55&lt;/span&gt;
&lt;span class="normal"&gt;56&lt;/span&gt;
&lt;span class="normal"&gt;57&lt;/span&gt;
&lt;span class="normal"&gt;58&lt;/span&gt;
&lt;span class="normal"&gt;59&lt;/span&gt;
&lt;span class="normal"&gt;60&lt;/span&gt;
&lt;span class="normal"&gt;61&lt;/span&gt;
&lt;span class="normal"&gt;62&lt;/span&gt;
&lt;span class="normal"&gt;63&lt;/span&gt;
&lt;span class="normal"&gt;64&lt;/span&gt;
&lt;span class="normal"&gt;65&lt;/span&gt;
&lt;span class="normal"&gt;66&lt;/span&gt;
&lt;span class="normal"&gt;67&lt;/span&gt;
&lt;span class="normal"&gt;68&lt;/span&gt;
&lt;span class="normal"&gt;69&lt;/span&gt;
&lt;span class="normal"&gt;70&lt;/span&gt;
&lt;span class="normal"&gt;71&lt;/span&gt;
&lt;span class="normal"&gt;72&lt;/span&gt;
&lt;span class="normal"&gt;73&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
&lt;span class="w"&gt;                     &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00001&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00010&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b00100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                       &lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b01000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b10000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// synopsys state-vector state&lt;/span&gt;
&lt;span class="kt"&gt;reg&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// synopsys enum code&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="c1"&gt;// synopsys full-case parallel-case&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;IDLE:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;S1:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;S2:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;S3:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nl"&gt;ERROR:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;always&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;@(&lt;/span&gt;&lt;span class="k"&gt;posedge&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;clk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rst&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// reset&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// default output&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nl"&gt;IDLE:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nl"&gt;S1:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nl"&gt;S2:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nl"&gt;S3:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nl"&gt;ERROR:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="safe-fsm"&gt;Safe FSM&lt;/h3&gt;
&lt;p&gt;所谓 “ 安全 ” 的状态机，就是说即使因为某些意外原因，状态机跑飞了，仍然可以自动回复到正常状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例：可能出现的不安全情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如，我们采用 One-Hot 编码方式，对于 8 个状态，总共使用了 8 bit 的寄存器，那么这个状态寄存器向量可以取到的值一共有 &lt;code&gt;2^8 = 256&lt;/code&gt; 种。如果我们只对需要的 8 种状态进行了说明，而忽略了剩余的 248 种，此时综合工具 (Synplify、XST) 会对设计进行 “ 优化 ”，将没有用到的状态去掉。但是，有时候这种 “ 优化 ” 反而不好，如果状态机进入未定义的全 0 状态，那么它就会卡在这个未定义的状态，无法自动回复正常工作状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果我们对状态向量的所有取值情况都显式地进行了说明，那么这个状态机就是安全的，否则就是不安全的。书写完备的 &lt;code&gt;case&lt;/code&gt; 语句。在代码中对每一种可能的取值对进行描述，对于不使用的状态编码，一定要有 &lt;code&gt;default&lt;/code&gt; 分支进行说明。&lt;/p&gt;
&lt;p&gt;在第二段 &lt;code&gt;always&lt;/code&gt; 中，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;begian&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这里应该赋值 &lt;code&gt;8'bx&lt;/code&gt; 更合理，因为状态机上电时处于未知状态，所以应该赋值 &lt;code&gt;x&lt;/code&gt; 更符合实际，但是这样赋值必须有个条件，就是必须所有的状态编码都全部被使用了，不然就会出现锁死现象，FSM 无法返回工作状态。我们前面使用的是 One-Hot 编码方式，有大量无效状态，所以这里不能赋值为 &lt;code&gt;x&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XST 支持状态机编码的完备属性 —— &lt;code&gt;case implementation style&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是这个设置可能会导致前后仿真不一致的问题，一般不使用。我们应该在代码中满足条件，而不是依靠综合工具。&lt;/p&gt;
&lt;p&gt;XST 的选项 &lt;code&gt;safe implementation&lt;/code&gt; 值默认为 &lt;code&gt;None&lt;/code&gt;，如果应用环境要求 FSM 必须能恢复任何错误，比如航天、医疗、汽车等，这时我们可以打开这个设置，这时综合工具会添加额外的逻辑，保证 FSM 可以从无效状态恢复过来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使使用第一种方法，似乎我们的状态机已经是 perfect 了，但是真的是这样么？考虑这种情况：一个状态机有 8 个状态，采用 One-Hot 编码方式，代码含有 &lt;code&gt;default&lt;/code&gt; 分支处理未定义的状态向量可能取到的值。现在把这个状态机放在卫星中，接受宇宙射线的辐射，导致状态向量的值发生了变化，进入了无效状态，然后状态机自动恢复到正常状态 (Good Job)，但是！状态机的外围电路并没有随着状态机恢复，它还在等 FSM 输出某个信号呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，仅仅是回到正常状态并不够，最好的设计应该有个错误状态专门来与外围电路通信，当 FSM 进入错误状态时，外围电路会检测到这个错误状态，并采取合适的措施（如重启、复位 FSM）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结合上面讨论的 index one-hot 编码方式，就有了两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;显式地定义定义一个 ERROR state&lt;/p&gt;
&lt;p&gt;如模板所示。&lt;/p&gt;
&lt;p&gt;比如一个 FSM，有 4 个状态，分别是 IDLE、S1、S2、S3，那么额外定义一个 ERROR 状态机的框图如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在每个 case item 中，最后添加一个 else 分支且 &lt;code&gt;NS[ERROR] = 1'b1&lt;/code&gt;，并且多加一个 case item&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;CS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zero-idle&lt;/p&gt;
&lt;p&gt;在状态定义时，不用显式地定义一个 ERROR 状态，而是用全 0 状态表示 ERROR 状态：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;parameter&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;S1&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;S2&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;S3&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="mi"&gt;&amp;#39;d4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;多加一个 case item：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;~|&lt;/span&gt;&lt;span class="nl"&gt;CS:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;IDLE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对比两种方式，我觉得第一种更能体现出设计意图，所以在模板中选择这种方式。&lt;/p&gt;
&lt;h3 id="casecs"&gt;case(CS)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用 case 的原则：&lt;/strong&gt; 尽量不要使用综合指令 full-case 和 parallel-case，而是代码本身满足 full、parallel 的条件（因为综合指令可能导致前后仿真不一致的问题）&lt;/p&gt;
&lt;p&gt;下面根据状态编码方案分类讨论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果使用 “ 非 index one-hot + 非 reverse case” 的方法，那么在第二个 always block 中，在 case 前给 NS 一个默认值（如下）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这是个很有用的小技巧，它可以帮助我们在综合前发现状态是否完备：如果状态完备，则在下面的 &lt;code&gt;case&lt;/code&gt; 中会给 &lt;code&gt;NS&lt;/code&gt; 合适的值；如果状态不完备，则状态机会进入错误状态，输出不定，仿真时可以很快的发现。而且，综合工具对于 &lt;code&gt;x&lt;/code&gt; 采取的态度是 &lt;code&gt;don't care&lt;/code&gt;，综合时会自动将其忽略，生成的电路最简洁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 index one-hot + reverse case 的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NS 必须赋值为全 0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;8&lt;/span&gt;&lt;span class="mb"&gt;&amp;#39;b0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 synopsys 综合指令&lt;/p&gt;
&lt;p&gt;一般的原则是尽量不要使用综合指令，这里是个特殊情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// synopsys full-case parallel-case&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;default 分支&lt;/p&gt;
&lt;p&gt;使用了综合指令，则 default 分支在综合时就没有必要，但是仿真器并不能识别综合指令，所以在行为仿真的时候仍然需要 default 分支，所以可以用下面的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// synopsys translate-off&lt;/span&gt;
&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;$display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;FSM is dead!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// synopsys translate-on&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用 index one-hot + reverse case 的方式，这里违背了 case 语句本身满足 full-case、parallel-case 的原则，使用了综合指令、并且省掉了 default 分支，是唯一的例外情况，其他情况下都应该遵守这一原则！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="ouput"&gt;Ouput&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;避免 Latch&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在第三个 &lt;code&gt;always&lt;/code&gt; 中，在 &lt;code&gt;case&lt;/code&gt; 前，所有的输出都有默认的值，这样做的好处是可以消除 &lt;code&gt;Latch&lt;/code&gt; 的出现，而且，可以减少在后面每种状态下重复相同的赋值，而且强调显示了 case 内哪个输出发生了变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外一种避免 latch 的方法：书写完备的 &lt;code&gt;if-else&lt;/code&gt; 和 &lt;code&gt;case&lt;/code&gt; 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;消除输出毛刺&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于三段式，因为输出是寄存器输出，所以解决了输出毛次。&lt;/p&gt;
&lt;p&gt;讨论一下采用寄存器输出的方式对设计的影响&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动可以优化 FSM 的时序性能&lt;/p&gt;
&lt;p&gt;影响一个时序电路运行速度的主要因素是两个寄存器之间的组合逻辑路径的长度，越长的组合逻辑路径，其时序性能越差。一个电路中的最长组合逻辑路径决定了这个电路最高运行速率，该路径就是这个电路的关键路径（&lt;code&gt;critical path&lt;/code&gt;）。所以，切断最长的组合逻辑路径可以提高局部电路的运行速度，切断多个较长的组合逻辑路径可以提高整体电路的运行速度。切断组合逻辑路径的工具就是寄存器。所以，添加寄存器可以提高电路的性能，但是会增加资源的消耗，这也是速度（speed）和面积（area）互为矛盾的原因。&lt;/p&gt;
&lt;p&gt;在考虑 FSM 的时序问题时，不能独立的考虑 FSM 本身，需要综合考虑 FSM 模块和下游模块构成的电路。在 FSM 不采用输出寄存时，在 FSM 模块和下游模块的接口处，是两部分组合逻辑直接相连。关键路径由两部分组合逻辑构成；在 FSM 采用输出寄存时，两个模块的组合逻辑被分隔成两部分，可能的关键路径被切断了。同步寄存器输出和组合逻辑输出就是采用资源优化还是速度优化的问题。组合逻辑表面上会提高电路的速度，看似节省了资源而且提高了速度，其实不然（对 FPGA 结构来说，节省寄存器不等于节省 LE；对同步设计来说，异步输出速度上的优势是可以忽略的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出采用寄存器驱动会降低输出队输入信号变化的响应速度？&lt;/p&gt;
&lt;p&gt;到底应不应该采用 FSM 输出寄存器？是否必须在时序性能和响应速度之间做出取舍？在同步设计中，答案是必须牺牲一定的响应速度以换取更佳的时序性能，只考虑响应速度会带来潜在的时序性能损失。&lt;/p&gt;
&lt;p&gt;在考虑 FSM 的响应速度时，不能独立的考虑 FSM 本身，需要综合考虑 FSM 模块和上、下游模块构成的电路。采用输出寄存器的电路可以运行在更高的时钟频率下，所引入的响应时延与更高的运行频率相比是可以牺牲的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="case-ns-vs-case-cs"&gt;case (NS) vs case (CS)&lt;/h3&gt;
&lt;p&gt;采用二段式实现状态机，它的输出是组合逻辑，可能存在竞争和冒险，产生毛刺，要消除毛刺就要对输出用寄存器打一拍，但是很多时候，是不允许插入寄存器节拍的。&lt;/p&gt;
&lt;p&gt;这时候可以采用三段式实现，三段式的输出是寄存器输出，所以消除了毛次；同时，如果三段式的第三段判断输出采用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;
&lt;span class="normal"&gt;8&lt;/span&gt;
&lt;span class="normal"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nl"&gt;IDLE:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;begin&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// ....&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;begian&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;endcase&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以提前判断下一状态的输出，节省了一个节拍，使输出和状态变化同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;example&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计一个简单的 FSM，测试使用 &lt;code&gt;case(CS)&lt;/code&gt; 和 &lt;code&gt;case(NS)&lt;/code&gt; 的结果：&lt;/p&gt;
&lt;p&gt;FSM 设计：一共有 4 个状态 (IDLE、S1、S2、S3)，只有一个输入 (&lt;code&gt;jump&lt;/code&gt; 信号 )，两个输出 (&lt;code&gt;dout-p&lt;/code&gt;、&lt;code&gt;dout-q&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;跳转规律：状态机开始处于 IDLE 状态，当 jump 变高时，从 IDLE 跳转到 S1 状态，同时内部的一个 4 bit 计数器开始计数，当计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 S2，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时跳转到 S3，当再次计数到 &lt;code&gt;4'b1111&lt;/code&gt; 时，跳转到 IDLE，等待 jump 再次变高。状态转移图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="diagram" src="/images/fsm-design/diagram.png"&gt;&lt;/p&gt;
&lt;p&gt;程序：&lt;/p&gt;
&lt;p&gt;&lt;a href="/files/fsm.v"&gt;状态机源文件 fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/files/tb_fsm.v"&gt;测试平台 testbench tb-fsm.v&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仿真结果：使用 &lt;code&gt;NS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出同时改变。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_ns.png"&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;CS&lt;/code&gt; 判断，结果如下图，可以看到，当 &lt;code&gt;CS&lt;/code&gt; 发生变化时，输出变化相对于状态变化延时一个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;img alt="case ns" src="/images/fsm-design/case_cs.png"&gt;&lt;/p&gt;
&lt;h2 id="ref"&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsSNUG1998SJ-FSM.pdf"&gt;Clifford E. Cumming State Machine Coding Styles for Synthesis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.sunburst-design.com/papers/CummingsICU2002-FSMFundamentals.pdf"&gt;Clifford E. Cumming The Fundamentals of Efficient Synthesizable Finite State Machine
Design using NC-Verilog and BuildGates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.trilobyte.com/pdf/golson-snug94.pdf"&gt;Steve Golson State machine design techniques for Verilog and VHDL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/freeny/archive/2012/04/14/2447612.html"&gt;Verilog HDL 学习心得&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;foreveryoung 《状态机设计》&lt;/p&gt;
&lt;p&gt;云创工作室《 Verilog HDL 程序设计与实践》&lt;/p&gt;</content><category term="IC"></category><category term="FSM"></category><category term="Verilog"></category></entry><entry><title>学习 Arduino #2 初识 Intel Galileo 开发板</title><link href="https://qian-gu.github.io/posts/embedded/learn-arduino-series-2-intel-galileo-development-board.html" rel="alternate"></link><published>2014-05-29T23:27:00+08:00</published><updated>2014-05-29T23:27:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-05-29:/posts/embedded/learn-arduino-series-2-intel-galileo-development-board.html</id><summary type="html">&lt;p&gt;学习 Arduino，#2 初识 Intel Galileo 开发板&lt;/p&gt;</summary><content type="html">&lt;h2 id="preface"&gt;Preface&lt;/h2&gt;
&lt;p&gt;Arduino 有很多开发板，分别针对不同的应用环境含有不同的模块。学习一款 Intel 推出的开发板 —— &lt;em&gt;Intel Galileo Development Board&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;Intel Gailileo Development Board 是 Intel 进入 Arduino 领域的试水产品，它含有一颗 Quark Soc X1000 CPU，这是一款 32 位、x86 构架、低功耗的 SoC 芯片，它的主频可以达到 400 MHz，内部有 512 KB 的 SRAM，同时 Galileo 有丰富的接口 (USB, JTag, RS232, Ethernet, mPCIE...)，支持很多外围设备。&lt;/p&gt;
&lt;p&gt;Galileo 试图达到的目标是融合 Arduino 对硬件操作的便利和 Linux 系统对硬件操作完整支持。所以，Galileo 也兼容 Arduino 接口，你可以很方便的把 Arduino 项目移植到 Galileo 上运行，使用常用的一些 Arduino 库 (Ethernet, Wi-Fi, SD, EEPROM...) 也可以获得内部 Linux 系统的完整功能 (Python, SSH, Telnet， OpenCV...)。&lt;/p&gt;
&lt;p&gt;总结一下我学习这块板子的知识，不仅仅为 Arduino 开发做准备，也为后面的一个竞赛 ( 基于 Yocto 项目 ) 开发积累知识～&lt;/p&gt;
&lt;h2 id="official-arduino-boards"&gt;Official Arduino Boards&lt;/h2&gt;
&lt;p&gt;Arduino 官网上列出所有了官方开发板，其中也包含了官方认证过的开发板 (Intel Galileo)，和一些推荐的第三方产品&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Main/Products"&gt;Arduino Products&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还详细列出了这些开发板上的微控制器的区别&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Products.Compare"&gt;Compare boards specs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;官方的开发板的核心都是 Atmel 的微控制器，基于市场战略的需求，看到数莓派、Arduino 发展的热火朝天，Intel 也坐不住了 ( 瞎猜的 =.=)，推出了新的基于 Intel 架构 (x86)、可以和 Arduino 兼容的开发板。Galileo 是这个家族中的第一款，目前 Intel 又推出了一款新的开发板，取名叫 Edison。(Intel 这是要把所有科学家的名字都取个遍么 )&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="intel-galileo-board"&gt;Intel Galileo Board&lt;/h2&gt;
&lt;h3 id="arduincocc"&gt;Arduinco.cc&lt;/h3&gt;
&lt;p&gt;在 Arduino 官网上有一篇简单介绍 Galileo 的网页&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/ArduinoCertified/IntelGalileo"&gt;Intel Galileo on arduino.cc&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="intel-official-introduction"&gt;Intel Official Introduction&lt;/h3&gt;
&lt;p&gt;Arduino 官网上的介绍只是非常简单的介绍，Intel 自己的官网上有关于 Galileo 全部的详细资料&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.intel.cn/content/www/cn/zh/do-it-yourself/galileo-maker-quark-board.html"&gt;Galileo Maker Quark Board&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于 Galileo 的全部文档，包括 Datasheet、Schematic、Quick Start、User Guide 等：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://communities.intel.com/community/makers/documentation/galileodocuments"&gt;Intel Galileo Development Board Documents&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="other-introductions"&gt;Other Introductions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt; 送上一篇非常好的介绍文章（来自 Ifanr.com），介绍了在 Maker 眼中，这个板子到底可以 hack 到什么程度～&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ifanr.com/388835"&gt;x86 版的 Arduino 来了，Intel Galileo 开发板的体验、分析和应用【超长文多图】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再&lt;/strong&gt; 附上一篇完爆我的总结的教程～&lt;/p&gt;
&lt;p&gt;&lt;a href="https://learn.sparkfun.com/tutorials/galileo-getting-started-guide"&gt;Galileo Getting Started Guide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇教程基本就是按照 Intel 官方的 Getting Started 流程写的，总结一下我遇到的问题 (Windows 7 &amp;amp; Linux Ubuntu)。&lt;/p&gt;
&lt;p&gt;Arduino 官方的 IDE 中 &lt;code&gt;Board&lt;/code&gt; 选项中没有 Galileo，所以我们应该从 Intel 下载定制过的 IDE。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows IDE 闪退&lt;/p&gt;
&lt;p&gt;这个 IDE 在部分 Windows 下有闪退的现象。&lt;/p&gt;
&lt;p&gt;原因 是 Intel 的 IDE 版本采用的是未发布的 1.5.3, 它会检测系统的语言设置，当系统不是 En/US 时，就会退出。&lt;/p&gt;
&lt;p&gt;解决方法 更改系统语言设置 或者 使用一款名为 Locale Emulator 的软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IDE 解压路径&lt;/p&gt;
&lt;p&gt;Windows 下的解压路径 &lt;em&gt;必须是顶层目录&lt;/em&gt;，比如 &lt;code&gt;D:\arduino-1.5.3&lt;/code&gt;，否则在 &lt;code&gt;Verify&lt;/code&gt; 时会提示找不到特定的文件 / 目录。Linux 下无此问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 连接板子和 PC&lt;/p&gt;
&lt;p&gt;在 Windows 下第一次连接系统自动安装驱动肯定会失败的，需要我们手动指定驱动文件的路径。&lt;/p&gt;
&lt;p&gt;在 Linux 终端下，必须以 &lt;code&gt;sudo&lt;/code&gt; 权限运行 IDE，否则即使板子已经连接了 PC，在 IDE 下的 &lt;code&gt;Tools\Serial Port&lt;/code&gt; 是 disable 的，不能选择端口&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;./arduino&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux 下 disable modem manager&lt;/p&gt;
&lt;p&gt;前面的教程中提到，在大多数 Linux 发行版下，都需要 disable modem manager 才能 &lt;code&gt;Upload&lt;/code&gt; 成功，不过我在 Ubuntu 下没有遇到这个问题 ...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;然后&lt;/strong&gt; 扯几句&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;硬件配置&lt;/p&gt;
&lt;p&gt;从 Board Guide 中找到的截图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="key-componets-1" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_1.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="key-componets-2" src="/images/learning-arduino-series-2-intel-galileo-development-board/key_components_2.png"&gt;&lt;/p&gt;
&lt;p&gt;从它的配置中可以看到，Galileo 并不是一款简单的 Arduino 开发板，它的硬件系统其实是按照 PC 来设计的，如果我们只是简单的把它当作 Arduino 开发板来应用，有点大材小用了，这样子完全没有体现出 Galileo 的优势，只是一个速度更快的 Arduino 罢了。&lt;/p&gt;
&lt;p&gt;事实上，如果功能上没有比传统的 Arduino 更强大的功能，估计 Intel 也不会推出这个产品了～Galileo 的真正强大的地方在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;背后基于 UEFI/Linux 的软件平台以及 Galileo 自身的硬件配置。为此，Intel 提供了丰富的开发文档、软件代码支持，方便开发人员真正的发挥出 Galileo 的所有潜力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件构架&lt;/p&gt;
&lt;p&gt;Galileo 不仅仅是硬件上按照 PC 设计的，事实上，它的软件构架也和 PC 一样。和普通的单片机不同，它并不是简单的运行用户开发的程序那么简单。它实际上运行着一个操作系统 —— 包含 UEFI(BIOS 的替代者 )、Grub、嵌入式 Linux 系统，用户编写的 &lt;code&gt;Sketch&lt;/code&gt; 只是一个在 Linux 上面运行的应用而已。&lt;/p&gt;
&lt;p&gt;Galileo 启动时可以从 ISP Flash 中启动一个微型的 Linux 系统，也可以从 MicroSD 卡中启动一个完整版的 Linux 系统。我们 &lt;code&gt;Upload&lt;/code&gt; 时，Arduino IDE 将程序编译链接成一个标准的 Linux ELF 文件，并且下载到 Arduino 板子上运行，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="target-software" src="/images/learning-arduino-series-2-intel-galileo-development-board/target_software.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发嵌入式 Linux 设备&lt;/p&gt;
&lt;p&gt;或许这才是 Galileo 的 " 正经 " 用途吧 ... 基于 Yocto Project，我们可以开发属于自己的 Linux 系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="Embedded"></category><category term="Intel Galileo"></category><category term="Arduino"></category></entry><entry><title>学习 Arduino #1 Arduino 入门</title><link href="https://qian-gu.github.io/posts/embedded/learn-arduino-series-1-getting-started.html" rel="alternate"></link><published>2014-05-27T12:34:00+08:00</published><updated>2014-05-27T12:34:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-05-27:/posts/embedded/learn-arduino-series-1-getting-started.html</id><summary type="html">&lt;p&gt;学习 Arduino，#1 Arduino 入门&lt;/p&gt;</summary><content type="html">&lt;h2 id="what-is-arduino"&gt;What is Arduino&lt;/h2&gt;
&lt;p&gt;&lt;img alt="logo" src="/images/learning-arduino-series-1-getting-started/logo.png"&gt;&lt;/p&gt;
&lt;p&gt;版权所有：Arduino.cc&lt;/p&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino 官网&lt;/a&gt; 首页的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ARDUINO IS AN OPEN-SOURCE ELECTRONICS PROTOTYPING PLATFORM BASED ON FLEXIBLE, EASY-TO-USE HARDWARE AND SOFTWARE. IT'S INTENDED FOR ARTISTS, DESIGNERS, HOBBYISTS AND ANYONE INTERESTED IN CREATING INTERACTIVE OBJECTS OR ENVIRONMENTS.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官方网站最权威的答案：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino is a tool for making computers that can sense and control more of the physical world than your desktop computer. &lt;strong&gt;It's an open-source physical computing platform based on a simple microcontroller board, and a development environment for writing software for the board.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino can be used to develop interactive objects, taking inputs from a variety of switches or sensors, and controlling a variety of lights, motors, and other physical outputs. Arduino projects can be stand-alone, or they can communicate with software running on your computer (e.g. Flash, Processing, MaxMSP.) The boards can be assembled by hand or purchased preassembled; the open-source IDE can be downloaded for free.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Development Language：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino programming language&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IDE：&lt;/strong&gt; &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt; &lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Wikipedia 上的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的说：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino 是一个开放源代码的单片机，它使用了 Atmel AVR 单片机，采用了基于开放源代码的软硬件平台，构建于开放源代码 simple I/O 接口板。开发语言为 Arduino programming language（基于 Wiring 语言），开发环境基于 Processing 。&lt;/p&gt;
&lt;h2 id="story-of-arduino"&gt;Story of Arduino&lt;/h2&gt;
&lt;p&gt;wikipedia 上的&lt;a href="http://zh.wikipedia.org/wiki/Arduino"&gt;小故事&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arduino 的核心开发团队成员包括：Massimo Banzi，David Cuartielles，Tom Igoe，Gianluca Martino，David Mellis 和 Nicholas Zambetti。&lt;/p&gt;
&lt;p&gt;据说 Massimo Banzi 之前是意大利 Ivrea 一家高科技设计学校的老师。他的学生们经常抱怨找不到便宜好用的微控制器。2005 年冬天， Massimo Banzi 跟 David Cuartielles 讨论了这个问题。David Cuartielles 是一个西班牙籍芯片工程师，当时在这所学校做访问学者。两人决定设计自己的电路板，并引入了 Banzi 的学生 David Mellis 为电路板设计编程语言。两天以后，David Mellis 就写出了程式码。又过了三天，电路板就完工了。这块电路板被命名为 Arduino。几乎任何人，即使不懂电脑编程，也能用 Arduino 做出很酷的东西，比如对传感器作出回应，闪烁灯光，还能控制马达。随后 Banzi，Cuartielles，和 Mellis 把设计图放到了网上。保持设计的开放源码理念，因为版权法可以监管开源软件，却很难用在硬件上，他们决定采用共享创意许可。共享创意是为保护开放版权行为而出现的类似 GPL 的一种许可（license）。在共享创意许可下，任何人都被允许生产电路板的复制品，还能重新设计，甚至销售原设计的复制品。你不需要付版税，甚至不用取得 Arduino 团队的许可。然而，如果你重新发布了引用设计，你必须说明原始 Arduino 团队的贡献。如果你调整或改动了电路板，你的最新设计必须使用相同或类似的共享创意许可，以保证新版本的 Arduino 电路板也会一样的自由和开放。唯一被保留的只有 Arduino 这个名字。它被注册成了商标。如果有人想用这个名字卖电路板，那他们可能必须付一点商标费用给 Arduino 的核心开发团队成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="why-is-arduino"&gt;Why is Arduino&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Guide/Introduction"&gt;官网介绍&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are many other microcontrollers and microcontroller platforms available for physical computing. Parallax Basic Stamp, Netmedia's BX-24, Phidgets, MIT's Handyboard, and many others offer similar functionality. All of these tools take the messy details of microcontroller programming and wrap it up in an easy-to-use package. &lt;strong&gt;Arduino also simplifies the process of working with microcontrollers, but it offers some advantage for teachers, students, and interested amateurs over other systems:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inexpensive&lt;/li&gt;
&lt;li&gt;Cross-platform (Windows, Linux, Macintosh OSX)&lt;/li&gt;
&lt;li&gt;Simple, clear programming environment&lt;/li&gt;
&lt;li&gt;Open source and extensible software&lt;/li&gt;
&lt;li&gt;Open source and extensible hardware&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="how-to-develope"&gt;How-to Develope&lt;/h2&gt;
&lt;h3 id="ide-installation"&gt;IDE installation&lt;/h3&gt;
&lt;p&gt;官网上有 Windows, Linux, Mac 的详细安装步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://arduino.cc/en/Guide/Windows"&gt;for Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://playground.arduino.cc/Learning/Linux"&gt;for Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux 安装过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;解决包依赖关系：安装 openjdk-7-jre (openjdk-6-jre, sun's java 6 runtime, the sun-java6-jre package, the oracle JRE 7 应该也可以 )&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;openjdk-7-jre
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载合适的 &lt;a href="http://arduino.cc/en/Main/Software"&gt;Arduino IDE&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;解压、切换到解压路径，运行目录下的 &lt;code&gt;arduino&lt;/code&gt; 脚本&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;tar&lt;span class="w"&gt; &lt;/span&gt;-zxvf&lt;span class="w"&gt; &lt;/span&gt;arduino-1.0.5-linux32.tgz
&lt;span class="nb"&gt;cd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;arduino-1.0.5
./arduino
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法二 (for Ubuntu)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载 &amp;amp; 安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;arduino&lt;span class="w"&gt; &lt;/span&gt;arduino-core
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;$&lt;span class="w"&gt; &lt;/span&gt;arduino
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="dev"&gt;Dev&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IDE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arduino IDE 是用 Java 写的跨平台的程序，它源自 &lt;a href="http://en.wikipedia.org/wiki/Processing-(programming-language)"&gt;Processing programming language&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Wiring-(development-platform)"&gt;Wiring&lt;/a&gt; 项目的 IDE 。它是为艺术家和其他不熟悉软件开发的新手而设计的。它包含一个有语法高亮、括号匹配、自动缩进功能的代码编辑器，还可以通过一个按键完成编译程序 (compile) 和烧录至电路板 (upload) 的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Programming&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个 Arduino 程序 / 代码 称为 "&lt;em&gt;Sketch&lt;/em&gt;"。Arduino 程序是用 C/C++ 写成的，Arduino IDE 含有一个名叫 "Wiring" 的代码库 ( 源自于 Wiring 项目 )，这样子可以大幅度简化常用 I/O 操作，用户只需要定义两个函数就可以写出一个可以运行的程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;setup()&lt;/em&gt; : 系统上电或者复位时启动，只运行一次，初始化配置&lt;/li&gt;
&lt;li&gt;&lt;em&gt;loop()&lt;/em&gt; : 一直循环被调用，直到断电&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arduino 的示例程序 "Blink"：( 等同于 C 的 hello world，对于硬件最简单就是控制一个 LED 的亮灭 )&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;Blink&lt;/span&gt;
&lt;span class="cm"&gt;Turns on an LED on for one second, then off for one second, repeatedly.&lt;/span&gt;

&lt;span class="cm"&gt;This example code is in the public domain.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;

&lt;span class="c1"&gt;// Pin 13 has an LED connected on most Arduino boards.&lt;/span&gt;
&lt;span class="c1"&gt;// give it a name:&lt;/span&gt;
&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// the setup routine runs once when you press reset:&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;                &lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// initialize the digital pin as an output.&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;pinMode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;OUTPUT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// the loop routine runs over and over again forever:&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;HIGH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// turn the LED on (HIGH is the voltage level)&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;digitalWrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;led&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;LOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// turn the LED off by making the voltage LOW&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nf"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;               &lt;/span&gt;&lt;span class="c1"&gt;// wait for a second&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;上面的这段代码对于一个标准 C++ 编译器来说是无效的，事实上当我们按下 IDE 界面上的 "Upload to I/O board" 按钮时，IDE 会拷贝一份代码，在开头加上 &lt;code&gt;include&lt;/code&gt; 指示，在结尾加上一个很简单的 &lt;code&gt;main()&lt;/code&gt; 函数，这样它就是一个有效的 C++ 程序了。&lt;/p&gt;
&lt;p&gt;Arduino 使用 &lt;a href="http://en.wikipedia.org/wiki/GNU-toolchain"&gt;GNU toolchain&lt;/a&gt; 和 AVR Libc 来编译程序的，使用 AVRdude 把程序下载到板子上。因为 Arduino 平台采用的是 Atmel 的微控制器，所以 Atmel 的开发环境 AVR Studio 或者更新的 Atmel Studio 应该也可以作为 Arduino 的开发环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学习资源&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Arduino 的联合创始人 Massimo Banzi 的 Tutorial Series Vedio&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youku.com/playlist-show/id-19440139.html"&gt;优酷视频地址&lt;/a&gt;，一共 11 课，涵盖最基本的面包板搭电路、I/O 接口控制、传感器控制、网络应用等方面，如果有编程基础，很快就可以上手制作自己的设备了～&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/thread-1066-1-1.html"&gt;论坛教程汇总帖&lt;/a&gt;，因为 Arduino 诞生的一个很大的目的就是为设计师、艺术家、业余爱好者提供更加方便的开发环境，所以，Arduino 的教程对于有编程基础的同学来说是很容易的 ：-P&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Reference/HomePage"&gt;Arduino Language Reference en&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 Arduino 编程语言的介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/reference/"&gt;Arduino Language Reference zh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Arduino 中文社区翻译的 编程语言介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/en/Tutorial/HomePage"&gt;Arduino Core Functions, Libraries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网上关于 IDE 中 &lt;code&gt;File/Examples/&lt;/code&gt; 下示例程序的说明&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_1"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://arduino.cc/"&gt;Arduino official website&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Arduino"&gt;Arduino on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.arduino.cn/"&gt;Arduino 中文社区&lt;/a&gt;&lt;/p&gt;</content><category term="Embedded"></category><category term="Open-source Hardware"></category><category term="Arduino"></category></entry><entry><title>FPGA 数字处理基础 (1)</title><link href="https://qian-gu.github.io/posts/ic/fpga-digital-processing-basic-1.html" rel="alternate"></link><published>2014-05-14T23:25:00+08:00</published><updated>2014-05-14T23:25:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-05-14:/posts/ic/fpga-digital-processing-basic-1.html</id><summary type="html">&lt;p&gt;总结 FPGA 处理数字信号的基础知识 (1)&lt;/p&gt;</summary><content type="html">&lt;h2 id="_1"&gt;数字处理基础&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数字处理基础&lt;/strong&gt;主要包括两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数的表示&lt;/li&gt;
&lt;li&gt;常用算术运算的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面分别讨论。&lt;/p&gt;
&lt;h2 id="_2"&gt;数的表示&lt;/h2&gt;
&lt;p&gt;这部分讨论对于计算机 (PC)、数字信号处理器件 (DSP)、数字芯片 ( 包括 FPGA) 都是成立的。&lt;/p&gt;
&lt;h3 id="_3"&gt;人类如何计数&lt;/h3&gt;
&lt;p&gt;最早我们的祖先采用的是结绳计数，经过几千年的发展，现在我们使用的 10 进制位置计数法 。那么我们为什么偏偏选择 10 这个数字呢？&lt;/p&gt;
&lt;p&gt;大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles-Petzold"&gt;Charles Petzold&lt;/a&gt; 在他的著作 &lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt; 中分析了我们的计数进制现象 。原因其实很简单，10 这个数字对于我们如此特别只是因为我们有 10 个手指 ( 脚趾 )，于是我们采用了 10 进制，并且逐渐习惯了它 。他在书中模拟了一下进制系统的演化过程，让我们逐渐从人类的 10 进制思维逐渐转化到计算机的 2 进制系统中：&lt;/p&gt;
&lt;p&gt;假设我们是卡通动画中的人物，比如米老鼠 Mickey，仔细观察它就会发现，他的每个手只有 4 个手指，理所当然，他采用 8 进制来计数。如果更进一步，假设我们是龙虾，那么我们的每一只钳子上有两个 “ 手指 ”，一共有 4 个手指，所以，我们会采取 4 进制计数系统。最后，假设我们是海豚，那么我们只有两个鳍来计数了，这时候的计数系统就是 2 进制数字系统了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;r 进制 to 10 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要按权值展开就可以了，比如： &lt;/p&gt;
&lt;p&gt;2 进制数 &lt;code&gt;110101&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;32 + 16 + 4 + 1 = 53&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;8 进制数 &lt;code&gt;B65F&lt;/code&gt; 对应的 10 进制数为 &lt;code&gt;11 × 16^3 + 6 × 16^2 + 5 × 16 + 15 × 1 = 46687&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10 进制 to r 进制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整数部分：基数连除，逆序取余&lt;/p&gt;
&lt;p&gt;小数部分：基数连乘，顺序取余&lt;/p&gt;
&lt;h3 id="_4"&gt;计算机如何计数&lt;/h3&gt;
&lt;h4 id="_5"&gt;正数 &amp;amp; 负数&lt;/h4&gt;
&lt;p&gt;人类和计算机的计数原理是完全不同的，所以采用的方法也是完全不同的。对于人来说，区分正负数只需要在数字绝对值前添加一个符号 &lt;code&gt;+&lt;/code&gt; 或者 &lt;code&gt;-&lt;/code&gt; 即可，但是计算机只有 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 这两个符号可以使用；对于人来说，减法借位很容易，但是对于计算机硬件电路来说这是一件很麻烦的事。&lt;/p&gt;
&lt;p&gt;常用的表示方法有 3 种：&lt;strong&gt;原码&lt;/strong&gt;、&lt;strong&gt;反码&lt;/strong&gt;、&lt;strong&gt;补码&lt;/strong&gt; 。对于计算机而言，硬件上最容易实现的是补码，这也是大多数计算机采用补码系统的原因 。&lt;/p&gt;
&lt;p&gt;以前总结过一篇博客，&lt;a href="http://guqian110.github.io/posts/cs/signed-number-representations.html"&gt;原码、反码、补码&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id="_6"&gt;整数 &amp;amp; 小数&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;整数&lt;/p&gt;
&lt;p&gt;对于整数而言，不存在小数点的问题，所以自然地将我们人类所熟悉的 10 进制数转化为计算机熟悉的 2 进制数，分配足够的空间存储起来就 ok 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小数&lt;/p&gt;
&lt;p&gt;在计算机中，整数和小数之间并不是很容易转换，而且小数的存储和处理要比整数复杂。对于小数可以有两种方法来表示：&lt;strong&gt;定点数&lt;/strong&gt; &amp;amp; &lt;strong&gt;浮点数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定点数的意思是小数点在数中的位置是固定不变的。整数可以看作是一种特殊的定点数，小数点在数的末尾。值得注意的是小数点的位置信息并没有和数字存储在一起，所以，使用定点数的程序必须知道小数点的位置。&lt;/p&gt;
&lt;p&gt;浮点数的意思是小数点在数中的位置是变化的。当代大部分计算机处理浮点数的标准是 IEEE 在 1985 年制定的 ANSI/IEEE Std 754-1985 。&lt;/p&gt;
&lt;p&gt;在计算机出现不久的年代，计算机处理浮点数是一件很重要但也让人头疼的事。最早，还没有专门处理浮点数的硬件，所以程序猿必须编写软件来完成浮点数的计算。浮点数在科学运算和工程类程序中极为重要，因此常常被赋予很高的优先级，在计算机发展的早期，为新制造的计算机做的第一项工作就是为其编写浮点数运算程序。&lt;/p&gt;
&lt;p&gt;如果可以直接利用计算机机器码指令来实现浮点数的计算，类似于 16 位处理器上进行乘法和除法运输，那么这台机器上所有的浮点数运算都会变得更快。IBM 公司在 1954 年发布了 IBM 704，它是第一台将浮点数运算硬件作为可选配件的商用计算机。该机器的浮点运算硬件可以直接进行加法、减法、乘法和除法，其他的浮点运算必须通过软件来实现。&lt;/p&gt;
&lt;p&gt;从 1980 年开始，浮点运算硬件开始应用于桌面计算机，这起始于 Intel 当年发布的 8087 数字协同处理 (Numberic Data Coprocessor) 芯片，当时这种集成电路被称为 &lt;strong&gt;数学协同处理器 (math coprocessor)&lt;/strong&gt; 或者 &lt;strong&gt;浮点运算单元 (floating-point,FPU)&lt;/strong&gt;。8087 不能独立工作，必须和 8086 或者 8088 一起工作，所以被称为 “&lt;strong&gt;协处理器&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;在最初版本的 IBM PC 主板上，位于 8080 芯片的右边有一个 40 个管脚的插槽供 8087 芯片接入，但是，这个插槽是空的，如果用户需要浮点运算则必须单独购买一块 8087 芯片。数字协处理器并不能加速所有的程序的运行速度，比如文字处理程序几乎用不到浮点运算，而电子表格处理程序对浮点数运算依赖程度很高。&lt;/p&gt;
&lt;p&gt;安装了数学协处理器，程序员必须使用协处理器的机器码指令来编写特定的程序，因为数学协处理器不是标准硬件。最后就出现了这样的局面：如果机器上安装了数学协处理器，程序员就要学会编写相应的应用程序以支持它的运行；如果没有安装，程序员必须通过编程来模拟它进行浮点数的运算。&lt;/p&gt;
&lt;p&gt;在 1989 年发布的 486DX 芯片中，FPU 已经内建在 CPU 的结构里，但是在 1991 年发布的 486SX 中，又没有内建 FPU，到了 1993 年发布的奔腾芯片中，CPU 内置 FPU 再次成为标准，并且是永远的标准。在 1990 年发布的 68040 芯片中，摩托罗拉首次将 FPU 集成到 CPU 中，在此之前是使用 68881 和 68882 数学协处理器来支持 68000 家族的微处理器。PowerPC 芯片同样使用了内置 FPU 的技术。&lt;/p&gt;
&lt;p&gt;FPGA 不同于微处理器，它内部没有内置 FPU( 不包括硬核 )，对于 FPGA，浮点数可以克服定点数动态范围小的缺点，但是在运算时，实现浮点数的硬件实时成本高，处理速度慢，所以在非实时运算中有广泛的应用。对于通信系统中的信号，一般都是实时处理的，所以在 FPGA 开发中，一般只使用定点数 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="fpga"&gt;常用算术运算的 FPGA 实现&lt;/h2&gt;
&lt;h3 id="_7"&gt;加法&lt;/h3&gt;
&lt;p&gt;在 Verilog HDL 中，直接使用运算符 &lt;code&gt;+&lt;/code&gt;，其本质上是一种并行加法器，应该保证两边的数位宽是一致的。举个栗子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;module&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;add_4&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;input&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;output&lt;/span&gt;&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="_8"&gt;乘法&lt;/h3&gt;
&lt;p&gt;第一种方法，最简单，直接使用运算符 &lt;code&gt;*&lt;/code&gt;，如下所示 。但是这种方法写出来的代码效率很低，甚至有时候是不可综合的，实际应用中基本不会采用这种方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;第二种方法是自己写代码实现乘法运算，或者是使用 IP COre。一般 FPGA 中都集成了硬核的乘法器，所以可以有两种方案来实现乘法器，DSP48 硬核 或者是 Slice 搭建 。&lt;/p&gt;
&lt;h3 id="_9"&gt;除法&lt;/h3&gt;
&lt;p&gt;除法是四则基本运算中最复杂的，也是最难实现的。除法可以看作是乘法的逆运算，但除法要复杂的多，最大的区别是乘法中的一些操作可以并行支持，通过流水线提高计算速度，但是除法必须顺序执行，运算最耗时间。&lt;/p&gt;
&lt;p&gt;Verilog 提供了除法运算符 &lt;code&gt;/&lt;/code&gt;，如下所示。但是只有在除数为 2 或者 2 的整幂次时才是可综合的，其余情况都不可综合 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;常用的方法是采用 IP Core，可以完成定点数和浮点数两类算法。&lt;/p&gt;
&lt;h3 id="cordic"&gt;Cordic 算法&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/CORDIC"&gt;Cordic 算法&lt;/a&gt; 算法即坐标旋转数字计算方法，是 J.D.Volder1 于 1959 年首次提出，主要用于三角函数、双曲线、指数、对数的计算。该算法通过基本的加和移位运算代替乘法运算，使得矢量的旋转和定向的计算不再需要三角函数、乘法、开方、反三角、指数等函数。&lt;/p&gt;
&lt;p&gt;它通常应用在没有硬件乘法器的应用中，比如微控制器、FPGA 中，cordic 进行的所有操作只有加法、移位和查表 。&lt;/p&gt;
&lt;p&gt;Coridc 算法可以自己编写代码实现，也可以使用 IP Core 。&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;事实上，所有的 IP 软核理论上都可以自己写，因为这些软核实际上就是别人写好的代码和文档，类似于 C 语言中的库函数。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="_10"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3795386/"&gt;《无线通信的 Matlab 和 FPGA 实现》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4822685/"&gt;code&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="digital processing"></category></entry><entry><title>学习 OFDM 及其 FPGA 实现 1 —— OFDM Basic</title><link href="https://qian-gu.github.io/posts/telecom/learning-ofdm-on-fpga-1-ofdm-basic.html" rel="alternate"></link><published>2014-05-13T23:16:00+08:00</published><updated>2014-05-13T23:16:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-05-13:/posts/telecom/learning-ofdm-on-fpga-1-ofdm-basic.html</id><summary type="html">&lt;p&gt;基于 FPGA 实现 OFDM 系统。第一篇，OFDM 基础。&lt;/p&gt;</summary><content type="html">&lt;h2 id="why-ofdm"&gt;Why OFDM&lt;/h2&gt;
&lt;h3 id="background"&gt;Background&lt;/h3&gt;
&lt;p&gt;移动通信的信道模型一般建立为 &lt;strong&gt;时变多径信道模型&lt;/strong&gt;，描述信道多径时延特性的一个重要统计参量是 &lt;strong&gt;均方根时延扩展&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;经过无线信道的时变多径传输，接收到的信号幅度会有起伏变化（瑞利分布 or 莱斯分布），这种现象称为 &lt;strong&gt;信号衰落&lt;/strong&gt; 。按照已调信号的带宽可以将衰落分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;窄带信号受到 &lt;strong&gt;平坦性衰落&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;宽带信号受到 &lt;strong&gt;频率选择性衰落&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判断信号受到何种衰落：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义信道的 &lt;strong&gt;相干带宽&lt;/strong&gt; 。当数字信号的带宽越小于信道的相干带宽，则经过时变多经信道后，在信号带宽内的不同频率分量的幅度的相关性越大，不同的频率分量近似经历相同的衰落，即平坦性衰落，平坦性衰落对接收信号的波形无明显影响，码间干扰可以忽略，该系统称为 &lt;strong&gt;窄带系统&lt;/strong&gt; 。当数字信号的带宽相对于信道的相干带宽越大时，信号带宽内的不同频率分量通过信道传输时会受到不同的衰落，即频率选择性衰落，频率选择性衰落使信号中的不同频率分量产生不同的幅度变化，造成接收信号的严重失真，引起吗见干扰，产生误码，该系统称为 &lt;strong&gt;宽带系统&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id="problem"&gt;Problem&lt;/h3&gt;
&lt;h4 id="_1"&gt;需求&lt;/h4&gt;
&lt;p&gt;无线信道的频率资源是有限的，要求数字通信系统有效利用信道频带。希望数据传输速率越高越好。&lt;/p&gt;
&lt;h4 id="_2"&gt;瓶颈&lt;/h4&gt;
&lt;p&gt;在系统设计选择数字调制方式时，必须兼顾 &lt;strong&gt;频带利用率&lt;/strong&gt; 和 &lt;strong&gt;误码性能&lt;/strong&gt; 。在 AWGN 信道下，在满足误码性能的前提下，应该尽可能采用频带利用率高的数字调制方式。&lt;/p&gt;
&lt;p&gt;然而，在以衰落为特征的移动通信系统中，影响误码性能的不仅仅是 &lt;strong&gt;加性噪声&lt;/strong&gt;，还包括 &lt;strong&gt;衰落&lt;/strong&gt; 和 &lt;strong&gt;码间干扰&lt;/strong&gt; 。实现高速无线通信并非易事。&lt;/p&gt;
&lt;p&gt;为避免码间干扰，数字调制信号的最大符号速率受到很大的限制 。&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;信道均衡&lt;/strong&gt; 是一种经典的对抗码间干扰的技术，许多移动通信系统都采用信道均衡技术消除码间干扰。但是如果数据速率非常高，采用单载波传输数据，需要设计几十审计上百个抽头的均衡器，这简直是硬件设计的噩梦 。&lt;/p&gt;
&lt;p&gt;既要对抗码间干扰，又要满足低复杂度且高效的手段传输高速数据业务，我们可以采用另外一种技术 —— &lt;strong&gt;OFDM&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id="ofdm-history"&gt;OFDM History&lt;/h2&gt;
&lt;p&gt;多载波调制技术早在 20 世纪 50 年代末至 60 年代初就已经应用于军事高频无线通信中，由于实现复杂，没有被广泛应用 。OFDM 就是一种多载波调制，其子载波间隔是子载波符号间隔的倒数，各子载波的频谱是重叠的，这种重叠可以使频谱效率显著提高 。&lt;/p&gt;
&lt;p&gt;20 世纪 70 年代，Weinstein 和 Ebert 提出用 &lt;strong&gt;离傅里叶变换 (DFT)&lt;/strong&gt; 及其 &lt;strong&gt;逆变换 (IDFT)&lt;/strong&gt; 进行 OFDM 多载波调制方式的运算。&lt;/p&gt;
&lt;p&gt;DFT 和 IDFT 的快速计算方法：FFT 和 IFFT 使 OFDM 能够以低成本的数字方式实现 。&lt;/p&gt;
&lt;p&gt;在 20 世纪 80 年代，随着 OFDM 理论的不断完善、数字信号处理及微电子技术的不断快速发展，OFDM 技术也逐步走向实用化 。&lt;/p&gt;
&lt;p&gt;大约从 20 世纪 90 年代起，OFDM 技术开始应用于各种有线及无线通信中，包括：DSL、DAB、DVB、WLAN 等。OFDM 已经成为下一代蜂窝移动通信空中接口的候选技术 。&lt;/p&gt;
&lt;h2 id="ofdm-theory"&gt;OFDM Theory&lt;/h2&gt;
&lt;p&gt;Orthogonal frequency-division multiplexing (OFDM) 的基本原理是将高速的数据流分解为多路并行的低速数据流，在多个载波上同时进行传输。&lt;/p&gt;
&lt;p&gt;通过将高速数据分解为多个并行低速速率，克服了信道时延扩展对数据速率的限制，其中各个子载波之间是相互正交的关系，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="carrier wave" src="/images/learning-ofdm-basic/carriers.png"&gt;&lt;/p&gt;
&lt;p&gt;OFDM 每个子载波的调制方式可以相互不同，比如 BPSK、QPSK、QAM 等方式 。&lt;/p&gt;
&lt;p&gt;(OFDM 系统的内容可以写一本书了，简单写写 :-P )&lt;/p&gt;
&lt;h3 id="ofdm"&gt;OFDM 基带数字实现&lt;/h3&gt;
&lt;h4 id="transmitter"&gt;发送端 Transmitter&lt;/h4&gt;
&lt;p&gt;基带系统发送端要实现的功能是将待发送序列 {A1,A2,A3...} 变换，得到复包络的采样值 {a1,a2,a3...} 。&lt;/p&gt;
&lt;p&gt;为了实现 OFDM 调制的基带数字实现，首先要将 OFDM 信号的复包络进行采样，成为离散时间信号 。根据公式 (《通信原理》)，采样结果正好是对发送序列进行离散傅里叶反变换 (IDFT) 的结果，所以，我们可以 &lt;em&gt;借助 IDFT 即可得到 OFDM 复包络的时间采样 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;发送端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="transmitter" src="/images/learning-ofdm-basic/transmitter.png"&gt;&lt;/p&gt;
&lt;h4 id="receiver"&gt;接收端 Receiver&lt;/h4&gt;
&lt;p&gt;基带系统接收端要实现的功能是对采样序列 {a1,a2,a3...} 进行变换，得到发送端发送过来的信息序列 {A1,A2,A3...} 。&lt;/p&gt;
&lt;p&gt;接收端通过 I/Q 正交解调可以恢复 OFDM 信号的复包络，将其采样得到的时间序列 。因为发送端采用的 IDFT 是可逆变换，所以对采样结果进行 DFT 就可以得到发送序列 。&lt;/p&gt;
&lt;p&gt;当序列的点数为 2 的整幂次时，DFT 和 IDFT 存在快速算法： FFT 和 IFFT 。&lt;/p&gt;
&lt;p&gt;接收端框图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="receiver" src="/images/learning-ofdm-basic/receiver.png"&gt;&lt;/p&gt;
&lt;h3 id="cyclic-prefix"&gt;循环前缀 cyclic prefix&lt;/h3&gt;
&lt;p&gt;为了有效对抗多径信道的时延扩展，OFDM 系统由多个子载波构成，只要子载波的取值可以满足符号周期远大于信道的时延扩展，就可以达到目标。在此基础上，还需要采取措施消除前后两个 OFDM 符号之间的 &lt;strong&gt;码间干扰 ISI&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;一种方法是在每个 OFDM 符号之间插入 &lt;strong&gt;保护间隔 Guard Interval&lt;/strong&gt; 。为了对抗信号因信道延迟的影响，Gurad interval(Tg) 长度要大于最大的 Delay spread，即 Tg &amp;gt; delay spread time。&lt;/p&gt;
&lt;p&gt;在保护区间未放信号的 OFDM 系统称 ZP-OFDM(zero padding)。ZP-OFDM 有比较低的传输功率，但在接收端接收于 zero padding 区域信号时，会破坏载波的正交性造成 “&lt;strong&gt;载波间的干扰（ICI）&lt;/strong&gt;”，所以复制 OFDM symbol 后半段信号并摆放于保护区间内，称之为 &lt;strong&gt;循环字首 (cyclic prefix)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id="_3"&gt;加窗技术&lt;/h3&gt;
&lt;p&gt;前面介绍了 OFDM 符号的生成、循环前缀消除码间干扰，但是此时符号边界有尖锐的相位跳变，由此可知，OFDM 的带外衰减是比较慢的 。虽然随着载波数目的增大，OFDM 信号的带外衰减会增加，但是仍然不够快 。&lt;/p&gt;
&lt;p&gt;为了使 OFDM 信号的带外衰减更快，可以采用对单个 OFDM 符号加窗的方法 。OFDM 的窗函数可以使信号的幅度在 u 符号边界更平滑地过渡到 0 。常用的窗函数是 &lt;strong&gt;升余弦滚降窗&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;增大滚降因子虽然能够使带外衰减更快，但降低了 OFDM 系统对多经实验的容忍能力，所以 &lt;em&gt;在实际系统设计中，应当选择较小的滚降因子 。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="ofdm_1"&gt;OFDM 系统设计&lt;/h3&gt;
&lt;p&gt;OFDM 系统框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ofdm-system" src="/images/learning-ofdm-basic/ofdm_system.jpg"&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;交织&lt;/strong&gt; 是为了克服深衰落发生突发差错的影响，如果交织器的长度足够大，解交织后可将突发差错改造为独立差错，再通过纠错译码来纠正 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在发送端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;二进制数据&lt;/em&gt; 通过纠错编码、交织后映射到 QAM 星座得到 &lt;em&gt;一个 QAM 复数符号序列&lt;/em&gt;，再经过并串转换，得到 &lt;em&gt;N 个并行 QAM 符号&lt;/em&gt;，每个符号进行 IFFT，将 OFDM 复包络的频域样值变换为 &lt;em&gt;时域样值&lt;/em&gt;，进行并串转换，将时域样值变换为按时间顺序排列的 &lt;em&gt;时域样值&lt;/em&gt;，然后在每个 OFDM 符号前插入前缀，通过 D/A，将离散的复包络变成 &lt;em&gt;连续时间的复包络&lt;/em&gt; 。再将复包络的 I(t) 和 Q(t) 正交调制得到 &lt;em&gt;OFDM 信号&lt;/em&gt;，将基带信号上变频到射频，经过功放，发送出去 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在接收端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端于发送端进行相反的变换，恢复出原数据 .&lt;/p&gt;
&lt;h2 id="_4"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1446684/"&gt;《通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/4130536/"&gt;《移动通信原理》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Orthogonal-frequency-division-multiplexing"&gt;OFDM wikipedia&lt;/a&gt;&lt;/p&gt;</content><category term="Telecom"></category><category term="OFDM"></category></entry><entry><title>我的 PKM</title><link href="https://qian-gu.github.io/posts/misc/my-pkm.html" rel="alternate"></link><published>2014-05-06T15:57:00+08:00</published><updated>2014-05-06T15:57:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-05-06:/posts/misc/my-pkm.html</id><summary type="html">&lt;p&gt;总结学习习惯和 PKM 工具。&lt;/p&gt;</summary><content type="html">&lt;h2 id="pkm"&gt;PKM&lt;/h2&gt;
&lt;h3 id="pkm_1"&gt;什么是 PKM&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;个人知识管理 (Personal Knowledge Management) 是一种新的知识管理的理念和方法，能将个人拥有的各种资料、随手可得的信息变成更具价值的知识，最终利于自己的工作、生活。通过对个人知识的管理，人们可以养成良好的学习习惯 , 增强信息素养，完善自己的专业知识体系 , 提高自己的能力和竞争力，为实现个人价值和可持续发展打下坚实基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知乎上的&lt;a href="http://www.zhihu.com/question/19576595"&gt;回答&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人知识管理的概念最早是由 Paul Dorsey 教授提出的 , 原文为 ” Personal Knowledge Management should be viewed as a set a problem-solving skills that have both a logical or conceptual as well as physical or hands-on component. ”, 中文意思就是 : 个人知识管理应该被看作既有逻辑概念层面又有实际操作层面的一套解决问题的技巧与方法。所以个人知识管理主要讲的是一种方法论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Personal-knowledge-management"&gt;Personal knowledge management on wikipedia&lt;/a&gt; &lt;/p&gt;
&lt;h3 id="blog"&gt;为什么写这篇 blog&lt;/h3&gt;
&lt;p&gt;从小到大，上了这么多年的学，每个人都有自己的学习习惯和知识管理方法。这篇 blog 是在我 Google、知乎问答、参考相关博客内容的基础上，总结出的学习习惯和使用各种工具的经验，写这篇博客的目的不是秀逼格有多高（估计很多人都看不上），也不是所谓的教程（根本不够资格），而是&lt;strong&gt;为了分享和讨论&lt;/strong&gt; :-D&lt;/p&gt;
&lt;h2 id="_1"&gt;获取知识&lt;/h2&gt;
&lt;p&gt;总结我的知识来源，大致可以分为 3 类：纸质书籍、网络资源、其他 。分别总结如下&lt;/p&gt;
&lt;h3 id="_2"&gt;书籍&lt;/h3&gt;
&lt;p&gt;书籍上的知识占到了我总来源的 50% 。相比于电子读物，我更喜欢阅读纸质书籍。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;纸质书籍更适合深度阅读&lt;/p&gt;
&lt;p&gt;这就是为什么很多码农桌子上都有那么几本经典著作，虽然他们的电脑里面也保存着相应的电子版。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纸和笔是最原始的阅读工具，但是也是最有效，或者 &lt;em&gt;最自由的&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是目前电子书籍 / 笔记最大的缺点，写一段标注文字，画一个草图，列一个表格，插入一个公式，不仅需要花费很多时间，而且操作很繁琐，结果也往往差强人意 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阅读体验&lt;/p&gt;
&lt;p&gt;毫无疑问纸质书籍的阅读体验更好一些，不然 Kindle 也就不会出现了 :-D&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于读书笔记，我的方法很原始 =.=&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书边笔记，这样笔记和书是一体的，如果空白不够大，有便利贴&lt;/li&gt;
&lt;li&gt;标记符号，简单的标记，比如 &lt;code&gt;？&lt;/code&gt; 表示疑问、&lt;code&gt;！&lt;/code&gt; 表示注意、&lt;code&gt;||&lt;/code&gt; 表示分层、&lt;code&gt;*&lt;/code&gt; 表示重要内容、圈出关键名词 / 定义 etc&lt;/li&gt;
&lt;li&gt;整理笔记，定期将书本上的笔记整理到 Blog / Evernote 中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_3"&gt;网络&lt;/h3&gt;
&lt;p&gt;互联网时代，善于利用互联网上的资源，相当于守着一座 “ 知识金山 ”&lt;/p&gt;
&lt;p&gt;每天面对海量的信息，如果不加以过滤，我们就会被淹没在信息的海洋之中，浪费了大量时间而毫无收益。我的信息来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RSS 订阅&lt;/p&gt;
&lt;p&gt;以前使用 Google Reader，自从 GR 死了之后，转到了 &lt;a href="http://cloud.feedly.com"&gt;Feedly&lt;/a&gt; 。主要是搜集一些大牛的博客，订阅 &lt;em&gt;真正&lt;/em&gt; 感兴趣的内容。&lt;/p&gt;
&lt;p&gt;RSS 订阅是个时间黑洞，曾经我的 RSS 订阅长期 1000+，而且我从来没有看完过，作为处女座强迫症患者，有时候花费了很多时间，甚至占用上课学习时间。后来看到 &lt;a href="http://mindhacks.cn/"&gt;刘未鹏&lt;/a&gt; 在 &lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt; 中有一篇文章讲自己的学习习惯，才明白原来这是源自人不肯 “ 关上一扇门 ” 的心理。&lt;strong&gt;事实上，真正宝贵的信息，在其他来源你也可以接触到。&lt;/strong&gt;于是，我退订了很多从来不看或者很少看的源，从此，告别阅读焦虑。:-D&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google / Wiki&lt;/p&gt;
&lt;p&gt;拒绝做伸手党，我们遇到的很多问题实际上别人都遇到过了，并且提供了解决方法。在网上发帖问别人的时候，很多问题都可以从 FAQ、官方文档中都能找到答案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;知乎 / Quora / Stack Overflow&lt;/p&gt;
&lt;p&gt;这绝对是一个值得一生相伴的好东西 :-P 长期混迹于此，瞬间高大上的境界、令人仰视的逼格不再是梦想，相信我，你的人生因此而改变！（利益相关：非广告，深度沉迷者）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;论坛 / 豆瓣小组&lt;/p&gt;
&lt;p&gt;当然是讨论知识的论坛，而非八卦娱乐主题的论坛。长期泡论坛，不仅可以寻找答案，帮助别人，还可以扩展自己的见识，结识大牛，论坛里面的老油条个个都是大神。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用到的工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://cloud.feedly.com"&gt;feedly&lt;/a&gt; 是一款 RSS 阅读器&lt;/p&gt;
&lt;p&gt;同类产品还有很多，比如国外的 Diggo、国内的鲜果、豆瓣九点等 。feedly 在国内访问并不是很稳定，即使这样，我仍然选择它是因为舒服的排版、另外功能上有些源 Diggo 无法抓取到 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://getpocket.com/a/"&gt;pocket&lt;/a&gt; 是一个用于管理互联网文章的应用程序&lt;/p&gt;
&lt;p&gt;PC 上有 chrome 插件，手机上也有相应的客户端，这样我们就可以很方便地在各个平台上、把各个源的文章都收集到一起，稍后阅读（比如排队、休息时）。&lt;/p&gt;
&lt;p&gt;我还它当作汇聚资料的容器使用，比如我写这篇博客，从网上搜集到很多相关内容，把我认为重要的保存在 pocket 当中，然后再做整理 。&lt;/p&gt;
&lt;p&gt;P.S. 还有另外一个方法，feedly 上的文章可以直接保存到 Evernote 中，但是这是付费功能，虽然可以用 ifttt 解决，但是这种方法无法收集其他地方的文章，而且，不知道是不是因为天朝的原因，ifttt 收集的速度并不快，一般要 30 分钟左右才能在 Evernote 中看到收集的文章，最重要的一点，在 Evernote 中看文章，眼睛一直盯着屏幕的右下角，都快成斜眼了 T-T，so 还是 pocket 好！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_4"&gt;其他&lt;/h3&gt;
&lt;p&gt;所谓其他，就是在其它地方，看到的、想到的，使用手机肯定是最方便的。我只使用过两款应用 Google Keep 和 Evernote 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Google-Keep"&gt;Google Keep&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google 发布的笔记软件，和其他各种笔记类软件相比，Keep 的功能实在是 “ 弱爆了 ”，或许称之为 &lt;em&gt;便签 sticker&lt;/em&gt; 更合适 .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://evernote.com"&gt;Evernote&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大名鼎鼎的笔记软件，功能非常强大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有很多人把这两个软件做比较&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20869752"&gt;Google Keep VS Evernote，你还会继续使用 Evernote 吗？为什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20859926"&gt;刚宣布 Reader 关停，Google Keep 随即上线，这是用来跟 Evernote 竞争的产品吗？谷歌做这个有什么优势？谷歌如何让用户有安全感地放心使用旗下产品？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事实上，这两个产品的定位根本就不一样，引用里面的某个答案&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google Keep 偏重于随时随地记录碎片知识 , 建立待办事项 , 是个效率工具 . 完成的事情就随手一滑存档掉 , 并没有提供更一步的存储整理的途径 . 所以 &lt;strong&gt;Google Keep 并不是知识的终点&lt;/strong&gt;, 它只是用来记录临时想法的 , 这恰恰和它的 logo 形象十分契合 ( 想想卡通里面人物突然奇思妙想了 ... 灯泡就亮了 - -). 它就是用来存储这些 " 灯泡 " 的 .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般，我使用 Keep 来记录平时的想法，也把它当作便签来使用，记录杂事，有部分 to-do-list 的作用。毕竟，Evernote 缓慢的启动速度和不方便的操作实在是太影响心情了 。&lt;/p&gt;
&lt;p&gt;还有一个答案，不能同意更多：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;归根到底，&lt;strong&gt;keep 是一个轻量级 GTD 系统，它要解决的问题和 evernote 是不同的。那些认为 keep 可以取代 evernote 的用户，他们本身就不需要 evernote&lt;/strong&gt; —— 对他们而言，evernote 的强大反而太过繁冗，已是多余。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_5"&gt;整理知识&lt;/h2&gt;
&lt;p&gt;获取到知识，下一步就是整理和吸收它们了。&lt;/p&gt;
&lt;h3 id="evernote"&gt;Evernote&lt;/h3&gt;
&lt;p&gt;说道 PKM，就不得不提 Evernote 。这么一款大名鼎鼎的笔记软件，有很多人在使用，分享使用技巧 。搜集到一个很全的资源帖：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.douban.com/group/topic/28544265/"&gt;印象笔记 Evernote 教程 (douban)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;里面总结了官方的教程、民间高手的使用心得。基本上花费一下午的时间在豆瓣 &amp;amp; 知乎上逛一逛，就可以成为高手了 。&lt;/p&gt;
&lt;p&gt;我不是 EN 的高级用户，也没有专门去探索进阶用法，我只是把它当作单纯的电子笔记本，不代替便签（Google Keep），也不代替知识管理软件（Wiz、OneNote），一般也就以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存博客草稿，毕竟 Keep 这样的便签不适合于写大段文字&lt;/li&gt;
&lt;li&gt;记录私人笔记&lt;/li&gt;
&lt;li&gt;摘抄网络上的精彩内容（也是为写 blog 服务），EN 在 chrome 上的 web clipper 插件真心不错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;忍不住跑题说一下我的使用感受：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：全平台、全功能、云同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：大而无当，这是一款变形金刚一样的软件，功能强大到有人为此写出一本厚厚的&lt;a href="http://book.douban.com/subject/24524405/"&gt;使用教程&lt;/a&gt; 。但是，强大的功能也就意味着软件的笨重和操作的繁琐。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和便签类应用相比&lt;/p&gt;
&lt;p&gt;它太笨重了！ 与 Keep 简洁的操作（快速新建、左右滑动归档、撤销），这货简直慢的让人无法忍受。知乎上有个贴子专门讨论这个问题：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20820355"&gt;为什么有人对印象笔记没有任何兴趣呢？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中有个回答，也是我的感受：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你明知道它的功能正是你需要的，但打開它就是不想用，也不知道從何用起。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和知识管理类应用相比&lt;/p&gt;
&lt;p&gt;仅个人意见，EN 并不适合作知识管理 。它只有 笔记本 和 笔记本组 这两个概念，也就是说，它最多支持 2 级目录，而实际上，我们的知识体系应该是和树一样，不断地分支增长的 。其他笔记类应用比如 Wiz 笔记就要比它好很多 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt; 我曾经也为用 Keep 还是 EN 纠结过，最终我选择了 Keep，直到后来我看到这句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那些认为 keep 可以取代 evernote 的用户，他们本身就不需要 evernote&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我才明白，我根本就不需要 EN！我曾经尝试过在 EN 中建立一个完备正交的目录，后来发现，其中最重要的部分和我的博客目录是一模一样的 。我已经有个博客了，为什么还要 EN 呢？（个人认为 blog 比 EN 更好，原因后文解释）&lt;/p&gt;
&lt;p&gt;事实上很多人根本就没有管理知识的必要，因为他们没有那么多知识需要整理。使用 Evernote 的动机无非就是人类的天性 ——“ 收藏 ” 癖好，看到什么东西都想收藏，比如用过的袋子，小本子，现在轮到网页，图片，链接了。可是我们收藏了以后还会去看么？就像我们硬盘里面收集的 “ 世界一百部名著 ” 一样，它静静地躺在硬盘中，积累了厚厚的灰 。&lt;/p&gt;
&lt;p&gt;EN 的 logo 是一只大象，寓意来自美国谚语 “An elephant never forgets”，大象的记忆力很强，这和它的宣传 “Evernote 是你的第二个大脑 ” 是一致的，而且是一个永远不会忘记的大脑。&lt;/p&gt;
&lt;p&gt;所以，为什么不就这么用呢？在 EN 中新建几个笔记本，把我们不需要记住但是以后可能会用到的 “ 知识 ” 丢进去，加上简单的标签，然后我们只需要记住在笔记里有这么个记录，然后其他的全都可以忘掉了，需要的时候去搜索一下就可以了。利用它强大的接口功能，记录杂事、美食、私人日记、生活小感悟、小常识，但是对于体系结构化的知识，个人认为写一个技术博客是更优的选择（理由在后文） :-P&lt;/p&gt;
&lt;p&gt;漫长的跑题终于结束了，总之就是，&lt;strong&gt;把 EN 当作收集小知识的笔记本即可，个人知识管理选择其他软件 / 写博客是更优的选择。给它做做减法，使用你需要的功能，不要成为工具的奴隶。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="xmind"&gt;XMind&lt;/h3&gt;
&lt;p&gt;目前还处于用笔和纸的阶段，大概了解了一些 XMind 的用途，感觉很好很强大。尤其是用它建立的结构化的提纲，对于整理文章、知识体系结构有巨大的帮助。还在探索中，更加进阶的功能和使用心得以后再总结。&lt;/p&gt;
&lt;h2 id="_6"&gt;使用 / 分享知识&lt;/h2&gt;
&lt;p&gt;月光博客中的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识共享和传播，是为了让别人知道你知道的知识，并得到信息的反馈，为什么要分享，不在于你认识什么人，而在于什么人认识你，不在于什么人影响了你，而在于你影响了什么人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获取、整理知识，接下来就是使用 / 分享知识。只有把别人的东西转化为自己的，才算是掌握了。我觉得最好的方法就是写 Blog。&lt;/p&gt;
&lt;h3 id="blog_1"&gt;为什么要写 Blog&lt;/h3&gt;
&lt;p&gt;这个问题曾经我也问过自己，以前只是看到学长学姐们写的 Blog，感觉很厉害，认为自己也应该有这样一个。后来看到 &lt;a href="http://book.douban.com/subject/6709809/"&gt;暗时间&lt;/a&gt; 里面的两篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/"&gt;《书写是为了更好的思考》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/"&gt;《为什么你从现在开始就应该写博客》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;认真总结了一下写博客的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;总结知识&lt;/p&gt;
&lt;p&gt;这是我写 Blog 最直接的一个动机。只有把别人的东西转化为自己的，才算是真正掌握了。记录下自己某段时间的学习收获，思考感悟，不仅可以帮助自己回忆以前的知识，说不定还可以帮助到别人（我就是受益者，从别人的博客中学习到了很多知识）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帮助思考&lt;/p&gt;
&lt;p&gt;这是写 Blog 最大的好处。这个好处不仅仅局限于写 Blog 这种形式，无论以什么方式，只要写下你的思考过程和内容，就可以帮助你思考问题，也就是 &lt;strong&gt;书写&lt;/strong&gt; 的好处。&lt;a href="http://book.douban.com/subject/6709809/"&gt;《暗时间》&lt;/a&gt; 里面有个很形象的比喻：&lt;em&gt;人的思考就像是在黑暗中打着手电筒前行。&lt;/em&gt;因为人的脑力资源是有限的，所以我们经常遇到想问题想岔了，然后回不到原点的情况。书写不仅可以帮助我们缓存手电筒照到的区域，还可以帮助我们扩大手电筒的照亮直径。比如我写这篇博客，开始只是记录下别人的 PKM 的方法和工具的关键字，然后在大纲和简记的基础上，补充自己的心得完成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到交流帮助&lt;/p&gt;
&lt;p&gt;Blog 相比于 EN 的最大的优势。写 Blog 是开放的，别人可以随意看，而写 EN 我们只能自己看（EN 的共享笔记体验并不好）。每个人的思考都有盲点，你的盲点可以在别人那里得到补充，知识和思考在讨论得到提炼升华。&lt;/p&gt;
&lt;p&gt;还有一个好处是，敦促你必须认真思考。想象你在给一个玩偶小熊讲一个原理、技术，那么你必须 &lt;em&gt;“ 彻底反思整个知识体系，弄清这座大厦的根基在什么地方，弄清它的骨架在什么地方，一砖一瓦到底是怎么垒起来的。设想自己在 11 层，给处于 1 层的小熊讲明白一件事。”&lt;/em&gt; 现在你不需要小熊了，因为有更挑剔的的对手 —— 你的博客的读者。你偷懒不写 / 写出无意义的文章，他们不会像小熊一样包容你，只有写出高质量的博客才对得起观众，否则就是浪费他们的时间了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼心智&lt;/p&gt;
&lt;p&gt;激励你去坚持学习和思考：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了让你的博客有价值，你必须不断地总结自己学习的结果，比必须不断思考，给出比别人深刻、读到的见解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让你学会持之以恒地做一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;理性地书写的时候，大脑逐渐进入推理分析模块，一切不愉快的情绪，烦躁感都会逐渐消隐下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述体验在写代码时也能体会到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锻炼文字功底&lt;/p&gt;
&lt;p&gt;对于码农，这算是优点么？反正没有坏处 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_7"&gt;写在最后&lt;/h2&gt;
&lt;p&gt;总结一下总的流程就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取知识&lt;/strong&gt;：书籍 + feedly + pocket + Google Keep&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理知识&lt;/strong&gt;：Evernote + XMind&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用 / 分享知识&lt;/strong&gt;：Blog&lt;/p&gt;
&lt;p&gt;总结出来并且在实际行动中加以利用才是王道。&lt;/p&gt;
&lt;h2 id="_8"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.sand-ox.com/2011/02/pkm-tools/"&gt;我，和我的知识工具们 (2011-02-15 更新 )&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.williamlong.info/archives/3388.html"&gt;我的知识管理工具列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19557303"&gt;Evernote on zhihu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/topic/19558457"&gt;PKM on zhihu&lt;/a&gt;&lt;/p&gt;</content><category term="Misc"></category><category term="PKM"></category></entry><entry><title>学习 Linux 软件包依赖管理</title><link href="https://qian-gu.github.io/posts/cs/learning-linux-package-management.html" rel="alternate"></link><published>2014-04-21T13:43:00+08:00</published><updated>2014-04-21T13:43:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-21:/posts/cs/learning-linux-package-management.html</id><summary type="html">&lt;p&gt;安装软件时遇到依赖库版本过高的问题，学习总结 Linux 软件包管理 。&lt;/p&gt;</summary><content type="html">&lt;h2 id="linux"&gt;Linux 软件包依赖问题&lt;/h2&gt;
&lt;p&gt;早期的 Linux 系统上的软件是通过源码方式发布的，大家下载下来，在自己的机器上编译，得到可执行程序 。&lt;/p&gt;
&lt;p&gt;但是，任何程序员写程序都有可能会依赖一些别人已经写成的库，所以几乎一定规模的程序必然有依赖 。尤其是对于 Linux 系统，因为它是 &lt;strong&gt;free（自由，not 免费）&lt;/strong&gt;，开源软件的开发者不是在一个体系下，软件包的依赖关系就比较伤脑筋了， 尤其是当我们的系统里有成百上千的软件时，软件包管理的必要性就更明显了 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;比如我们需要安装 package-a，而 package-a  依赖于 package-b 才能运行，但是我们的系统没有安装 package-b，如果强制安装 package-a，软件很可能不能正常运行 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S.&lt;/strong&gt;  其实在 Windows 下也存在相似的问题，只是因为有微软统一的体系，很多 &lt;code&gt;dll&lt;/code&gt; 被集成在系统中，所以这个问题不明显 。&lt;/p&gt;
&lt;p&gt;不同的系统对于这个问题有不同的处理方法，这也体现出它们不同的处理问题的哲学：&lt;/p&gt;
&lt;p&gt;知乎上的问题：&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有个回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GNU/Linux：通常这个系统大多数软件是自由软件，换句话说，他们通常依赖的库也是自由的，所以软件开发者认为你可以自由的获取这些依赖库，自然就不需要自己再提供了。由系统 “ 发行版 ” 负责维护属于这个系统的所有依赖库，并且安装软件时确定依赖&lt;/p&gt;
&lt;p&gt;这个体系的特点是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统依赖通常是统一的，如果有多个程序依赖同一个库，在这个系统中通常是同一份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具有庞大的资源。例如 Debian 系现成的可依赖软件多达 30G，所以通常不可能预先把所有依赖都安装全，但庞大的依赖库给编程人员提供了很多方便&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你安装的软件越多，共同依赖所体现出的价值越高，解决依赖问题就越简单（因为当你安装足够多软件时，主流的依赖已经全部在你系统了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于巨大的共同依赖库存在，软件本身可以很小&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Windows：通常而言，这个系统的软件是商业软件，因此，他们依赖的库也很有可能是商业软件，所以，不可能要求用户自行获取这些依赖，这些依赖通常在发布软件的时候提供。如果你安装的软件少，这个体系很方便 。&lt;/p&gt;
&lt;p&gt;不过这造成了一些缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;没有一个庞大的公共库，很多功能以及基础库都是每个公司自己实现一套，浪费很多劳动力，编程人员到每个公司得学习一套不同的库，给编程人员带来不便&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有应用程序都自己带依赖，因此很可能有许多程序同时附带了相同的依赖，并且这些相同依赖还有可能是不同的版本，这会造成许多混乱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于所有应用程序都自己提供所有依赖，每个软件体积都很庞大&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统中安装的软件越多，越容易出问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id="linux_1"&gt;Linux 包管理系统&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Package-management-system"&gt;Package management system on wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;package management system&lt;/strong&gt;, also called &lt;strong&gt;package manager&lt;/strong&gt;, is a collection of software tools to automate the process of installing, upgrading, configuring, and removing software packages for a computer's operating system in a consistent manner. It typically maintains a database of software dependencies and version information to prevent software mismatches and missing prerequisites.&lt;/p&gt;
&lt;p&gt;Package management systems are designed to save organizations time and money through remote administration and software distribution technology that eliminate the need for manual installs and updates. This can be particularly useful for large enterprises whose operating systems are based on Linux and other Unix-like systems, typically consisting of hundreds or even thousands of distinct software packages; in the former case, a package management system is a convenience, in the latter case it becomes essential.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 发行版中，几乎每一个发行版都有自己的软件包管理系统 。&lt;/p&gt;
&lt;h3 id="dpkg"&gt;Dpkg&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Dpkg"&gt;Dpkg on wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dpkg 是基于 Debian 系统的包管理软件 。&lt;code&gt;dpg&lt;/code&gt; 可以用来安装、删除、提供&lt;code&gt;.deb&lt;/code&gt; 格式软件包相关信息的文件 。&lt;/p&gt;
&lt;p&gt;dpkg 由 Matt Welsh、Carl Streeter、 Ian Murdock 用 Perl 语言编写，后来在 1994 年。 Ian Jackson 改用 C 重写了大部分内容 。&lt;/p&gt;
&lt;p&gt;dpkg 是 “Debian package” 的缩写，它最初是为 Debian 系统编写的，也可以在使用 &lt;code&gt;.deb&lt;/code&gt; 格式的 Ubuntu 系统上使用 。&lt;/p&gt;
&lt;h4 id="_1"&gt;常用语法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dpkg&lt;span class="w"&gt; &lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;peackage.deb&lt;span class="w"&gt;        &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;install
dpkg&lt;span class="w"&gt; &lt;/span&gt;-r&lt;span class="w"&gt; &lt;/span&gt;package.deb&lt;span class="w"&gt;         &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;remove
dpkg&lt;span class="w"&gt; &lt;/span&gt;-l&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;optional&lt;span class="w"&gt; &lt;/span&gt;pattern&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;list&lt;span class="w"&gt; &lt;/span&gt;installed&lt;span class="w"&gt; &lt;/span&gt;package
dpkg&lt;span class="w"&gt; &lt;/span&gt;--configure&lt;span class="w"&gt; &lt;/span&gt;package&lt;span class="w"&gt;    &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;configure&lt;span class="w"&gt; &lt;/span&gt;package
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_2"&gt;详细用法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dpkg&lt;span class="w"&gt; &lt;/span&gt;--help
man&lt;span class="w"&gt; &lt;/span&gt;dpkg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="apt"&gt;Apt&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Advanced-Packaging-Tool"&gt;Advanced Packaging Tool on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Advanced Packaging Tool, or APT, is a free software user interface that works with core libraries to handle the installation and removal of software on the Debian GNU/Linux distribution and its variants. APT simplifies the process of managing software on Unix-like computer systems by automating the retrieval, configuration and installation of software packages, either from precompiled files or by compiling source code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;apt 最初是设计为 dpkg 的前端，用来处理 &lt;code&gt;.deb&lt;/code&gt; 格式的文件，后来它被 &lt;code&gt;APT-RPM&lt;/code&gt; 组织改造可以支持 RPM 包管理系统 。&lt;/p&gt;
&lt;p&gt;apt 由 &lt;code&gt;apt-get&lt;/code&gt;、&lt;code&gt;apt-cache&lt;/code&gt; 和 &lt;code&gt;apt-config&lt;/code&gt; 等小工具组成&lt;/p&gt;
&lt;h4 id="_3"&gt;常用语法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;package&lt;span class="w"&gt;             &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;install
apt-get&lt;span class="w"&gt; &lt;/span&gt;remove&lt;span class="w"&gt; &lt;/span&gt;package&lt;span class="w"&gt;              &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;remove
apt-cache&lt;span class="w"&gt; &lt;/span&gt;search&lt;span class="w"&gt; &lt;/span&gt;package&lt;span class="w"&gt;            &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;search
apt-get&lt;span class="w"&gt; &lt;/span&gt;update&lt;span class="w"&gt;                      &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;update&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;source&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;list
apt-get&lt;span class="w"&gt; &lt;/span&gt;upgrade&lt;span class="w"&gt;                     &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;upgrade&lt;span class="w"&gt; &lt;/span&gt;installed&lt;span class="w"&gt; &lt;/span&gt;software
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_4"&gt;详细用法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;man&lt;span class="w"&gt; &lt;/span&gt;apt
man&lt;span class="w"&gt; &lt;/span&gt;apt-get
man&lt;span class="w"&gt; &lt;/span&gt;apt-update
man&lt;span class="w"&gt; &lt;/span&gt;apt-upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_5"&gt;彩蛋&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get -h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;help 内容结束的最后一样会有一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This APT has Super Cow Powers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 terminal 中输入 &lt;code&gt;apt-get moo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会显示一头牛 :-P&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="aptitude"&gt;Aptitude&lt;/h3&gt;
&lt;p&gt;[aptitude on wiki][aptitude ]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;aptitude is a front-end to the Advanced Packaging Tool (APT). It displays a list of software packages and allows the user to interactively pick packages to install or remove. It has an especially powerful search system utilizing flexible search patterns. It was initially created for Debian, but has appeared in RPM Package Manager (RPM) based distributions as well (such as Conectiva).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;aptitude 是 APT 的文本界面客户端，它的交互性比 apt 好，似乎在处理依赖问题上也更好一些（我遇到的问题，用 aptitude 可以很方便地解决而 apt 不行 ）&lt;/p&gt;
&lt;h4 id="_6"&gt;常用语法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;aptitude&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;package
aptitude&lt;span class="w"&gt; &lt;/span&gt;remove&lt;span class="w"&gt; &lt;/span&gt;package
aptitude&lt;span class="w"&gt; &lt;/span&gt;clean
aptitude&lt;span class="w"&gt; &lt;/span&gt;search&lt;span class="w"&gt; &lt;/span&gt;package
aptitude&lt;span class="w"&gt; &lt;/span&gt;show&lt;span class="w"&gt; &lt;/span&gt;string
aptitude&lt;span class="w"&gt; &lt;/span&gt;update
aptitude&lt;span class="w"&gt; &lt;/span&gt;dist-update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_7"&gt;详细用法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;man&lt;span class="w"&gt; &lt;/span&gt;aptitude
aptitude&lt;span class="w"&gt; &lt;/span&gt;-h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h4 id="_8"&gt;彩蛋&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;aptitude&lt;span class="w"&gt; &lt;/span&gt;moo
aptitude&lt;span class="w"&gt; &lt;/span&gt;-v&lt;span class="w"&gt; &lt;/span&gt;moo
aptitude&lt;span class="w"&gt; &lt;/span&gt;-vv&lt;span class="w"&gt; &lt;/span&gt;moo
aptitude&lt;span class="w"&gt; &lt;/span&gt;-vvv&lt;span class="w"&gt; &lt;/span&gt;moo
aptitude&lt;span class="w"&gt; &lt;/span&gt;-vvvv&lt;span class="w"&gt; &lt;/span&gt;moo
aptitude&lt;span class="w"&gt; &lt;/span&gt;-vvvvv&lt;span class="w"&gt; &lt;/span&gt;moo
aptitude&lt;span class="w"&gt; &lt;/span&gt;-vvvvvv&lt;span class="w"&gt; &lt;/span&gt;moo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="yum"&gt;YUM&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/Yum"&gt;Yellowdog Updater, Modified on wiki&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Yellowdog Updater, Modified (yum) is an open-source command-line package-management utility for Linux operating systems using the RPM Package Manager. Though yum has a command-line interface, several other tools provide graphical user interfaces to yum functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;YUM 是一个基于 RPM 包管理的字符前端软件包管理器。能够从指定的服务器自动下载 RPM 包并且安装，可以处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装 。被 Yellow Dog Linux 本身，以及 Fedora、Red Hat Enterprise Linux 采用 。&lt;/p&gt;
&lt;h2 id="_9"&gt;举个栗子&lt;/h2&gt;
&lt;p&gt;有些软件要求的库的版本高于 (&amp;gt;=)xx.xxx，有些软件要求库的版本必须是 (=)xx.xxx，如果我们的库不能满足要求则无法安装软件 。一般 &lt;code&gt;apt-get&lt;/code&gt; 会处理比较简单的依赖关系，但是有些依赖关系 &lt;code&gt;apt-get&lt;/code&gt; 并不能解决 。这时候可以试试 &lt;code&gt;aptitude&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id="_10"&gt;问题&lt;/h3&gt;
&lt;p&gt;为新安装的 Ubuntu 安装开发环境时，遇到了库版本过高的问题，执行下面的命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;build-essential
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果 apt-get 提示有不满足依赖关系的包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done&lt;/p&gt;
&lt;p&gt;Building dependency tree&lt;/p&gt;
&lt;p&gt;Reading state information... Done&lt;/p&gt;
&lt;p&gt;Some packages could not be installed. This may mean that you have&lt;/p&gt;
&lt;p&gt;requested an impossible situation or if you are using the unstable&lt;/p&gt;
&lt;p&gt;distribution that some required packages have not yet been created&lt;/p&gt;
&lt;p&gt;or been moved out of Incoming.&lt;/p&gt;
&lt;p&gt;The following information may help to resolve the situation:&lt;/p&gt;
&lt;p&gt;The following packages have unmet dependencies:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build-essential : Depends: dpkg-dev (&amp;gt;= 1.13.5) but it is not going to be installed&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我们手动安装特定的库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;dpkg-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果提示我们库版本过高&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reading package lists... Done&lt;/p&gt;
&lt;p&gt;Building dependency tree&lt;/p&gt;
&lt;p&gt;Reading state information... Done&lt;/p&gt;
&lt;p&gt;Some packages could not be installed. This may mean that you have&lt;/p&gt;
&lt;p&gt;requested an impossible situation or if you are using the unstable&lt;/p&gt;
&lt;p&gt;distribution that some required packages have not yet been created&lt;/p&gt;
&lt;p&gt;or been moved out of Incoming.&lt;/p&gt;
&lt;p&gt;The following information may help to resolve the situation:&lt;/p&gt;
&lt;p&gt;The following packages have unmet dependencies:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is to be installed&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Recommends: build-essential but it is not going to be installed&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;       Recommends: fakeroot but it is not going to be installed

       Recommends: libalgorithm-merge-perl but it is not going to be installed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;E: Unable to correct problems, you have held broken packages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="aptitude_1"&gt;解决问题 —— 使用 &lt;code&gt;aptitude&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;解决方法就是降级&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;方法有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;apt-get 直接指定安装特定的版本&lt;/p&gt;
&lt;p&gt;首先查询是否提供低版本的包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;apt-cache&lt;span class="w"&gt; &lt;/span&gt;showpkg&lt;span class="w"&gt; &lt;/span&gt;package-name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;若有则指定安装某个版本&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;package-name&lt;span class="o"&gt;=&lt;/span&gt;version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 aptitude 自动处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我采用的第二种方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;aptitude&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;build-essential
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;结果如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following NEW packages will be installed:&lt;/p&gt;
&lt;p&gt;build-essential dpkg-dev{ab} &lt;/p&gt;
&lt;p&gt;The following packages are RECOMMENDED but will NOT be installed:&lt;/p&gt;
&lt;p&gt;fakeroot libalgorithm-merge-perl &lt;/p&gt;
&lt;p&gt;0 packages upgraded, 2 newly installed, 0 to remove and 18 not upgraded.&lt;/p&gt;
&lt;p&gt;Need to get 718 kB of archives. After unpacking 1,636 kB will be used.&lt;/p&gt;
&lt;p&gt;The following packages have unmet dependencies:&lt;/p&gt;
&lt;p&gt;dpkg-dev : Depends: libdpkg-perl (= 1.16.10ubuntu1) but 1.16.12ubuntu1 is installed.&lt;/p&gt;
&lt;p&gt;The following actions will resolve these dependencies:&lt;/p&gt;
&lt;p&gt;Keep the following packages at their current version:&lt;/p&gt;
&lt;p&gt;1)     build-essential [Not Installed]&lt;/p&gt;
&lt;p&gt;2)     dpkg-dev [Not Installed]&lt;/p&gt;
&lt;p&gt;Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然不是中止安装，选择 &lt;code&gt;n&lt;/code&gt;， aptitude 给出另外一个解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following actions will resolve these dependencies:&lt;/p&gt;
&lt;p&gt;Downgrade the following packages:&lt;/p&gt;
&lt;p&gt;1)     libdpkg-perl [1.16.12ubuntu1 (now) -&amp;gt; 1.16.10ubuntu1 (raring)]&lt;/p&gt;
&lt;p&gt;Accept this solution? [Y/n/q/?]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这正是我们需要解决的版本过高的问题，将库软件版本降级&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The following packages will be DOWNGRADED:&lt;/p&gt;
&lt;p&gt;libdpkg-perl &lt;/p&gt;
&lt;p&gt;The following NEW packages will be installed:&lt;/p&gt;
&lt;p&gt;build-essential dpkg-dev{a} &lt;/p&gt;
&lt;p&gt;The following packages are RECOMMENDED but will NOT be installed:&lt;/p&gt;
&lt;p&gt;fakeroot libalgorithm-merge-perl &lt;/p&gt;
&lt;p&gt;0 packages upgraded, 2 newly installed, 1 downgraded, 0 to remove and 18 not upgraded.&lt;/p&gt;
&lt;p&gt;Need to get 904 kB of archives. After unpacking 1,632 kB will be used.&lt;/p&gt;
&lt;p&gt;Do you want to continue? [Y/n/?] &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选择 &lt;code&gt;y&lt;/code&gt;。然后 aptitude 会完成剩余的工作 。&lt;/p&gt;
&lt;p&gt;问题解决啦！&lt;/p&gt;
&lt;h2 id="_11"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/20443067"&gt;Unix 的包依赖是如何形成的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://daway320.blog.163.com/blog/static/3878369920107331733393/"&gt;apt-get install 安装软件问题 ( 安装包的依赖库版本过高问题 )&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="Package Management"></category></entry><entry><title>学习 Vim 保存项目设置</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-save-project-configuration.html" rel="alternate"></link><published>2014-04-20T14:32:00+08:00</published><updated>2014-04-20T14:32:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-20:/posts/tools/learning-vim-save-project-configuration.html</id><summary type="html">&lt;p&gt;总结 Vim 保存项目设置 。&lt;/p&gt;</summary><content type="html">&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于 Vim 和 IDE 的争论，这是程序猿的圣战，不再浪费时间 :-D&lt;/li&gt;
&lt;li&gt;在参考了很多人分享的博客和教程之后，终于把 Vim 搭建成为一个自己定制的 IDE（这种说法严格意义上说，是不对的，应该是 “ 组合一组工具成为一个 IDE ”），总结一下～&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;很多编辑器都有一个功能是以前打开过的文档会有记忆，再次打开时会直接跳转到上次编辑的地方，比如 &lt;code&gt;Sublime Text 2&lt;/code&gt;，强大的 Vim 当然也有这个功能，&lt;strong&gt;我们的目标就是让 Vim 和其他 IDE 一样，可以记住上次的编辑状态&lt;/strong&gt;。Vim 要实现这个功能，涉及到两个地方的配置：&lt;code&gt;session&lt;/code&gt; 和 &lt;code&gt;viminfo&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="session"&gt;Session&lt;/h2&gt;
&lt;h3 id="intro"&gt;Intro&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;session
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以看到关于 &lt;code&gt;session&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Session keeps the Views for all windows, plus the global settings.  You can save a Session and when you restore it later the window layout looks the same. You can use a Session to quickly switch between different projects, automatically loading the files you were last working on in that project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我使用的 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr-21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.4&lt;/code&gt;  节保存的就是关于 session 的说明，在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;21&lt;/span&gt;.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以看到关于 session 的详细介绍 。&lt;/p&gt;
&lt;h3 id="config"&gt;Config&lt;/h3&gt;
&lt;p&gt;Session 保存的信息由 &lt;code&gt;sessionoptions&lt;/code&gt; 确定，详细用法可以查看 help&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;sessionoption&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;'sessionoptions' 'ssop' string  (default: &lt;strong&gt;"blank,buffers,curdir,folds,help,options,tabpages,winsize"&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is a comma separated list of words.  Each word enables saving and restoring something&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说 session 保存的会话的属性默认的有 8 个 ：&lt;strong&gt;当前编辑的空窗口、缓冲区、当前目录、折叠信息、帮助信息、选项、标签页、窗口大小信息 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的设置中，不要同时包含 &lt;code&gt;curdir&lt;/code&gt; 和 &lt;code&gt;sesdir&lt;/code&gt; 两个选项，若两个选项都不包含，则保存 session 时，会保存绝路径 。添加 &lt;code&gt;sesdir&lt;/code&gt; 可以将当前目录设置为 &lt;code&gt;session-file&lt;/code&gt;  所在的目录，这个设置有个很有用的地方就是，当我们通过网络访问我们的工程或者有很多个工程版本，这时候只需要每个工程下保存一个 session-file 即可 。&lt;/p&gt;
&lt;p&gt;删除 / 加入 某个选项的方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:set&lt;span class="w"&gt; &lt;/span&gt;sessionoptions-&lt;span class="o"&gt;=&lt;/span&gt;curdir
:set&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;sesdir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="save"&gt;Save&lt;/h3&gt;
&lt;p&gt;详细的语法可以在 help 中查看&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;mksession
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code&gt;mksession&lt;/code&gt; 命令保存会话&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:set&lt;span class="w"&gt; &lt;/span&gt;sessionoptopms-&lt;span class="o"&gt;=&lt;/span&gt;curdir
:set&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;sesdir
:mksession&lt;span class="w"&gt; &lt;/span&gt;project.vim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果 session-file 已经存在，则使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:mksession!&lt;span class="w"&gt; &lt;/span&gt;project.vim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="load"&gt;Load&lt;/h3&gt;
&lt;p&gt;然后退出 Vim，在别的目录下打开，干点别的事，这时候我们想起刚才的工程里面有个小 bug，想恢复过去，这时候就是只需要使用 &lt;code&gt;source&lt;/code&gt; 命令即可 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;source&lt;/code&gt; 命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;source&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;PATHto/project.vim
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这时候可以看到，已经恢复了之前的状态 。&lt;/p&gt;
&lt;p&gt;只使用 session 就可以恢复一些上次编辑的信息，但是这还不够，我们还可以配合使用 &lt;code&gt;viminfo&lt;/code&gt; 来恢复更多的信息 。在 Vim 的 &lt;code&gt;:help 21.4&lt;/code&gt; 中有介绍两者的关系：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Sessions store many things, but not the position of marks, contents of registers and the command line history.&lt;/strong&gt;  You need to use the viminfo feature for these things.&lt;/li&gt;
&lt;li&gt;In most situations you will want to use sessions separately from viminfo. This can be used to switch to another session, but keep the command line history.  And yank text into registers in one session, and paste it back in another session.&lt;/li&gt;
&lt;li&gt;You might prefer to keep the info with the session.  You will have to do this yourself then.&lt;/li&gt;
&lt;li&gt;You could also use a Session file.  &lt;strong&gt;The difference is that the viminfo file does not depend on what you are working on.&lt;/strong&gt;  There normally is only one viminfo file.  Session files are used to save the state of a specific editing Session.  You could have several Session files, one for each project you are working on.  Viminfo and Session files together can be used to effectively
enter Vim and directly start working in your desired setup.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="viminfo"&gt;Viminfo&lt;/h2&gt;
&lt;h3 id="intro_1"&gt;Intro&lt;/h3&gt;
&lt;p&gt;在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;viminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以看到关于 &lt;code&gt;viminfo&lt;/code&gt; 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you exit Vim and later start it again, you would normally lose a lot of information.  The viminfo file can be used to remember that information, which enables you to continue where you left off.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Vim 7.3 中， &lt;code&gt;help&lt;/code&gt; 中的 &lt;code&gt;usr-21.txt&lt;/code&gt; 的主题是 &lt;code&gt;Go away and come back&lt;/code&gt;，其中 &lt;code&gt;21.3&lt;/code&gt;  节保存的就是关于 viminfo 的说明，在 Vim 中输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;21&lt;/span&gt;.3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以看到关于 viminfo 的详细介绍 。&lt;/p&gt;
&lt;p&gt;viminfo 文件可以保存的内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The command line history 命令行历史&lt;/li&gt;
&lt;li&gt;The search string history 字符串搜寻历史&lt;/li&gt;
&lt;li&gt;The input-line history 输入行历史&lt;/li&gt;
&lt;li&gt;Contents of non-empty register 非空寄存器内容&lt;/li&gt;
&lt;li&gt;Marks for serval files 文件位置标记&lt;/li&gt;
&lt;li&gt;Last search/substitute pattern 最近模式匹配搜索历史&lt;/li&gt;
&lt;li&gt;The buffer list 缓冲区列表&lt;/li&gt;
&lt;li&gt;Global variables 全局变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="save_1"&gt;Save&lt;/h3&gt;
&lt;p&gt;其实 Vim 每次退出时都会在 &lt;code&gt;～/&lt;/code&gt; 目录下保存一个 &lt;code&gt;.viminfo&lt;/code&gt; 的文件，但是每次打开关闭一个文件都会覆盖上次的记录，所以我们需要为工程手动保存一个 viminfo 文件，并且保存在工程目录下，防止被覆盖 。&lt;/p&gt;
&lt;p&gt;保存命令 &lt;code&gt;:wviminfo&lt;/code&gt; 的帮助&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;:wviminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code&gt;wviminfo&lt;/code&gt; 保存&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:wviminfo&lt;span class="w"&gt; &lt;/span&gt;project.viminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="load_1"&gt;Load&lt;/h3&gt;
&lt;p&gt;载入命令 &lt;code&gt;rviminfo&lt;/code&gt; 帮助&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:help&lt;span class="w"&gt; &lt;/span&gt;:rviminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;载入 viminfo 文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:rviminfo&lt;span class="w"&gt; &lt;/span&gt;path/to/project.viminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="_1"&gt;总结&lt;/h2&gt;
&lt;p&gt;为了节省每次都要手动输入一些设置命令，我们可以把部分相同的设置放在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sessionoptions-&lt;span class="o"&gt;=&lt;/span&gt;curdir
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;sessionoptions&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;sesdir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;每次退出 Vim 时保存&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:mksession&lt;span class="w"&gt; &lt;/span&gt;project.vim
:wviminfo&lt;span class="w"&gt; &lt;/span&gt;project.viminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;进入 Vim 想恢复项目设置时&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:source&lt;span class="w"&gt; &lt;/span&gt;projetc.vim
:rviminfo&lt;span class="w"&gt; &lt;/span&gt;projetc.viminfo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="_2"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-session-file-and-viminfo/"&gt;vi/vim 使用进阶 : 使用会话和 viminfo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-save-project-configuration/"&gt;vi/vim 使用进阶 : 保存项目相关配置&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category></entry><entry><title>学习 Vim 使用 Vundle 管理插件</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-vundle.html" rel="alternate"></link><published>2014-04-16T17:06:00+08:00</published><updated>2014-04-16T17:06:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-16:/posts/tools/learning-vim-vundle.html</id><summary type="html">&lt;p&gt;学习 Vim，使用 Vundle 管理插件 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;学习 Vim，使用 Vundle 管理插件 。&lt;/p&gt;
&lt;h2 id="vim"&gt;Vim 插件&lt;/h2&gt;
&lt;p&gt;Vim 的强大之处在于它的可扩展性，你可以把它当作一个简单的文本编辑器，也可以安装各种功能强大的插件，把它武装成一个 IDE 。我们可以从 &lt;a href="http://www.vim.org/scripts/script-search-results.php"&gt;Vim 官网&lt;/a&gt; 或 &lt;a href="https://vimawesome.com/"&gt;Vim Awesome&lt;/a&gt; 上找到 Vim 插件 。&lt;/p&gt;
&lt;h2 id="vundle"&gt;什么是 Vundle&lt;/h2&gt;
&lt;p&gt;Vim 的插件虽然强大，但是因为 Vim 根本就没有插件管理这个概念，所有插件的文件都散布在 ~/.vim 下的几个文件夹中，配置 vim 的过程 , 就是在网上不停的搜插件，拷贝到 &lt;code&gt;~/.vim&lt;/code&gt; 下，发现更新，要重新下载重新拷贝，想要删除某个不需要插件，更是要小心翼翼的不要删错。配置出顺手的 Vim, 需要极大的耐心和运气，而且如果换一台电脑，就要重复一次这样的痛苦经历 。&lt;/p&gt;
&lt;p&gt;自然地，因为管理插件的需求，最早出现了一些管理插件的脚本，但是写脚本需要一定的 shell 知识，直接 copy 别人的自己并不一定适用 。后来，出现了一些插件，比如 pathogen，muzuiget，vim-flavor，Vundle 等 。&lt;/p&gt;
&lt;p&gt;目前比较流行的方式是采用 &lt;a href="https://github.com/gmarik/Vundle.vim"&gt;Vundle&lt;/a&gt; 来管理插件，Vundle 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vundle is short for Vim bundle and is a Vim plugin manager.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vundle 可以在交互的方式下做到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 中管理和配置插件&lt;/li&gt;
&lt;li&gt;安装插件&lt;/li&gt;
&lt;li&gt;更新插件&lt;/li&gt;
&lt;li&gt;按名字搜索插件&lt;/li&gt;
&lt;li&gt;删除插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="vundle_1"&gt;如何使用 Vundle 管理插件&lt;/h2&gt;
&lt;h3 id="vundle_2"&gt;安装 Vundle&lt;/h3&gt;
&lt;p&gt;从 GitHub 上 clone 下来就可以了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;git&lt;span class="w"&gt; &lt;/span&gt;clone&lt;span class="w"&gt; &lt;/span&gt;https://github.com/gmarik/vundle.git&lt;span class="w"&gt; &lt;/span&gt;~/.vim/bundle/vundle
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="vundle_3"&gt;配置 Vundle&lt;/h3&gt;
&lt;p&gt;将下列内容加入到 &lt;code&gt;.vimrc&lt;/code&gt; 文件中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;
&lt;span class="normal"&gt;11&lt;/span&gt;
&lt;span class="normal"&gt;12&lt;/span&gt;
&lt;span class="normal"&gt;13&lt;/span&gt;
&lt;span class="normal"&gt;14&lt;/span&gt;
&lt;span class="normal"&gt;15&lt;/span&gt;
&lt;span class="normal"&gt;16&lt;/span&gt;
&lt;span class="normal"&gt;17&lt;/span&gt;
&lt;span class="normal"&gt;18&lt;/span&gt;
&lt;span class="normal"&gt;19&lt;/span&gt;
&lt;span class="normal"&gt;20&lt;/span&gt;
&lt;span class="normal"&gt;21&lt;/span&gt;
&lt;span class="normal"&gt;22&lt;/span&gt;
&lt;span class="normal"&gt;23&lt;/span&gt;
&lt;span class="normal"&gt;24&lt;/span&gt;
&lt;span class="normal"&gt;25&lt;/span&gt;
&lt;span class="normal"&gt;26&lt;/span&gt;
&lt;span class="normal"&gt;27&lt;/span&gt;
&lt;span class="normal"&gt;28&lt;/span&gt;
&lt;span class="normal"&gt;29&lt;/span&gt;
&lt;span class="normal"&gt;30&lt;/span&gt;
&lt;span class="normal"&gt;31&lt;/span&gt;
&lt;span class="normal"&gt;32&lt;/span&gt;
&lt;span class="normal"&gt;33&lt;/span&gt;
&lt;span class="normal"&gt;34&lt;/span&gt;
&lt;span class="normal"&gt;35&lt;/span&gt;
&lt;span class="normal"&gt;36&lt;/span&gt;
&lt;span class="normal"&gt;37&lt;/span&gt;
&lt;span class="normal"&gt;38&lt;/span&gt;
&lt;span class="normal"&gt;39&lt;/span&gt;
&lt;span class="normal"&gt;40&lt;/span&gt;
&lt;span class="normal"&gt;41&lt;/span&gt;
&lt;span class="normal"&gt;42&lt;/span&gt;
&lt;span class="normal"&gt;43&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nocompatible&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; be iMproved, required&lt;/span&gt;
&lt;span class="s2"&gt;filetype off                  &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;required

&lt;span class="s2"&gt;&amp;quot; set the runtime path to include Vundle and initialize&lt;/span&gt;
&lt;span class="s2"&gt;set rtp+=~/.vim/bundle/Vundle.vim&lt;/span&gt;
&lt;span class="s2"&gt;call vundle#begin()&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;alternatively,&lt;span class="w"&gt; &lt;/span&gt;pass&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;path&lt;span class="w"&gt; &lt;/span&gt;where&lt;span class="w"&gt; &lt;/span&gt;Vundle&lt;span class="w"&gt; &lt;/span&gt;should&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;plugins
&lt;span class="s2"&gt;&amp;quot;call vundle#begin(&amp;#39;~/some/path/here&amp;#39;)&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Vundle&lt;span class="w"&gt; &lt;/span&gt;manage&lt;span class="w"&gt; &lt;/span&gt;Vundle,&lt;span class="w"&gt; &lt;/span&gt;required
Plugin&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;VundleVim/Vundle.vim&amp;#39;&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; The following are examples of different formats supported.&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Keep&lt;span class="w"&gt; &lt;/span&gt;Plugin&lt;span class="w"&gt; &lt;/span&gt;commands&lt;span class="w"&gt; &lt;/span&gt;between&lt;span class="w"&gt; &lt;/span&gt;vundle#begin/end.
&lt;span class="s2"&gt;&amp;quot; plugin on GitHub repo&lt;/span&gt;
&lt;span class="s2"&gt;Plugin &amp;#39;tpope/vim-fugitive&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;plugin&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;http://vim-scripts.org/vim/scripts.html
&lt;span class="s2"&gt;&amp;quot; Plugin &amp;#39;L9&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Git&lt;span class="w"&gt; &lt;/span&gt;plugin&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;hosted&lt;span class="w"&gt; &lt;/span&gt;on&lt;span class="w"&gt; &lt;/span&gt;GitHub
Plugin&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;git://git.wincent.com/command-t.git&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; git repos on your local machine (i.e. when working on your own plugin)&lt;/span&gt;
&lt;span class="s2"&gt;Plugin &amp;#39;file:///home/gmarik/path/to/plugin&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;The&lt;span class="w"&gt; &lt;/span&gt;sparkup&lt;span class="w"&gt; &lt;/span&gt;vim&lt;span class="w"&gt; &lt;/span&gt;script&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;subdirectory&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;this&lt;span class="w"&gt; &lt;/span&gt;repo&lt;span class="w"&gt; &lt;/span&gt;called&lt;span class="w"&gt; &lt;/span&gt;vim.
&lt;span class="s2"&gt;&amp;quot; Pass the path to set the runtimepath properly.&lt;/span&gt;
&lt;span class="s2"&gt;Plugin &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Install&lt;span class="w"&gt; &lt;/span&gt;L9&lt;span class="w"&gt; &lt;/span&gt;and&lt;span class="w"&gt; &lt;/span&gt;avoid&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;Naming&lt;span class="w"&gt; &lt;/span&gt;conflict&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;you&lt;span class="s1"&gt;&amp;#39;ve already installed a&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; different version somewhere else.&lt;/span&gt;
&lt;span class="s1"&gt;&amp;quot; Plugin &amp;#39;&lt;/span&gt;ascenator/L9&lt;span class="s1"&gt;&amp;#39;, {&amp;#39;&lt;/span&gt;name&lt;span class="s1"&gt;&amp;#39;: &amp;#39;&lt;/span&gt;newL9&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="s2"&gt;&amp;quot; All of your Plugins must be added before the following line&lt;/span&gt;
&lt;span class="s2"&gt;call vundle#end()            &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;required
filetype&lt;span class="w"&gt; &lt;/span&gt;plugin&lt;span class="w"&gt; &lt;/span&gt;indent&lt;span class="w"&gt; &lt;/span&gt;on&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot; required&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;To&lt;span class="w"&gt; &lt;/span&gt;ignore&lt;span class="w"&gt; &lt;/span&gt;plugin&lt;span class="w"&gt; &lt;/span&gt;indent&lt;span class="w"&gt; &lt;/span&gt;changes,&lt;span class="w"&gt; &lt;/span&gt;instead&lt;span class="w"&gt; &lt;/span&gt;use:
&lt;span class="s2"&gt;&amp;quot;filetype plugin on&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; Brief help&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;:PluginList&lt;span class="w"&gt;       &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;lists&lt;span class="w"&gt; &lt;/span&gt;configured&lt;span class="w"&gt; &lt;/span&gt;plugins
&lt;span class="s2"&gt;&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;:PluginSearch&lt;span class="w"&gt; &lt;/span&gt;foo&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;searches&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;foo&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;append&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;!&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;refresh&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;local&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;cache
&lt;span class="s2"&gt;&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot; see :h vundle for more details or wiki for FAQ&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Put&lt;span class="w"&gt; &lt;/span&gt;your&lt;span class="w"&gt; &lt;/span&gt;non-Plugin&lt;span class="w"&gt; &lt;/span&gt;stuff&lt;span class="w"&gt; &lt;/span&gt;after&lt;span class="w"&gt; &lt;/span&gt;this&lt;span class="w"&gt; &lt;/span&gt;line
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;从上面的配置文件中可以看到，Vundle 把插件分为了 4 类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;plugin on GitHub repo&lt;/p&gt;
&lt;p&gt;GitHub 上的插件，需要按照 &lt;code&gt;usrname/repos&lt;/code&gt; 的格式写出插件的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;plugin from http://vim-scripts.org/vim/scripts.html &lt;/p&gt;
&lt;p&gt;Vim scripts 上的插件，不用作者名，直接写插件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git plugin not hosted on GitHub&lt;/p&gt;
&lt;p&gt;不是 GitHub 上的插件，需要写出插件的 git 链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git repo on your local machine&lt;/p&gt;
&lt;p&gt;本地 git repo 的插件，需要写出插件的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="vundle_4"&gt;运行 Vundle&lt;/h3&gt;
&lt;p&gt;修改好 &lt;code&gt;.vimrc&lt;/code&gt; 文件后，打开 Vim，使用以下命令管理插件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;列表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginList&lt;span class="w"&gt; &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;列出已安装的插件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginInstall&lt;span class="w"&gt;  &lt;/span&gt;// 安装插件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜索&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginSearch&lt;span class="w"&gt; &lt;/span&gt;foo&lt;span class="w"&gt;  &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;搜索插件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginInstall!&lt;span class="w"&gt;  &lt;/span&gt;//&lt;span class="w"&gt; &lt;/span&gt;或者
:PluginUpdate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;.vimrc&lt;/code&gt; 文件中删除 / 注释掉相应的插件名，然后输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:PluginClean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zuyunfei.com/2013/04/12/killer-plugin-of-vim-vundle/"&gt;vim 中的杀手级插件 : vundle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zfanw.com/blog/vundle-vim-plugin-management.html"&gt;Vundle 管理 Vim 插件&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category><category term="vundle"></category></entry><entry><title>学习 Vim 初步配置 Vim</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-vimrc-preliminary.html" rel="alternate"></link><published>2014-04-16T12:44:00+08:00</published><updated>2014-04-16T12:44:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-16:/posts/tools/learning-vim-vimrc-preliminary.html</id><summary type="html">&lt;p&gt;总结初步配置 Vim，让 Vim 更顺手 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;总结初步配置 Vim，让 Vim 更顺手 。&lt;/p&gt;
&lt;h2 id="vim"&gt;在哪里配置 Vim&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习 Vi 和 Vim 编辑器&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim 依照特定顺序寻找初始化的信号，它执行找到的第一组指令（可以是 环境变量 or 配置文件），然后开始编辑工作 。所以，Vim 在下列清单中遇到的第一个项目，就是清单中被执行的唯一项目 。书寻如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;VIMINIT&lt;/code&gt; 。它是环境变量，如果不为空，Vim 把它的内容当作 ex 命令执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户 &lt;code&gt;vimrc&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exrc&lt;/code&gt; 选项 。如果设置了 Vim 的 exrc 选项，它会寻找三个额外的配置文件 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;vimrc&lt;/code&gt;（vim runtime configure）文件一般有 3 个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;/etc/vim/vimrc&lt;/p&gt;
&lt;p&gt;本配置文件影响所有的用户，一般不应该更改这个配置文件，因为谁也不能保证别人的喜好和自己一样 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/usr/share/vim/vimrc&lt;/p&gt;
&lt;p&gt;输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt; &lt;/span&gt;ll&lt;span class="w"&gt; &lt;/span&gt;/usr/share/vim/vimrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以看到，本文件是 &lt;code&gt;/etc/vim/vimrc&lt;/code&gt; 的软链接 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;~/.vimrc&lt;/p&gt;
&lt;p&gt;一般来说，配置 vim 就是在这个文件中配置，如果不存在的话 &lt;code&gt;touch&lt;/code&gt; 一个新文件并命名 &lt;code&gt;。vimrc&lt;/code&gt; 。我们在下面说的配置都是在本文件中配置 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="esc"&gt;映射 &lt;code&gt;esc&lt;/code&gt; 键&lt;/h2&gt;
&lt;p&gt;因为历史原因，Joy 设计 vi 时采用的键盘和我们现在用的标准键盘布局并不一样，当时他的键盘的 &lt;code&gt;esc&lt;/code&gt; 键在现在我们的 &lt;code&gt;Caps Lock&lt;/code&gt; 键的位置，所以才设计使用 &lt;code&gt;esc&lt;/code&gt; 作为模式转换键 。为了更加方便顺手地使用 vim，当然要把这两个键相互调换一下 。&lt;/p&gt;
&lt;p&gt;在 vim 的官网上就有介绍如何实现两个按键的调换&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vim.wikia.com/wiki/Map-caps-lock-to-escape-in-XWindows"&gt;Map caps lock to escape in XWindows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体方法，在 &lt;code&gt;～/&lt;/code&gt; 目录下新建一个文件，加入一下内容&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;!&lt;span class="w"&gt; &lt;/span&gt;Swap&lt;span class="w"&gt; &lt;/span&gt;caps&lt;span class="w"&gt; &lt;/span&gt;lock&lt;span class="w"&gt; &lt;/span&gt;and&lt;span class="w"&gt; &lt;/span&gt;escape
remove&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Lock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Caps-Lock
keysym&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Escape&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Caps-Lock
keysym&lt;span class="w"&gt; &lt;/span&gt;Caps-Lock&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Escape
add&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;Lock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Caps-Lock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;保存为 .speedswrapper&lt;/p&gt;
&lt;p&gt;然后输入命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;xmodmap&lt;span class="w"&gt; &lt;/span&gt;~/.speedswrapper
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这时，对于整个系统范围，这两个键已经调换了位置 。&lt;/p&gt;
&lt;h2 id="colorscheme"&gt;设置颜色主题 colorscheme&lt;/h2&gt;
&lt;p&gt;Vim 自带一些颜色主题，一般存放在 &lt;code&gt;/usr/share/vim/vim7x&lt;/code&gt; 目录下（我的 Vim 版本为 7.3，所以路径为 &lt;code&gt;/usr/share/vim/vim73&lt;/code&gt;）.&lt;/p&gt;
&lt;p&gt;如果对系统自带的主题不满意，网上有很多不错的主题，个人最喜欢 &lt;a href="https://github.com/tomasr/molokai"&gt;molikai&lt;/a&gt; 主题，把下载下来的配色文件拷贝到 &lt;code&gt;usr/share/vim/vim73&lt;/code&gt; 路径下，打开 vim 后 输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;:colorscheme&lt;span class="w"&gt; &lt;/span&gt;molikai
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就 ok 了～ 不过这个方法在关闭 vim 后就恢复了，要想省去每次都输命令的烦恼，只需要在下一步 .vimrc 文件中加入以下内容就可以了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;colorscheme&lt;span class="w"&gt; &lt;/span&gt;molikai
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="vimrc"&gt;编写 .Vimrc&lt;/h2&gt;
&lt;p&gt;vimrc 文件是配置 Vim 编辑特性比较好的地方，差不多任何 Vim 选项都能在次文件中被设置为打开或者关闭，而且它特别适合设置全局变量与定义函数、缩写、按键映射 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注释以双引号 &lt;code&gt;“&lt;/code&gt; 开始，可位于一行的任何 2 位置，所有位于双引号后面的文本，包括双引号都会被视为注释而忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用冒号 &lt;code&gt;:&lt;/code&gt; 表示 ex 命令&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim_1"&gt;配置 Vim 特性&lt;/h3&gt;
&lt;p&gt;vimrc 配置很简单，网上有很多人都分享了自己的配置方案 。我找到一份注释良好的&lt;a href="https://github.com/amix/vimrc"&gt;配置范例&lt;/a&gt;，这篇博客的作者总结了自己 8 年的使用经验，给出了 &lt;a href="https://github.com/amix/vimrc/blob/master/vimrcs/basic.vim"&gt;Basic&lt;/a&gt; 和 &lt;a href="https://github.com/amix/vimrc"&gt;Awesome&lt;/a&gt; 两份配置文件。一开始只需要看基础版就足够了，后续可以在高级版上定制自己的配置。&lt;/p&gt;
&lt;h2 id="_1"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/6126937/"&gt;学习 vi 和 Vim 编辑器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/amix/vimrc"&gt;The Ultimate vimrc&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category></entry><entry><title>C++ const 限定符</title><link href="https://qian-gu.github.io/posts/cs/cosnt-qualifier.html" rel="alternate"></link><published>2014-04-09T11:13:00+08:00</published><updated>2014-04-09T11:13:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-09:/posts/cs/cosnt-qualifier.html</id><summary type="html">&lt;p&gt;总结 const 限定符的用法。&lt;/p&gt;</summary><content type="html">&lt;h2 id="const"&gt;为什么要使用 const 限定符&lt;/h2&gt;
&lt;h3 id="const_1"&gt;一个需要使用 const 的简单例子&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; 中的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;这段代码语法上是没有问题的，但是事实上是有两个小问题的，而且两个小问题都和数字 &lt;code&gt;512&lt;/code&gt; 有关 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个问题是 程序的可读性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较 &lt;code&gt;index&lt;/code&gt; 与 &lt;code&gt;512&lt;/code&gt; 有什么意思呢？也就是说 512 这个值作用何在？在程序中这种数字被称为 &lt;code&gt;魔数（magic number）&lt;/code&gt;，它的意义在上下文中没有体现出来，好像这个数是凭空魔术般变出来的 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个问题是 程序的可维护性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如歌这个程序非常庞大，512 这个数字出现了 100 次，进一步假设这 100 次中，有 80 次是表示某个缓冲区的大小，剩余 20 次用于其他目的 。现在，我们需要把缓冲区的大小增大到 1024，要实现这个目标，必须检查每个 512 出现的位置，必须确定哪些是表示缓冲区大小，哪些不是 。&lt;/p&gt;
&lt;p&gt;解决这两个问题的方法是定义一个变量，并且初始化为 512&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;通过定义一个好记的变量，就可以增强程序的可读性，而且需要改变这个值时，只需要咋初始化的地方做修改 。这种方法不仅明显减小了工作量，而且大大减小了出错的可能性 。&lt;/p&gt;
&lt;p&gt;看起来问题好像已经解决了，但是，事实上，我们可以进一步。在上面的代码中，&lt;code&gt;buf_size&lt;/code&gt; 是可以被修改的，它有可能会被有意或者无意修改 。为了避免这种情况，就需要使用 const 限定符了 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;上面的代码定义 &lt;code&gt;buf-size&lt;/code&gt; 为常量（constant）并且初始化为 512。变量（variable）&lt;code&gt;buf_size&lt;/code&gt; 仍然是一个左值，但是这个左值现在是不能被修改的，因为 const 把变量转化为常量，所以在定义的时候必须初始化。&lt;/p&gt;
&lt;h2 id="const_2"&gt;如何使用 const 限定符&lt;/h2&gt;
&lt;p&gt;C++ Primer 中有这么一句话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It (const) transforms an object into a constant.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是在这句话之后有说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The variable bufSize is still an lvalue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是矛盾的，因为常量是不能当左值的 。个人感觉严谨的说法应该是 "cosnt 使变量具有了常量的属性 “&lt;/p&gt;
&lt;h3 id="_1"&gt;文件的局部变量&lt;/h3&gt;
&lt;p&gt;const 限定符修同时也改变了变量的作用范围 。普通非 const 变量的默认是具有外部连接（&lt;code&gt;external linkage&lt;/code&gt;）的，在全局作用域内定义非 const 变量时，它在整个程序中都可以被访问 。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// file1.cpp&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//file2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;但是，对于全局作用域内的 const 类型的对象，其默认是内部连接（&lt;code&gt;internal linkage&lt;/code&gt;），仅在定义该对象的文件内可见，不能被其他文件访问 。要想在整个程序里面访问，就必须在定义的时候显式地声明为 &lt;code&gt;extern&lt;/code&gt; 类型 。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;//file1.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fcn&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//fiel2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="const_3"&gt;使用 const 的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在头文件中定义，源文件需要使用时 include&lt;/p&gt;
&lt;p&gt;如果 const 变量是用常量表达式初始化的，那么就可以把它的定义放在头文件中，即使多次包含这个头文件也不会产生 ” 重定义 “  的问题 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// file1.h&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// file2.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;file1.h&amp;quot;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在源文件中定义，声明为 extern&lt;/p&gt;
&lt;p&gt;如果 const 变量不是用常量表达式初始化的，那么就不能把它当在头文件中 。只能在源文件中定义并初始化 。因为 const 变量是文件局部变量，所以要在其他文件中使用该变量，必须在定义时加上 &lt;code&gt;extern&lt;/code&gt; 声明 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// file1.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;其他文件要使用这个变量，有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在头文件中声明为 extern 类型，以使其他文件共享&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// file1.h&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// fil2.cpp&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;file1.h&amp;quot;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不在头文件中声明，其他文件中使用前声明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;// file2.cpp&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="admonition warning"&gt;
&lt;p class="admonition-title"&gt;Warning&lt;/p&gt;
&lt;p&gt;在 C 中 const 是默认为外部连接的，在 C++ 中是默认为内部连接的。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;至于为什么要这么规定，&lt;a href="http://book.douban.com/subject/1459728/"&gt;Thinking in C++&lt;/a&gt; 中有说明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Constants were introduced in early versions of C++ while the Standard C specification was
still being finished. It was then seen as a good idea and included in C. But somehow, const in
C came to mean “an ordinary variable that cannot be changed.” &lt;em&gt;In C, it always occupies
storage and its name is global. The C compiler cannot treat a const as a compile-time
constant.&lt;/em&gt; In C, if you say&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="nc"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;you will get an error, even though it seems like a rational thing to do. Because bufsize
occupies storage somewhere, the C compiler cannot know the value at compile time.&lt;/p&gt;
&lt;p&gt;In C++, a const doesn’t necessarily create storage. In C a const always creates storage.
Whether or not storage is reserved for a const in C++ depends on how it is used. In general, if
a const is used simply to replace a name with a value (just as you would use a #define), then
storage doesn’t have to be created for the const. If no storage is created (this depends on the
complexity of the data type and the sophistication of the compiler), the values may be folded
into the code for greater efficiency after type checking, not before, as with #define. If,
however, you take an address of a const(even unknowingly, by passing it to a function that
takes a reference argument) or you define it as extern, then storage is created for the const.&lt;/p&gt;
&lt;p&gt;Since a const in C++ defaults to internal linkage, you can’t just define a const in one file and
reference it as an extern in another file. To give a const external linkage so it can be
referenced from another file, you must explicitly define it as extern, like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that by giving it an initializer and saying it is extern, you force storage to be created for the const(although the compiler still has the option of doing constant folding here). The
initialization establishes this as a definition, not a declaration. The declaration:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb nb-Type"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;in C++ means that the definition exists elsewhere (again, this is not necessarily true in C).
&lt;em&gt;You can now see why C++ requires a constdefinition to have an initializer: the initializer
distinguishes a declaration from a definition (in C it’s always a definition, so no initializer is
necessary).&lt;/em&gt; With an external constdeclaration, the compiler cannot do constant folding
because it doesn’t know the value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="const-const"&gt;const 引用 &amp;amp; const 对象&lt;/h3&gt;
&lt;p&gt;在引用的定义中声明 const，此 const 约束的是引用，而不是引用的对象 。比如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;其中，&lt;code&gt;const&lt;/code&gt; 修饰的是 &lt;code&gt;int &amp;amp;&lt;/code&gt;，规定了引用 &lt;code&gt;ref&lt;/code&gt; 为 const 类型变量，而 &lt;code&gt;ival&lt;/code&gt; 的类型则由其他语句定义说明 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const 引用： 引用变量为 const 类型，引用对象的类型可以是 const、nonconst、r-value&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nonconst 引用： 引用变量为 nonconst 类型，引用对象只能是同类型的 nonconst 类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为引用只是对象的另外一个名字，它们指向的是统一块内存空间，所以通过修改引用的值就能达到修改对象的值的目的 。&lt;/p&gt;
&lt;p&gt;当对象是 const 类型时，隐含的含义是该对象不能被修改，所以只能定义 const 类型的引用指向它；nonconst 类型的引用隐含的意思是可以通过引用修改对象值，这对于 const 类型的对象来说是不允许的 。&lt;/p&gt;
&lt;p&gt;当对象是 nonconst 类型时，隐含的含义是该对象可以通过引用来修改，此时，const 引用和 nonconst 引用都可以指向该对象 。当使用 nonconst 引用时，可以通过引用修改对象的值；当使用 const 引用时，虽然对象的值是可以改变的，但是不能通过该引用修改，因为引用的类型是 const，定义以后，不能再修改 。 &lt;/p&gt;
&lt;h2 id="const_4"&gt;何时应该使用 const&lt;/h2&gt;
&lt;p&gt;Scott Meyers 大神的经典著作 &lt;a href="http://book.douban.com/subject/1842426/"&gt;Effective C++&lt;/a&gt; 里面提到的关于 const 的使用 。&lt;/p&gt;
&lt;h3 id="effective-c-02-constenuminline-defineprefer-constsenumsand-inline-to-define"&gt;Effective C++ 条款 02：尽量以 const、enum、inline 替换 #define（Prefer consts,enums,and inline to #define）&lt;/h3&gt;
&lt;p&gt;事实上设计 &lt;code&gt;const&lt;/code&gt; 的最初动机就是取代预处理器 &lt;code&gt;#define&lt;/code&gt; 来进行值替代 。因为 #define 不被视为语言的一部分，这就是它的问题所在。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#define ASPECT_RATIO 1.653;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;记号名 ASPECT_RATIO 也许从未被编译器看见，也许在编译器开始处理代码前就被与处理器移走了，于是记号没有进入记号表，当出现编译错误时，也许会提示是 1.653 而不是 ASPECT_RATIO，这回带来很多困惑 。&lt;/p&gt;
&lt;p&gt;解决之道就是以一个常量代替上述的宏&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AspectRatio&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;1.653&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="effective-c-03-constuse-const-whenever-possible"&gt;Effective C++ 条款 03：尽可能使用 const（Use const whenever possible）&lt;/h3&gt;
&lt;h2 id="_2"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1459728/"&gt;Thinking in C++&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1842426/"&gt;Effective C++&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="C++"></category><category term="const"></category></entry><entry><title>学习 Linux SSH</title><link href="https://qian-gu.github.io/posts/tools/learning-linux-ssh.html" rel="alternate"></link><published>2014-04-04T17:00:00+08:00</published><updated>2014-04-04T17:00:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-04:/posts/tools/learning-linux-ssh.html</id><summary type="html">&lt;p&gt;学习 SSH、SCP 命令，建立两台电脑相互访问 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;实验室的师兄师姐毕业了，继承了他们的旧电脑 。宿舍的笔记本和实验室的电脑出现了相互之间传送同步文件的需求 。想到了两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;云同步&lt;/li&gt;
&lt;li&gt;SSH / SCP&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决方案 1 是最省事的，也是目前最流行的，目前各大互联网公司都提供各种云服务，比如国外的 Google Drive、Dropbox，国内的百度云、360 网盘什么的。这种方案最大的有点是跨平台，不过这个方案是借助了第三方的服务器，需要连接到互联网才行，而且对网速是有一定要求的。&lt;/p&gt;
&lt;p&gt;解决方案 2 相比于方案 1 的优势是：不是必须要连接到互联网，在局域网内也可以同步文件 。一般局域网内传输文件的速度要比连外界的服务器快很多 。&lt;/p&gt;
&lt;p&gt;考虑到校园网的环境，明显方案 2 更加好 。&lt;/p&gt;
&lt;h2 id="ssh"&gt;什么是 SSH&lt;/h2&gt;
&lt;p&gt;最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑 。&lt;a href="http://en.wikipedia.org/wiki/Secure-Shell"&gt;SSH&lt;/a&gt; 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置 。&lt;/p&gt;
&lt;p&gt;最初的 SSH 协议是由芬兰的一家公司的研究员 Tatu Ylönen 于 1995 年设计开发的，但是因为受版权和加密算法等等的限制，现在很多人都转而使用 OpenSSH 。OpenSSH 是 SSH 的替代软件包，而且是开放源代码和免费的 。—— Wikipedia&lt;/p&gt;
&lt;p&gt;关于 SSH 的原理，找到了一系列 &lt;a href="http://www.ruanyifeng.com/blog/"&gt;阮一峰&lt;/a&gt;的文章，很简洁明了 :&lt;/p&gt;
&lt;h3 id="ssh_1"&gt;SSH&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh-remote-login.html"&gt;SSH 原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh-port-forwarding.html"&gt;SSH 原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="ssh_2"&gt;SSH 的用法&lt;/h2&gt;
&lt;p&gt;最简单明了的教程就是 man page 了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;man&lt;span class="w"&gt; &lt;/span&gt;ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt; 1&lt;/span&gt;
&lt;span class="normal"&gt; 2&lt;/span&gt;
&lt;span class="normal"&gt; 3&lt;/span&gt;
&lt;span class="normal"&gt; 4&lt;/span&gt;
&lt;span class="normal"&gt; 5&lt;/span&gt;
&lt;span class="normal"&gt; 6&lt;/span&gt;
&lt;span class="normal"&gt; 7&lt;/span&gt;
&lt;span class="normal"&gt; 8&lt;/span&gt;
&lt;span class="normal"&gt; 9&lt;/span&gt;
&lt;span class="normal"&gt;10&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NAME
&lt;span class="w"&gt;    &lt;/span&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;—&lt;span class="w"&gt; &lt;/span&gt;OpenSSH&lt;span class="w"&gt; &lt;/span&gt;SSH&lt;span class="w"&gt; &lt;/span&gt;client&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;remote&lt;span class="w"&gt; &lt;/span&gt;login&lt;span class="w"&gt; &lt;/span&gt;program&lt;span class="o"&gt;)&lt;/span&gt;

SYNOPSIS
&lt;span class="w"&gt; &lt;/span&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-1246AaCfgKkMNnqsTtVvXxYy&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-b&lt;span class="w"&gt; &lt;/span&gt;bind-address&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;cipher-spec&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;bind-address:&lt;span class="o"&gt;]&lt;/span&gt;port&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-e&lt;span class="w"&gt; &lt;/span&gt;escape-char&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-F&lt;span class="w"&gt; &lt;/span&gt;configfile&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-I&lt;span class="w"&gt; &lt;/span&gt;pkcs11&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;identity-file&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-L&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;bind-address:&lt;span class="o"&gt;]&lt;/span&gt;port:host:hostport&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-l&lt;span class="w"&gt; &lt;/span&gt;login-name&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;mac-spec&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-O&lt;span class="w"&gt; &lt;/span&gt;ctl-cmd&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;option&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-p&lt;span class="w"&gt; &lt;/span&gt;port&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-R&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;bind-address:&lt;span class="o"&gt;]&lt;/span&gt;port:host:hostport&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;ctl-path&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-W&lt;span class="w"&gt; &lt;/span&gt;host:port&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;local-tun&lt;span class="o"&gt;[&lt;/span&gt;:remote-tun&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;user@&lt;span class="o"&gt;]&lt;/span&gt;hostname&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;command&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;进阶的书籍有：&lt;a href="http://docstore.mik.ua/orelly/networking-2ndEd/ssh/index.htm"&gt;SSH, The Secure Shell: The Definitive Guide&lt;/a&gt;, O'reilly&lt;/p&gt;
&lt;p&gt;目前已经有两台安装了 Ubuntu 的电脑，实验室的一台 name 是 &lt;em&gt;lab&lt;/em&gt; ，宿舍的一台 name 是 &lt;em&gt;dom&lt;/em&gt; ，两台电脑上都有一个用户名为 &lt;em&gt;chien&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的目的是使两台电脑可以相互之间通过 SSH 访问。&lt;/strong&gt; 下面就是整个过程：&lt;/p&gt;
&lt;h3 id="ssh-server"&gt;安装 SSH server&lt;/h3&gt;
&lt;p&gt;SSH 只是一种协议，在 Ubuntu 下，具体实现使用的是 &lt;a href="http://www.openssh.com/"&gt;OpenSSH&lt;/a&gt; 。Ubuntu 默认是安装了 SSH 客户端 &lt;code&gt;openssh-client&lt;/code&gt;，而没有安装 SSH 服务程序 &lt;code&gt;openssh-server&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;检测本机是否已经安装了 SSH server&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;localhost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;如果结果是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh:&lt;span class="w"&gt; &lt;/span&gt;connect&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;host&lt;span class="w"&gt; &lt;/span&gt;localhost&lt;span class="w"&gt; &lt;/span&gt;port&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;22&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;Connection&lt;span class="w"&gt; &lt;/span&gt;refused
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;说明 SSH server 还没有安装 。&lt;/p&gt;
&lt;p&gt;安装方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;apt-get&lt;span class="w"&gt; &lt;/span&gt;install&lt;span class="w"&gt; &lt;/span&gt;openssh-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="ssh_3"&gt;启动 SSH 服务&lt;/h3&gt;
&lt;p&gt;启动 SSH server&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;sudo&lt;span class="w"&gt; &lt;/span&gt;/etc/init.d/ssh&lt;span class="w"&gt; &lt;/span&gt;start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;查询服务是否正确启动&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ps&lt;span class="w"&gt; &lt;/span&gt;-e&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;grep&lt;span class="w"&gt; &lt;/span&gt;ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;返回结果应该类似于&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4156&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;?&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="m"&gt;00&lt;/span&gt;:00:00&lt;span class="w"&gt; &lt;/span&gt;ssh-agent
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;4606&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;?&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="m"&gt;00&lt;/span&gt;:00:00&lt;span class="w"&gt; &lt;/span&gt;sshd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;则说明服务已经正确启动 。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为两台电脑要相互访问，所以它们的角色即使 server，又是 client，所以需要在两台电脑上都执行上面两步 。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="_1"&gt;远程访问&lt;/h3&gt;
&lt;p&gt;首先，查询本机 IP 地址&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ifconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;比如 lab 的 IP 地址是 &lt;code&gt;10.105.55.155&lt;/code&gt;, dom 的 IP 地址是 &lt;code&gt;10.210.111.116&lt;/code&gt; 。（因为是校园网，所以分配到的都是内网地址）&lt;/p&gt;
&lt;p&gt;然后，在宿舍用 dom 访问 lab 这台机器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;chien@10.105.55.155
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login1" src="/images/learning-linux-ssh/login1.png"&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 dom 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 lab 机器，远程机器 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;p&gt;同理，在实验室用 lab 访问 dom 这台机器&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh&lt;span class="w"&gt; &lt;/span&gt;chien@10.210.111.116
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;实际结果如下图&lt;/p&gt;
&lt;p&gt;&lt;img alt="login2" src="/images/learning-linux-ssh/login2.png"&gt;&lt;/p&gt;
&lt;p&gt;在执行命令前，提示符显示目前的用户是在 lab 这台机器上的用户 chien，本机 home 目录下有 &lt;code&gt;lab&lt;/code&gt; 文件，但是没有 &lt;code&gt;dom&lt;/code&gt; 文件 。执行了登录命令以后，就会切换到以 chien 身份登录到 dom 机器，远程机器 home 目录下有有 &lt;code&gt;dom&lt;/code&gt; 文件，但是没有 &lt;code&gt;lab&lt;/code&gt; 文件 。&lt;/p&gt;
&lt;h3 id="ip"&gt;省去 IP 地址&lt;/h3&gt;
&lt;p&gt;每次登录都需要记忆、手动输入 IP 地址，其实只需要改 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件，就能省去手动输入 IP 地址的烦恼。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;vim&lt;span class="w"&gt; &lt;/span&gt;/etc/hosts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在 dom 的 hosts 文件后面添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;lab&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.105.55.155
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在 lab 的 hosts 文件后面添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;dom&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;.210.111.116
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;以后，登录时只需要输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;//&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;dom&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;lab
ssh&lt;span class="w"&gt; &lt;/span&gt;lab

//&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;lab&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;domm
ssh&lt;span class="w"&gt; &lt;/span&gt;dom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以登录了。&lt;/p&gt;
&lt;h3 id="_2"&gt;公钥登录&lt;/h3&gt;
&lt;p&gt;上一步解决了 IP 地址的问题，但是还是需要手动输入密码 。我们可以用公钥登录的方法，免去输密码的烦恼。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，什么是数字签名 Digital Signature&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what-is-a-digital-signature.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次，生成数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 默认安装了 &lt;code&gt;ssh-keygen&lt;/code&gt;，可以生成公钥和私钥&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-keygen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;命令执行过程中会询问保存密钥文件的路径，还可以为密钥文件设置口令（passphrase）。运行结束以后，在 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 目录下，会新生成两个文件：&lt;code&gt;id-rsa.pub&lt;/code&gt; 和 &lt;code&gt;id-rsa&lt;/code&gt; 。前者是你的公钥，后者是你的私钥。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后，发布数字签名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;ssh-copy-id&lt;/code&gt; 命令可以把公钥复制到远程机器中 。&lt;/p&gt;
&lt;p&gt;将 dom 的公钥发送到 lab 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-copy-di&lt;span class="w"&gt; &lt;/span&gt;chien@lab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;将 lab 的公钥发送到 dom 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;ssh-copy-di&lt;span class="w"&gt; &lt;/span&gt;chien@dom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;最后，使用公钥登录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时，远程登录时就不再需要输入密码了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;//&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;dom&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;lab
ssh&lt;span class="w"&gt; &lt;/span&gt;lab

//&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;lab&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;dom
ssh&lt;span class="w"&gt; &lt;/span&gt;dom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h2 id="scp"&gt;使用 SCP 传输文件&lt;/h2&gt;
&lt;p&gt;SSH 提供了一些命令和 shell 用来登录远程服务器 。在默认情况下它不允许你拷贝文件 , 但是还是提供了一个 "scp" 命令 。scp 命令是 SSH 中最方便有用的命令了，试想，在两台服务器之间直接传送文件。仅仅用 scp 一个命令就完全解决了 。&lt;/p&gt;
&lt;p&gt;man page&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;man&lt;span class="w"&gt; &lt;/span&gt;scp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;
&lt;span class="normal"&gt;5&lt;/span&gt;
&lt;span class="normal"&gt;6&lt;/span&gt;
&lt;span class="normal"&gt;7&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;NAME
&lt;span class="w"&gt; &lt;/span&gt;scp&lt;span class="w"&gt; &lt;/span&gt;—&lt;span class="w"&gt; &lt;/span&gt;secure&lt;span class="w"&gt; &lt;/span&gt;copy&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;remote&lt;span class="w"&gt; &lt;/span&gt;file&lt;span class="w"&gt; &lt;/span&gt;copy&lt;span class="w"&gt; &lt;/span&gt;program&lt;span class="o"&gt;)&lt;/span&gt;

SYNOPSIS
&lt;span class="w"&gt; &lt;/span&gt;scp&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-12346BCpqrv&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-c&lt;span class="w"&gt; &lt;/span&gt;cipher&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-F&lt;span class="w"&gt; &lt;/span&gt;ssh-config&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-i&lt;span class="w"&gt; &lt;/span&gt;identity-file&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-l&lt;span class="w"&gt; &lt;/span&gt;limit&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;ssh-option&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-P&lt;span class="w"&gt; &lt;/span&gt;port&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;program&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;[[&lt;/span&gt;user@&lt;span class="o"&gt;]&lt;/span&gt;host1:&lt;span class="o"&gt;]&lt;/span&gt;file1&lt;span class="w"&gt; &lt;/span&gt;...&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[[&lt;/span&gt;user@&lt;span class="o"&gt;]&lt;/span&gt;host2:&lt;span class="o"&gt;]&lt;/span&gt;file2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;scp 可以实现把 [[user@]host1:]file1 复制到 [[user@]host2:]file2 的功能。所以&lt;/p&gt;
&lt;h3 id="dom-lab"&gt;上传 dom 本地文件至服务器 lab&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;scp&lt;span class="w"&gt; &lt;/span&gt;~/dom&lt;span class="w"&gt; &lt;/span&gt;chien@lab:~/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3 id="lab-dom"&gt;下载 lab 服务器文件至本地 dom&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;scp&lt;span class="w"&gt; &lt;/span&gt;chien@lab:lab&lt;span class="w"&gt; &lt;/span&gt;~/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;若发送文件夹则添加参数 &lt;code&gt;-r&lt;/code&gt; 即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;scp&lt;span class="w"&gt; &lt;/span&gt;-r&lt;span class="w"&gt; &lt;/span&gt;~/test&lt;span class="w"&gt; &lt;/span&gt;chien@lab:~/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;至此，就实现了两台电脑的之间相互远程访问的功能 。&lt;/p&gt;
&lt;h2 id="reference"&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh-remote-login.html"&gt;数字签名是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/12/ssh-port-forwarding.html"&gt;What is a Digital Signature?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ruanyifeng.com/blog/2011/08/what-is-a-digital-signature.html"&gt;SSH 原理与运用（一）：远程登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.youdzone.com/signature.html"&gt;SSH 原理与运用（二）：远程操作与端口转发&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="SSH"></category></entry><entry><title>学习 FPGA 入门</title><link href="https://qian-gu.github.io/posts/ic/learning-fpga-getting-started.html" rel="alternate"></link><published>2014-04-03T12:40:00+08:00</published><updated>2014-04-03T12:40:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-04-03:/posts/ic/learning-fpga-getting-started.html</id><summary type="html">&lt;p&gt;总结 FPGA 的学习经历，温故而知新。&lt;/p&gt;</summary><content type="html">&lt;h2 id="fpga"&gt;FPGA 是什么&lt;/h2&gt;
&lt;p&gt;FPGA 是 PLD 家族中的一员，要说清楚什么是 FPGA，就不得不说一说 PLD。（&lt;strong&gt;以下内容来自 wikipedia&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id="pld-asic"&gt;PLD &amp;amp; ASIC&lt;/h3&gt;
&lt;p&gt;早期的数字逻辑系统，是由中、小规模集成电路芯片搭建而成的。这种形式的电路在可靠性、工作速度、功耗和体积方面都难以满足大规模、高性能信息处理系统的要求 。后来，随着集成电路的发展，出现可专用集成电路 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专用集成电路&lt;/strong&gt;（Application Specific Integrated Circuits, &lt;a href="http://en.wikipedia.org/wiki/Application-specific-integrated-circuit"&gt;&lt;code&gt;ASIC&lt;/code&gt;&lt;/a&gt;）是指依产品需求不同而非通用目的，而自定义的特殊规格集成电路 。ASIC 可以将整个系统集成到一个芯片上。由于芯片内集成度高、连线短，所以它可以满足之前 ” 搭建系统 “ 难以满足的性能指标 。&lt;/p&gt;
&lt;p&gt;随着芯片尺寸的减小和设计工具的发展，这些年来 ASIC 芯片最大的集成度从 5,000 增长到了 超过 100,000,000 门 。现代的 ASIC 通常都包含了微处理器、存储块（如 ROM 、RAM 、EEPROM 、Flash 等）。这种 ASIC 被称为 SoC （&lt;a href="http://en.wikipedia.org/wiki/System-on-chip"&gt;system on chip&lt;/a&gt;），ASIC 设计师采用硬件描述语言（Hardware Description Language，HDL），比如 Verilog、VHDL，描述 ASIC 的功能 。&lt;/p&gt;
&lt;p&gt;但是 ASIC 的研制周期长，现代信息处理的快速发展要求集成电路的设计、测试和生产周期尽可能的段，这就促进了可编程逻辑器件的发展 。严格地说，有些可编程器件出现的时间比 ASIC 出现的早，这里说的可编程器件主要是指 CPLD/FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程逻辑器件&lt;/strong&gt;（Programmable Logic Device,&lt;a href="http://en.wikipedia.org/wiki/Programmable-logic-devices"&gt;&lt;code&gt;PLD&lt;/code&gt;&lt;/a&gt;）是一种用来搭建可重配置数字电路的电子器件。和逻辑门（logic gate）不同，PLD 出厂时逻辑功能是没有被定义的，在使用之前，必须先重配置（reconfigure）。&lt;/p&gt;
&lt;h3 id="_1"&gt;历史&lt;/h3&gt;
&lt;h4 id="rom-as-pld"&gt;ROM as PLD&lt;/h4&gt;
&lt;p&gt;在 PLD 器件被发明之前，就已经有人将 &lt;a href="http://en.wikipedia.org/wiki/Read-only-memory"&gt;ROM&lt;/a&gt; 以 PLD 的概念来运用，用 ROM 芯片来充当一些输入性的组合逻辑（combinatorial logic）的函数发生器。ROM 有 m 个地址线，则有 &lt;code&gt;n = 2^m&lt;/code&gt; 个输出结果，这和布尔逻辑是一一对应的，所以如果把 ROM 的地址线当作相互之间没有关系的输入，则相应的输出就可以实现不同的函数。&lt;/p&gt;
&lt;p&gt;早期的 Mask ROM 存储数据的方式是使用内部的硬件电路，所以只能在出厂时就写入数据，而且以后不能更改。这就导致了一系列缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;因为消费者必须联系制造商才能生产出自定义的芯片，所以只有买大量的 ROM 芯片时才经济划算 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为同样的原因，从设计到最终生产出产品，中间耗费的时间很长 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mask ROM 在研发中基本上不能使用，因为设计师在改进设计时需要经常改动 ROM 里面的值 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个设备中含有故障的 Mask ROM，那么修复这个设备的唯一方法就是召回设备并且更换其中的每一个 Mask ROM 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;PROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable-read-only-memory"&gt;PROM&lt;/a&gt;（Programmable Read Only Memory）是周文俊于 1956 年发明的。他在纽约 Garden City 的 American Bosch Arma Corporation 工作，当时，美国空军为了提升空军用计算机以及 Atlas E/F 波段导弹的灵活性和保安性而提出要求，这项技术就是为了满足这一要求而产生的 。&lt;/p&gt;
&lt;p&gt;PROM 是通过熔丝 / 反熔丝（fuse/antifuse）实现对每个 bit 的设置 。通过使用高电压脉冲改变内部的物理结构，这种方法通常是不可逆的，所以它只允许用户更改一次配置 。PROM 解决了上面提到的问题 1 和问题 2 ，因为公司可以买一大批没有配置过的 PROM，设计人员可以根据自己的需要随意配置 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EPROM"&gt;EPROM&lt;/a&gt;（Erasable Programmable Read Only Memory）是 intel 公司的 Dov Frohman 于 1971 年发明的 。与 PROM 不同的是，EPROM 可利用高电压将资料编程写入，通过紫外线照射的方式不断的重置为未配置状态。因此，在封装外壳上会预留一个石英玻璃所制的透明窗以便进行紫外线曝光。写入程序后通常会用贴纸遮盖透明窗，以防日久不慎曝光过量影响资料。&lt;/p&gt;
&lt;p&gt;因为 EPROM 可以重复配置，所以它解决了上面的第 3 个问题 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EEPROM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/EEPROM"&gt;EEPROM&lt;/a&gt;（Electrically Erasable Programmable Read-Only Memory）于 1983 年被发明出来。相比 EPROM，EEPROM 不需要用紫外线照射，也不需取下，就可以用特定的电压，来抹除芯片上的信息，以便写入新的数据 。&lt;/p&gt;
&lt;p&gt;如果设备可以从外部接收数据（比如 PC 通过串口线），就可以在线配置 EEPROM，这样它解决了问题 4 。&lt;/p&gt;
&lt;p&gt;虽然解决了上面的 4 个问题，但是把 ROM 当作 PLD 器件使用，还是有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;与专用逻辑电路相比，ROM 的速度很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当输入不同步时（异步状态），ROM 的输出有毛刺&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更加耗电&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与可编程逻辑相比，价格更贵，尤其是高速应用中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，大部分 ROM 没有输出寄存器，所以它不能直接应用在时序电路中，所以在状态机的设计中，通常还需要一个外部的 TTL 寄存器 。对电路设计的业余爱好者来说，有时也仍然用 “2716” 之类的普遍型 EPROM 芯片来充当 PLD，这种用法有时也称为 “ 穷人的 PAL”。（PAL 也是 PLD 的一种，以下将再进一步说明）&lt;/p&gt;
&lt;p&gt;于是，就出现了 PLD 器件。&lt;/p&gt;
&lt;h4 id="_2"&gt;早期可编程逻辑&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1969 年，Motorola 生产出 XC157，它是一个有 12 个逻辑门和 30 个独立输入 / 输出管脚的可编程逻辑正列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（PLA）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1971 年，通用电器公司（GE）在新的 PROM 技术的基础上发明了一种可编程逻辑器件。这个实验性质的设备通过使用多层逻辑来提高 IBM 的 ROAM 性能 。GE 的这个设备是最早的 PLD 设备，比 Altera 的 EPLD 早了十几年 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1974 年，GE 和 Monolithic Memories 达成协议，开发一种可编程逻辑器件。这个设备被称为 ”Programmable Associative Logic Array“ 或者是 PALA 。最终于 1976 年完成 MMI 5760 ，它可以实现超过 100 门的时序电路。GE 的开发环境支持这一器件，它可以直接将布尔表达式转化为配置器件的代码，然而最终这个器件却没有上市。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="pla"&gt;PLA&lt;/h4&gt;
&lt;p&gt;1970 年，德州仪器（TI）在 IBM 的 ROAM 基础上生产出 TMS2000，它有 17 个输入管脚，18 个输出管脚，8 个 JK 触发器来存储。TI 为这个设备发明了一个新名字 Programmable Logic Array（&lt;a href="http://en.wikipedia.org/wiki/Programmable-Logic-Array"&gt;PLA&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;PLA 具有一组可编程的 AND 阵列，AND 阵列之后连接一组可编程的 OR 阵列 ，这样就可以只在合乎设定条件时才允许产生逻辑信号输出 。&lt;/p&gt;
&lt;p&gt;虽然名字中含有可编程 3 个字，但是并不是所有的 PLA 都可以现场编程，事实上许多都属遮罩性的可编程化，性质与 ROM 相同，必须在芯片制造厂内就执行与完成程序化设定，尤其是内嵌于电路较复杂的芯片（例如：微处理器）的 PLA 多属此种程序化方式。&lt;/p&gt;
&lt;h4 id="pal"&gt;PAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable-Array-Logic"&gt;PAL&lt;/a&gt;（Programmable Array Logic）是 Monolithic Memories 公司在 1978 年 3 月提出的，在数字电路中用来搭建逻辑功能的可编程器件的总称 。PAL 内部含有固定的或门阵列，可编程的与门阵列，从而实现所要求的逻辑函数。&lt;/p&gt;
&lt;p&gt;PAL 内部有个 PROM 的核，外部附加的输出逻辑电路，这样就可以实现所需要的逻辑功能 。因为 PAL 是基于 PROM 的，所以要使用特殊的设备，PAL 才具有可编程性，而且是 ” 一次编程 “ 。&lt;/p&gt;
&lt;h4 id="gal"&gt;GAL&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Generic-array-logic"&gt;GAL&lt;/a&gt;（Generic array logic）是 PAL 的发展，是 Lattice Semiconductor 于 1985 年发明 。这个设备具有和 PAL 同样的功能，但是可以重配置多次，所以 GAL 在设计中很有用，一旦有错误，只需要擦除后重新配置即可 。&lt;/p&gt;
&lt;p&gt;后来，International CMOS Technology (ICT) 公司发明了 类似的设备，称为 PEEL（programmable electrically erasable logic）。&lt;/p&gt;
&lt;h4 id="cpld"&gt;CPLD&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Complex-programmable-logic-device"&gt;CPLD&lt;/a&gt;（Complex programmable logic device）适合用来实现各种运算和组合逻辑（combinational logic）。PAL、GAL 仅适合用在约数百个逻辑门所构成的小型电路，若要实现更大的电路则适合用 CPLD，一颗 CPLD 内等于包含了数颗的 PAL，各 PAL（逻辑区块）间的互接连线也可以进行程序性的规划、烧录，CPLD 运用这种多合一（All-In-One）的整合作法，使其一颗就能实现数千个逻辑门，甚至数十万个逻辑门才能构成的电路。&lt;/p&gt;
&lt;p&gt;CPLD 与 PAL 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非易失性配置存储器。与 FPGA 不同，CPLD v 不需要外部的 ROM，只要系统上电，就可以正常工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于许多旧的 CPLD 来说，布线约束要求大部分逻辑块要和输入输出相连接，以减少内部状态记录，对于新的 CPLD 系列来说，已经不需要这样了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPLD 与 FPGA 的共同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以利用大量的逻辑资源，CPLD 等价有有数百万的逻辑门资源可以用来实现比较复杂的设计，而 PAL 最多等价有几千个逻辑门，FPGA 有几万到几百万的逻辑门。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一些更加灵活的资源，比如宏模块之间复杂的反馈连接和整数运算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大的 CPLD 和小 FPGA 之间最显著的差别就是 CPLD 含有片内非易失性存储器 。因为非易失性存储器的特点，CPLD 在数字电路设计中被当作 ”boot loader“ 来使用，之后它再把系统的控制权转交给没有这种特性的设备，最好的例子就是使一块 CPLD 从非易失性存储器中装载配置 FPGA 所需要的数据 。&lt;/p&gt;
&lt;h4 id="fpga_1"&gt;FPGA&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable-gate-array"&gt;FPGA&lt;/a&gt;（Field Programmable Gate Array，FPGA）是在 PAL、GAL、CPLD 等可编程逻辑器件的基础上进一步发展的产物。它是作为专用集成电路领域中的一种半定制电路而出现的，既解决了全定制电路的不足，又克服了原有可编程逻辑器件门电路数有限的缺点。&lt;/p&gt;
&lt;p&gt;当 PAL 忙于进展成 GAL、CPLD 时，另一种 “ 可编程化 ” 的流派也逐渐成形，此称之为现场可编程闸阵列（Field Programmable Gate Array，FPGA）。FPGA 是以阵列（Gate Array）技术为基础所发展成的一种 PLD 。所谓 ”Field Programmable“ 就是说芯片是出厂以后由客户或者设计师配置而工作的 。&lt;/p&gt;
&lt;p&gt;1980 年代后期，Naval Surface Warfare Department 在 Steve Casselman 的提议下成立了实验项目，目的是为了研制一台由 600,000 个逻辑门组成的计算机。Casselman 最后成功了并且在 1992 年获得了专利 。&lt;/p&gt;
&lt;p&gt;Xilinx 公司的共同创世人 &lt;a href="http://en.wikipedia.org/wiki/Ross-Freeman"&gt;Ross Freeman&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Bernard-Vonderschmitt"&gt;Bernard Vonderschmitt&lt;/a&gt; 在 1985 年发明出第一款商业 FPGA —— XC2064 。XC2064 芯片有可以编程的逻辑门和可以编程的内部连接线，这开辟了一项新的技术和市场 。XC2064 有 64 个可配置逻辑块（configurable logic blocks，CLBs），和 3 输入查找表（lookup tables，LUTs）。&lt;/p&gt;
&lt;p&gt;从 1985 开始到 90 年代中期，Xilinx 一直处于高速发展阶段，之后竞争对手出现了，截至 1993 年，Actel 占据了 18% 的市场 。&lt;/p&gt;
&lt;p&gt;90 年代是 FPGA 爆炸式发展的年代，这一期间出现了大量高端技术和产品。在 90 年代初期，FPGA 主要应用于通信领域，在 90 年代后期，FPGA 已经广泛应用于消费品、汽车和工业应用 。&lt;/p&gt;
&lt;h2 id="fpga_2"&gt;为什么选择 FPGA&lt;/h2&gt;
&lt;h3 id="fpga-vs-asic"&gt;FPGA vs ASIC&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ASIC 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ASIC 在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ASIC 的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计周期最长，设计成本贵，设计费用最高，适合于批量很大或者对产品成本不计较的场合。&lt;/p&gt;
&lt;p&gt;至于 FPGA 的优点和缺点完全就是 ASIC 的取反 。FPGA 一般来说比专用集成电路（ASIC）的速度要慢，无法完成更复杂的设计，并且会消耗更多的电能。但是，FPGA 具有很多优点，比如可以快速成品，而且其内部逻辑可以被设计者反复修改，从而改正程序中的错误，此外，使用 FPGA 进行除错的成本较低 。在一些技术更新比较快的行业，FPGA 几乎是电子系统中的必要部件，因为在大批量供货前，必须迅速抢占市场，这时 FPGA 方便灵活的优势就显得很重要。这也是 FPGA 能够发展起来的原因，市场是不会允许一个毫无优势的技术发展到今天这种地步的 。&lt;/p&gt;
&lt;p&gt;两者不是对立的，由于各自的特点它们有各自适用的环境，不能一棒子打死，否定其中一个。事实上更多的情况是：设计开发是在普通的 FPGA 上完成的，然后将设计转移到一个类似于 ASIC 的芯片上 。&lt;/p&gt;
&lt;h3 id="fpga-vs-cpld"&gt;FPGA vs CPLD&lt;/h3&gt;
&lt;p&gt;为了达到上述目的，还有一种方法是使用 CPLD 。
CPLD 和 FPGA 都包括了一些相对大数量的可以编辑逻辑单元。CPLD 逻辑门的密度在几千到几万个逻辑单元之间，而 FPGA 通常是在几万到几百万。&lt;/p&gt;
&lt;p&gt;FPGA 与 CLPD 最大的区别就是：FPGA 是基于查找表（look up table，LUT），而 CPLD 是基于海门架构（sea-of-gates），也就是它们的系统结构 。CPLD 的结构具有一定的局限性 。这个结构由一个或者多个可编辑的结果之和的逻辑组列和一些相对少量的锁定的寄存器组成 。这样的结果是缺乏编辑灵活性，但是它的优点是，其延迟时间易于预计，逻辑单元对连接单元比率较高 。而 FPGA 具有的连接单元数量很大，这样虽然让它可以更加灵活的编辑，但是结构却复杂的多 。&lt;/p&gt;
&lt;p&gt;CPLD 和 FPGA 另外一个区别是大多数的 FPGA 含有高层次的内置模块（比如加法器和乘法器）和内置的存储器 。一个由此带来的重要区别是，很多新的 FPGA 支持完全的或者部分的系统内重新配置 。允许他们的设计随着系统升级或者动态重新配置而改变 。一些 FPGA 可以让设备的一部分重新编辑，而其他部分继续正常运行 。&lt;/p&gt;
&lt;p&gt;CPLD 与 FPGA 之间结构、原理上的差别导致两者应用上的差别 。考虑成本、性能要求等因素，应该根据实际情况选择 。&lt;/p&gt;
&lt;h2 id="xilinx-altera"&gt;Xilinx &amp;amp; Altera&lt;/h2&gt;
&lt;p&gt;FPGA 的制造商主要是 Xilinx 和 Altera 两家，他们合起来市场占有率达到了 80% 之多 。两家是 FPGA 技术的领导者也是长期竞争对手 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Xilinx"&gt;Xilinx&lt;/a&gt; 于 1984 年创建于美国加利福尼亚州的硅谷，总部位于硅谷核心的圣何塞。它是一家主要提供 FPGA 的科技公司 。并且就是它的创始人是发明了 FPGA 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Altera"&gt;Altera&lt;/a&gt; 是一家位于美国硅谷的可编程逻辑器件和 CPLD 的制造商 。该公司于 1984 年推出了其首款可编程逻辑设备。&lt;/p&gt;
&lt;p&gt;两家一直是互为竞争对手，一般来说，大学里面都 Altera 的器件和 VHDL 上课，所以在学校里面用 Xilinx 的人比较少 。&lt;/p&gt;
&lt;p&gt;因为原理是一样的，所以只要学会一种，另一种就很容易上手。学校实验室里面用的是 Xilinx 。&lt;/p&gt;
&lt;h2 id="xilinx-fpga-architecture"&gt;Xilinx FPGA Architecture（架构）&lt;/h2&gt;
&lt;p&gt;FPGA 需要反复烧写，所以不能像 ASIC 一样通过固定的与非门来完成，只能采用一种易于反复配置的结构，查找表就可以很好的满足这一要求。目前主流 FPGA 都是采用了基于 SRAM 工艺的查找表结构（军品和宇航级 FPGA 采用 Flash 或者熔丝 / 反熔丝工艺），通过烧写文件改变查找表内容的方法来实现对 FPGA 的重复配置。&lt;/p&gt;
&lt;p&gt;查找表（look-up table，LUT）本质上就是一个 RAM 。当用户通过原理图或 HDL 语言描述了一个电路以后，FPGA 开发软件会计算逻辑电路的所有可能结果，并把真值表事先写入 RAM，这样，每输入一个信号进行逻辑运算就相当于输入一个地址进行查找，这样 LUT 就具有了和逻辑电路相同的功能 。实际上，LUT 具有更快的执行速度和更大的规模 。&lt;/p&gt;
&lt;p&gt;上电时，FPGA 将外部存储器中的数据读入片内 RAM，完成配置后，进入工作状态；掉电后 FPGA 恢复为白片，内部逻辑消失。这样 FPGA 不仅能够反复使用，还无须专门的 FPGA 编程器，只需通用的 EPROM、PROM 编程器即可。&lt;/p&gt;
&lt;p&gt;目前，Xilinx FPGA 仍然是基于查找表技术，但是其概念已经远远超出查找表技术的限制，并且整合了常用功能的硬核模块（如块 RAM，时钟管理和 DSP）。Xilinx FPGA 内部大致可以分为 6 部分：&lt;/p&gt;
&lt;h3 id="iob"&gt;IOB&lt;/h3&gt;
&lt;p&gt;可编程输入 / 输出单元简称 I/O 单元，是芯片与外界电路的接口部分，完成不同电气特性下输入 / 输出信号的驱动和匹配 。&lt;/p&gt;
&lt;h3 id="clb"&gt;CLB&lt;/h3&gt;
&lt;p&gt;CLB（Configurable Logic Block）是 FPGA 内的基本逻辑单元，Xilinx FPGA 的 CLB 由多个相同的 Slice 和附加逻辑组成 。&lt;/p&gt;
&lt;h3 id="dcm"&gt;DCM&lt;/h3&gt;
&lt;p&gt;业内大多数 FPGA 都提供数字时钟管理（Digital Clock Manager）。Xilinx FPGA 提供 DCM 和 PLL 。&lt;/p&gt;
&lt;h3 id="bram"&gt;BRAM&lt;/h3&gt;
&lt;p&gt;大多数 FPGA 都具有内嵌的块 RAM，这大大扩展了 FPGA 的应用范围和灵活度 。块 RAM 可以被配置为单口 RAM、双端口 RAM、内容地址存储器（CAM）和 FIFO 等常用存储结构 。&lt;/p&gt;
&lt;h3 id="routing-resource"&gt;Routing Resource&lt;/h3&gt;
&lt;p&gt;布线资源连通 FPGA 内部的所有单元，而连线的长度和工艺决定着信号在连线上的驱动能力和传输速度 。Xilinx FPGA 的布线资源可以分为 4 类：全局布线资源、长线资源、短线资源、分布式资源 。&lt;/p&gt;
&lt;h3 id="embedded-module"&gt;Embedded Module&lt;/h3&gt;
&lt;p&gt;内嵌功能模块只要是指 DLL、PLL、DSP 和 CPU 等 &lt;strong&gt;软核&lt;/strong&gt;，还有底层的 &lt;strong&gt;硬核&lt;/strong&gt; 资源，比如内嵌的 Power PC、ARM9、DSP 芯片等 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Xilinx 主流 FPGA&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Xilinx 主流的 FPGA 主要有 A 系列、K 系列、V 系列、Spartan 系列，如今还有最新的 Zynq 系列，官网上有详细介绍 。&lt;/p&gt;
&lt;h2 id="_3"&gt;开发流程&lt;/h2&gt;
&lt;p&gt;FPGA 的开发流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="design flow" src="/images/learning-fpga-getting-started/design-flow.jpg"&gt;&lt;/p&gt;
&lt;p&gt;整个开发过程就是使用开发工具 ISE Design Suite，按照流程图进行 。图示是标准流程，但是实际上并不是严格按照每一个步骤进行 。&lt;/p&gt;
&lt;p&gt;一般简化过的流程是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设计可综合的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合 Systhesis&lt;/p&gt;
&lt;p&gt;前两步主要是确保写的代码是开发工具可以转化为实际电路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;综合后仿真&lt;/p&gt;
&lt;p&gt;这一步保证模块的逻辑功能是正确的，即检验模块的结果是否和预期一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序约束&lt;/p&gt;
&lt;p&gt;为设计添加时序约束和管脚约束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现 Implement&lt;/p&gt;
&lt;p&gt;按照约束条件将综合结果映射到实际器件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时序分析&lt;/p&gt;
&lt;p&gt;实际上，一次就能达到时序要求且布线成功的情况并不多，尤其是对于高速设计，所以需要根据上一步的时序结果对设计进行修改，以满足时序要求，类似于写软件的 Debug 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载，在线调试&lt;/p&gt;
&lt;p&gt;将设计下载到芯片中调试。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_4"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Programmable-logic-devices"&gt;PLD wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Field-programmable-gate-array"&gt;FPGA wikipedia&lt;/a&gt;&lt;/p&gt;</content><category term="IC"></category><category term="FPGA"></category></entry><entry><title>C/C++ 内置数据类型</title><link href="https://qian-gu.github.io/posts/cs/built-in-types.html" rel="alternate"></link><published>2014-03-31T13:37:00+08:00</published><updated>2014-03-31T13:37:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-03-31:/posts/cs/built-in-types.html</id><summary type="html">&lt;p&gt;重读经典 C++ Primer，总结 C++ 内置数据类型。&lt;/p&gt;</summary><content type="html">&lt;p&gt;类型是程序设计的基础。一些程序设计语言，比如 Smalltalk 和 Python，在运行的时候才检查预计中的对象的类型，相反 C++ 是静态类型（statically typed）语言，在编译时执行类型检查。导致的结果是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量和函数在使用前必须先声明。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每种类型都定义了其存储空间要求和可以在该类型的所有对象上执行的操作。C++ 是 在 C 的基础上扩充得到的，为了和 C 兼容， C++ 在必要时必须能够直接处理硬件，所以 C++ 提供的一组基本内置类型，如 int、char 等，这些类型与它们在机器硬件上的标示方式紧密相关，所以 C++ 可以称为 “ 具有高级语言库的低级语言 ”。&lt;/p&gt;
&lt;p&gt;本文只限于总结 C++ 的内置类型（Built-in Types），不讨论自定义类型。&lt;/p&gt;
&lt;h2 id="_1"&gt;基本内置类型&lt;/h2&gt;
&lt;h3 id="_2"&gt;算术类型&lt;/h3&gt;
&lt;p&gt;C++ 语言自身定义了一组基本类型来表示不同的数据，如整数、浮点数、字母、bool 类型等，这些类型统称为 &lt;code&gt;算术类型（Arithmetic type）&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算术类型的存储空间依机器而定，即用多少二进制位 bit 来表示一个数 。C++ 标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间 。事实上，对于 &lt;code&gt;int&lt;/code&gt; 类型，几乎所有的编译器使用的存储空间都比所要求的大 。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;sizeof()&lt;/code&gt; 操作符可以查询对象或类型的大小（以字节为单位），包含头文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;limits&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;就可以使用 STL 库中的 &lt;code&gt;numeric-limits&amp;lt;T&amp;gt;::max&lt;/code&gt; 和 &lt;code&gt;numeric-limits&amp;lt;T&amp;gt;::min&lt;/code&gt; 查询各个内置内类类型的最大值和最小值。&lt;/p&gt;
&lt;p&gt;下面是 Ubuntu amd64 版本上的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="size" src="/images/built-in-types/size.png"&gt;&lt;/p&gt;
&lt;p&gt;算术类型可以分为两类：表示整数的 &lt;code&gt;整型&lt;/code&gt; 和表示浮点数的 &lt;code&gt;浮点型&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Integral Types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示整数、字符、布尔值的算术类型合称为 整型（integral types）。&lt;/p&gt;
&lt;p&gt;整数的基本表示类型是 &lt;code&gt;int&lt;/code&gt; 。int 类型前面可以加两类修饰说明，表示数据位数长短的 &lt;code&gt;short&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; ；表示有无符号的 &lt;code&gt;signed&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 。组合出来的结果就有 4 种：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;每一种的数据长短和可以表示的范围都不相同。&lt;/p&gt;
&lt;p&gt;字符类型有两种：&lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;wchar-t&lt;/code&gt; 。char 用来表示基本字符集中的字符，wchar-t 用于扩展字符集 ，比如汉字和日语。修饰 int 类型有无符号的 signed 和 unsigned 也可以修饰 char 类型。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; (chapter 2) 中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Unlike the other integral types, there are three distinct types for char: plain char, signed char, and unsigned char. Although there are three distinct types, there are only two ways a char can be represented. The char type is respresented using either the signed char or unsigned char version. Which representation is used for char varies by compiler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么会有这么奇怪的事呢？上网搜索了一下，按照自己的理解总结了一下：&lt;/p&gt;
&lt;p&gt;signed/unsigned 可以描述的类型有 int 和 char 两种，C 标准里面规定：对于 int 类型，如果没有在类型前显式地声明，默认 int 是 signed 类型，而对于 char 类型，则是 &lt;em&gt;Implementation Defined&lt;/em&gt; 。也就是说由编译器在编译的时候决定具体使用哪一种 。而为什么要作出这么奇怪的规定呢？是因为 char 类型本来就是用来表示字符而非数字的， ASCII 码字只使用 7 bit，所以使用 signed/unsigned 对其没有影响，但是如果使用 char 类型来表示一个 8 bit 的数字（有时候空间不够用时不得不这样做，比如嵌入式系统中），为了可移植性，必须写明 signed/unsigned 。所以，如果用来表示字符，则直接使用 char 就行，如果用来表示整数，则声明是 signed/unsigned 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.51cto.com/art/200912/166574.htm"&gt;Linux C 编程一站式学习：整型&lt;/a&gt; 中进一步解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译器可以定义 char 型是无符号的，也可以定义 char 型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种，x86 平台的 gcc 定义 char 型是有符号的。这也是 C 标准的 Rationale 之一： &lt;em&gt;优先考虑效率，而可移植性尚在其次。&lt;/em&gt; 这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用。另一方面，写不可移植的代码有时候也是必要的，比如 Linux 内核代码使用了很多只有 gcc 支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写。如果不是为了效率，一般来说就没有理由故意编写不可移植的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上有&lt;a href="http://www.cppblog.com/wuzimian/archive/2012/05/28/176427.aspx"&gt;博客&lt;/a&gt;说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;VC 编译器、x86 上的 GCC 都把 char 定义为 signed char，而 arm-linux-gcc 却把 char 定义为 unsigned char 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，编写一个测试小程序就可以知道我们使用的编译器是如何处理的。&lt;/p&gt;
&lt;p&gt;源代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch1 = %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ch1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="char" src="/images/built-in-types/char.png"&gt;&lt;/p&gt;
&lt;p&gt;结果说明，gcc 把 char 默认为 signed char 处理。&lt;/p&gt;
&lt;p&gt;布尔类型表示 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 。可以将任何算术类型的值赋给 &lt;code&gt;bool&lt;/code&gt; 对象，&lt;code&gt;0&lt;/code&gt; 表示 &lt;code&gt;false&lt;/code&gt; ，任何非 &lt;code&gt;0&lt;/code&gt; 值都表示 &lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Floating-Point Types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;float&lt;/code&gt; 表示 单精度浮点数&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;double&lt;/code&gt; 表示 双精度浮点数&lt;/p&gt;
&lt;p&gt;类型 &lt;code&gt;long double&lt;/code&gt; 表示 扩展精度浮点数&lt;/p&gt;
&lt;p&gt;从前面的运行结果可以看出在我的电脑上 float 使用 1 个字（32 bit） 表示，double 使用 2 个字（64 bit） 表示，long double 使用 4 个字（128 bit） 表示 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;C++ Primer&lt;/a&gt; (chapter 2)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The float type is usually not precise enough for real programsfloat is guaranteed to offer only 6 significant digits. The double type guarantees at least 10 significant digits, which is sufficient for most calculations.&lt;/p&gt;
&lt;p&gt;Determining which floating-point type to use is easier: It is almost always right to use double. The loss of precision implicit in float is significant, whereas the cost of double precision calculations versus single precision is negligible. In fact, on some machines, double precision is faster than single. The precision offered by long double usually is unnecessary and often entails considerable extra run-time cost.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="void"&gt;void&lt;/h3&gt;
&lt;p&gt;void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。&lt;/p&gt;
&lt;h2 id="initialize"&gt;初始化 Initialize&lt;/h2&gt;
&lt;h3 id="_3"&gt;初始化 &amp;amp; 赋值&lt;/h3&gt;
&lt;p&gt;首先是初始化的必要性：&lt;/p&gt;
&lt;p&gt;在 C++ 中，初始化是一个非常重要的概念，给变量一个初始值几乎总是正确的，但不要求必须这么做。定义变量时，应该给变量赋初始值，除非确定将变量用于其他意图之前会覆盖这个初值。如果不能保证读取变量前重置变量，就应该初始化变量。变量没有初始化是很常见的导致程序崩溃 / 结果错误的原因，而且有时候很难像 Debug 一样找到这个错误（bug 导致程序一定不对，但是没有初始化的变量的结果是随机的）。所以，良好的习惯是对每个变量都进行初始化 。&lt;/p&gt;
&lt;p&gt;其次是初始化和赋值的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;code&gt;Initialization&lt;/code&gt;：创建变量并且给它赋初始值&lt;/li&gt;
&lt;li&gt;赋值 &lt;code&gt;Assigment&lt;/code&gt;：擦除变量的当前值并用新值代替&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 提供两种初始化变量的方法：复制初始化（&lt;code&gt;copy-initialization&lt;/code&gt;）和直接初始化（&lt;code&gt;direct-initialization&lt;/code&gt;）。复制初始化使用 &lt;code&gt;=&lt;/code&gt;，直接初始化使用 &lt;code&gt;()&lt;/code&gt; 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// copy-initialization&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;ival&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// direct-initialization&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;使用 &lt;code&gt;=&lt;/code&gt; 很容易让人把初始化和赋值混淆在一起，但是在 C++ 中这是两种不同的操作，当涉及到类对象时，两种不同的初始化方式的区别是很微妙的。目前先不考虑这点，只需要知道直接初始化语法更灵活而且效率高。&lt;/p&gt;
&lt;h3 id="_4"&gt;内置类型初始化&lt;/h3&gt;
&lt;p&gt;当我们定义一个变量却没有初始化时，系统 &lt;strong&gt;有可能&lt;/strong&gt; 会为我们进行隐式的初始化。至于系统是否帮我们隐式初始化变量，以及为变量赋予一个怎样的初始值，这要取决于该变量的类型以及我们在何处定义的该变量。&lt;/p&gt;
&lt;p&gt;内置类型的变量是否自动初始化取决于变量定义的位置。在函数体外（全局范围）定义的变量都初始化为 0，函数体内定义的变量不进行自动初始化。&lt;/p&gt;
&lt;h2 id="_5"&gt;算术类型转换&lt;/h2&gt;
&lt;h3 id="_6"&gt;隐式类型转换&lt;/h3&gt;
&lt;p&gt;当两个操作数类型不同时，C++ 并不是直接把两个数加在一起，而是提供了一组转换规则，以便在执行算术操作之前，将两个数转换为同一数据类型。这些转换规则由编译器自动执行，不需要程序员介入，有时甚至不需要程序员了解。因此它们被称为隐式类型转换 (&lt;code&gt;implicit type conversion&lt;/code&gt;) 。&lt;/p&gt;
&lt;p&gt;在以下情况会发生隐式类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;混合类型表达式，操作数被转换为相同类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// ival converted to double&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用作条件表达式被转化为 bool 型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="c1"&gt;// ival converted to bool&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// cin converted to bool&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用表达式初始化（赋值）某一变量，表达式被转化为该变量类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ival&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;3.14&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 3.14 converted to int&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ip&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;             &lt;/span&gt;&lt;span class="c1"&gt;// the int 0 converted to a null pointer of type int *&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，函数调用时也可能发生隐式类型转化。&lt;/p&gt;
&lt;h3 id="_7"&gt;算术类型转换&lt;/h3&gt;
&lt;p&gt;C++ 语言为内置类型提供了一组转化规则，其中最常用的就是算术转化（arithmetic conversion）。算术转化规则定义了一个 &lt;strong&gt;类型转换层次&lt;/strong&gt;，该层次规定了操作数应该按照什么次序转换为表达式中最宽的数据类型。&lt;/p&gt;
&lt;p&gt;有两条通用规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为了保留精度，如果有必要，数据总是被提升为较宽的类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有含有小于整形的有序类型的算术表达式在计算之前其类型都会被转换成整型（整型提升 integral promotion）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于有符号数和无符号数，原则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不同级数据转换，若较宽的类型可以表示所有较窄的类型的数，则直接将较窄的类型提升为较宽的类型，否则，把两个数都转换为无符号的较宽的类型 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同级数据转换，unsigned int 和 int ，signed 类型会转换为 unsigned 类型 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;unsigned 操作数的转换依赖于机器中整型的相对大小，所以，这类转换依赖于机器。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;short 类型 与 int 类型 。在我的机器上，short 类型所占用的宽度为半字（2 Byte），int 类型占用的宽度为 1 个字（4 Byte）。所有的 unsigned short 的值都包含在 int 之中，所以，unsigned short 转换为 int 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;
&lt;span class="normal"&gt;3&lt;/span&gt;
&lt;span class="normal"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;signed&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unsigned int b&amp;#39; = &amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;运行结果为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span class="normal"&gt;1&lt;/span&gt;
&lt;span class="normal"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;4294967276&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;因为 &lt;code&gt;b = -2&lt;/code&gt; 被转化为一个很大的正数 &lt;code&gt;b' = 4294967276&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="references"&gt;references&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1767741/"&gt;c++ Primer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cppblog.com/wuzimian/archive/2012/05/28/176427.aspx"&gt;C++ 之 char , signed char , unsigned char，以及 Integral Promotion&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://book.51cto.com/art/200912/166574.htm"&gt;Linux C 编程一站式学习：整型&lt;/a&gt;&lt;/p&gt;</content><category term="CS"></category><category term="C++"></category><category term="data type"></category></entry><entry><title>学习 Vim 存活</title><link href="https://qian-gu.github.io/posts/tools/learning-vim-survival.html" rel="alternate"></link><published>2014-03-25T21:23:00+08:00</published><updated>2014-03-25T21:23:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-03-25:/posts/tools/learning-vim-survival.html</id><summary type="html">&lt;p&gt;这个系列的博客是我学习 Vim 过程中的记录和总结，希望可以帮助到和我一样的菜鸟。&lt;/p&gt;</summary><content type="html">&lt;div class="admonition info"&gt;
&lt;p class="admonition-title"&gt;Info&lt;/p&gt;
&lt;p&gt;这个系列的博客是我学习 Vim 过程中的记录和总结，内容基本上来自网络上前辈们的博客，还有部分内容是我自己学习的心得。真心感谢前辈们的分享，我会尽量在后面的文章中标明内容出处，比如我学习 Vim 的路线就是按照&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;这个博客&lt;/a&gt;来学习的。希望我的学习历程可以帮助到和我一样的菜鸟，能更好地使用这款神器。&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id="vim"&gt;Vim 是什么&lt;/h2&gt;
&lt;p&gt;简单的说，&lt;a href="http://en.wikipedia.org/wiki/Vim-(text-editor)"&gt;Vim&lt;/a&gt; 就是广大的编辑器中的一员，但是对程序猿来说，她并不是一款简单的编辑器。她强大的编辑能力、苗条的身材（软件体积小、启动速度快）和 Linux 系统的血缘关系（几乎是 Linux 系统的标配），使其在全世界有成千上万的粉丝，以至于掌握 Vim 成为每个码农必备技能。&lt;/p&gt;
&lt;p&gt;Wikipedia 上 Vim 的介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Vim (an acronym for Vi IMproved) is a text editor written by Bram Moolenaar and first released publicly in 1991. Based on the vi editor common to Unix-like systems, Vim is designed for use both from a command line interface and as a standalone application in a graphical user interface. Vim is free and open source software and is released under a license that includes some charityware clauses, encouraging users who enjoy the software to consider donating to children in Uganda. The license is compatible with the GNU General Public License.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;历史&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;摘抄（翻译）自 &lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;Wikipedia&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于 vi/Vim 的发展，还是从头说起：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ed-(text-editor)"&gt;ed&lt;/a&gt;&lt;/strong&gt; 是 UNIX 界最古老最基本的编辑器，它由 &lt;a href="http://en.wikipedia.org/wiki/Ken-Thompson-(computer-programmer)"&gt;Ken Thompson&lt;/a&gt; (UNIX 之父 ) 于 1971 年在 &lt;a href="http://en.wikipedia.org/wiki/PDP-11"&gt;PDP-11&lt;/a&gt;/20 上用汇编写成 。ed 的许多特性来自于 Thompson 在加州伯克利大学上学时受到的 &lt;a href="http://en.wikipedia.org/wiki/QED-(text-editor)"&gt;qed&lt;/a&gt; 编辑器的影响 。Thompson 对 qed 非常熟悉，他在 &lt;a href="http://en.wikipedia.org/wiki/Compatible-Time-Sharing-System"&gt;CTSS&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/Multics"&gt;Multics&lt;/a&gt; 操作系统上重新实现了一边 qed ，并且在他的版本中，第一次实现了正则表达式（ &lt;a href="http://en.wikipedia.org/wiki/Regular-expression"&gt;regular expressions&lt;/a&gt;）。虽然正则表达式也是 ed 的一部分，但是一般认为在 qed 中正则表达式的实现更多一些 。&lt;/p&gt;
&lt;p&gt;ed 是为电传机（&lt;a href="http://en.wikipedia.org/wiki/Teletype"&gt;teletype&lt;/a&gt;）而不是终端显示器（&lt;a href="http://en.wikipedia.org/wiki/Display-terminal"&gt;display terminals&lt;/a&gt;）设计的行编辑器，它是一个行编辑器。在它的起源地 —— AT&amp;amp;T 实验室，人们似乎很满意把 ed 设置为默认的编辑器，即使它的功能很基本而且很不友好。 &lt;a href="http://en.wikipedia.org/wiki/George-Coulouris-(computer-scientist)"&gt;George Coulouris&lt;/a&gt; 回忆说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] for many years, they had no suitable terminals. They carried on with TTYs and other printing terminals for a long time, and when they did buy screens for everyone, they got Tektronix 4014s. These were large storage tube displays. You can't run a screen editor on a storage-tube display as the picture can't be updated. Thus it had to fall to someone else to pioneer screen editing for Unix, and that was us initially, and we continued to do so for many years.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coulouris 认为 ed 的隐藏的命令只适合于 “ 神人 ”（immortals），所以在 &lt;a href="http://en.wikipedia.org/wiki/Queen-Mary,-University-of-London"&gt;Queen Mary College&lt;/a&gt; 当讲师的期间，他在 Thompson 的代码的基础上加强了 ed，并且命名为 em （the "editor for mortals"）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;em&lt;/strong&gt; 是为终端显示器设计（display terminals）的，一次只显示一行的可视化编辑器，它是 UNIX 中第一个大量使用 "raw terminal input mode" 的程序，这种模式下，由应用程序而不是终端的驱动处理键盘的输入。1976 年夏天，Coulouris 参观 &lt;a href="http://en.wikipedia.org/wiki/University-of-California,-Berkeley"&gt;UC Berkeley&lt;/a&gt; 时，他带着一卷录有 em 的 DEC 磁带，他给很多人演示了 em ，有的人认为 em 只是有潜力，但是有的人却对此留下了深刻影响，其中就包括 &lt;a href="http://en.wikipedia.org/wiki/Bill-Joy"&gt;Bill Joy&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;受到 em 的鼓舞，加上他们自己使用 ed 时的技巧，Bill Joy 和 Chuck Haley 这两个刚从 UC Berkeley 的毕业的研究生使用 em 的代码，设计了一个叫 en 的编辑器，然后把 en 扩展为 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Ex-(editor)"&gt;ex&lt;/a&gt;&lt;/strong&gt; v0.1 。&lt;/p&gt;
&lt;p&gt;ex 仍然只显示一行而非一屏的内容。后来，Chuck Haley 退出了开发，Bruce Englar 鼓励 Bill Joy 重新设计了 ex，在 1977 年 6 月到 10 月期间，他为 ex 添加了全屏可视化模式 ，ex 的 visual mode 也就是 &lt;strong&gt;vi&lt;/strong&gt; 的命名原因 。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;vi /ˈviːˈaɪ/ is a screen-oriented text editor originally created for the Unix operating system. The portable subset of the behavior of vi and programs based on it, and the ex editor language supported within these programs, is described by (and thus standardized by) the Single Unix Specification and POSIX.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;据 Bill Joy 讲，很多 vi 的可视化灵感来自于另外一个叫做 &lt;a href="http://en.wikipedia.org/wiki/Bravo-(software)"&gt;Bravo&lt;/a&gt; 的编辑器，在一次关于 vi 的起源的访谈中，他说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A lot of the ideas for the screen editing mode were stolen from a Bravo manual I surreptitiously looked at and copied. Dot is really the double-escape from Bravo, the redo command. Most of the stuff was stolen. There were some things stolen from ed—we got a manual page for the Toronto version of ed, which I think Rob Pike had something to do with. We took some of the regular expression extensions out of that.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于为什么 vi 要设计成这么不友好，其实是有历史原因的：&lt;/p&gt;
&lt;p&gt;Joy 使用的是 Lear Siegler ADM3A 终端，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="Terminal-ADM3A" src="/images/learning-vim-survival/Terminal_ADM3A.png"&gt;&lt;/p&gt;
&lt;p&gt;在这个终端上，&lt;code&gt;ESC&lt;/code&gt; 键的位置是现在 &lt;a href="http://en.wikipedia.org/wiki/IBM-PC-keyboard"&gt;IBM PC keyboard&lt;/a&gt; 键盘的 &lt;code&gt;Tab&lt;/code&gt; 键的位置，所以，选择 &lt;code&gt;ESC&lt;/code&gt; 作为模式切换键是很方便的设计 。同时，&lt;code&gt;h&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;、&lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;l&lt;/code&gt; 键也起方向键的作用，所以，vi 也采用相同的设计 。Joy 解释说，因为他开发软件时使用的 Modem 的速率只有 300 波特，显示器上的刷新速度还没有他的思考速度快，所以他设计了单字符这样的简洁风格的命令。&lt;/p&gt;
&lt;p&gt;1978 年 3 月，Joy 负责的 BSD Unix 发布了，系统自带了 ex 1.1，这为他的编辑器在 UC Berkeley 积攒了大量人气。从那时起，Unix 系统自带的编辑器只有 ed 和 ex 。在 1984 年的一次采访中，Joy 把 vi 的成功归功于免费，当时的其他编辑器，比如 Emacs 要花费数百美金 。&lt;/p&gt;
&lt;p&gt;观察显示基本上所有的 ex 用户都是在 visual mode 下工作，所以在 ex 2.0（作为 1979 年 5 月的 BSD Unix 的一部分）中，Joy 把 vi 作为 ex 的硬链接，这样用户一打开 ex，就默认进入 visual mode ，所以说，vi 并不是 ex 的进化，vi 就是 ex 。&lt;/p&gt;
&lt;p&gt;虽然在今天看来，vi 是一个很小的，轻量级的程序，但是 Joy 把 ex 2.0(vi) 描述为一个非常大的程序，因为它几乎占据了 &lt;a href="http://en.wikipedia.org/wiki/PDP-11#Models"&gt;PDP-11/70&lt;/a&gt; 的所有内存。在 1979 年第 3 版 BSD 中，PDP-11 已经无法存储 v3.1 的 vi 。&lt;/p&gt;
&lt;p&gt;Joy 一直领导着 vi 的开发，一直到 1979 年 6 月的 vi 2.7，到 1980 年 8 月的 v3.5 版本中，还作出偶尔的贡献。在谈及 vi 的起源和他为何退出开发时，他说，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I wish we hadn't used all the keys on the keyboard. I think one of the interesting things is that vi is really a mode-based editor. I think as mode-based editors go, it's pretty good. One of the good things about EMACS, though, is its programmability and the modelessness. Those are two ideas which never occurred to me. I also wasn't very good at optimizing code when I wrote vi. I think the redisplay module of the editor is almost intractable. It does a really good job for what it does, but when you're writing programs as you're learning... That's why I stopped working on it.&lt;/p&gt;
&lt;p&gt;What actually happened was that I was in the process of adding multiwindows to vi when we installed our VAX, which would have been in December of '78. We didn't have any backups and the tape drive broke. I continued to work even without being able to do backups. And then the source code got scrunched and I didn't have a complete listing. I had almost rewritten all of the display code for windows, and that was when I gave up. After that, I went back to the previous version and just documented the code, finished the manual and closed it off. If that scrunch had not happened, vi would have multiple windows, and I might have put in some programmability—but I don't know.&lt;/p&gt;
&lt;p&gt;The fundamental problem with vi is that it doesn't have a mouse and therefore you've got all these commands. In some sense, its backwards from the kind of thing you'd get from a mouse-oriented thing. I think multiple levels of undo would be wonderful, too. But fundamentally, vi is still ed inside. You can't really fool it.
It's like one of those pinatas—things that have candy inside but has layer after layer of paper mache on top. It doesn't really have a unified concept. I think if I were going to go back—I wouldn't go back, but start over again.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 1979 年， &lt;a href="http://en.wikipedia.org/wiki/Mary-Ann-Horton"&gt;Mark Horton&lt;/a&gt; 接管了 vi 的开发，他添加了对方向键和功能键的支持，用  terminfo 代替了 termcap，提高了 vi 的性能 。&lt;/p&gt;
&lt;p&gt;到 1981 年的 8 月，v3.7 版的 vi 以前，UC Berkeley 是 vi 开发的中心，但是随着 1982 年初 Joy 的离开去创办 &lt;a href="http://en.wikipedia.org/wiki/Sun-Microsystems"&gt;Sun Microsystems&lt;/a&gt;，AT&amp;amp;T 的  &lt;a href="http://en.wikipedia.org/wiki/UNIX-System-V"&gt;UNIX System V&lt;/a&gt; (1983 年 1 月 ) 采用 vi，vi 代码库的变化开始变得缓慢混乱，而且变得相互不兼容。在 UC Berkeley，虽然有修改代码，但是版本号一直没有超过 3.7 。商业的 Unix 制造商，比如 Sun, &lt;a href="http://en.wikipedia.org/wiki/HP"&gt;HP&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Digital-Equipment-Corporation"&gt;DEC&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/IBM"&gt;IBM&lt;/a&gt;，他们的系统 &lt;a href="http://en.wikipedia.org/wiki/Solaris-(operating-system)"&gt;Solaris&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/HP-UX"&gt;HP-UX&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/Tru64-UNIX"&gt;Tru64 UNIX&lt;/a&gt;, 和 &lt;a href="http://en.wikipedia.org/wiki/AIX"&gt;AIX&lt;/a&gt;，今天仍然在使用从 3.7 release 中衍生出来的代码，但是加入了新的特性，比如可以调整的按键映射、加密等 。&lt;/p&gt;
&lt;p&gt;虽然商业的制造商可以使用 Joy 的代码库（直至今天），但是有许多人却不能使用。因为 Joy 是在 Thompson 的 ed 的基础上开发的，所以 ex 和 vi 是派生出来的产品，不能发布给没有 AT&amp;amp;T 的许可证的人使用。想在类 Unix 系统上找到一个编辑器的话必须在别的地方寻找。1985 年，一个 Emacs 的版本（&lt;a href="http://en.wikipedia.org/wiki/MicroEMACS"&gt;MicroEmacs&lt;/a&gt;）在很多平台上可以使用，但是直到 1987 年 6 月才出现一个 vi 的克隆版本 —— Steive 。在 1990 年 1 月初，Steve Kirkendall 为发布了一个新的 vi 克隆版本 &lt;a href="http://en.wikipedia.org/wiki/Elvis-(text-editor)"&gt;Elvis&lt;/a&gt;，它比 Stive 更加完整更加忠实于 vi 。它很快就吸引了社区用户的热情，&lt;a href="http://en.wikipedia.org/wiki/Andrew-S.-Tanenbaum"&gt;Andrew Tanenbaum&lt;/a&gt; 马上在社区讨论在 &lt;a href="http://en.wikipedia.org/wiki/Minix"&gt;Minix&lt;/a&gt; 中使用哪一个当中 vi 的克隆，结果 Elvis 胜利了，直到今天仍然在 Minix 中当作 vi 的克隆体使用 。&lt;/p&gt;
&lt;p&gt;在 1989 年，&lt;a href="http://en.wikipedia.org/wiki/Lynne-Jolitz"&gt;Lynne Jolitz&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/William-Jolitz"&gt;William Jolitz&lt;/a&gt; 开始着手把 BSD Unix 移植到 386 系列的处理器上，为了发布一个免费版本，他们必须绕过 AT&amp;amp;T 含有的代码，其中就包括 Joy 的 vi 。为了填补 vi 的空白，他们在 1992 年的 386BSD 发布版中采用了 Elvis 作为 vi 的替代品，386BSD 后来的分支 &lt;a href="http://en.wikipedia.org/wiki/FreeBSD"&gt;FreeBSD&lt;/a&gt; 和 &lt;a href="http://en.wikipedia.org/wiki/NetBSD"&gt;NetBSD&lt;/a&gt; 也延续了这一决定。但是在 UC Berkely，Keith Bostic 使用 Kirkendall 的 Elvis（v1.8）代码，编写了 &lt;a href="http://en.wikipedia.org/wiki/Nvi"&gt;nvi&lt;/a&gt;，并于 1994 年春发布。当 FreeBSD 和 NetBSD 在 4.4-Lite2 代码库的基础上重新同步以后，他们也采用了 nvi，并且一直延续到今天。&lt;/p&gt;
&lt;p&gt;虽然有很多 vi 的克隆体，而且它们都有很多加强的特性，但是在 2000 年前左右，Gunnar Ritter 使用了 2.11BSD 中的 Joy 的代码，并把 vi 移植到了类 Unix 系统中，比如 Linux 和 FreeBSD 。从技术上讲，他没有许可证而发布 vi 的做法是非法的，但是，到了 2002 年 1 月，AT&amp;amp;T 的许可证被取消了，vi 可以作为开源项目在其他发布版中使用。Ritter 继续在 Joy 的代码的基础上加强 vi 的特性，就像那些商业版一样。他的成果 &lt;a href="http://ex-vi.cvs.sourceforge.net/"&gt;Traditional Vi&lt;/a&gt; 在很多系统上运行。&lt;/p&gt;
&lt;p&gt;虽然 Joy 的 vi 现在又可以在 BSD Unix 上使用，但是很多 BSD 的粉丝都转移到更加强大、但仍然保留着 vi 的某些特性的 nvi 的阵地。从某种意义上说，这是一个奇怪的反常现象，在 Joy 的 vi 的发源地 BSD 中不再使用 vi，但是缺少它的 AT&amp;amp;T 的发行版却仍然保留了它并使用至今。&lt;/p&gt;
&lt;p&gt;在 1984 年 Emacs 发布以前，vi 几乎是所有 Hacker 使用的 Unix 标准编辑器，从 2006 年开始，作为 &lt;a href="http://en.wikipedia.org/wiki/Single-UNIX-Specification"&gt;” 单一 Unix 标准 “（Single UNIX Specification）&lt;/a&gt;的一部分，vi 和 vi 的变形体一定可以在今天的系统中找到。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Bram-Moolenaar"&gt;Bram Moolenaar&lt;/a&gt; 于 1988 年买了一台 Amiga 计算机，Amiga 上没有他常用的 vi，于是他在开源的 Stevie 的基础上，于 1991 年发布了 Vim v1.14 。&lt;/p&gt;
&lt;p&gt;起初 &lt;strong&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim-(text-editor)"&gt;Vim&lt;/a&gt;&lt;/strong&gt; 是 ”Vi IMitation“ 的缩写，但是后来 1993 年 12 发布的 Vim 2.0 版本中改名为 &lt;em&gt;"Vi IMproved"&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;vim 现在是 &lt;a href="http://en.wikipedia.org/wiki/GNU-General-Public-License"&gt;GNU General Public （GPL）&lt;/a&gt;下的自由软件，几乎在所有的 Linux 系统和 苹果 OS X 系统中都可以找到她的身影。&lt;/p&gt;
&lt;h2 id="vim_1"&gt;为什么选择 Vim&lt;/h2&gt;
&lt;p&gt;程序猿界的 &lt;strong&gt;圣战：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt; vs &lt;strong&gt;Linux&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vim/Emacs&lt;/strong&gt; vs &lt;strong&gt;IDE&lt;/strong&gt; (&lt;strong&gt;Vim&lt;/strong&gt; vs &lt;strong&gt;Emacs&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt; vs &lt;strong&gt;JAVA&lt;/strong&gt; vs &lt;strong&gt;Python&lt;/strong&gt; vs ...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim-vs-ide"&gt;Vim vs IDE&lt;/h3&gt;
&lt;p&gt;首先是在 Vim 和 IDE 之间的争论。到底是该选择 vim 还是 IDE ？在 Stackoverflow 和 知乎 上有非常多的这样的帖子。&lt;/p&gt;
&lt;p&gt;比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim"&gt;What is your most productive shortcut with Vim?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再比如这篇：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhihu.com/question/21504638"&gt;为什么不少程序员极度推崇 Vim 和 Emacs，却对 IDE 嗤之以鼻？??&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总之，萝卜芹菜各有所爱，有 Geek 精神、喜欢折腾的人不用你去说服，他自然会去学习 Vim，没有心情、懒得折腾的人，你再怎么说 Vim 好，他也不会去尝试。&lt;/p&gt;
&lt;p&gt;我选择 Vim 的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vim 是 Linux 的标配编辑器，在 Linux 下开发，不会 Vim 的程序猿不是好程序猿&lt;/li&gt;
&lt;li&gt;还是因为 Linux 的原因。大多数 Linux 下的程序都是不需要界面的，终端才是 Linux 的精华。在终端下，除了选择 Vim 你说还能选谁呢？ 因为 Vim 和 Linux 的 ” 血缘 “ 关系，终端 + Vim 给你纯正的 Linux 体验（再说当你远程 ssh 登录时，总不能还用 IDE 吧？）&lt;/li&gt;
&lt;li&gt;Vim 下有着高度的编码一致性体验。学会了 Vim，写不同语言不同代码的体验是一样的，妈妈再也不用担心我要花时间学习不同的 IDE 了 ~&lt;/li&gt;
&lt;li&gt;我写的代码基本只限定在底层开发，主要代码是 C/C++、Shell 脚本、Python 脚本，不会涉及到 JAVA，更不会涉及前端开发；而且都是我的 ” 玩具小程序 “，几乎不涉及好几百个源文件的项目，所以我不需要 IDE 的强大的管理能力，写一个 makefile 就 OK 了&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.zhihu.com/question/22096642/answer/20290505"&gt;学习过 CPU 知识的人都知道，频繁打断流水线才是最影响效率的东西。在调试代码的时候，显然纯键盘流要比不停的 ” 鼠标 -&amp;gt; 键盘 -&amp;gt; 鼠标 -&amp;gt; ...“ 有效率的多，而且省事。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vim-vs-emacs"&gt;vim vs emacs&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;来自 wiki 百科：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Editor-war"&gt;Editor war&lt;/a&gt; 是指两类文本编辑器 Vi（以及衍生版本） 和 Emacs 之间的争论，这已经成为 hacker 文化和自由软件社区文化的一部分 。&lt;/p&gt;
&lt;p&gt;因为他们都认为自己的选择是完美的，所以相互蔑视，相互之间争论（点燃战火）。相比其他的 IT 领域战争（如浏览器大战、操作系统之争、编程语言之争、代码缩进风格之战 )，编辑器的选择其实通常只是个人问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遵循 “ 简单工具，多样组合 ” 的理念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小，符合 Unix 哲学中的 “ 只做一件事，并做好它 ”，避免了功能蔓延&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比 Emacs 快（至少历史上是这样的）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可运行于任何实现了 C 标准库的系统之上，包括 UNIX、Linux、AmigaOS、DOS、Windows、Mac、BeOS 和 POSIX 兼容系统等等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让 QWERTY 键盘用户将手指保持在默认键位上，使编辑时手指移动更少&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更普及。基本上所有 Unix 和类 Unix 系统都默认提供了 vi 或其变体&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Emacs 的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符合 “ 厨房水槽 ” 理念，提供了比 vi 更多的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移植最广泛的非试用计算机程序之一。它能在各种操作系统上运行，包括大多数类 Unix 系统（GNU/Linux、各种 BSD、Solaris、AIX、IRIX、AmigaOS、Mac OS X 等）、MS-DOS、Microsoft Windows 和 OpenVMS。Unix 系统，无论自由版本或商业版本，均随系统提供 Emacs 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可扩展和可定制（Lisp 的变体 - Emacs Lisp）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Richard-Stallman"&gt;Richard Stallman&lt;/a&gt; 组建了 The Church of Emacs，它称 vi 为 “ 魔鬼的编辑器 ”（vi-vi-vi 在罗马数字中表示兽名数目）。然而它并不反对 vi；相反，它视私有软件为诅咒。（“ 使用自由版本的 vi 不是罪恶，而是赎罪。”）它还有专门的新闻组，alt.religion.emacs，发布主题宣扬这个滑稽的宗教。&lt;/p&gt;
&lt;p&gt;Stallman 曾称自己是 St IGNU−cius，Emacs 教会的圣人。&lt;/p&gt;
&lt;p&gt;vi 支持者也成立了对立的 Cult of vi，较强硬的 Emacs 的用户攻击这是 “ 抄袭他们的创意 ”。&lt;/p&gt;
&lt;p&gt;关于 vi 的模式，一些 Emacs 用户说 vi 有两个模式 – “ 不停地哔哔叫 ” 和 “ 搞砸一切 ”。vi 用户则指责 Emacs 的快捷键会引发 " 腕管综合症 "，或者拿 EMACS 这个缩写词作文章，比如 “Escape Meta Alt Control Shift”（攻击 Emacs 太依赖修改键）。一些人断定是代表 “Eight Megabytes And Constantly Swapping”（8 MB，还不断进行内存交换，过去这已经是很多内存了），或者 “EMACS Makes Any Computer Slow”（EMACS 使一切计算机跑得慢，这是斯托曼惯用的递归缩写），讽刺 Emacs 对系统资源的高需求。&lt;/p&gt;
&lt;p&gt;针对 Emacs 的 “ 功能蔓延 ”，vi 支持者认为 Emacs 是 “ 一个伟大的操作系统，只缺个体面的编辑器 ”。&lt;/p&gt;
&lt;p&gt;UNIX 用户中流行一个游戏，考验一个 Emacs 用户对这个编辑器的理解深度，或者是拿 Emacs 的复杂性开玩笑，内容是：预测一下，如果一个用户按住修改键（比如 Control 或 Alt），然后键入自己的名字，会发生什么事。&lt;/p&gt;
&lt;h2 id="vim_2"&gt;开始学习 Vim&lt;/h2&gt;
&lt;p&gt;闲扯了这么多，终于开始学习 vim 了 ...&lt;/p&gt;
&lt;p&gt;结合我痛苦的学习过程，我觉得以下的学习顺序比较适合我这样的新手：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入门：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，在终端下输入 vimtutor 就能进入一个 vim 自带的教程，大概花半个小时的时间就能做完。完成以后基本上就可以说会使用这款 大 (chou) 名 (ming) 鼎 (zhao) 鼎 (zhu) 的 ” 反人类 “  的编辑器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;学习陈皓大神在 &lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 的博客 &lt;a href="http://coolshell.cn/articles/5426.html"&gt;vim 练级攻略&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同样，&lt;a href="http://coolshell.cn/"&gt;coolshell&lt;/a&gt; 上介绍的一个关于 Vim 的游戏 —— &lt;a href="http://vim-adventures.com/"&gt;vim adventrue&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去图书馆借本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/3041178/"&gt;Learning the vi and Vim Editors&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阅读 Vim manpage 和 &lt;a href="https://github.com/asins/vimcdoc"&gt;安装 vim docs 中文版插件&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一本书 &lt;em&gt;&lt;a href="http://book.douban.com/subject/10599776/"&gt;Pratical Vim&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim 作者 Bram Moolenaar 的文档 &lt;em&gt;&lt;a href="http://www.moolenaar.net/habits.html"&gt;seven habits for effective text editing&lt;/a&gt;&lt;/em&gt;  和 &lt;a href="http://v.youku.com/v-show/id-XMTIwNDY5MjY4.html"&gt;演讲视频&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/"&gt;vi/vim 使用进阶&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_2"&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vi"&gt;vi wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Vim-(text-editor)"&gt;Vim wikipedia&lt;/a&gt;&lt;/p&gt;</content><category term="Tools"></category><category term="vim"></category></entry><entry><title>Code 书评</title><link href="https://qian-gu.github.io/posts/book/code-review.html" rel="alternate"></link><published>2014-03-21T16:33:00+08:00</published><updated>2014-03-21T16:33:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-03-21:/posts/book/code-review.html</id><summary type="html">&lt;p&gt;最近花了一个星期的时间，终于把 Code 看完了，感慨颇深。&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近花了一个星期的时间，终于把 &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code&lt;/em&gt;&lt;/a&gt; 看完了，看完全书，观后感总结出来就一个字 —— 爽～&lt;/p&gt;
&lt;p&gt;书名： &lt;a href="http://book.douban.com/subject/1494026/"&gt;&lt;em&gt;Code:  The Hidden Language of Computer Hardware and Software&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者： &lt;a href="http://charlespetzold.com/"&gt;Charles Petzold&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这本书的作者 &lt;a href="http://en.wikipedia.org/wiki/Charles-Petzold"&gt;Charles Petzold&lt;/a&gt; 是 Windows 编程界一位大师，世界顶级技术作家。1994 年 5 月，Petzold 作为仅有的七个人之一（并且是唯一的作家）被《Window Magazine》和 Microsoft 公司授予 “Windows Pioneer” 奖，以表彰他对 Microsoft Windows 的成功做出的贡献 。&lt;/p&gt;
&lt;p&gt;关于这本书的 “ 江湖地位 ” ，只需要来看看 stackoverflow 上的这个帖子就明白了：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本书排名在&lt;em&gt;第 15&lt;/em&gt;，当然绝对排名没有很大的意义，但是也能说明本书的影响力 。另外本书号称 “ 完全不懂计算机的人也能看懂 ”... 如果这都不读，我不知道还有什么样的书值得我们去花费时间 : D&lt;/p&gt;
&lt;h2 id="_1"&gt;打通任督二脉&lt;/h2&gt;
&lt;p&gt;纵观程序员的 “ 武功秘籍 ”，不外乎两种：一种是讲 &lt;code&gt;道&lt;/code&gt;，另外一种是讲 &lt;code&gt;术&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;道&lt;/code&gt; 即 “ 道理 ”（真理），是脱离了具体事物，抽象出来的事物的本质 。比如平时学习的 &lt;em&gt;数学&lt;/em&gt;、&lt;em&gt;物理&lt;/em&gt;、&lt;em&gt;化学&lt;/em&gt; 知识，再比程序中的 &lt;em&gt;算法&lt;/em&gt;、分析解决问题的 &lt;em&gt;思维方式&lt;/em&gt; 等，都不会因时间和环境变化而不适用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;术&lt;/code&gt; 即 “ 技术 ”（技巧），是人们在具体工程实践中总结出来的一些技巧。比如 “The art of XXX” ，“The principle of XXX” 等 。&lt;/p&gt;
&lt;p&gt;是的，这本书既不是单独讲道，也不是单独讲术，而是将两者结合起来，让你不仅明白道的深奥，也明白术的精妙；让你体会到道是如何在术中实现，也体会到术是如何在道的约束下追求极限的 。更加关键的是全书都是用很平白的语言讲述，平白到 “ 即使完全不懂计算机的人也能读懂 ” 的地步，这就是其厉害之处了。&lt;/p&gt;
&lt;p&gt;就好像你学习了五花八门的心法秘籍和各式武功，每一门都厉害无比，可偏偏无法把这些武功融会贯通，修至大成 。这时候，你需要的不是一本《葵花宝典》，而是《论天下武功之间的关系及其融会贯通方法》，打通自己的任督二脉，也就是这本 &lt;a href="http://book.douban.com/subject/1494026/"&gt;Code&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;读这本书时，让我想起了在大学 4 年间读的各种课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 6 章 “ 电报机与继电器 ” 让我想起《大学物理》，虽然翘了很多课，但是电磁感应什么的有中学基础，还好没有忘记。&lt;/li&gt;
&lt;li&gt;第 7～9 章，书中对计数的方法和进制的讨论，让我想起《大学计算机基础》，然后花了一天时间去把以前一知半解的 “ 原码、反码、补码 ” 仔细推敲总结一遍，收获颇大。&lt;/li&gt;
&lt;li&gt;第 10 章，布尔代数 让我想起《离散数学》，尤其发人深醒的是布尔发明了布尔逻辑 100 多年后，才有人（香农）将其和电路联系起来。&lt;/li&gt;
&lt;li&gt;第 11～13 章，跟随作者的思路，我才明白当年令人痛不欲生的《模拟电路》、《数字电路》到底是来干什么的，数字电路是如何从最基本的门搭建出来更强的功能的元器件的，联系前面学习的编码的知识，明白这样做的道理。&lt;/li&gt;
&lt;li&gt;第 16～22 章，让我想起《微机原理》，对微处理器的工作方式不再模糊不清，跟随着作者的思路搭建一台 “ 计算机 ”（当然和现在的计算机完全不同，但是原理是一模一样的），为自己搭建的处理器设计一套可以实现自动功能的编程语言，然后写一段程序，甚至一窥操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有等等 ...&lt;/p&gt;
&lt;p&gt;胡扯了这么多，书固然是好书，但是更让人深思的是国内外教育的差异。吐槽我们的教育体制毫无意义，作为普通人，我们能做到的就是自己努力，找真正的好书、向真正的大师学习，比如上面提到过的&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read"&gt;What is the single most influential book every programmer should read?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了技术、还有很多程序员需要看的书。找到一本好书，然后认真阅读。&lt;/p&gt;</content><category term="Book"></category><category term="Code"></category><category term="review"></category></entry><entry><title>原码、反码、补码</title><link href="https://qian-gu.github.io/posts/cs/signed-number-representations.html" rel="alternate"></link><published>2014-03-19T14:31:00+08:00</published><updated>2014-03-19T14:31:00+08:00</updated><author><name>Qian Gu</name></author><id>tag:qian-gu.github.io,2014-03-19:/posts/cs/signed-number-representations.html</id><summary type="html">&lt;p&gt;最近找到一本好书——《编码: 隐匿在计算机软硬件背后的语言》 。作者是大名鼎鼎的 Charles Petzold 。看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 Google、Wiki，于是总结出下文 。&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近找到一本好书 ——&lt;a href="http://book.douban.com/subject/4822685/"&gt;《编码 : 隐匿在计算机软硬件背后的语言》&lt;/a&gt;。作者是大名鼎鼎的 &lt;a href="http://en.wikipedia.org/wiki/Charles-Petzold"&gt;Charles Petzold&lt;/a&gt; (&lt;a href="http://charlespetzold.com/"&gt;个人网站&lt;/a&gt;)。书的介绍也很有意思，据说完全不懂计算机的人也能看懂 ... 于是买了本来拜读一下。&lt;/p&gt;
&lt;p&gt;看到用继电器搭建加法器、减法器，讨论二进制编码方式那章，想起一直不是很清楚的原码、反码、补码等，果断 &lt;a href="https://www.google.com.hk/"&gt;Google&lt;/a&gt;、&lt;a href="http://en.wikipedia.org/wiki/Main-Page"&gt;Wiki&lt;/a&gt;，于是总结出下文。&lt;/p&gt;
&lt;h2 id="_1"&gt;基本概念&lt;/h2&gt;
&lt;h3 id="_2"&gt;机器数&lt;/h3&gt;
&lt;p&gt;顾名思义，一个数字在机器中的存储方式，“&lt;em&gt;数&lt;/em&gt; ” 是指 有符号数（&lt;code&gt;signed number&lt;/code&gt;），即包含了正负号的数，“&lt;em&gt;机器&lt;/em&gt; ” 当然是指计算机（&lt;code&gt;Computer&lt;/code&gt;）了。&lt;/p&gt;
&lt;p&gt;从小学毕业，刚进入初中，我们就知道数字是有符号的：&lt;em&gt;正数&lt;/em&gt; 和 &lt;em&gt;负数&lt;/em&gt;。但是在计算机的世界中只有两个元素：0 和 1 ，没有额外的专门表示正负号的符号。怎么办呢？解决方法就是添加一位来表示符号。于是，人们约定把符号位放在一个数字的 &lt;em&gt;最高有效位&lt;/em&gt;（Most significant bit, &lt;code&gt;MSB&lt;/code&gt;），在&lt;a href="http://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F"&gt;大端序&lt;/a&gt;中，&lt;code&gt;MSB&lt;/code&gt; 指的是一个二进制数的最左边的一位。一般 &lt;code&gt;MSB&lt;/code&gt; 等于 0  表示正数，1 表示负数。&lt;/p&gt;
&lt;h3 id="_3"&gt;真值&lt;/h3&gt;
&lt;p&gt;因为机器数中有一位表示符号，所以机器数的形式值不等于真正的数值，机器数对应的数值称为机器数的 &lt;em&gt;真值&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;用 8 bit 表示一个数字，因为有符号位的存在，可以表示的范围为 (-127, -0, +0, +127) 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;+5 的 机器数 = 0,000_0101； 真值 = +5

-5 的 机器数 = 1,000_0101； 真值 = -5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种机器数的编码方式称为 &lt;a href="http://en.wikipedia.org/wiki/Signed-magnitude#Signed-magnitude-representation"&gt;&lt;em&gt;原码&lt;/em&gt;&lt;/a&gt; (&lt;code&gt;signed-magnitude&lt;/code&gt;) ，是机器数编码方式中的一种。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The four best-known methods of extending the binary numeral system to represent signed numbers are: sign-and-magnitude, Ones' complement, two's complement, and excess-K.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There is no definitive criterion by which any of the representations is universally superior. The representation used in most current computing devices is two's complement, although the Unisys ClearPath Dorado series mainframes use Ones' complement.&lt;/em&gt;
（&lt;a href="http://en.wikipedia.org/wiki/Signed-number-representations"&gt;Wikipeida&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面分别讨论。&lt;/p&gt;
&lt;h2 id="_4"&gt;机器数表示法&lt;/h2&gt;
&lt;h3 id="sign-and-magnitude"&gt;原码（sign and magnitude）&lt;/h3&gt;
&lt;h4 id="_5"&gt;编码规则&lt;/h4&gt;
&lt;p&gt;最高位表示符号位，正数符号位为 0，负数符号位为 1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;正数：  0,xxxxxxx

负数：  1,xxxxxxx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8 bit 的原码可以表示的范围是 [ -127, -0, +0, +127]，共 255 个数。&lt;/p&gt;
&lt;h4 id="_6"&gt;计算法则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;1. 两数符号相同：低位相加，最高位的符号位不变（当低位相加产生进位时，溢出 Overflow）

2. 两数符号不同：比较绝对值的大小，差的绝对值 = 大数 - 小数 ，符号位和大数的符号位相同
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id="_7"&gt;缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;电路复杂&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从前面的计算方法中可以看到，原码中的符号位不能直接参与运算，必须要单独的线路来确定符号位&lt;/li&gt;
&lt;li&gt;原码的计算不能避免减法运算，加法运算是产生 &lt;em&gt;进位&lt;/em&gt;，减法运算需要 &lt;em&gt;借位&lt;/em&gt;，这是两种不同的运算过程，需要额外的电路把 &lt;code&gt;加法器&lt;/code&gt; 改造为 &lt;code&gt;减法器&lt;/code&gt;（&lt;a href="http://www.charlespetzold.com/code/"&gt;《编码》&lt;/a&gt;这本书里面有详细介绍 如何使用继电器搭建 加法器 和 减法器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0 的表示不唯一&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 可以编码为两种方式： &lt;code&gt;+0&lt;/code&gt; 和 &lt;code&gt;-0&lt;/code&gt;，进一步增加了逻辑的复杂性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_8"&gt;总结&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;This approach is directly comparable to the common way of showing a sign (placing a "+" or "−" next to the number's magnitude). Some early binary computers (e.g., &lt;a href="http://en.wikipedia.org/wiki/IBM-7090"&gt;IBM 7090&lt;/a&gt;) used this representation, perhaps because of its natural relation to common usage. Signed magnitude is the most common way of representing the significand in floating point values.（&lt;a href="http://en.wikipedia.org/wiki/Signed-magnitude#Signed-magnitude-representation"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然 &lt;code&gt;原码&lt;/code&gt; 的编码方式最接近人类的习惯，但是，并不适合在计算机中使用，为了解决原码计算中的一些问题，于是 &lt;code&gt;反码&lt;/code&gt; 就出现了。&lt;/p&gt;
&lt;h3 id="ones-complement"&gt;反码（Ones' complement）&lt;/h3&gt;
&lt;p&gt;首先，来看看 &lt;a href="http://www.charlespetzold.com/code/"&gt;Code&lt;/a&gt; 中介绍了基于 10 进制的补码：&lt;/p&gt;
&lt;p&gt;实现一个减法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照我们从数学课上学习到知识，这个计算需要进行 &lt;em&gt;借位&lt;/em&gt; 操作，为了避免这个在计算机中很难实现的操作，可以稍微变化一下计算过程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中，用两个减法代替了原来的一个减法，避免了烦琐的 &lt;em&gt;借位&lt;/em&gt; 操作。在这个运算中，负数 &lt;code&gt;-176&lt;/code&gt; 转化为另外一个数 &lt;code&gt;999 - 176&lt;/code&gt; ，这个数称为它的 &lt;code&gt;9 的补数 (nine's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 9 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;1 的补数 (Ones' complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;把减数从一串 1 当中减去，结果就称为这个数的 “1 的补数 ”，在求 1 的补数的时候，其实并不需要做减法，因为求 1 的补数，只需要将原来的 1 变为 0 ，0 变为 1 即可，也就是取反，在电路中只需要一个反向器就可以实现，所以 &lt;code&gt;1 的补数&lt;/code&gt; 也称为 &lt;code&gt;反码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;从上面的描述就可以很容易写出下面的反码编码规则。&lt;/p&gt;
&lt;h4 id="_9"&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;正数：反码 = 原码

负数：反码 = 符号位不变，其他位取反
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8 bit 的反码可以表示的范围是 [ -127, -0, +0, +127]，共 255 个数。&lt;/p&gt;
&lt;h4 id="_10"&gt;计算法则&lt;/h4&gt;
&lt;p&gt;反码的计算不用区分符号和绝对值，直接进行计算，计算结果若有溢出，需要将溢出加到最低位，这种操作称为 “ 循环进位 ”（end-around carry）。&lt;/p&gt;
&lt;h4 id="_11"&gt;优缺点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;优点，电路简单&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，所以反码计算不需要单独的判断符号的电路，也不需要判断两个数绝对值相对大小的电路&lt;/li&gt;
&lt;li&gt;节省了减法器，只需要一组额外的反向器就能把加法器改进为可以计算 加 / 减法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机中仍然需要进行 “ 循环进位 ” 的硬件电路，但是这种复杂度的电路是可以接受的&lt;/li&gt;
&lt;li&gt;0 的表示不唯一，0 的编码仍然有两种方式： &lt;code&gt;+0&lt;/code&gt; 和 &lt;code&gt;-0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_12"&gt;总结&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;a href="http://en.wikipedia.org/wiki/PDP-1"&gt;PDP-1&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC-160-series"&gt;CDC 160 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/CDC-6000-series"&gt;CDC 6000 series&lt;/a&gt;, &lt;a href="http://en.wikipedia.org/wiki/UNIVAC-1100"&gt;UNIVAC 1100 series&lt;/a&gt;, and the &lt;a href="http://en.wikipedia.org/wiki/LINC"&gt;LINC&lt;/a&gt; computer used Ones' complement representation.（&lt;a href="http://en.wikipedia.org/wiki/Signed-number-representations#Ones.27-complement"&gt;Wiki&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;反码&lt;/code&gt; 中仍然没有避免 0 有两种编码方式的问题，虽然对于人来说，+0 和 -0 没有区别，但是对于计算机来说，判断一个数是否为 0，要进行两次判断。为了解决 0 的表示问题和硬件上的 “ 循环进位 ”，于是人们又发明了 &lt;code&gt;补码&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="twos-complement"&gt;补码（Two's complement）&lt;/h3&gt;
&lt;p&gt;前面介绍的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 - 176 =？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照反码的方法可以转换为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (999-176) + 1 - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们稍微再变形一下，就有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;253 + (1000 - 176) - 1000 = ?&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在这个运算中 &lt;code&gt;-176&lt;/code&gt; 转化为 &lt;code&gt;1000 - 176&lt;/code&gt;，这个数称为它的 &lt;code&gt;10 的补数 (ten's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这个运算的关键在于：&lt;em&gt;把负数用 10 的补数表示，减法转化为加法&lt;/em&gt; 。同理，我们推广到 2 进制，就得到了 &lt;code&gt;2 的补数 (two's complement)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;因为对一位二进制数 b 取补码就是 &lt;code&gt;1 - b + 1 = 10 - b&lt;/code&gt;，相当于从 2 里面减去 b , 所以，这种方法称为 &lt;code&gt;2 的补数&lt;/code&gt;，这种编码方式简称 &lt;code&gt;补码&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;举例说明，要表示 -4 ，需要对 &lt;code&gt;0000_0100&lt;/code&gt;取补码，&lt;code&gt;1111_1111 - 0000_0100 + 1 = 1_0000_0000 - 0000_0100&lt;/code&gt;，相当于从 &lt;span class="math"&gt;\(2^8\)&lt;/span&gt; 里面减去 4 。&lt;/p&gt;
&lt;p&gt;从上面的计算过程可以很容易写出下面的补码编码规则。&lt;/p&gt;
&lt;h4 id="_13"&gt;编码规则&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;正数：补码 = 原码

负数：补码 = 反码 + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8 bit 补码可以表示的范围是 [ -128, -1, +0, +127]，共 256 个数 。&lt;/p&gt;
&lt;p&gt;目前大多数计算机内部使用的都是补码，所以对于编程中的 32 位 &lt;code&gt;int&lt;/code&gt; 型变量，它可以表示的范围就是 [ &lt;span class="math"&gt;\(-2^{32}\)&lt;/span&gt;, &lt;span class="math"&gt;\(2^{32} - 1\)&lt;/span&gt;] 。&lt;/p&gt;
&lt;h4 id="_14"&gt;计算法则&lt;/h4&gt;
&lt;p&gt;采用补码的系统，减法转换成加法（减法等同于加上一个负数，所以不再有减法），忽略计算结果最高位的进位，不必加回到最低位上去。&lt;/p&gt;
&lt;h4 id="_15"&gt;优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;电路简单，从计算法则中可以看到，不用考虑 “ 循环进位 ” 的问题，所以，补码系统的电路是最简单的，这也是补码系统应用最广泛的原因&lt;/li&gt;
&lt;li&gt;0 的表示是唯一的，不再有 -0 的困扰&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="_16"&gt;补码中的数学原理&lt;/h4&gt;
&lt;p&gt;补码能将减法转化为加法，其数学原理就是 &lt;strong&gt;模&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;如果有个手表的时间为 6 点，实际时间为 4 点，那么如何校准呢？

答案有两种方法：

1. 逆时针转动  2，也就是做减法 6 - 2 = 4
2. 顺时针转动 10, 也就是做加法 (6 + 10) mod 12 = 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从这个例子中就可以很明白的看到减法是如何转化为加法的，也就是如何将一个负数 转化为正数的。&lt;/p&gt;
&lt;div class="math"&gt;$$A - B = A + (-B + M)$$&lt;/div&gt;
&lt;p&gt;这个式子中的 &lt;span class="math"&gt;\(-B + M\)&lt;/span&gt; 即为 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的 &lt;em&gt;补数&lt;/em&gt; （类似于几何中的&lt;em&gt;补角&lt;/em&gt;） 。&lt;/p&gt;
&lt;h4 id="_17"&gt;溢出问题&lt;/h4&gt;
&lt;p&gt;摘自 &lt;a href="http://baike.baidu.com/view/60437.htm"&gt;百度百科&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论采用何种机器数，只要运算的结果大于数值设备所能表示数的范围，就会产生溢出。 溢出现象应当作一种故障来处理，因为它使结果数发生错误。异号两数相加时，实际是两数的绝对值相减，不可能产生溢出，但有可能出现正常进位；同号两数相加时，实际上是两数的绝对值相加，既可能产生溢出，也可能出现正常进位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于补码运算存在符号位进位自然丢失而运算结果正确的问题，因此，应区分补码的溢出与正常进位。&lt;/p&gt;
&lt;p&gt;详细论证过程不再复制粘贴了 ... 直接给出结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出。&lt;/li&gt;
&lt;li&gt;逻辑电路实现时可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_18"&gt;小技巧&lt;/h4&gt;
&lt;p&gt;补码求值公式：&lt;/p&gt;
&lt;div class="math"&gt;$$(-1)^{x-{n-1}}\cdot2^{n-1}+\sum-{i=0}^{n-2}{x-i\cdot2^i}$$&lt;/div&gt;
&lt;p&gt;对一个补码快速取反的方法有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;span class="math"&gt;\(2^n\)&lt;/span&gt; 减去它&lt;/p&gt;
&lt;p&gt;原理：由 &lt;span class="math"&gt;\(x + (-x) = 2^n\)&lt;/span&gt; 可以得到 &lt;span class="math"&gt;\(-x = 2^n - x\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按位取反后加 1&lt;/p&gt;
&lt;p&gt;原理：由 &lt;span class="math"&gt;\(x + \overline{x} = -1\)&lt;/span&gt; 可以得到 &lt;span class="math"&gt;\(-x = \overline{x} + 1\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="_19"&gt;总结&lt;/h4&gt;
&lt;p&gt;由 &lt;em&gt;“ 减去一个数 = 加上一个负数 ”&lt;/em&gt;，计算机系统内部就不再有减法操作&lt;/p&gt;
&lt;p&gt;由 &lt;em&gt;“ 负数的表示由取模运算转变为补码表示 ”&lt;/em&gt;，计算机系统就可以用一个正数来表示负数&lt;/p&gt;
&lt;p&gt;所以，计算机内部只需要加法器就可以完成 加减法 和 正负数 的表示 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two's complement is the easiest to implement in hardware, which may be the ultimate reason for its widespread popularity. Processors on the early mainframes often consisted of thousands of transistors – eliminating a significant number of transistors was a significant cost savings. Mainframes such as the IBM System/360, the GE-600 series, and the PDP-6 and PDP-10 used two's complement, as did minicomputers such as the PDP-5 and PDP-8 and the PDP-11 and VAX. The architects of the early integrated circuit-based CPUs (Intel 8080, etc.) chose to use two's complement math. As IC technology advanced, virtually all adopted two's complement technology. x86, m68k, Power Architecture, MIPS, SPARC, ARM, Itanium, PA-RISC, and DEC Alpha processors are all two's complement.&lt;/em&gt;(&lt;a href="http://en.wikipedia.org/wiki/Signed-number-representations#Two.27s-complement"&gt;Wiki&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_20"&gt;有符号数和无符号数&lt;/h2&gt;
&lt;p&gt;摘自 &lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;硬件做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样 。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;  1000_0010              130                       -126
+ 1111_1000     =&amp;gt;   +   248              =&amp;gt;   +   -  8
--------------      ---------------           -----------
1_0111_1010              122 进 1                  122
                         122 + 256 = 378
                       无符号数（ok）          有符号数（error）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;硬件加法器在做完计算之后，根据最高位产生的进位设置 &lt;em&gt;进位标志&lt;/em&gt; ，同时根据最高位和次高位产生的进位的异或设置 &lt;em&gt;溢出标志&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;如果看作无符号数 130 和 248 相加，计算结果是 122 进 1，也就是 122+256，这个结果是对的 ; 如果把这两个操作数看作有符号数 -126 和 -8 相加，计算结果是错的，因为产生了溢出 。&lt;/p&gt;
&lt;p&gt;至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。&lt;/p&gt;
&lt;p&gt;通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有 bit 都是零则设置零标志，如果计算结果的最高位是 1 则设置负数标志，如果程序把计算结果理解成有符号数，也可以检查负数标志来判断结果的正负。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;从 &lt;code&gt;原码&lt;/code&gt; 到 &lt;code&gt;反码&lt;/code&gt;，再到 &lt;code&gt;补码&lt;/code&gt;，可以清楚看到为了解决问题而改进的技术路线，虽然这些是非常基础知识，可能对我们对写程序没有很大的帮助，但是搞清楚这些不仅让你对计算机底层更加了解，更加关键的是这个学习过程和解决编码问题的思路 。&lt;/p&gt;
&lt;h2 id="_21"&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Signed-number-representations"&gt;Signed number representations——Wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Ones'-complement"&gt;Ones' complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Two's-complement"&gt;Two's complement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://learn.akae.cn/media/ch14s03.html"&gt;整数的加减运算&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://baike.baidu.com/view/60437.htm"&gt;机器数 —— 百度百科&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'blue ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="CS"></category><category term="Code"></category></entry></feed>