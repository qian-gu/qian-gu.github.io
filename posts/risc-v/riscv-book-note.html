
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark)"
    href="https://qian-gu.github.io/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://qian-gu.github.io/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="/static/custom.css">

  <link rel="shortcut icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">
  <link rel="icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Microsoft EDGE -->
  <meta name="msapplication-TileColor" content="#333333">

  <link href="https://qian-gu.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Qian's Blog Atom">


<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48826831-1', 'auto');
  ga('send', 'pageview');
</script>






 

<meta name="author" content="Qian Gu" />
<meta name="description" content="The RISC-V Reader: An Open Architecture Atlas 读书笔记" />
<meta name="keywords" content="RISC-V, Spec">


  <meta property="og:site_name" content="Qian's Blog"/>
  <meta property="og:title" content="RISC-V Book 阅读笔记"/>
  <meta property="og:description" content="The RISC-V Reader: An Open Architecture Atlas 读书笔记"/>
  <meta property="og:locale" content="en"/>
  <meta property="og:url" content="https://qian-gu.github.io/posts/risc-v/riscv-book-note.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2024-04-13 14:26:00+08:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://qian-gu.github.io/author/qian-gu.html">
  <meta property="article:section" content="RISC-V"/>
  <meta property="article:tag" content="RISC-V"/>
  <meta property="article:tag" content="Spec"/>
  <meta property="og:image" content="https://qian-gu.github.io/images/logo.png">

  <title>Qian's Blog &ndash; RISC-V Book 阅读笔记</title>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-1821536199377100",
      enable_page_level_ads: true
    });
  </script>

</head>
<body >

<aside>
  <div>
    <a href="https://qian-gu.github.io/">
      <img src="https://qian-gu.github.io/images/logo.png" alt="Qian Gu" title="Qian Gu">
    </a>

    <h1>
      <a href="https://qian-gu.github.io/">Qian Gu</a>
    </h1>

    <p>Read >> Think >> Write</p>

    <div class="stork">
      <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick="loadStorkIndex()"/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>

    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://qian-gu.github.io/pages/about-me.html#about-me">
                About Me
              </a>
            </li>

      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-envelope"
rel="me"           href="mailto:guqian110@163.com"
           target="_blank">
          <i class="fa-solid fa-envelope"></i>
        </a>
      </li>
      <li>
        <a class="sc-github"
           href="https://github.com/qian-gu"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-twitter"
           href="https://twitter.com/qian_gu"
           target="_blank">
          <i class="fa-brands fa-twitter"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/feeds/all.atom.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://qian-gu.github.io/">Home</a>

  <a href="/authors.html">Authors</a>
  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://qian-gu.github.io/feeds/all.atom.xml">Atom</a>

</nav>

<article class="single">
  <header>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.1.0/css/all.css" rel="stylesheet">
      
    <h1 id="riscv-book-note">RISC-V Book 阅读笔记</h1>
    <p>
      Posted on 2024-04-13 14:26 in <a href="https://qian-gu.github.io/category/risc-v.html">RISC-V</a>

    </p>
    <div class="tag-cloud">
      <p>
        <a href="https://qian-gu.github.io/tag/risc-v.html">RISC-V</a>
        <a href="https://qian-gu.github.io/tag/spec.html">Spec</a>
      </p>
    </div>
  </header>


  <div class="related-posts">
    <h4>Part 3 of the RISC-V Notes series</h4>
       <h5>Previous articles</h5>
       <ul>
           <li><a href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-1-unprivileged.html">RISC-V Spec 阅读笔记 #1 —— Unprivileged ISA</a></li>
           <li><a href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-2-privileged.html">RISC-V Spec 阅读笔记 #2 —— Privileged ISA</a></li>
       </ul>
  </div>

  <div>
    <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#risc-v">为什么要有 RISC-V？</a><ul>
<li><a href="#isa">ISA 设计导论</a></li>
<li><a href="#_1">结语</a></li>
</ul>
</li>
<li><a href="#rv32irisc-v">RV32I：RISC-V 基础整数指令集</a><ul>
<li><a href="#rv32i">RV32I 指令格式</a></li>
<li><a href="#rv32i_1">RV32I 寄存器</a></li>
<li><a href="#rv32i_2">RV32I 整数计算</a></li>
<li><a href="#rv32i_3">RV32I 取数和存数</a></li>
<li><a href="#rv32i_4">RV32I 条件分支</a></li>
<li><a href="#rv32i_5">RV32I 无条件跳转</a></li>
<li><a href="#rv32i_6">其他 RV32I 指令</a></li>
<li><a href="#_2">结语</a></li>
</ul>
</li>
<li><a href="#risc-v_1">RISC-V 汇编语言</a><ul>
<li><a href="#_3">函数调用过程</a></li>
<li><a href="#_4">结语</a></li>
</ul>
</li>
<li><a href="#rv32m">RV32M：乘法和除法指令</a><ul>
<li><a href="#_5">结语</a></li>
</ul>
</li>
<li><a href="#rv32f-rv32d">RV32F 和 RV32D：单精度和双精度浮点数</a><ul>
<li><a href="#_6">浮点寄存器</a></li>
<li><a href="#_7">浮点取数、存数和算术运算</a></li>
<li><a href="#_8">结语</a></li>
</ul>
</li>
<li><a href="#rv32a">RV32A：原子指令</a><ul>
<li><a href="#_9">结语</a></li>
</ul>
</li>
<li><a href="#rv32c">RV32C：压缩指令</a><ul>
<li><a href="#_10">结语</a></li>
</ul>
</li>
<li><a href="#rv32v">RV32V：向量</a><ul>
<li><a href="#_11">向量计算指令</a></li>
<li><a href="#_12">向量寄存器和动态类型</a></li>
<li><a href="#_13">向量取数和存数</a></li>
<li><a href="#_14">向量操作的并行度</a></li>
<li><a href="#_15">向量操作的条件执行</a></li>
<li><a href="#_16">结语</a></li>
</ul>
</li>
<li><a href="#rv6464">RV64：64 位地址指令</a><ul>
<li><a href="#_17">结语</a></li>
</ul>
</li>
<li><a href="#rv3264">RV32/64 特权架构</a><ul>
<li><a href="#_18">机器模式</a></li>
<li><a href="#_19">机器模式的异常处理</a></li>
<li><a href="#_20">嵌入式系统中的用户模式和进程隔离</a></li>
<li><a href="#_21">现代操作系统的监管模式</a></li>
<li><a href="#_22">页式虚拟内存</a></li>
<li><a href="#_23">结语</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="risc-v">为什么要有 RISC-V？</h2>
<blockquote>
<p>大道至简。</p>
<p>—— 列奥纳多 · 达 · 芬奇（Leonardo da Vinci）</p>
</blockquote>
<p>年轻、开放、模块化。</p>
<h3 id="isa">ISA 设计导论</h3>
<p>计算机架构师在设计 ISA 时需要遵守的基本原则和做出权衡，评价一个 ISA 的 7 个指标：</p>
<ul>
<li>
<p><strong>成本</strong> </p>
<p>ISA 越简单，area 越小，成本越低。</p>
</li>
<li>
<p><strong>简洁</strong> </p>
<p>简洁不光可以节省制造成本，还能节省设计和验证时间，降低文档开销，使得用户更加容易了解和使用。高端 implement 可以通过组合简单指令来提升性能，但是如果直接在 ISA 中添加更大、更复杂的指令会给低端 implement 带来负担。</p>
</li>
<li>
<p><strong>性能</strong> </p>
<p>完成相同的任务，RISC 比 CISC 需要的指令更多，但是 RISC 因为其 ISA 的简洁性，可以通过更高的时钟频率和更小的 CPI 来弥补。</p>
</li>
<li>
<p><strong>架构和实现分离</strong> </p>
<p>延迟分支槽：MIPS-32 ISA 在 architecture 层面解决某一时期某个 implement 的问题，导致其他和后续的 implement 为了保持向后兼容不得不做一些无用的工作。</p>
<p>架构师除了不应该加入那些仅有助于一个 implement 的功能，也不应该加入阻碍某些实现的功能。比如 ARM-32 提供的 load multiple 指令，这个指令可以提升单发射 pipeline 的性能，但是会对多发射 pipeline 带来负面影响。因为简单的多发射实现无法支持 load multiple 指令和其他指令的并行调度，所以要么实现更复杂的多发射机制，要么降低这种情况下的指令吞吐。</p>
</li>
<li>
<p><strong>提升空间</strong> </p>
<p>随着摩尔定律的终结，大幅提高性价比的唯一途径是 DSA（为特定领域添加自定义指令，如 DL、AR 等），所以 ISA 必须预留操作码空间。</p>
</li>
<li>
<p><strong>代码大小</strong> </p>
<p>让代码变短是 ISA 架构师的目标，因为可以降低所需存储器的面积（嵌入式的一项巨大成本），降低 I$ 的 miss ratio，从而降低功耗（访问片外 DRAM 代价远高于片上 SRAM）并提升性能。</p>
</li>
<li>
<p><strong>易于编程 / 编译 / 链接</strong> </p>
<p>GPR 数量越多，编译器和汇编程序员的工作越轻松。ARM-32 有 16 个寄存器，X86-32 只有 8 个，现代 ISA 都有相对较多的 32 个。</p>
<p>位置无关代码（Position Independent Code, PIC）有助于支持动态链接，因为共享库的代码可以放在不同地址。PC 相对分支和数据寻址是 PIC 的福音，RISC-V 支持 PC 相对寻址，但是 x86-32 和 MIPS-32 不支持。</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>ISA 就好比俄罗斯方块中的方块形状集合，集合要设计的够用且不冗余。</p>
</div>
<h3 id="_1">结语</h3>
<blockquote>
<p>用形式逻辑方法容易看出，存在某种抽象的 [ 指令集 ]，足以控制和执行任意操作序列 …… 现在看来，选择一款 [ 指令集 ] 的真正决定性因素更多是实用性：[ 指令集 ] 所需装置的简洁性，应用于实际重要问题的清晰度，以及处理这些问题的速度。
——[Burks et al. 1946]</p>
</blockquote>
<p>RISC-V 是一款最新的、清晰的、简约的、开放的 ISA，它以过去 ISA 所犯错误为鉴。RISC-V 架构师的目标是让它能用于从最小到最快的所有计算设备。遵循冯 · 诺依曼在 1940 年代的建议，RISC-V 强调简洁性以保持低成本，同时拥有大量寄存器和直观的指令执行速度，从而帮助编译器和汇编语言程序员将实际的重要问题转换为适当的高效代码。</p>
<h2 id="rv32irisc-v">RV32I：RISC-V 基础整数指令集</h2>
<blockquote>
<p>…… 提升计算性能并让用户切实享受到性能提升的唯一方法是同时设计编译器和计算机。这样软件用不到的特性将不会在硬件上实现 ……</p>
<p>—— 法兰 · 艾伦（Frances Elizabeth “Fran” Allen），1981</p>
</blockquote>
<h3 id="rv32i">RV32I 指令格式</h3>
<p>简洁的指令格式：</p>
<ul>
<li>简洁：四种基础格式 R(egister) + I(mmediate) + S(tore) + U(pper) + 两种扩展格式 B(ranch) + J(ump)</li>
<li>性能：支持 3 个操作数</li>
<li>性能：rs1，rs2，rd 位置固定，在 dec 前访问 GPR</li>
<li>性能：imm 的符号位永远在 inst[31]，符号位扩展可在 dec 前进行</li>
<li>易于编程：全 0 和全 1 为非法指令</li>
<li>成本：精心挑选 op_code，使得 datapath 相同的指令共享 op_code，从而简化控制逻辑</li>
<li>提升空间：RV32I 占用 32bit 指令编码空间不到 1/8，预留指令编码空间</li>
</ul>
<h3 id="rv32i_1">RV32I 寄存器</h3>
<ul>
<li>易于编程：RISC-V = 32 个 GPR + 1 PC；ARM-32 = 16 个 GPR（包含 PC）</li>
<li>简洁：实现相同功能，设置 x0 为常 0 可以简化操作，额外设置 PC 可以简化分支预测复杂度，且少占用一个 GPR</li>
</ul>
<h3 id="rv32i_2">RV32I 整数计算</h3>
<ul>
<li>简洁：imm 总是符号位扩展，所以无需 imm 版本的 sub 指令</li>
<li>简洁：虽然 branch 支持 2 个 GPR 之间的所有运算关系，还是提供 slt 方便处理更复杂的条件表达式</li>
<li>易于编程：lui 搭配后续一条指令，可以构造出 32bit 的 imm；auipc 搭配 jal/jalr 可以实现相对于 PC 的任意偏移跳转和数据访问</li>
</ul>
<h3 id="rv32i_3">RV32I 取数和存数</h3>
<ul>
<li>简洁：RV32I 只支持一种标准寻址模式： <strong>偏移寻址</strong> ，即跳转地址 = 寄存器 + imm[11:0]</li>
<li>简洁：没有栈指令，ABI 中指定 x2 为 sp 就能使得标准寻址模式具有 push/pop 的优点，无需增加 ISA 复杂度</li>
<li>易于编程：ARM-32 和 MIPS-32 要求数据按其长度对齐，RISC-V 无此要求</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>因为一条 32bit 指令无法容纳 32bit 地址，所以 linker 通常要把每个符号调整成 2 条 RV32I 指令。</p>
<ul>
<li>对于数据地址，需要调整为 lui 和 addi</li>
<li>对于代码地址，需要调整为 auipc 和 jalr</li>
</ul>
<p>很多时候跳转距离没那么大，此时并不需要两条，linker 会多趟扫描代码，尽可能优化成一条 jal 指令（包含 imm[19:0]，可以寻址前后 1MB），这个过程叫做 linker relaxation。</p>
</div>
<h3 id="rv32i_4">RV32I 条件分支</h3>
<ul>
<li>简洁：RISC-V 没有 MIPS-32 的延迟分支，也没有 ARM-32 和 x86-32 的条件码</li>
<li>简洁：auipc 的 imm 为 0 就可以得到当前 PC，x86-32 需要先调用函数把 PC push，然后读出 PC，最后再 pop</li>
<li>简洁：大部分程序都忽略整数的算术溢出，所以 RISC-V 让软件检测溢出</li>
</ul>
<h3 id="rv32i_5">RV32I 无条件跳转</h3>
<ul>
<li>简洁：RV32I 不支持复杂的过程调用指令，如 x86-32 的 enter/leave，Tensilica 的 register windows</li>
</ul>
<div class="admonition info">
<p class="admonition-title">Info</p>
<p>register windows：通过远多于 32 个 GPR 来加速函数调用。在函数调用时，为其分配新的一组 32 个寄存器（也称为窗口），为了支持传参，两个函数的窗口会重叠，即有些寄存器同时属于两个相邻的窗口。</p>
</div>
<h3 id="rv32i_6">其他 RV32I 指令</h3>
<ul>
<li>简洁：RISC-V 通过 memory-map IO 来访问设备，没有 x86-32 的专用 I/O 指令</li>
</ul>
<h3 id="_2">结语</h3>
<blockquote>
<p>那些遗忘过去的人注定要重蹈覆辙。</p>
<p>—— 乔治 · 桑塔亚那（George Santayana），1905</p>
</blockquote>
<p>得益于起步时间比过去的 ISA 晚 20∼30 年，RISC-V 架构师可以实践 Santayana 的建议，借鉴包括 RISC-I 在内不同 ISA 的设计，取其精华，去其糟粕。此外，RISC-V 国际基金会将以可选扩展的方式缓慢地演进指令集，以规避给过去的成功 ISA 造成麻烦的野蛮生长现象。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>图 2.7 按照 7 个评价指标汇总了 ARM-32、MIPS-32、x86-32 和 RV32I 的对比</p>
</div>
<h2 id="risc-v_1">RISC-V 汇编语言</h2>
<blockquote>
<p>给看似困难的问题找到简单的解法往往令人满足，而最好的解法通常是简单的。</p>
<p>—— 伊凡 · 苏泽兰（Ivan Sutherland）</p>
</blockquote>
<h3 id="_3">函数调用过程</h3>
<p>通常分为 6 个阶段：</p>
<ol>
<li>caller 将参数放到 callee 可访问的位置</li>
<li>调换到 callee 的入口（使用 jal）</li>
<li>获取函数所需的局部存储资源，按需保存 GPR</li>
<li>执行函数功能</li>
<li>将返回值放到 caller 可访问的位置，恢复 GPR，释放局部存储资源</li>
<li>将控制权返回给 caller（使用 ret）</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>保存寄存器由 callee 负责维护，重新解释上述过程如下：</p>
<p>在 caller 中执行 call 指令跳转进入 callee 后，callee 首先做两件事：</p>
<ol>
<li>分配 stack frame，为保存现场准备资源</li>
<li>将 callee 需要维护的保存寄存器存储到 stack 中</li>
</ol>
<p>当 callee 完成功能后，执行 ret 指令前做两件事情：</p>
<ol>
<li>从 stack 向保存寄存器恢复现场</li>
<li>恢复保存寄存器 <code>sp</code> == 释放 stack frame（局部资源）</li>
</ol>
</div>
<p>为了提升性能，应尽量把变量放在 GPR 中而不是内存中，同时要避免因为保存和恢复 GPR 而频繁访问内存。RISC-V 有足够的寄存器兼顾两者：既能把操作数放在 GPR，又能减少保存和恢复它们的次数。关键在于，一些寄存器不保证其值在函数调用前后保持一致，称为临时寄存器；另一些能保证，称为保存寄存器。不再调用其他函数的函数称为叶子函数。当一个叶子函数只有少量参数和局部变量时，可将其分配到寄存器，无需分配到内存。大部分函数调用均如此，此时程序无需将寄存器保存到内存。</p>
<p>典型例子 main 函数调用 prinf：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1"># 编译，将 c 代码转化为 asm 代码，结果如图 3.6</span>
gcc<span class="w"> </span>-o<span class="w"> </span>hello.s<span class="w"> </span>-S<span class="w"> </span>hello.c
<span class="c1"># 编译，将 asm 代码转化为 .o 文件，.o 文件无法直接查看，需要先 dump，结果如图 3.7</span>
<span class="c1"># 其中一些指令的地址字段是 0，需要 linker 填充</span>
gcc<span class="w"> </span>-o<span class="w"> </span>hello.o<span class="w"> </span>-c<span class="w"> </span>hello.s
objdump<span class="w"> </span>-D<span class="w"> </span>hello.o<span class="w"> </span>&gt;&gt;<span class="w"> </span>hello.o.dump
<span class="c1"># 链接，将 .o 文件转化为 elf 文件，elf 文件无法直接查看，需要先 dump，结果如图 3.8</span>
<span class="c1"># 地址字段已替换</span>
gcc<span class="w"> </span>-o<span class="w"> </span>hello<span class="w"> </span>hello.c
objdump<span class="w"> </span>-D<span class="w"> </span>hello<span class="w"> </span>&gt;&gt;<span class="w"> </span>hello.dump
</code></pre></div></td></tr></table></div>

<h3 id="_4">结语</h3>
<blockquote>
<p>保持简洁，直接。</p>
<p>—— 凯利 · 约翰逊（Kelly Johnson），提出 “KISS 原则 ” 的航空工程师，1960</p>
</blockquote>
<p>汇编器向简洁的 RISC-V ISA 增加了 60 条伪指令，在不增加硬件开销的同时令 RISC-V 代码更易于读写。RISC-V 提供一系列简单有效的机制，可降低成本、提高性能、易于编程。</p>
<h2 id="rv32m">RV32M：乘法和除法指令</h2>
<blockquote>
<p>若无必要，勿增实体。</p>
<p>—— 奥卡姆的威廉（William of Occam），约 1320</p>
</blockquote>
<ul>
<li>在几乎任何处理器上，执行速度：移位 &gt; 乘法 &gt;&gt; 除法。</li>
<li>除以常数，可以转化成乘以一个近似的倒数，再校正积的高位部分</li>
<li>ARM-32 在 2005 之后才添加了除法指令；MISP-32 使用特殊的寄存器作为乘除法的 rd，所以需要额外的传送指令，会降低性能，增加体系结构的状态，降低切换任务的速度</li>
<li>mulh 和 mulhu 可以检查乘法溢出</li>
<li>除数为 0 不会产生 trap，所以可以只在需要时通过 beqz 检查除数是否为 0</li>
<li>mulhsu 对 multi-word singed 乘法很有用</li>
</ul>
<h3 id="_5">结语</h3>
<blockquote>
<p>最便宜、最快且最可靠的组件是那些不存在的组件。</p>
<p>—— 切斯特 · 戈登 · 贝尔（C. Gordon Bell），著名小型计算机架构师</p>
</blockquote>
<h2 id="rv32f-rv32d">RV32F 和 RV32D：单精度和双精度浮点数</h2>
<blockquote>
<p>达成完美之时并非无所可增，而是无所可减。</p>
<p>—— 安托万 · 德 · 圣埃克絮佩里（Antoine de Saint-Exupéry），《人的大地》，1939</p>
</blockquote>
<h3 id="_6">浮点寄存器</h3>
<ul>
<li>性能：4 种指令格式中 rs 和 rd 只有 5bit 刚好表达 32 个 x 寄存器，为了保持指令格式不变，为浮点另外设置一组（32 个）f 寄存器</li>
<li>如果只支持 RV32F 则 FLEN=32，如果支持 RV32D 则 FLEN=64</li>
<li>fcsr 用于存放 round mode 和精确异常 flag</li>
<li>ARM-32 和 MIPS-32 有 32 个 float 寄存器，但是只有 16 个 double 寄存器（把两个 float 拼接成一个 double 使用）</li>
<li>x86-32 浮点运算早期使用 stack 而不是寄存器，后续版本增加了 8 个 64bit 浮点寄存器</li>
<li>ARM-32 和 x86-32 不支持 x 和 f 寄存器之间直接传送数据的指令，要实现该功能，必须先写内存，再读内存</li>
</ul>
<h3 id="_7">浮点取数、存数和算术运算</h3>
<ul>
<li>性能：许多浮点运算（矩阵乘法）在乘法后立即执行一次加法 / 减法，所以 RISC-V 提供了 fmadd、fmsub、fnmadd、fnmsub 指令</li>
</ul>
<h3 id="_8">结语</h3>
<blockquote>
<p>少即是多。</p>
<p>—— 罗伯特 · 勃朗宁（Robert Browning），1855。</p>
</blockquote>
<h2 id="rv32a">RV32A：原子指令</h2>
<blockquote>
<p>一切事物都应该尽量简单，但不能过分简单。</p>
<p>—— 阿尔伯特 · 爱因斯坦（Albert Einstein），1933</p>
</blockquote>
<p>RV32A 用于同步的原子操作有两种：</p>
<ul>
<li>原子内存操作（atomic memory operation，AMO）</li>
<li>预订取数 / 条件存数（load reserved / store conditional）</li>
</ul>
<p>为何 RV32A 要提供两种原子操作？答案是对应两种区别很大的使用场景。</p>
<p>场景一：编程语言开发者假定顶层的 ISA 提供原子的 compare-and-swap 操作：比较某寄存器和另一寄存器寻址的内存值，若相等，则将第 3 个寄存器的值与内存值交换。这是一种通用的同步原语，基于它可以实现其他任意 word 同步操作。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code># 用 lr/sc 对内存 M[a0] 进行 compare-and-swap
# 期望的旧值在 a1 中；期望的新值在 a2 中
0: lr.w a3, (a0)  # 取出旧值
4: bne a3, a1, 80  # 旧值是否等于 a1？
8: sc.w a3, a2, (a0)  # 如果相等，则换入新值
c: bnez a3, 0  # 如果失败，重试
... compare-and-swap 成功后的代码 ...
...
80:  # compare-and-swap 失败
```
</code></pre></div></td></tr></table></div>

<p>场景二：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code># 用 AMO 实现 test-and-set 自旋锁，用于保护临界区
0: li t0, 1 # 初始化锁值
4: amoswap.w.aq t1, t0, (a0) # 尝试获取锁
8: bnez t1, 4 # 若失败则重试
... 临界区代码 ..
20: amoswap.w.rl x0, x0, (a) # 释放锁
```
</code></pre></div></td></tr></table></div>

<h3 id="_9">结语</h3>
<p>RV32A 是可选的，一个不支持它的 RISC-V 处理器会更简单。然而，正如爱因 斯坦所言，一切事物都应该尽量简单，但不能过分简单。RV32A 正是如此，许多场景 都离不开它。</p>
<h2 id="rv32c">RV32C：压缩指令</h2>
<blockquote>
<p>小即是美。</p>
<p>—— 恩斯特 · 弗里德里希 · 舒马赫（E. F. Schumacher），1973</p>
</blockquote>
<ul>
<li>代码大小：以前的 ISA 为缩减代码大小而添加很多指令和指令格式，ARM 和 MIPS 分别对 ISA 重新设计了两遍：ARM 设计了 ARM Thumb 和 Thumb2，MIPS 则设计了 MIPS16 和 microMIPS。这些新 ISA 给处理器和编译器带来额外的设计开销，同时还增加汇编语言程序员的认知负担。</li>
<li>简洁：RV32C 采用一种新方法：每条短指令都必须对应一条标准的 32 位 RISC-V 指 令。此外，16 位指令仅对汇编器和链接器可见，并由它们决定是否将标准指令替换为相应的短指令。编译器开发者和汇编语言程序员无需关心 RV32C 指令及其格式，他 们只需知道最终得到的程序比大部分情况下更小。</li>
<li>成本：尽管处理器设计者不能忽略 RV32C 指令，但能通过以下技巧降低实现开销：在执 行指令前通过一个译码器将所有 16 位指令翻译成相应的 32 位指令。</li>
</ul>
<p>为什么有些架构师会跳过 RV32C：16bit 的 RV32C 和 32bit 的 RV32I 混合在一起会恶化 decoder 的时序，而在高性能处理器中，dec 本身就是时序瓶颈，所以很难处理这种情况。典型例子：</p>
<ul>
<li>superscalar 一个 cycle 内 decode 多条指令</li>
<li>宏融合 macrofusion：decoder 把多条指令组合成更复杂的指令来执行</li>
</ul>
<h3 id="_10">结语</h3>
<blockquote>
<p>我本能写出更短的信，但我没有时间。</p>
<p>—— 布莱兹 · 帕斯卡（Blaise Pascal），1656。</p>
</blockquote>
<p>RV32C 让 RISC-V 编译出当今几乎最短的代码。您几乎能将其视为硬件辅助的伪指令。但这里汇编器将其隐藏起来，汇编语言程序员和编译器开发者无需感知。</p>
<h2 id="rv32v">RV32V：向量</h2>
<blockquote>
<p>我追求简洁，无法理解复杂的事物。</p>
<p>—— 西摩 · 克雷（Seymour Cray）</p>
</blockquote>
<ul>
<li>性能：注数据级并行，该技术用于可在大量数据上并发计算的目标应用程序。最著名的数据级并行架构是 SIMD（Single Instruction Multiple Data，单指令多数据）。</li>
<li>架构和实现分离：将向量长度和每个时钟周期的最大操作次数与指令编码分离，是向量架构的关键。向量微架构师可灵活设计数据并行硬件单元，不会影响程序员，而程序员无需重写代码即可享受更长向量的好处。</li>
<li>易于编程 / 编译 / 链接：向量架构的指令数量比 SIMD 架构少得多。而且，与 SIMD 不同，向量架构的编译技术十分完善。</li>
</ul>
<h3 id="_11">向量计算指令</h3>
<ul>
<li>RV32IMAFD 每一条整数和浮点计算指令基本都有对应的向量版本</li>
<li>每条向量指令根据操作数的类型，有多个版本</li>
</ul>
<h3 id="_12">向量寄存器和动态类型</h3>
<ul>
<li>32 个名称以 v 开头的向量寄存器，但每个向量寄存器的元素数量并不固定，取决于操作的位宽和向量寄存器堆大小，后者由处理器设计者决定。</li>
</ul>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>VLEN</code></td>
<td>每个 VRF 的位宽，单位为 bit</td>
</tr>
<tr>
<td><code>mvl</code></td>
<td>单条指令能正确运行的最大向量元素个数</td>
</tr>
<tr>
<td><code>vl</code></td>
<td>待处理的向量元素个数</td>
</tr>
</tbody>
</table>
<ul>
<li>易于编程 / 编译 / 链接：RV32V 采取将数据类型和位宽与向量寄存器关联的新方法，而不是与指令操作码关联。程序在执行向量计算指令前，先在向量寄存器中设置数据类型和位宽。使用动态寄存器类型可大幅减少向量指令数量。动态类型向量架构能降低汇编语言程序员的认知负担和编译器中代码生成器的复杂度。</li>
<li>向量架构不如 SIMD 架构流行的一个原因是，大家担心添加很大的向量寄存器会增加中断时保存和恢复程序（上下文切换）的开销。动态寄存器类型有助于改善此情况。根据 RV32V 约定，软件在不使用向量指令时需要禁用所有向量寄存器，这意味着处理器既具备向量寄存器的性能优势，又仅在向量指令执行过程中发生中断时才引入额外的上下文切换开销。</li>
</ul>
<h3 id="_13">向量取数和存数</h3>
<ul>
<li>易于编程 / 编译 / 链接：虽然可以设置 stride = 1 使得 stride 兼容 unistride，但是提供 unistride 指令可以缩小代码体积和指令数。（vlds/vsts 需要 2 个 rs，而 vld/vst 只需要 1 个）</li>
<li>易于编程 / 编译 / 链接：为了支持稀疏数组，提供 index 指令</li>
</ul>
<h3 id="_14">向量操作的并行度</h3>
<ul>
<li>性能：向量元素之间独立，硬件可以并行计算，每个 cycle 计算的元素数量由 VLEN 和 EEW 决定</li>
<li>易于编程 / 编译 / 链接：在 SIMD 架构中，由 ISA 架构师决定每个 cycle 并行操作的最大数量和每个寄存器的元素数量，如果寄存器位宽翻倍，则指令数也翻倍，还需要同步修改编译器。RV32V 则由 implementation 决定，无需修改 ISA 和编译器，同一份 RV32V 程序，无需修改（修改代码和重新编译）就可以同时在最简单或最激进的向量处理器上运行。</li>
</ul>
<h3 id="_15">向量操作的条件执行</h3>
<p>一些向量计算包含 if 语句。向量架构不依赖于条件分支，而是用掩码禁止部分元素的向量操作。</p>
<h3 id="_16">结语</h3>
<blockquote>
<p>若代码可向量化，最好的架构就是向量架构。</p>
<p>—— 吉姆 · 史密斯（Jim Smith）于 1994 年在国际计算机体系结构研讨会（ISCA）上的主题演讲</p>
</blockquote>
<h2 id="rv6464">RV64：64 位地址指令</h2>
<blockquote>
<p>在计算机设计中只有一种错误难以恢复 —— 用于存储器寻址和存储管理的地址位 不足。</p>
<p>—— 切斯特 · 戈登 · 贝尔，1976</p>
</blockquote>
<ul>
<li>代码大小：RV64 基本上是 RV32 的超集，唯一例外是压缩指令。</li>
<li>与 RISC-V 不同，ARM 决定采用最大主义方法来设计 ISA。</li>
<li>成本：程序大小的差异显著，让 RV64 要么能通过较低的指令缓存缺失率提升性能，要么在缺失率尚可接受的前提下，采用更小的指令缓存来降低成本。</li>
</ul>
<h3 id="_17">结语</h3>
<blockquote>
<p>成为先驱的一个问题是你总会犯错误，而我永远不想成为先驱。在看到先驱所犯错误后，第二个做这件事才是最好的。</p>
<p>—— 西摩 · 克雷（Seymour Cray），第一台超级计算机的架构师，1976 年</p>
</blockquote>
<p>64 位架构更能体现 RISC-V 设计的合理性，这对 20 年后才开始设计的我们是更容易实现的，因为我们能借鉴先驱经验，取其精华，去其糟粕。</p>
<h2 id="rv3264">RV32/64 特权架构</h2>
<blockquote>
<p>简洁是可靠性的前提。</p>
<p>—— 艾兹赫尔 · 韦伯 · 戴克斯特拉（Edsger W. Dijkstra）</p>
</blockquote>
<p>高特权模式通常能访问低特权模式的所有功能，同时还具备若干低特权模式下不可用的额外功能，如中断处理和 I/O 操作。处理器通常在最低特权模式下运行，当发生中断和异常时，则将控制权转移到更高特权的模式。</p>
<p>RV 的 3 种模式：</p>
<ul>
<li>machine mode</li>
<li>supervisor mode</li>
<li>user mode</li>
</ul>
<p>特权架构指令很少，但是增加了若干 csr 来实现其新增功能。</p>
<ul>
<li>简洁：RV32 和 RV64 特权架构，两者的差异仅体现在整数寄存器的位宽。</li>
</ul>
<h3 id="_18">机器模式</h3>
<p>机器模式最重要的特性是拦截和处理异常 exception（不寻常的 runtime event）。RISC-V 将 exception 分为两类：</p>
<ul>
<li>同步异常 synchronous exception：指令执行的结果，比如访问非法地址，指令 opcode 无效</li>
<li>中断 interrupt：和指令流异步的外部事件，比如鼠标点击。标准中断源有 3 个<ul>
<li>软件 software：通过写入一个内存映射寄存器触发，通常用于一个 hart 通知另一个 hart，此机制在其他架构中称为处理器间中断 interprocessor interrupt</li>
<li>时钟 timer：mtime &gt;= mtimecmp（内存映射寄存器）时触发</li>
<li>外部来源 external：由 PLIC（大部分外设都挂载在它上面）产生，PLIC 因平台而异</li>
</ul>
</li>
</ul>
<p>RISC-V 允许不对齐访存，但是仍包含访存地址不对齐异常。原因是考虑到不对齐访存的硬件实现较复杂，且出现频率很低，因此一些硬件实现方案选择不支持不对齐的普通访存操作。这类处理器需要陷入异常处理程序，然后通过一系列较小的对齐访存操作，来在软件中模拟不对齐访存。应用程序代码对此一无所知：不对齐访存操作仍然正确执行，虽然执行得慢，但硬件实现却很简单。此外，高性能处理器亦可在硬件中实现不对齐访存。</p>
<h3 id="_19">机器模式的异常处理</h3>
<p>异常处理必须的 8 个 csr：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>全拼</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mstatus</code></td>
<td>Machine Status</td>
<td>维护各种状态，如全局中断使能</td>
</tr>
<tr>
<td><code>mip</code></td>
<td>Machine Interrupt Pending</td>
<td>记录当前的中断请求</td>
</tr>
<tr>
<td><code>mie</code></td>
<td>Machine Interrupt Enable</td>
<td>维护处理器的中断使能状态</td>
</tr>
<tr>
<td><code>mcause</code></td>
<td>Machine Exception Cause</td>
<td>指示发生了何种异常</td>
</tr>
<tr>
<td><code>mtvec</code></td>
<td>Machine Trap Vector</td>
<td>存放发生异常时处理器跳转的地址</td>
</tr>
<tr>
<td><code>mtval</code></td>
<td>Machine Trap Value</td>
<td>存放当前自陷相关的额外信息，如地址异常的故障地址、非法指令异常的指令，发生其他异常时其值为 0</td>
</tr>
<tr>
<td><code>mepc</code></td>
<td>Machine Exception PC</td>
<td>指向发生异常的指令</td>
</tr>
<tr>
<td><code>mscratch</code></td>
<td>Machine Scratch</td>
<td>向异常处理程序提供一个字的临时存储</td>
</tr>
</tbody>
</table>
<p>M-mode 响应 exception 的例子：</p>
<ol>
<li>首先检查条件 mstatus.MIE = 1，mie 和 mip 的 bit 位，满足条件后原子性地完成以下步骤</li>
<li>将 exception 指令的 PC 保存到 mepc，然后把 PC 设置为 mtvec<ul>
<li>对于 synchronous exception：mepc 指向触发 exception 的指令</li>
<li>对于 interrupt：mepc 指向 ISR 后恢复执行的指令</li>
</ul>
</li>
<li>把 exception 原因写入 mcause，并把故障地址或其他相关信息写入 mtval</li>
<li>把 MIE 的旧值保存到 MPIE，把 mstatus.MIE 清零以屏蔽 interrupt</li>
<li>把 exception 发生前的模式保存到 mstatus.MPP，然后把模式更改为 M</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CSR 中没有记录当前的 privilege 等级，只有 MPP、SPP、UPP，所以软件无法查询得知当前处于哪个模式，原因是 ISA 认为软件开发人员应该准确地知道每段代码所处的特权等级，无需查询。
从硬件设计的角度，内部需要有一个寄存器来记录当前状态，否则无法判断当前等级是否有权限执行某些指令。该内部寄存器未开放给软件，所以在 ISA CSR 中也不可见。</p>
</div>
<p>mscratch 的作用：提供一种快速的保存 - 恢复机制，可以直接把某个 XRF 写入到 mscratch，而不是 stack 中。如果需要保存更多的寄存器，一般 mscratch 指向一片空闲的内存，ISR 可以根据需求把想要的任意个寄存器内容写入到该空间：</p>
<ol>
<li>首先用 csrrw 指令交换 mscratch 和 a0 的内容（mscratch 是 csr，普通指令无法直接使用，必须先交换到 XRF 中。因为 ISR 没有参数，所以 a0 是空闲 XRF，可以用来和 mscratch 交换）</li>
<li>将任意个 XRF 保存到内存中</li>
<li>中断处理</li>
<li>处理完后再从内存中恢复数据到 XRF</li>
<li>用 csrrw 交换 mscratch 和 a0，恢复内容</li>
<li>用 mret 返回</li>
</ol>
<p>示例代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1"># example：timer 中断的 ISR。</span>
<span class="c1"># 假设</span>
<span class="c1"># 1. mstatus.MIE=1 已打开全局中断使能</span>
<span class="c1"># 2. timer 中断使能 mie[7]=1 已打开</span>
<span class="c1"># 3. mtvec 设置为本处理程序的地址</span>
<span class="c1"># 4. mscratch 指向一段 16Byte 的临时缓冲区</span>

<span class="c1"># step1. 交换 mscratch 和 a0。a0 保持空闲内存供后续普通指令使用，mscratch 保存 a0 旧值，用于后续恢复</span>
<span class="nf">csrrw</span><span class="w"> </span><span class="no">a0</span><span class="p">,</span><span class="w"> </span><span class="no">mscratch</span><span class="p">,</span><span class="w"> </span><span class="no">a0</span>

<span class="c1"># step2. 保存 XRF 到空闲内存。因为后续要使用到 a1, a2, a3, a4 这几个 XRF，所以先保存旧值</span>
<span class="nf">sw</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
<span class="nf">sw</span><span class="w"> </span><span class="no">a2</span><span class="p">,</span><span class="w">  </span><span class="mi">4</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
<span class="nf">sw</span><span class="w"> </span><span class="no">a3</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
<span class="nf">sw</span><span class="w"> </span><span class="no">a4</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>

<span class="c1"># step3. 中断处理</span>
<span class="c1"># 解析中断原因</span>
<span class="nf">csrr</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="no">mcause</span><span class="w">        </span><span class="c1"># 读出异常原因</span>
<span class="nf">bgez</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="no">exception</span><span class="w">     </span><span class="c1"># 若非中断则跳转，bgez 的 rs 是 signed 类型，中断对应的 MSB = 1 为负数</span>
<span class="nf">andi</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="mi">0x3f</span><span class="w">      </span><span class="c1"># 单独取出中断原因</span>
<span class="nf">li</span><span class="w">   </span><span class="no">a2</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w">             </span><span class="c1"># a2 = 时钟中断号</span>
<span class="nf">bne</span><span class="w">  </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="no">a2</span><span class="p">,</span><span class="w"> </span><span class="no">otherInt</span><span class="w">  </span><span class="c1"># 若非 timer 中断则跳转</span>
<span class="c1"># 处理 timer 中断，递增 mtimecmp</span>
<span class="nf">la</span><span class="w">   </span><span class="no">a1</span><span class="p">,</span><span class="w"> </span><span class="no">mtimecmp</span><span class="w">      </span><span class="c1"># mtimecmp 是 memory map csr，读出该地址的到 a1</span>
<span class="nf">lw</span><span class="w">   </span><span class="no">a2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span><span class="w">         </span><span class="c1"># 读出 mtimecmp 的低 32bit 到 a2</span>
<span class="nf">lw</span><span class="w">   </span><span class="no">a3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span><span class="w">         </span><span class="c1"># 读出 mtimecmp 的高 32bit 到 a3</span>
<span class="nf">addi</span><span class="w"> </span><span class="no">a4</span><span class="p">,</span><span class="w"> </span><span class="no">a2</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="w">      </span><span class="c1"># 给 mtimecmp 的低 32bit 加上 1000，求和结果保存到 a4</span>
<span class="nf">sltu</span><span class="w"> </span><span class="no">a2</span><span class="p">,</span><span class="w"> </span><span class="no">a4</span><span class="p">,</span><span class="w"> </span><span class="no">a2</span><span class="w">        </span><span class="c1"># 计算进位，如果和 a4 比加数 a2 小，说明有进位，进位保存在 a2 中</span>
<span class="nf">add</span><span class="w">  </span><span class="no">a3</span><span class="p">,</span><span class="w"> </span><span class="no">a3</span><span class="p">,</span><span class="w"> </span><span class="no">a2</span><span class="w">        </span><span class="c1"># 把进位加到 mtimecmp 的高位 a3 上</span>
<span class="nf">sw</span><span class="w">   </span><span class="no">a3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span><span class="w">         </span><span class="c1"># 保存递增后的 mtimecmp 高位</span>
<span class="nf">sw</span><span class="w">   </span><span class="no">a4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="no">a1</span><span class="p">)</span><span class="w">         </span><span class="c1"># 保存递增后的 mtimecmp 低位</span>

<span class="c1"># step4. 恢复 XRF, a1, a2, a3, a4</span>
<span class="nf">lw</span><span class="w"> </span><span class="no">a4</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
<span class="nf">lw</span><span class="w"> </span><span class="no">a3</span><span class="p">,</span><span class="w">  </span><span class="mi">8</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
<span class="nf">lw</span><span class="w"> </span><span class="no">a2</span><span class="p">,</span><span class="w">  </span><span class="mi">4</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>
<span class="nf">lw</span><span class="w"> </span><span class="no">a1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">(</span><span class="no">a0</span><span class="p">)</span>

<span class="c1"># step5. 恢复 a0 和 mscratch 旧值</span>
<span class="nf">csrrw</span><span class="w"> </span><span class="no">a0</span><span class="p">,</span><span class="w"> </span><span class="no">mscratch</span><span class="p">,</span><span class="w"> </span><span class="no">a0</span>

<span class="c1"># step6. 从 ISR 返回</span>
<span class="nf">mret</span>
</code></pre></div></td></tr></table></div>

<h3 id="_20">嵌入式系统中的用户模式和进程隔离</h3>
<p>并非所有代码都是可信任的：底层 OS 代码可行度较高，可以访问所有硬件资源；应用程序代码可行度较低，需要进行限制：</p>
<ul>
<li>限制 U 模式代码可执行的指令（M 模式指令）和访问的资源（M 模式 CSR）</li>
<li>限制 U 模式代码只能访问各自的内存，即 PMP（指定哪些内存可以让 U 模式访问）</li>
</ul>
<h3 id="_21">现代操作系统的监管模式</h3>
<p>TODO</p>
<h3 id="_22">页式虚拟内存</h3>
<p>TODO</p>
<h3 id="_23">结语</h3>
<blockquote>
<p>一项又一项的研究表明，最优秀的设计师能更轻松地设计出更快、更小、更简洁、更明了的结构。伟大和平凡之间相差近一个数量级。</p>
<p>—— 弗雷德 · 布鲁克斯（Fred Brooks, Jr.）, 1986.&gt; 一款指令集的 7 个评价标准：</p>
<ul>
<li>成本</li>
<li>简洁</li>
<li>性能</li>
<li>架构和实现分离</li>
<li>提升空间</li>
<li>代码大小</li>
<li>易于编程 / 编译 / 链接</li>
</ul>
</blockquote>
<p>围绕这 7 个评价指标从全系统角度向读者介绍 RISC-V 的精巧设计和众多的取舍考量。</p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="https://qian-gu.github.io/posts/tools/gnu-make-manual-note.html" title="GNU Make Manual 笔记">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="https://qian-gu.github.io/posts/cs/understanding-and-using-c-pointers-notes.html" title="深入理解 C 指针读书笔记">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-2-privileged.html">RISC-V Spec 阅读笔记 #2 —— Privileged ISA</a></li>
      <li><a href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-1-unprivileged.html">RISC-V Spec 阅读笔记 #1 —— Unprivileged ISA</a></li>
    </ul>
  </div>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-1821536199377100"
         data-ad-slot="4843941849"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

<!-- Gitalk -->
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://qian-gu.github.io/theme/gitalk/md5.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '4b3de26a6e80be727416',
  clientSecret: '993d79339c842fc56d9739ef268f38806dc93f50',
  repo: 'qian-gu.github.io',
  owner: 'qian-gu',
  admin: ['qian-gu'],
  id: md5(location.href),
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- End Gitalk -->
</article>

<footer>
<p>
  &copy; 2025  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://qian-gu.github.io/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="ligtht"
          type="text/javascript">
  </script>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://qian-gu.github.io/theme/img/cc/by-sa.png"
         width="80"
         height="15"/>
  </a>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Qian's Blog ",
  "url" : "https://qian-gu.github.io",
  "image": "https://qian-gu.github.io/images/logo.png",
  "description": "Qian's Thoughts and Writings"
}
</script><a href="https://github.com/qian-gu/qian-gu.github.io" target="_blank" class="github-corner" aria-label="View source on Github">
    <svg width="80"
         height="80"
         viewBox="0 0 250 250"
         style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
         aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor"
              style="transform-origin: 130px 106px;"
              class="octo-arm">
        </path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor"
              class="octo-body">
        </path>
    </svg>
</a>
  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://qian-gu.github.io/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://qian-gu.github.io/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://qian-gu.github.io/theme/stork/stork.js"></script>

</body>
</html>