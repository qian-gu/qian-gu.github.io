
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark)"
    href="https://qian-gu.github.io/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://qian-gu.github.io/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="/static/custom.css">

  <link rel="shortcut icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">
  <link rel="icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Microsoft EDGE -->
  <meta name="msapplication-TileColor" content="#333333">

  <link href="https://qian-gu.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Qian's Blog Atom">


<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48826831-1', 'auto');
  ga('send', 'pageview');
</script>






 

<meta name="author" content="Qian Gu" />
<meta name="description" content="总结 FPGA 处理数字信号的基础知识 (2)" />
<meta name="keywords" content="digital processing">


  <meta property="og:site_name" content="Qian's Blog"/>
  <meta property="og:title" content="FPGA 数字处理基础 (2)"/>
  <meta property="og:description" content="总结 FPGA 处理数字信号的基础知识 (2)"/>
  <meta property="og:locale" content="en"/>
  <meta property="og:url" content="https://qian-gu.github.io/posts/ic/fpga-digital-processing-basic-2.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2014-07-07 23:28:00+08:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://qian-gu.github.io/author/qian-gu.html">
  <meta property="article:section" content="IC"/>
  <meta property="article:tag" content="digital processing"/>
  <meta property="og:image" content="https://qian-gu.github.io/images/logo.png">

  <title>Qian's Blog &ndash; FPGA 数字处理基础 (2)</title>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-1821536199377100",
      enable_page_level_ads: true
    });
  </script>

</head>
<body >

<aside>
  <div>
    <a href="https://qian-gu.github.io/">
      <img src="https://qian-gu.github.io/images/logo.png" alt="Qian Gu" title="Qian Gu">
    </a>

    <h1>
      <a href="https://qian-gu.github.io/">Qian Gu</a>
    </h1>

    <p>Read >> Think >> Write</p>

    <div class="stork">
      <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick="loadStorkIndex()"/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>

    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://qian-gu.github.io/pages/about-me.html#about-me">
                About Me
              </a>
            </li>

      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-envelope"
rel="me"           href="mailto:guqian110@163.com"
           target="_blank">
          <i class="fa-solid fa-envelope"></i>
        </a>
      </li>
      <li>
        <a class="sc-github"
           href="https://github.com/qian-gu"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-twitter"
           href="https://twitter.com/qian_gu"
           target="_blank">
          <i class="fa-brands fa-twitter"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/feeds/all.atom.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://qian-gu.github.io/">Home</a>

  <a href="/authors.html">Authors</a>
  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://qian-gu.github.io/feeds/all.atom.xml">Atom</a>

</nav>

<article class="single">
  <header>
      
    <h1 id="fpga-digital-processing-basic-2">FPGA 数字处理基础 (2)</h1>
    <p>
      Posted on 2014-07-07 23:28 in <a href="https://qian-gu.github.io/category/ic.html">IC</a>

    </p>
    <div class="tag-cloud">
      <p>
        <a href="https://qian-gu.github.io/tag/digital-processing.html">digital processing</a>
      </p>
    </div>
  </header>



  <div>
    <p>讨论 FPGA 中无符号数 unsigned 和有符号数 signed 的问题。</p>
<h2 id="basic-knowledge">Basic Knowledge</h2>
<hr>
<p><strong>整数的分类：</strong> 无符号数 <code>unsigned</code> 和 有符号数 <code>signed</code>。</p>
<p><strong>数制：</strong> 10、2、8、16 进制</p>
<p><strong>机器数：</strong> 机器数的意思是数字在机器中的表示方式。主要有 3 种</p>
<p><code>原码 sign-magnitude</code>、<code>反码 one's complement</code>、<code>补码 two's complement</code></p>
<p>以前写过的一篇总结： <a href="http://guqian110.github.io/pages/2014/03/19/signed-number-representations.html">原码、反码、补码</a></p>
<p><strong>计算机系统：</strong> 采用二进制、补码系统。</p>
<p><br></p>
<p><em>FPGA 中是如何表示数字的呢？</em></p>
<p>以前写过一篇总结，<a href="http://guqian110.github.io/pages/2014/05/14/fpga-digital-processing-basic-1.html">FPGA 数字处理基础 (1)</a></p>
<p>本文算是上面文章的续吧。</p>
<p><br></p>
<h2 id="unsigned-in-verilog">(un)signed in Verilog</h2>
<hr>
<h3 id="integer">Integer</h3>
<p>标准格式：</p>
<p><code>&lt;null|+|-&gt;&lt;size&gt;&lt;sign:s|S&gt;&lt;base:d|D|h|H|o|O|b|B&gt;&lt;0~9|0～f|0~7|0~1|x|z&gt;</code></p>
<p>其中 size 和 base 可选。</p>
<p>所以就有两个格式：</p>
<ol>
<li>
<p>一串 0～9 组成的数字，前面可能有 +/- 符号，默认解释为有符号数</p>
</li>
<li>
<p><code>&lt;size&gt;'&lt;s&gt;&lt;base&gt;&lt;value&gt;</code>，默认是无符号数，除非明确使用 <code>s</code> 字段</p>
<ul>
<li>
<p>第一个参数 size 表示用多少个 bit 来存储这个整数，这个参数的取值应该是一个非 0 的无符号十进制数。若没有给出，默认最小是 32 bit</p>
</li>
<li>
<p>第二个参数 s 表示这个数是有符号数，这个字段只影响编译器如何解释这个数。若没有这个字段，则将这个数解释为无符号数</p>
</li>
<li>
<p>第三个参数 base 表示使用什么进制来表示这个数，若没有给出，默认是十进制</p>
</li>
<li>
<p>第四个参数 value 表示这个数的大小，取值应该是一个无符号的符合 base 的数</p>
</li>
</ul>
</li>
</ol>
<p><strong>在 FPGA 也采用补码系统</strong>，即在综合时，综合工具会将有符号数翻译为补码，在硬件中存储起来。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="mh">4</span><span class="mi">&#39;d5</span><span class="w">   </span><span class="c1">// 占用 4 bit，存储的值为无符号数  5 的原码 0101，综合工具将其视为无符号数 5</span>
<span class="mh">4</span><span class="p">&#39;</span><span class="n">sd5</span><span class="w">  </span><span class="c1">// 占用 4 bit，存储的值为无符号数  5 的原码 0101，综合工具将其视为有符号数 +5</span>
<span class="o">-</span><span class="mh">4</span><span class="mi">&#39;d5</span><span class="w">  </span><span class="c1">// 占用 4 bit，存储的值为有符号数 -5 的补码 1011，综合工具将其视为无符号数 11</span>
<span class="o">-</span><span class="mh">4</span><span class="p">&#39;</span><span class="n">sd5</span><span class="w"> </span><span class="c1">// 占用 4 bit，存储的值为 1011</span>
</code></pre></div></td></tr></table></div>

<h3 id="register">Register</h3>
<p>Verilog 中数据的基本类型： <code>wire</code>、<code>reg</code>、<code>integer</code></p>
<p>在 Verilog-1995 中，规定所有的 wire、reg 都是 unsigned 类型，只有 integer 是 signed 类型。但是 integer 的宽度是固定的 ( 与宿主机的字是一样的，最小为 32 位 )，这样子，造成了很大的不方便和浪费。</p>
<p>在 Verilog-2001 中，添加了 wire、reg 也可以是 signed 类型了。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">reg</span><span class="w">             </span><span class="p">[</span><span class="mh">8</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">a</span><span class="p">;</span><span class="w">  </span><span class="c1">// unsigned</span>
<span class="kt">reg</span><span class="w">     </span><span class="k">signed</span><span class="w">  </span><span class="p">[</span><span class="mh">8</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">b</span><span class="p">;</span><span class="w">  </span><span class="c1">// signed</span>
</code></pre></div></td></tr></table></div>

<p><br></p>
<p><strong>Problem</strong></p>
<blockquote>
<p>数据可以是 signed 和 unsigned，寄存器也可以是 signed 和 unsigned，那么综合时，是以哪个为准呢？</p>
</blockquote>
<p>这个问题一开始自己没有搞清楚，迷惑了一下午，后来写了几个小测试程序，最后发现这个结论：</p>
<p><strong>Conclusion</strong> </p>
<blockquote>
<ol>
<li>
<p><em>以变量类型为准</em></p>
<p>即 reg/wire 为哪种，那么综合时就以这个为标准进行综合。比如当 reg 为 unsigned 类型，当我们给它赋值为 signed 类型的数据 <code>-5</code>(<code>-4’d5</code>) 时，综合出来的结果为 reg 存储的是 <code>-5</code> 的补码 <code>1011</code>, 但是解释为 unsigned 类型的 <code>+11</code>。这时候就结果和我们的预期是不一样的，出现了误差，一定要注意！另一种情况类似。</p>
</li>
<li>
<p>如果参与运算的变量混合有 signed 和 unsigned 类型，那么会将 signed 转换为 unsigned 类型。( 应该避免这种情况 )</p>
</li>
</ol>
</blockquote>
<p><br></p>
<p>========================================= 以下为详细的分类讨论 ==================================</p>
<p>编写一个简单的测试程序，查看综合结果和仿真波形，就可以知道综合时的策略。</p>
<p><strong>module: <a href="http://guqian110.github.io/files/test-signed.v">test-signed.v</a></strong></p>
<p><strong>testbench: <a href="http://guqian110.github.io/files/tb-test-signed.v">tb-test-signed.v</a></strong></p>
<h4 id="1-unsigned-reg-unsigned-value">1. unsigned reg &amp; unsigned value</h4>
<p>定义 reg 为 unsigned 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">reg</span><span class="w">     </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">i</span><span class="p">;</span><span class="w">      </span><span class="c1">// unsigned</span>
<span class="kt">reg</span><span class="w">     </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">flag</span><span class="p">;</span><span class="w">   </span><span class="c1">// unsigned</span>
</code></pre></div></td></tr></table></div>

<p>赋值为 unsigned 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">flag</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8</span><span class="mi">&#39;d10</span><span class="p">;</span><span class="w">  </span><span class="c1">// unsigned</span>
</code></pre></div></td></tr></table></div>

<p>那么可以从 RTL Schematic 中看到，综合出来的比较器是 unsigned 类型。</p>
<h4 id="2-unsigned-reg-signed-value">2. unsigned reg &amp; signed value</h4>
<p>定义 reg 为 unsigned 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">reg</span><span class="w">     </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">i</span><span class="p">;</span><span class="w">      </span><span class="c1">// unsigned</span>
<span class="kt">reg</span><span class="w">     </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">flag</span><span class="p">;</span><span class="w">   </span><span class="c1">// unsigned</span>
</code></pre></div></td></tr></table></div>

<p>赋值为 signed 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">flag</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">-</span><span class="mh">8</span><span class="p">&#39;</span><span class="n">sd10</span><span class="p">;</span><span class="w">    </span><span class="c1">// signed</span>
</code></pre></div></td></tr></table></div>

<p>那么综合出来的比较器是 unsigned 类型。</p>
<h4 id="3-signed-reg-signed-value">3. signed reg &amp; signed value</h4>
<p>定义 reg 为 signed 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">reg</span><span class="w">     </span><span class="k">signed</span><span class="w">  </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">i</span><span class="p">;</span><span class="w">      </span><span class="c1">// signed</span>
<span class="kt">reg</span><span class="w">     </span><span class="k">signed</span><span class="w">  </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">flag</span><span class="p">;</span><span class="w">   </span><span class="c1">// signed</span>
</code></pre></div></td></tr></table></div>

<p>赋值为 signed 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">flag</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">-</span><span class="mh">8</span><span class="p">&#39;</span><span class="n">sd10</span><span class="p">;</span><span class="w">    </span><span class="c1">// signed</span>
</code></pre></div></td></tr></table></div>

<p>那么综合出来的比较器是 signed 类型。</p>
<h4 id="4-signed-reg-unsigned-value">4. signed reg &amp; unsigned value</h4>
<p>定义 reg 为 signed 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">reg</span><span class="w">     </span><span class="k">signed</span><span class="w">  </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">i</span><span class="p">;</span><span class="w">      </span><span class="c1">// signed</span>
<span class="kt">reg</span><span class="w">     </span><span class="k">signed</span><span class="w">  </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">flag</span><span class="p">;</span><span class="w">   </span><span class="c1">// unsigned</span>
</code></pre></div></td></tr></table></div>

<p>赋值为 unsigned 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">flag</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">8</span><span class="mi">&#39;d10</span><span class="p">;</span><span class="w">  </span><span class="c1">// unsigned</span>
</code></pre></div></td></tr></table></div>

<p>那么综合出来的比较器是 signed 类型。</p>
<h4 id="5-signed-reg-unsigned-reg">5. signed reg &amp; unsigned reg</h4>
<p>如果参与运算的两个变量一个是 signed，另一个是 unsigned。（注意这种现象应该避免，一般我们是不会将两种不同类型的数据混在一起进行计算的）</p>
<p>定义 i 为 unsigned 类型，flag 为 signed 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">reg</span><span class="w">             </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">i</span><span class="p">;</span><span class="w">      </span><span class="c1">// unsigned</span>
<span class="kt">reg</span><span class="w">     </span><span class="k">signed</span><span class="w">  </span><span class="p">[</span><span class="n">SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">flag</span><span class="p">;</span><span class="w">   </span><span class="c1">// signed</span>
</code></pre></div></td></tr></table></div>

<p>给 flag 赋值为 signed 的 -5</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">flag</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">-</span><span class="mh">4</span><span class="mi">&#39;d5</span><span class="p">;</span><span class="w">      </span><span class="c1">// sigend</span>
</code></pre></div></td></tr></table></div>

<p>综合出来的比较器为 unsigned 类型。</p>
<p><strong>P.S.</strong> 变量 integer 也是也可综合的。在上例中，如果将 flag 的类型改为 integer 也是可综合的，但是，因为只用到了低 8 位，所以在综合时会提示高 24 位是未连接 unconnected，但是因为 integer 是一个整体，所以即使未连接也不能优化掉，这就是在 Verilog-1995 中 integer 不够灵活的体现，好在 Verilog-2001 中已经添加了支持 reg/wire 为 signed 的类型，而且综合工具 (XST) 也是支持的。</p>
<p>======================================= 分割线结束 ==========================================</p>
<p>以前只知道硬件上最基本的一些运算单元，比如加法器 (adder)、减法器 (subtractor)、比较器 (comparator) 等，完成的功能是固定的，电路是不会检查输入数据的类型的。涉及到 signed 和 unsigned 类型，就出现一个问题：对于基本运算单元 ( 比如加法器 )，运算单元并不知道输入的数据是哪种数据，对于 unsigned 和 signed 类型，必然出现适合一种时不适合另外一种的问题。</p>
<p>所以可以推断出 <strong>对于不同的数据类型，同样是个加法器，底层的硬件电路是不一样的</strong>。</p>
<p>如果我在程序中定义了 signed 和 unsigned 类型的数据，那么综合工具是否足够智能，能够根据数据的类型综合出正确适合的电路？</p>
<p>答案是肯定的，即<strong>综合器足够智能</strong>。</p>
<p>上面的程序证明了这一点，从 RTL 图中可以看到综合出的比较器是 signed 还是 unsigned 类型，仿真波形也可以看到，最终下载到板子上测试也符合预期。这些都证明 综合器足够智能。后来看到 <a href="http://www.xilinx.com/support/documentation/sw-manuals/xilinx14-7/xst.pdf">UG627(v14.5): XST User Guide</a>，才发现里面已经非常清楚地写着</p>
<p>Chapter 3: Signed and Unsigned Support in XST</p>
<blockquote>
<p>When using Verilog or VHDL in XST, some macros, such as adders or counters, can be
implemented for signed and unsigned values.
To enable support for signed and unsigned values in Verilog, enable Verilog-2001
as follows:
+ ISE® Design Suite
  Select Verilog 2001 as instructed in the Synthesis Options topic of ISE Design Suite
Help
+ XST Command Line
  Set -verilog2001 to yes.</p>
</blockquote>
<p>花费了大量时间上网找资料，在论坛里问别人无果，最后自己动手写程序测试，最后才发现原来官方资料里面早就写的清清楚楚 =.=</p>
<p><br></p>
<h2 id="conclusion">Conclusion</h2>
<hr>
<p>说了这么多，总结下来就是下面这几句话：</p>
<p><strong>经验：</strong></p>
<ol>
<li>
<p>遇到问题，先不要急着上网求助，上网求助这个方法虽然简单，但是是最不好的，一方面别人的话不一定可靠，另一方面，放弃思考直接上网求助对学习无益。</p>
</li>
<li>
<p>找资料的技巧很重要。虽然我大概能够猜测到 Xilinx 官方的文档中肯定有说明，但是就是懒得去下载文档，再去找。认为网上肯定有人也有相同的困惑，所以直接 Google。结果找到一堆没有帮助的网页，浪费了时间，最后还是要看文档。</p>
</li>
<li>
<p>实践是检验真理的唯一标准，到底行不行，写测试程序，在板子上跑跑，验证一下是最有力的证明。</p>
</li>
</ol>
<p><strong>知识：</strong></p>
<ol>
<li>
<p>Verilog-2001 已经支持 signed 类型的 wire 和 reg，所以我们代码中如果涉及到有符号数，那么像 C 语言一样直接定义、赋值、使用即可，综合工具会综合出正确的有符号数的运算电路。不必再像以前一样手动进行补码转换，自己来处理有符号数的补码计算的细节。</p>
</li>
<li>
<p>综合时的原则是按照寄存器的类型进行综合 ( 即上面的分类讨论的结论 )。</p>
</li>
<li>
<p>仔细对比 signed 和 unsigned 类型的综合结果，可以发现 Technology Schematic 是一样的，之所以和 “ 理论上硬件电路是应该不一样 ” 矛盾，我认为原因在于 FPGA 的实现是基于查找表的。以上面的例子来说明，这个比较器的功能最终是在一个 LUT6 的查找表上实现的，所以，ASIC 上硬件电路的不同映射到 FPGA 中就是 LUT 的内容不同。</p>
</li>
</ol>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="https://qian-gu.github.io/posts/tools/extend-verilog-snippet-in-st2.html" title="扩展 ST2 Verilog 插件的 snippet">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="https://qian-gu.github.io/posts/ic/parameterization-modeling-in-veriog.html" title="Verilog 中的参数化建模">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="https://qian-gu.github.io/posts/ic/fpga-digital-processing-basic-1.html">FPGA 数字处理基础 (1)</a></li>
    </ul>
  </div>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-1821536199377100"
         data-ad-slot="4843941849"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'ChienGu';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>
    Please enable JavaScript to view comments.
</noscript>
<!-- End Disqus -->
<div id="container"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: '页面 ID', // 可选。默认为 location.href
  owner: '你的 GitHub ID',
  repo: '存储评论的 repo',
  oauth: {
    client_id: '你的 client ID',
    client_secret: '你的 client secret',
  },
})
gitment.render('container')
</script>
</article>

<footer>
<p>
  &copy; 2023  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://qian-gu.github.io/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="ligtht"
          type="text/javascript">
  </script>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Qian's Blog ",
  "url" : "https://qian-gu.github.io",
  "image": "https://qian-gu.github.io/images/logo.png",
  "description": "Qian's Thoughts and Writings"
}
</script><a href="https://github.com/qian-gu/qian-gu.github.io" target="_blank" class="github-corner" aria-label="View source on Github">
    <svg width="80"
         height="80"
         viewBox="0 0 250 250"
         style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
         aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor"
              style="transform-origin: 130px 106px;"
              class="octo-arm">
        </path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor"
              class="octo-body">
        </path>
    </svg>
</a>
  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://qian-gu.github.io/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://qian-gu.github.io/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://qian-gu.github.io/theme/stork/stork.js"></script>

</body>
</html>