
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark)"
    href="https://qian-gu.github.io/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://qian-gu.github.io/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="/static/custom.css">

  <link rel="shortcut icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">
  <link rel="icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Microsoft EDGE -->
  <meta name="msapplication-TileColor" content="#333333">

  <link href="https://qian-gu.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Qian's Blog Atom">


<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48826831-1', 'auto');
  ga('send', 'pageview');
</script>






 

<meta name="author" content="Qian Gu" />
<meta name="description" content="读书笔记，总结 SV 新语法" />
<meta name="keywords" content="SystemVerilog">


  <meta property="og:site_name" content="Qian's Blog"/>
  <meta property="og:title" content="《SystemVerilog for Design》笔记"/>
  <meta property="og:description" content="读书笔记，总结 SV 新语法"/>
  <meta property="og:locale" content="en"/>
  <meta property="og:url" content="https://qian-gu.github.io/posts/ic/systemverilog-for-design-notes.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2021-04-04 21:01:00+08:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://qian-gu.github.io/author/qian-gu.html">
  <meta property="article:section" content="IC"/>
  <meta property="article:tag" content="SystemVerilog"/>
  <meta property="og:image" content="https://qian-gu.github.io/images/logo.png">

  <title>Qian's Blog &ndash; 《SystemVerilog for Design》笔记</title>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-1821536199377100",
      enable_page_level_ads: true
    });
  </script>

</head>
<body >

<aside>
  <div>
    <a href="https://qian-gu.github.io/">
      <img src="https://qian-gu.github.io/images/logo.png" alt="Qian Gu" title="Qian Gu">
    </a>

    <h1>
      <a href="https://qian-gu.github.io/">Qian Gu</a>
    </h1>

    <p>Read >> Think >> Write</p>

    <div class="stork">
      <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick="loadStorkIndex()"/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>

    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://qian-gu.github.io/pages/about-me.html#about-me">
                About Me
              </a>
            </li>

      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-envelope"
rel="me"           href="mailto:guqian110@163.com"
           target="_blank">
          <i class="fa-solid fa-envelope"></i>
        </a>
      </li>
      <li>
        <a class="sc-github"
           href="https://github.com/qian-gu"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-twitter"
           href="https://twitter.com/qian_gu"
           target="_blank">
          <i class="fa-brands fa-twitter"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/feeds/all.atom.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://qian-gu.github.io/">Home</a>

  <a href="/authors.html">Authors</a>
  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://qian-gu.github.io/feeds/all.atom.xml">Atom</a>

</nav>

<article class="single">
  <header>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.1.0/css/all.css" rel="stylesheet">
      
    <h1 id="systemverilog-for-design-notes">《SystemVerilog for Design》笔记</h1>
    <p>
      Posted on 2021-04-04 21:01 in <a href="https://qian-gu.github.io/category/ic.html">IC</a>

    </p>
    <div class="tag-cloud">
      <p>
        <a href="https://qian-gu.github.io/tag/systemverilog.html">SystemVerilog</a>
      </p>
    </div>
  </header>



  <div>
    <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#chapter-1-introduction-to-systemverilog">Chapter 1 Introduction to SystemVerilog</a></li>
<li><a href="#chapter-2-systemverilog-declration-spaces">Chapter 2 SystemVerilog Declration Spaces</a><ul>
<li><a href="#package">package</a></li>
<li><a href="#unit">$unit</a></li>
<li><a href="#summary">summary</a></li>
</ul>
</li>
<li><a href="#chapter-3-systemverilog-literal-values-and-built-in-data-types">Chapter 3 SystemVerilog Literal Values and Built-in Data Types</a><ul>
<li><a href="#literal-assigments">literal assigments</a></li>
<li><a href="#variable">variable</a></li>
<li><a href="#signed-and-unsigned">signed and unsigned</a></li>
<li><a href="#static-and-automatic-variable">static and automatic variable</a></li>
<li><a href="#type-casting">type casting</a></li>
</ul>
</li>
<li><a href="#chapter-4-systemverilog-user-defined-and-enumerated-types">Chapter 4 SystemVerilog User-Defined and Enumerated Types</a><ul>
<li><a href="#user-defined-types">user-defined types</a></li>
<li><a href="#enumerated-types">enumerated types</a></li>
<li><a href="#summary_1">summary</a></li>
</ul>
</li>
<li><a href="#chapter-5-systemverilog-arrays-structures-and-unions">Chapter 5 Systemverilog Arrays, Structures and Unions</a><ul>
<li><a href="#struct">struct</a></li>
<li><a href="#union">union</a></li>
<li><a href="#array">array</a></li>
<li><a href="#foreach">foreach</a></li>
<li><a href="#array-system-function">array system function</a></li>
<li><a href="#dynamic-arrays-associative-arrays-sparse-arrays-strings">dynamic arrays, associative arrays, sparse arrays, strings</a></li>
<li><a href="#summary_2">summary</a></li>
</ul>
</li>
<li><a href="#chapter-6-systemverilog-procedural-blocks-tasks-and-functions">Chapter 6 Systemverilog Procedural Blocks, Tasks and Functions</a><ul>
<li><a href="#awalys_comb">awalys_comb</a></li>
<li><a href="#always_latch">always_latch</a></li>
<li><a href="#always_ff">always_ff</a></li>
<li><a href="#taskfunction">task/function</a></li>
<li><a href="#summary_3">summary</a></li>
</ul>
</li>
<li><a href="#chapter-7-systemverilog-procedural-statements">Chapter 7 Systemverilog Procedural Statements</a><ul>
<li><a href="#new-operators">new operators</a></li>
<li><a href="#for-loops">for loops</a></li>
<li><a href="#dowhile-loop">do...while loop</a></li>
<li><a href="#foreach_1">foreach</a></li>
<li><a href="#jump-statements">jump statements</a></li>
<li><a href="#block-names">block names</a></li>
<li><a href="#statement-label">statement label</a></li>
<li><a href="#case-statement">case statement</a></li>
<li><a href="#ifelse">if...else</a></li>
<li><a href="#summary_4">summary</a></li>
</ul>
</li>
<li><a href="#chapter-8-modeling-finite-state-machine-with-systemverilog">Chapter 8 Modeling Finite State Machine with Systemverilog</a></li>
<li><a href="#chapter-9-systemverilog-design-hierarchy">Chapter 9 Systemverilog Design Hierarchy</a><ul>
<li><a href="#module-prototypes">module prototypes</a></li>
<li><a href="#named-ending-statements">named ending statements</a></li>
<li><a href="#nested-module-declarations">nested module declarations</a></li>
<li><a href="#simplified-netlists-of-module-instances">simplified netlists of module instances</a></li>
<li><a href="#net-aliasing">net aliasing</a></li>
<li><a href="#pass-values-through-module-ports">pass values through module ports</a></li>
<li><a href="#reference-ports">reference ports</a></li>
<li><a href="#enhanced-port-declarations">enhanced port declarations</a></li>
<li><a href="#parameterized-types">parameterized types</a></li>
<li><a href="#summary_5">summary</a></li>
</ul>
</li>
<li><a href="#chapter-10-systemverilog-interfacees">Chapter 10 Systemverilog Interfacees</a><ul>
<li><a href="#concepts">concepts</a></li>
<li><a href="#interface-declration">interface declration</a></li>
<li><a href="#using-interface-as-module-ports">using interface as module ports</a></li>
<li><a href="#instantiating-and-connecting-interface">instantiating and connecting interface</a></li>
<li><a href="#referencing-signals-within-an-interface">referencing signals within an interface</a></li>
<li><a href="#interface-modports">interface modports</a></li>
<li><a href="#using-taskfunction-in-interface">using task/function in interface</a></li>
<li><a href="#using-procedural-blocks-in-interface">using procedural blocks in interface</a></li>
<li><a href="#reconfigurable-interface">reconfigurable interface</a></li>
<li><a href="#summary_6">summary</a></li>
</ul>
</li>
<li><a href="#chapter-11-a-complete-design-modeled-with-systemverilog">Chapter 11 A Complete Design Modeled with SystemVerilog</a></li>
<li><a href="#chapter-12-behavioral-and-transaction-level-modeling">Chapter 12 Behavioral and Transaction Level Modeling</a></li>
<li><a href="#_1">附录</a></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol>
<li>本书假定读者已经掌握了 Verilog，主要内容是从对比角度介绍 SV 如何让设计者在更高层次对硬件进行建模，如何更高效地进行开发</li>
<li>笔记只记录了可综合的语法特性，略去了不可综合的部分</li>
</ol>
</div>
<h2 id="chapter-1-introduction-to-systemverilog">Chapter 1 Introduction to SystemVerilog</h2>
<p>Verilog 的标准：</p>
<ul>
<li>Verilog-1995 (<code>IEEE Std 1364-1995</code>)</li>
<li>Verilog-2001 (<code>IEEE Std 1364-2001</code>)</li>
<li>Verilog-2005 (<code>IEEE Std 1364-2005</code>)</li>
</ul>
<p>SV 的标准：</p>
<ul>
<li>IEEE Std 1800-2005</li>
<li>IEEE Std 1800-2009（合并 IEEE 1364-2005 和 IEEE 1800-2005）</li>
<li>IEEE Std 1800-2012</li>
</ul>
<h2 id="chapter-2-systemverilog-declration-spaces">Chapter 2 SystemVerilog Declration Spaces</h2>
<p>Verilog 中的 <code>wire</code>, <code>reg</code>, <code>task</code>, <code>function</code> 只能声明在 <code>module</code> 内部，这样做的缺点就是：同一个 taks、function 要在多个 module 中进行重复声明，不仅增加工作量，还可能出现多个相同功能的副本不对齐的错误。</p>
<h3 id="package">package</h3>
<p>SV 新增的 <code>package</code> 可以解决上述问题，在其内部可以声明的有，</p>
<ul>
<li><code>parameter</code>, <code>localparam</code></li>
<li><code>const</code></li>
<li><code>typedef</code></li>
<li><code>taks</code>（必须是 <code>automatic</code>）</li>
<li><code>function</code>（必须是 <code>automatic</code>）</li>
<li><code>import</code></li>
</ul>
<p>要在其他 module 中引用 package 中的声明，可以有 4 种方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>用 <code>::</code> 直接引用</td>
<td>多次使用时每次都要写完成路径，繁琐</td>
</tr>
<tr>
<td>通过 <code>import &lt;name&gt;</code> 明确导入</td>
<td>如果要导入多个，依然繁琐</td>
</tr>
<tr>
<td>通过 <code>import *</code> 通配符导入</td>
<td>实际上是把 package 加入到搜索路径中，优先级最低，端口上依然要通过作用域符号引用</td>
</tr>
<tr>
<td>导入到 <code>$unit</code> 中使用</td>
<td>可以去掉端口上的作用域符号，缺点见下文</td>
</tr>
</tbody>
</table>
<p>task 和 function 必须带上 automatic，而且不能包含静态变量，这是因为例化的每个 task/function 必须都有自己独立完整的一套资源，相互之间不能共享。同理，package 中也不能定义变量（logic/wire/reg），它们是不可综合的。</p>
<h3 id="unit">$unit</h3>
<p>SV 定义了一个 compilaton unit scope 的概念（即在 module、package 之外的区域，类似于 C 语言中的全局变量），可以存放一些独立于 package、module，interface 的声明：</p>
<ul>
<li>variable</li>
<li>net</li>
<li>constant</li>
<li>typedef, enum, class</li>
<li>task, function</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>$unit 不是全局的，只对那些与其同时编译的源文件可见。每次编译的时候会产生一个专属于这次编译的特定的 compilation unit scope，如果几个文件分开编译，就可能产生某些信号不可见的情况，这是<strong>非常危险</strong>的！直接在 $unit 中做声明是非常不好的习惯，会产生混乱的代码，维护、复用、debug 都非常困难。</p>
</div>
<p>SV 标识符的搜索策略： 本地声明 &gt; 通配符导入的声明 &gt; $unit 中的声明 &gt; hierarchy 中的声明，完全向后兼容 Verilog 的搜索策略。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>所有的标识符和类型定义必须先声明后使用。</p>
</div>
<p>如果一个标识符没有定义就使用，那么 Verilog 会自动隐式地将其声明为 net 类型（一般来说就是 <code>wire</code>），而且编译不会报错，所以可能会导致很微妙的错误：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">m1</span><span class="p">();</span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"> </span><span class="c1">// a is a local net</span>
<span class="n">endmoule</span>

<span class="kt">reg</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span>

<span class="k">module</span><span class="w"> </span><span class="n">m2</span><span class="p">()</span><span class="o">:</span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">;</span><span class="w"> </span><span class="c1">// sig is previous $unit variable</span>
<span class="n">endmoule</span>
</code></pre></div></td></tr></table></div>

<p>总之，把 package 导入到 $unit 中会遇到很多问题：</p>
<ol>
<li>对文件编译顺序有要求</li>
<li>多个文件分多次编译和同时一次性编译的效果不同</li>
<li>可以通过条件编译的方式解决，但仍然需要注意很多细节</li>
</ol>
<h3 id="summary">summary</h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li>不要在 $unit 中做任何声明，所有的声明都应该放在有名字的 package 中</li>
<li>在必要时可以把 package 导入到 $unit 中（比如某些 module/interface 中包含了定义在 package 中的自定义类型）</li>
<li><strong>不推荐使用 $unit，应该用 package 来规避相应风险。</strong></li>
</ul>
</div>
<h2 id="chapter-3-systemverilog-literal-values-and-built-in-data-types">Chapter 3 SystemVerilog Literal Values and Built-in Data Types</h2>
<h3 id="literal-assigments">literal assigments</h3>
<p>Verilog 中赋值全 1 的方法是不可扩展的（line 8），只能通过一些小技巧来实现（line 9～10）：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">parameter</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32</span><span class="p">;</span>
<span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="n">SIZE</span><span class="o">-</span><span class="mh">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>

<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">&#39;0</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&#39;</span><span class="n">bz</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&#39;</span><span class="n">bx</span><span class="p">;</span>

<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;hFFFF</span><span class="n">_FFFF</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="mh">0</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mh">1</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>SV 新增语法可以实现可扩展的赋值：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">&#39;0</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">&#39;1</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">&#39;z</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">&#39;x</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<h3 id="variable">variable</h3>
<p>SV 中对一个信号的定义包含两部分：</p>
<ul>
<li><code>type</code>：一共有两种，定义了信号是 net 还是 varibale</li>
<li><code>data type</code>：一共有两种，定义了信号是 2-state 还是 4-state</li>
</ul>
<table>
<thead>
<tr>
<th>type</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>varible</td>
<td><code>var</code>, <code>reg</code></td>
</tr>
<tr>
<td>net</td>
<td><code>wire</code>, <code>wor</code>, <code>wand</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>data type</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>2-state</td>
<td><code>bit</code>, <code>byte</code>, <code>int</code> ...</td>
</tr>
<tr>
<td>4-state</td>
<td><code>logic</code></td>
</tr>
</tbody>
</table>
<p><code>logic</code> 实际上并不是 <code>type</code>，而是 <code>data type</code>，表示信号取值是 4-state。只使用 logic 会自动推断出一个 variable，所以它可以和 <code>var</code> 配合起来，显式地定义。从语法上来说，logic 和 reg 等价，但是它不会像 reg 一样模糊不清。而 net 类型必须是 4-state data type，所以它也可以和 logic 配合显式定义。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">var</span><span class="w">  </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w"> </span><span class="c1">// 32-bit varible</span>
<span class="kt">wire</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="c1">// 32-bit net</span>
</code></pre></div></td></tr></table></div>

<p><code>bit</code> 同 logic 一样，它并不是 <code>type</code>，而是 <code>data type</code>，表示信号取值是 2-state。只使用 bit 会自动推断出一个 variable，所以它也可以和 var 配合起来显式定义。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">var</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>基本上 variable 可以替代所有的 reg 和 wire，它可以出现在 <code>always_comb</code>, <code>always_ff</code>, <code>assign</code> 这些地方。但是有一条限制：</p>
<p><strong>variable 不能被多个源驱动。</strong></p>
<p>这个限制可以帮助我们避免设计中的 bug，因为绝大部分设计中信号都应该只有一个驱动源。</p>
<h3 id="signed-and-unsigned">signed and unsigned</h3>
<p>SV 中的 <code>byte</code>, <code>shortint</code>, <code>int</code>, <code>longint</code> 默认是 signed 类型，可以通过显式的方式声明为 unsigned 类型，需要注意的是声明时 singed/unsigned 关键字只能放在 type 关键字的后面。</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">s_int</span><span class="p">;</span><span class="w">  </span><span class="c1">// signed 32-bit varibale</span>
<span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">u_int</span><span class="p">;</span><span class="w">  </span><span class="c1">// unsigned 32-bit variable</span>
</code></pre></div>

<h3 id="static-and-automatic-variable">static and automatic variable</h3>
<p>Verilog-1995 中所有的 varibale 都是 static 类型的，因为它们都是用来对硬件建模的，所以天然就是 static 类型。到了 Verilog-2001，task 和 function 中的 variable 可以声明成 automatic 类型，意味着这个 variable 的存储空间是由工具自动动态分配的，不再使用时会自动释放空间。automatic 类型主要是用来做验证或者是总线的功能模型。它有个作用是在多次调用的 task 中，使得在前一个 task 没有结束时可以进行下一次调用。</p>
<h3 id="type-casting">type casting</h3>
<p>Verilog 只能在 assign 时进行类型转化，或者是调用系统函数 signed/unsigned。SV 新增的类型转化可以直接在表达式中进行，不需要 assign 语句。SV 的类型转化分为两种：</p>
<ul>
<li>
<p>static(compile time) cast 静态转换是可综合的，发生在编译阶段，而且不会检查转化后取值是否正确，所以一定要小心处理！</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// type casting： &lt;type&gt;&#39;(&lt;expression&gt;)</span>
<span class="mh">7</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kt">int</span><span class="p">&#39;(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">3.0</span><span class="p">)</span><span class="w">  </span><span class="c1">// cas result of (2.0 * 3.0) to int, then add 7</span>

<span class="c1">// size casting： &lt;size&gt;&#39;(&lt;expression&gt;)</span>
<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">**</span><span class="mh">16</span><span class="p">&#39;(</span><span class="mh">2</span><span class="p">)</span><span class="w">      </span><span class="c1">// cast literal value 2 to be 16-bits wide</span>

<span class="c1">// sign casting： &lt;sign&gt;&#39;(&lt;expression&gt;)</span>
<span class="kt">shortint</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="k">signed</span><span class="p">&#39;({</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">});</span><span class="w">  </span><span class="c1">// cast concat result to a signed value</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>dynamic(run time) cast 动态转化（系统函数 $cast），是不可综合的</p>
</li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li>声明只包含 data type（<code>logic</code>, <code>bit</code>），没有 type 时，默认推断出 varibale</li>
<li>关键字 <code>var</code> 是可选的，并不会影响综合和仿真行为，只是增加代码可读性</li>
<li>只有 <code>var</code> 没有 data type 时，默认是 logic 类型</li>
<li>net 类型（<code>wire</code>）取值只能是 <code>logic</code> 类型（声明时 logic 可以选）</li>
<li><code>bit</code>, <code>byte</code>, <code>int</code> 等虽然是 data type，但是只能和 var 搭配，所以也可以看成是 type</li>
<li>可综合的设计，只使用 <code>logic</code></li>
<li>automatic 主要是仿真用，设计时的 automatic 只有定义在 package 中的 task/function 使用</li>
<li>小心使用 static cast</li>
</ul>
</div>
<h2 id="chapter-4-systemverilog-user-defined-and-enumerated-types">Chapter 4 SystemVerilog User-Defined and Enumerated Types</h2>
<p>SV 支持用户自定义数据类型，可以在保持准确性和可综合的前提下，让用户可以写出数量更少、可读性更好的语句在更高层次上对硬件进行建模。</p>
<h3 id="user-defined-types">user-defined types</h3>
<p>typedef 可以根据需要定义在 module、package、$unit 中，一般来说，为了提高代码可读性，自定义类型的名称以 <code>_t</code> 结尾。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">unit</span><span class="p">;</span>
<span class="n">uint</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">nibble</span><span class="p">;</span>
<span class="n">nibble</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">  </span><span class="c1">// a 32-bit vector made from 8 nibble types</span>
</code></pre></div></td></tr></table></div>

<h3 id="enumerated-types">enumerated types</h3>
<p>verilog 中没有枚举类型，设计 FSM 时只能通过 parameter 或者是 define 的形式实现。SV 新增的枚举类型可以实现相同功能，代码可读性更好。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">red</span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">,</span><span class="w"> </span><span class="n">blue</span><span class="p">}</span><span class="w"> </span><span class="n">RGB</span><span class="p">;</span><span class="w">  </span><span class="c1">// variable can have the values of red, green, blue</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">WAIT</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="p">,</span><span class="w"> </span><span class="n">STORE</span><span class="p">}</span><span class="w"> </span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="n">NextState</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>如果 label 很多，而且都很有规律，一个一个写出来非常繁琐，SV 还提供了两种定义 label 序列的方法：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">RESET</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">W</span><span class="p">[</span><span class="mi">6</span><span class="o">:</span><span class="mi">9</span><span class="p">]}</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">  </span><span class="c1">// state = RESET, S0, S1, ...S5, W6, ... W9</span>
</code></pre></div></td></tr></table></div>

<p>显然，在同一个作用域内 label 必须是独一无二的，否则会发生冲突。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// Error</span>
<span class="k">module</span><span class="w"> </span><span class="n">FSM</span><span class="w"> </span><span class="p">(...);</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">GO</span><span class="p">,</span><span class="w"> </span><span class="n">STOP</span><span class="p">}</span><span class="w"> </span><span class="n">fsm1_state</span><span class="p">;</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">WAIT</span><span class="p">,</span><span class="w"> </span><span class="n">GO</span><span class="p">,</span><span class="w"> </span><span class="n">DONE</span><span class="p">}</span><span class="w"> </span><span class="n">fsm2_state</span><span class="p">;</span>
<span class="k">endmodule</span>

<span class="c1">// Ok</span>
<span class="k">module</span><span class="w"> </span><span class="n">FSM</span><span class="w"> </span><span class="p">(...);</span>
<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">fsm1</span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">STOP</span><span class="p">,</span><span class="w"> </span><span class="n">Go</span><span class="p">}</span><span class="w"> </span><span class="n">fsm1_state</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">fsm2</span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">WAIT</span><span class="p">,</span><span class="w"> </span><span class="n">GO</span><span class="p">,</span><span class="w"> </span><span class="n">DONE</span><span class="p">}</span><span class="w"> </span><span class="n">fsm2_state</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<p>enumerate 数据类型默认是 int 类型（32-bit 的 2-state 类型），list 中的第一个 label 的值为 0, 第二个为 1, 依次类推，每个 label 会根据前面的取值自动 +1，所以没必要把每个 label 的取值都显式地写出来。但是不同 label 的取值必须不同。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="n">Z</span><span class="p">}</span><span class="w"> </span><span class="n">list1</span><span class="p">;</span><span class="w">  </span><span class="c1">// B=2, C=3, Y=25, Z=26</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="n">list2</span><span class="p">;</span><span class="w">  </span><span class="c1">// Error</span>
</code></pre></div></td></tr></table></div>

<p>enumerate 的类型也可以用户自定义，如果给 label 赋值则必须位宽匹配，否则会报错；如果 label 的数量超过了类型可以取值的数量也会报错；给 4-state 类型的 label 赋值了 x/z，那么下一个 label 必须显式赋值。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="kt">bit</span><span class="w"> </span><span class="p">{</span><span class="n">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">FALSE</span><span class="p">}</span><span class="w"> </span><span class="n">Boolean</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1-bit wide, 2-state</span>
<span class="k">enum</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">WAITE</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="p">,</span><span class="w"> </span><span class="n">READY</span><span class="p">}</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">  </span><span class="c1">// 2-bit wide, 4-state</span>

<span class="k">enum</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">WAITE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">3&#39;b001</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">3&#39;b010</span><span class="p">,</span><span class="w"> </span><span class="n">READY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">3&#39;b100</span><span class="p">}</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>

<span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">WAITE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">3&#39;b001</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="o">=</span><span class="mb">3&#39;b010</span><span class="p">,</span><span class="w"> </span><span class="n">READY</span><span class="o">=</span><span class="mb">3&#39;b100</span><span class="p">}</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">  </span><span class="c1">// Error!</span>

<span class="k">enum</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="o">=</span><span class="mb">1&#39;b0</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">}</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">  </span><span class="c1">// Error: too many labels for 1-bit size</span>

<span class="k">enum</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">WAIT</span><span class="p">,</span><span class="w"> </span><span class="n">ERR</span><span class="o">=</span><span class="mb">2&#39;bxx</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="p">,</span><span class="w"> </span><span class="n">READY</span><span class="p">}</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">  </span><span class="c1">// Error!</span>
</code></pre></div></td></tr></table></div>

<p>enum 和 typedef 配合使用时，叫做 typed enumerated type，用 import 时只会导入 type name，并不会导入 label，所有 label 必须显式导入，或者通过通配符导入。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="n">chip_types</span><span class="p">;</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">WAIT</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="p">,</span><span class="w"> </span><span class="n">STORE</span><span class="p">}</span><span class="w"> </span><span class="n">states_t</span><span class="p">;</span>
<span class="k">endpackage</span>

<span class="c1">// Error</span>
<span class="k">module</span><span class="w"> </span><span class="n">chip</span><span class="p">(...);</span>
<span class="w">    </span><span class="k">import</span><span class="w"> </span><span class="n">chip_types</span><span class="o">::</span><span class="n">states_t</span><span class="p">;</span><span class="w">  </span><span class="c1">// import the typedef name only</span>

<span class="w">    </span><span class="n">states_t</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p">;</span>
<span class="w">    </span><span class="k">always_ff</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">negedge</span><span class="w"> </span><span class="n">rst_n</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rst_n</span><span class="p">)</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">WAIT</span><span class="p">;</span><span class="w">  </span><span class="c1">// ERROR: WAIT has not been imported!</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">next_state</span><span class="p">;</span>

<span class="c1">// Ok</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">chip_types::WAIT</span><span class="p">;</span><span class="w">  </span><span class="c1">// method 1</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">chip_types::*</span><span class="p">;</span><span class="w">  </span><span class="c1">// method 2</span>
</code></pre></div></td></tr></table></div>

<p>大部分的 Verilog/SV 的 var 都是宽松类型，基本上任何类型的任何值都可以赋值给一个 var，在赋值时会根据规则自动转换成 var 对定的类型。enum 类型则是个 semi-strong type，只能用对应的 label、同类型的另外一个 enum、通过 cast 转换成对应 enum 类型的变量赋值。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">WAIT</span><span class="p">,</span><span class="w"> </span><span class="n">LOAD</span><span class="p">,</span><span class="w"> </span><span class="n">READY</span><span class="p">}</span><span class="w"> </span><span class="n">states_t</span><span class="p">;</span>
<span class="n">states_t</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">next_state</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">;</span>

<span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_state</span><span class="p">;</span><span class="w">  </span><span class="c1">// legal</span>
<span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">     </span><span class="c1">// legal, booth is `int` type</span>
<span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">     </span><span class="c1">// Error: illegal</span>
<span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// Error: illegal</span>
<span class="n">state</span><span class="o">++</span><span class="p">;</span><span class="w">             </span><span class="c1">// Error: illegal</span>
<span class="n">next_state</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"> </span><span class="c1">// Error: illegal</span>
</code></pre></div></td></tr></table></div>

<h3 id="summary_1">summary</h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li>typedef 可以提高代码可读性，命名使用 <code>_t</code> 结尾</li>
<li>enum 是 semi-strong type，可以提高设计的安全，import 时注意 label 的导入</li>
</ul>
</div>
<h2 id="chapter-5-systemverilog-arrays-structures-and-unions">Chapter 5 Systemverilog Arrays, Structures and Unions</h2>
<h3 id="struct">struct</h3>
<p>Verilog 中没有机制表示一组相关信号，只能通过信号前缀的方式来表示，SV 新增了类似 C 中的 structure，structure 内可以是任何类型的 variable，包括用户自定义的类型。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w">           </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">      </span><span class="c1">// 32-bit variable</span>
<span class="w">    </span><span class="n">opcode_t</span><span class="w">      </span><span class="n">opcode</span><span class="p">;</span><span class="w">    </span><span class="c1">// user-defined type</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">address</span><span class="p">;</span><span class="w">   </span><span class="c1">// 24-bit variable</span>
<span class="w">    </span><span class="kt">bit</span><span class="w">           </span><span class="n">error</span><span class="p">;</span><span class="w">     </span><span class="c1">// 1-bit 2-state var</span>
<span class="p">}</span><span class="w"> </span><span class="n">instruction_word</span><span class="p">;</span>

<span class="n">instruction_word</span><span class="p">.</span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">24&#39;hF000001E</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>strcut 可以是一组 var 也可以是一组 net，前面可以加上可选的 <code>var</code> 或 <code>wire</code>, <code>bit</code> 等，因为 net 本身要求是 4-state 类型，所以声明 net struct 时内部的所有成员也都必须是 4-state 的类型。虽然 struct 作为整体是可以声明为 net，但是 net 类型本身并不能作为 struct 内部的成员。可以用 <code>interface</code> 来实现同样的效果。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">var</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">opcode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">address</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span><span class="n">instruction_word_var</span><span class="p">;</span>

<span class="kt">wire</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">opcode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">address</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span><span class="n">instruction_word_net</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>struct 可以和 typedef 配合使用，没有 typedef 的 struct 叫做匿名 struct。struct 可以声明在 module 或 interface 内部使用，也可以定义在 package 中或 $unit 中供多个 module 使用。一般来说 struct 都是和 typedef 一起定义在 package 中，因为大多数情况下我们定一个 struct 的目的是为了在多个地方复用，比如在模块端口之间传递等。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">            </span><span class="c1">// structure definition</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">opcode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">address</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span><span class="n">instruction_word_t</span><span class="p">;</span>

<span class="n">instruction_word_t</span><span class="w"> </span><span class="n">IW</span><span class="p">;</span><span class="w">  </span><span class="c1">// structure allocation</span>
</code></pre></div></td></tr></table></div>

<p>struct 和 array 很类似，它们的不同之处和 C 语言中的类似：</p>
<ul>
<li>array 是一组同类型、同宽度的信号，strcut 内的信号可以是不同类型、不同宽度</li>
<li>array 中的信号通过下标来引用，strcut 中的信号通过名字来引用</li>
</ul>
<p>struct 可以用 <code>.</code> 给每个成员单独赋值，也可以给整个 struct 赋值，但是两种方式不能混用。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">opcode</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">address</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span><span class="n">instruction_word_t</span><span class="p">;</span>

<span class="n">instruction_word_t</span><span class="w"> </span><span class="n">IW</span><span class="p">;</span>

<span class="k">assign</span><span class="w"> </span><span class="n">IW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&#39;{</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mh">8&#39;hFF</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span><span class="w">                      </span><span class="c1">// legal</span>
<span class="k">assign</span><span class="w"> </span><span class="n">IW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&#39;{</span><span class="nl">address:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nl">opcode:</span><span class="mh">8&#39;hFF</span><span class="p">,</span><span class="w"> </span><span class="nl">a:</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="nl">b:</span><span class="mi">5</span><span class="p">};</span><span class="w">   </span><span class="c1">// legal</span>
<span class="k">assign</span><span class="w"> </span><span class="n">IW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&#39;{</span><span class="nl">address:</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">8&#39;hFF</span><span class="p">,</span><span class="w"> </span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">};</span><span class="w">              </span><span class="c1">// illegal</span>
</code></pre></div></td></tr></table></div>

<p>struct 默认是 unpacked 模式，即内部的成员是相互独立的，标准并不规定工具如何处理这些成员的存储关系；也可以声明成 packed 模式，packed strcut 内部的成员按照声明顺序存储，规则为：第一个元素在 MSB，依次类推。packed strcut 内部的成员可以通过名字来引用，也可以直接通过下标来引用。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">         </span><span class="n">valid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">tag</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">data_word</span><span class="p">;</span>

<span class="n">data_word</span><span class="p">.</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hF0</span><span class="p">;</span>
<span class="n">data_word</span><span class="p">[</span><span class="mi">39</span><span class="o">:</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;hF0</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>上面定义的 data_word 的存储格式如下：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>+--------------+--------------+
| valid | tag  | data         |
+--------------+--------------+
 40      39  32 31           0
</code></pre></div></td></tr></table></div>

<p>packed struct 存储时是按照 vector 处理的，所以对它的操作也和 vector 相同，可以对其进行数学运算、逻辑操作等。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">         </span><span class="n">valid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">tag</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">data_word_t</span><span class="p">;</span>

<span class="n">data_word_t</span><span class="w"> </span><span class="n">packet_in</span><span class="p">,</span><span class="w"> </span><span class="n">packet_out</span><span class="p">;</span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span>
<span class="w">    </span><span class="n">packet_out</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">packet_in</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>packed struct 还可以声明成 signed/unsigned 类型，主要会影响到其作为一个整体以 vector 类型参与数学运算和比较运算时的行为，但不会影响到内部成员的 signed/unsigned 的类型，每个成员仍然基于成员本身的声明类型。从 packed struct 中截取出的一部分永远是 unsigned 类型，这和 verilog 是一致的。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="kt">signed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">                </span><span class="n">valid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">        </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">tag</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="kt">signed</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">data_word_t</span><span class="p">;</span>

<span class="n">data_word_t</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w">          </span><span class="c1">// signed comparison</span>
<span class="w">        </span><span class="p">...</span>
</code></pre></div></td></tr></table></div>

<p>module、interface、task/function 的端口也可以声明为 struct 类型：首先必须用 typedef 将其声明为用户自定义类型。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="n">definitions</span><span class="p">;</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="n">SUB</span><span class="p">,</span><span class="w"> </span><span class="n">MULT</span><span class="p">,</span><span class="w"> </span><span class="n">DIV</span><span class="p">}</span><span class="w"> </span><span class="n">opcode_t</span><span class="p">;</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">logic</span><span class="w">  </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">opcode_t</span><span class="w">       </span><span class="n">opcode</span><span class="p">;</span>
<span class="w">        </span><span class="kt">logic</span><span class="w">  </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">address</span><span class="p">;</span>
<span class="w">        </span><span class="kt">logic</span><span class="w">          </span><span class="n">error</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">instruction_word_t</span><span class="p">;</span>

<span class="k">endpackage</span>

<span class="k">module</span><span class="w"> </span><span class="n">alu</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">input</span><span class="w"> </span><span class="n">definitions</span><span class="o">::</span><span class="n">instruction_word_t</span><span class="w">  </span><span class="n">IW</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w"> </span><span class="kt">wire</span><span class="w">                             </span><span class="n">clk</span><span class="p">);</span>

<span class="w">        </span><span class="p">...</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>unpacked struct 作为模块端口进行连接时，这两个模块的 strcut 类型必须是同一类型。即使两个模块各自定义了一套完全相同的匿名 struct，它们仍然是不同类型。所以必须用 typedef 将其声明为用户自定义类型才可以。</p>
</div>
<h3 id="union">union</h3>
<p>SV 中也新增了类似 C 语言的 union，其声明方法和赋值方法和 struct 类似。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>

<span class="n">data</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mh">5</span><span class="p">;</span>
<span class="n">data</span><span class="p">.</span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mh">5</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>union 也可以和 struct 一样用 typedef 声明成用户自定义类型，如果没有 typedef 则是匿名 union。</p>
<ul>
<li>
<p><strong>unpacked union 是不可综合的</strong></p>
</li>
<li>
<p>packed union 要求所有成员的 bit 位宽必须一致，所以 <strong>packed union 是可综合的</strong>。packed union 只能存储整数类型的数据，它可以按照一种类型写入，用另外一种类型读出，硬件模型不需要做任何特殊处理来保存数据是如何存储的，因为所有成员的位宽都相同</p>
<p>下面这个例子说明了 packed union 的两种表现方式：要么是一个 packed struct 方式的数据包，要么是一个数组</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">source_addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">15</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">dst_addr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">23</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">opcode</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">data_packet_t</span><span class="p">;</span>

<span class="k">union</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data_packet_t</span><span class="w">     </span><span class="n">packet</span><span class="p">;</span><span class="w">  </span><span class="c1">// packed structure</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">][</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">bytes</span><span class="p">;</span><span class="w">   </span><span class="c1">// packed array</span>
<span class="p">}</span><span class="w"> </span><span class="n">dreg</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>这两种方式的存储格式如下所示。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code>+-------------+----------+------+--------+
| source-addr | dst-addr | data | opcode |
+-------------+----------+------+--------+
 63            47         31     7      0

+----------+----------+----------+----------+----------+----------+----------+----------+
| bytes[7] | bytes[6] | bytes[5] | bytes[4] | bytes[3] | bytes[2] | bytes[1] | bytes[0] |
+----------+----------+----------+----------+----------+----------+----------+----------+
 63         55         47         39         31         23         15         7        0
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>一个 struct 和 union 的应用实例：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="n">definitions</span><span class="p">;</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="n">SUB</span><span class="p">,</span><span class="w"> </span><span class="n">MULT</span><span class="p">,</span><span class="w"> </span><span class="n">DIV</span><span class="p">,</span><span class="w"> </span><span class="n">SL</span><span class="p">,</span><span class="w"> </span><span class="n">SR</span><span class="p">}</span><span class="w"> </span><span class="n">opcode_t</span><span class="p">;</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">UNSIGNED</span><span class="p">,</span><span class="w"> </span><span class="n">SIGNED</span><span class="p">}</span><span class="w"> </span><span class="n">operand_types_t</span><span class="p">;</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">logic</span><span class="w">        </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">u_data</span><span class="p">;</span>
<span class="w">        </span><span class="kt">logic</span><span class="w"> </span><span class="n">singed</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">s_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">data_t</span><span class="p">;</span>

<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">opcode_t</span><span class="w">         </span><span class="n">opc</span><span class="p">;</span>
<span class="w">        </span><span class="n">operand_types_t</span><span class="w">  </span><span class="n">op_type</span><span class="p">;</span>
<span class="w">        </span><span class="n">data_t</span><span class="w">           </span><span class="n">op_a</span><span class="p">;</span>
<span class="w">        </span><span class="n">data_t</span><span class="w">           </span><span class="n">op_b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">instr_t</span><span class="p">;</span>

<span class="k">endpackage</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">definitions::*</span><span class="p">;</span>

<span class="k">module</span><span class="w"> </span><span class="n">alu</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">input</span><span class="w"> </span><span class="n">instr_t</span><span class="w"> </span><span class="n">IW</span><span class="p">,</span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="n">data_t</span><span class="w"> </span><span class="n">alu_out</span><span class="p">);</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="n">IW</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IW</span><span class="p">.</span><span class="n">op_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SIGNED</span><span class="p">)</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">IW</span><span class="p">.</span><span class="n">opc</span><span class="p">)</span>
<span class="w">                </span><span class="nl">ADD:</span><span class="w"> </span><span class="n">alu</span><span class="p">.</span><span class="n">s_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IW</span><span class="p">.</span><span class="n">op_a</span><span class="p">.</span><span class="n">s_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IW</span><span class="p">.</span><span class="n">op_b</span><span class="p">.</span><span class="n">s_data</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// ...</span>
<span class="w">            </span><span class="k">endcase</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">IW</span><span class="p">.</span><span class="n">opc</span><span class="p">)</span>
<span class="w">                </span><span class="nl">ADD:</span><span class="w"> </span><span class="n">alu</span><span class="p">.</span><span class="n">u_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IW</span><span class="p">.</span><span class="n">op_a</span><span class="p">.</span><span class="n">u_data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">IW</span><span class="p">.</span><span class="n">op_b</span><span class="p">.</span><span class="n">u_data</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// ...</span>
<span class="w">            </span><span class="k">endcase</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>SV 支持设计者自定义数据类型，在设计中某些信号（特别是端口信号）可能在不同模块中的含义是不一样的，所以需要支持数据类型动态变化，这是 union 存在的意义。举例：比如所有的 RV32I 的指令都是 32bit，但是可以分为不同的数据类型，那么可能在 IF 模块中指令信号是通用的 32bit 数据，而在 ID 模块中会变成各种类型的格式，这时候就可以把指令定义为 union 类型。</p>
<p>Union 只是语言上的小技巧，实现既可以支持自定义类型，又支持类型自动转化的效果，本质是还是一组宽 bit 信号。</p>
</div>
<h3 id="array">array</h3>
<p><strong>unpacked array</strong>：</p>
<p>Verilog 中的 array 一次只能访问一个元素，或者是一个元素的一个切片，操作多个元素会报错。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">integer</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">][</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">][</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span>

<span class="k">integer</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>

<span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">[</span><span class="mh">3</span><span class="p">][</span><span class="mh">0</span><span class="p">][</span><span class="mh">1</span><span class="p">];</span><span class="w">  </span><span class="c1">// legal: select 1 element</span>
<span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">[</span><span class="mh">3</span><span class="p">][</span><span class="mh">0</span><span class="p">];</span><span class="w">     </span><span class="c1">// illegal: selects 8 elements</span>
</code></pre></div></td></tr></table></div>

<p>这种 array 在 sv 中叫做 unpacked array，array 中的元素是分开存储的，标准并不会规定工具如何存储。相对于 Verilog，SV 的增强之处在于可以声明任何类型的 array，包括用户自定义的类型，而且可以引用 array 整体或者是一个 slice，从而实现复制 array，需要注意的是，复制时等号两端的 array 维度和类型必须一致。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">Mo</span><span class="p">,</span><span class="w"> </span><span class="n">Tu</span><span class="p">,</span><span class="w"> </span><span class="n">We</span><span class="p">,</span><span class="w"> </span><span class="n">Th</span><span class="p">,</span><span class="w"> </span><span class="n">Fr</span><span class="p">,</span><span class="w"> </span><span class="n">Sa</span><span class="p">,</span><span class="w"> </span><span class="n">Su</span><span class="p">}</span><span class="w"> </span><span class="n">Week</span><span class="p">;</span>
<span class="n">Week</span><span class="w"> </span><span class="n">Year</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">52</span><span class="p">];</span>

<span class="kt">int</span><span class="w"> </span><span class="n">a1</span><span class="w"> </span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">][</span><span class="mi">1023</span><span class="o">:</span><span class="mi">0</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a2</span><span class="w"> </span><span class="p">[</span><span class="mi">8</span><span class="o">:</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="o">:</span><span class="mi">1024</span><span class="p">];</span>

<span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="p">;</span><span class="w">        </span><span class="c1">// legal, copy an entire array</span>
<span class="n">a2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">  </span><span class="c1">// legal, copye a slice of an array</span>
</code></pre></div></td></tr></table></div>

<p>SV 还支持简化版的 array 定义，就像 C 语言一样，只需要定义 array 的大小即可，但是这种写法不能用在 vector(packed arry) 中。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">logic</span><span class="w">  </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span><span class="w">    </span><span class="c1">// legal, equal to next line</span>
<span class="kt">logic</span><span class="w">  </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">1023</span><span class="p">];</span>

<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">   </span><span class="c1">// illegal vector declaration</span>
</code></pre></div></td></tr></table></div>

<p><strong>packed array</strong>：</p>
<p>Verilog 中把位宽范围放在标识符前面的声明叫做 vector，把位宽范围放在标识符后面的声明叫做 array。SV 的叫法稍微不同，而且扩展了 packed array 使其可以声明成多维数组。</p>
<ul>
<li>vector = packed array</li>
<li>array = unpacked array<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">select</span><span class="p">;</span><span class="w">      </span><span class="c1">// 4-bit packed array</span>
<span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">63</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">        </span><span class="c1">// 64-bit packed array</span>
<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">][</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">  </span><span class="c1">// 2-D packed array: 4 8-bit sub-arrays</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>SV 定义了 packed array 的存储方式：像 vector 一样整个 array 必须连续存储，packed array 内部的每个维度都是 vector 的一个字段。上面例子中二维数组存储方式如下所示，这是协议规定的，和仿真器、编译器、操作系统、平台无关。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code>+--------------+--------------+--------------+--------------+
| data[3][7:0] | data[2][7:0] | data[1][7:0] | data[0][7:0] |
+--------------+--------------+--------------+--------------+
 31          24 23          16 15           8 7            0
</code></pre></div></td></tr></table></div>

<p>packed array 只能用下面元素组成，</p>
<ul>
<li>bit-wise 类型：logic、bit、reg</li>
<li>packed array, packed struct, packed union</li>
<li>任何 net 类型：wire<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">crc</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">63</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">dataword</span><span class="p">;</span>

<span class="n">data_word</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">darray</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1-D packed array of packed structures</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>packed array 可以按照一个元素、一部分 bit、一个 slice 的粒度访问：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">  </span><span class="c1">// 2-D packed array</span>

<span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="p">]</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">              </span><span class="c1">// whole array</span>

<span class="kt">wire</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mh">3</span><span class="p">][</span><span class="mh">7</span><span class="p">];</span><span class="w">             </span><span class="c1">// bit-select</span>

<span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">nib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mh">0</span><span class="p">][</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span><span class="w">      </span><span class="c1">// part-select</span>

<span class="kt">byte</span><span class="w"> </span><span class="n">high_byte</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">high_byte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mh">3</span><span class="p">];</span><span class="w">         </span><span class="c1">// 8-bit slice</span>

<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">word</span><span class="p">;</span>
<span class="k">assign</span><span class="w"> </span><span class="n">word</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span><span class="w">            </span><span class="c1">// 2 slices</span>
</code></pre></div></td></tr></table></div>

<p>因为 packed array 是按照 vector 存储的，所以所有 Verilog 中对 vector 的操作对 packed array 也是合法的，包括：</p>
<ul>
<li>bit 选择</li>
<li>部分选择</li>
<li>数据拼接</li>
<li>数学操作</li>
<li>关系操作</li>
<li>bit-wise 操作</li>
<li>逻辑操作</li>
</ul>
<p>如果位宽不匹配，packed array 会被自动截断 / 扩展成符号左边的位宽，这个规则和 Verilog 是一致的。</p>
<p>packed 和 unpacked 都很灵活，那么什么时候应该用什么类型的 array 呢？</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>unpacked array</td>
<td><ul><li>元素是 unpacked 类型的 struct，union，以及其他非 bit-wise 的类型</li><li>一次访问一整个元素的 array，比如 RAM/ROM</li></ul></td>
</tr>
<tr>
<td>packed array</td>
<td><ul><li>多个 1-bit 类型的信号组成的 vector（verilog 的用法）</li><li>可能访问 sub-field 的 vector</li></ul></td>
</tr>
</tbody>
</table>
<p>关于赋值，</p>
<ul>
<li>
<p>packed array 赋值可以像 verilog 里面的 vector 赋值一样</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">][</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">  </span><span class="c1">// 3-D packed arraay</span>

<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mb">1&#39;b0</span><span class="p">;</span><span class="w">    </span><span class="c1">// assign to one bit</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">32&#39;hF1A3C5E7</span><span class="p">;</span><span class="w">     </span><span class="c1">// assign to full array</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">4&#39;hF</span><span class="p">;</span><span class="w">  </span><span class="c1">// assign to a part select</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">16&#39;hFACE</span><span class="p">;</span><span class="w">      </span><span class="c1">// assign to a slice</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mb">16&#39;bz</span><span class="p">,</span><span class="w"> </span><span class="mb">16&#39;b0</span><span class="p">};</span><span class="w">   </span><span class="c1">// assign concatenation</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>unpacked array 可以用 SV 的新语法赋值</p>
<p>其中 <code>'{}</code> 表明内部是一个 list，通过前面的单引号和 Vrilog 的拼接操作符区分，而且 <code>'{}</code>、<code>'{n{}}</code> 和 verilog 中的 <code>{}</code>、<code>{n{}}</code> 不同，后者内部需要明确每个元素的位宽，前者位宽声明是可选的。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">byte</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">8&#39;h5</span><span class="p">;</span><span class="w">                </span><span class="c1">// assign to one element</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&#39;{</span><span class="mi">4</span><span class="p">&#39;{</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">}};</span><span class="w">         </span><span class="c1">// assign a list to the full array</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;{&#39;</span><span class="n">hF</span><span class="p">,</span><span class="w"> </span><span class="mh">&#39;hA</span><span class="p">,</span><span class="w"> </span><span class="mh">&#39;hC</span><span class="p">,</span><span class="w"> </span><span class="mh">&#39;hE</span><span class="p">};</span><span class="w">  </span><span class="c1">// assign a list to slice of array</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>当 packed 和 unpacked 多维数组嵌套在一起时，数组的下标寻址规则如下：</p>
<ul>
<li>首先寻址 unpacked array，从左到右的顺序</li>
<li>其次寻址 packed array，也是从左到右的顺序</li>
</ul>
<p><img alt="indexing" src="/images/systemverilog-for-design-notes/indexing.png"></p>
<p>用户自定义类型也可以用来组成 array，形成复合数据类型。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w"> </span><span class="n">uint</span><span class="p">;</span>
<span class="n">unit</span><span class="w"> </span><span class="n">u_array</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">127</span><span class="p">];</span><span class="w">       </span><span class="c1">// array of user types</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">nibble</span><span class="p">;</span>
<span class="n">nibble</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">big_word</span><span class="p">;</span><span class="w">     </span><span class="c1">// packed array, is equalitent to</span>
<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">big_word</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">nibble</span><span class="w"> </span><span class="n">nib_array</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">3</span><span class="p">];</span>
<span class="n">nib_array</span><span class="w"> </span><span class="n">compound_array</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">7</span><span class="p">];</span><span class="w">         </span><span class="c1">// is equalitent to</span>
<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">compound_array</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">7</span><span class="p">][</span><span class="mh">0</span><span class="o">:</span><span class="mh">3</span><span class="p">];</span>
</code></pre></div></td></tr></table></div>

<p>Verilog 只允许 1-D 的 packed array 作为模块端口、task/function 参数，而 SV 允许任何类型的任何 array 作为端口。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">CPU</span><span class="w"> </span><span class="p">(...);</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">lookup_table</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">255</span><span class="p">];</span>

<span class="w">    </span><span class="n">lookup</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="p">(.</span><span class="n">LUT</span><span class="p">(</span><span class="n">lookup_table</span><span class="p">));</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="p">(</span><span class="k">output</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">LUT</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">255</span><span class="p">]);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<p>struct 和 union 也可以作为 array 的元素，需要注意的是 packed array 的元素也必须是 packed 类型。同理 array 也可以作为 struct/union 的元素，packed struct/union 的元素也必须是 packed 类型。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">paced</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">packet_t</span><span class="p">;</span>

<span class="n">packet_t</span><span class="w"> </span><span class="p">[</span><span class="mh">23</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">packet_array</span><span class="p">;</span><span class="w">  </span><span class="c1">// packed array of 24 structures</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">real</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">data_t</span><span class="p">;</span>

<span class="n">data_t</span><span class="w"> </span><span class="n">data_array</span><span class="w"> </span><span class="p">[</span><span class="mh">23</span><span class="o">:</span><span class="mh">0</span><span class="p">];</span><span class="w">  </span><span class="c1">// unpacked array of 24 structures</span>

<span class="k">struct</span><span class="w"> </span><span class="k">packed</span><span class="w"> </span><span class="p">{</span><span class="w">              </span><span class="c1">// packed structure</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="n">parity</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">3</span><span class="o">:</span><span class="mh">0</span><span class="p">][</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">   </span><span class="c1">// packed array</span>
<span class="p">}</span><span class="w"> </span><span class="n">data_word</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">                     </span><span class="c1">// unpacked structure</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="n">data_ready</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">3</span><span class="p">];</span><span class="w">  </span><span class="c1">// unpacked array</span>
<span class="p">}</span><span class="w"> </span><span class="n">packet_t</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<h3 id="foreach">foreach</h3>
<p>有时候需要迭代处理 array 中的每个元素，一般都是通过 for 循环来处理，但是如果有很多个 for 循环或者是 array 的维度较多，则需要声明很多个 index，为了避免这一繁琐的声明，SV 新增了一种语法 <code>foreach</code> 来自动迭代，设计者不需要再手动声明每个 index 变量了。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">8</span><span class="p">][</span><span class="mh">1</span><span class="o">:</span><span class="mh">3</span><span class="p">];</span>

<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">])</span>
<span class="w">    </span><span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>

<span class="k">function</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">gen_crc</span><span class="w"> </span><span class="p">(</span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">][</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">gen_crc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">gen_crc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">^</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">endfunction</span>
</code></pre></div></td></tr></table></div>

<p>上面这个例子中：</p>
<ul>
<li>i, j 不需要声明，直接使用</li>
<li>i, j 用逗号隔开，和维度的映射规则和前面说的嵌套 array 寻址相同，所以上例中 i 指向外层循环、j 指向内层循环</li>
<li>如果想跳过某一维度，可以用两个逗号跳过，如果是在尾部，直接不写出来即可</li>
<li>这些循环变量是自动生成的、只读、只对循环内部可见</li>
</ul>
<h3 id="array-system-function">array system function</h3>
<p>大部分系统函数都是不可综合的，但是下面这些和 array 相关的系统函数是例外，它们是可综合的：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>$dimensions(array_name)</td>
<td>返回 array 的维度</td>
</tr>
<tr>
<td>$left(array_name, dimension)</td>
<td>返回 array 特定维度的 msb</td>
</tr>
<tr>
<td>$right(array_name, dimension)</td>
<td>返回 array 特定维度的 lsb</td>
</tr>
<tr>
<td>$low(array_name, dimension)</td>
<td>返回 array 特定维度的最低位索引</td>
</tr>
<tr>
<td>$high(array_name, dimension)</td>
<td>返回 array 特定维度的最高位索引</td>
</tr>
<tr>
<td>$size(array_name, dimension)</td>
<td>返回 array 特定维度元素总数 $high - $low + 1</td>
</tr>
<tr>
<td>$increasement(array_name, dimension)</td>
<td>如果 $left &gt;= $right 返回 1，否则返回 0</td>
</tr>
<tr>
<td>$bits(expression)</td>
<td>返回 expression 的总 bit 数（expression 的位宽是静态不变的，所以可综合）</td>
</tr>
</tbody>
</table>
<h3 id="dynamic-arrays-associative-arrays-sparse-arrays-strings">dynamic arrays, associative arrays, sparse arrays, strings</h3>
<p>这些都是不可综合的。</p>
<h3 id="summary_2">summary</h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li>unpacked/packed struct 都是可综合的</li>
<li>struct 可以作为端口在 module、interface、task/function 之间连接</li>
<li>只有 packed union 是可综合的，unpacked union 是不可综合的</li>
<li>array 及其赋值是可综合的，包括<ul>
<li>array 声明：packed/unpacked 都是可综合的，维度可以是任意数</li>
<li>array 赋值：给单个元素、部分 bit 位、单个元素的 part-select、array slice、整个 array 赋值，default 关键字也是可综合的</li>
<li>array 复制：packed-to-packed、相同 layout 的 unpacked-to-unpacked 都是可综合的</li>
<li>struct/union 中的 array 也是可综合的，其中 union 必须是 packed，所以其内部的 array 也必须是 packed</li>
<li>struct/union 组成的 array 也是可综合的</li>
<li>array 作为模块端口是可综合的</li>
</ul>
</li>
</ul>
</div>
<h2 id="chapter-6-systemverilog-procedural-blocks-tasks-and-functions">Chapter 6 Systemverilog Procedural Blocks, Tasks and Functions</h2>
<p>Verilog 中的 <code>always</code> 块的用法很多，既可以对硬件建模写可综合的代码，可以在仿真中建模写不可综合的代码，所以有很多各种各样的规则，这对设计者、工具都提出了很高的要求，SV 通过新增语法解决了这些问题 :</p>
<ul>
<li>always_comb</li>
<li>always_ff</li>
<li>always_latch</li>
</ul>
<h3 id="awalys_comb">awalys_comb</h3>
<p>顾名思义，组合逻辑专用。和普通的 always 相比其好处是：</p>
<ul>
<li>不需要再写出敏感列表，不会有漏掉信号的 bug</li>
<li>要求赋值语句的左侧信号不能在其他地方赋值，防止不符合组合逻辑的行为</li>
<li>工具不需要再推测设计意图</li>
<li><code>always_comb</code> 比 <code>always @*</code> 更好，因为 <code>always @*</code> 在有函数调用时推断出来的敏感列表可能不完整<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="o">*</span><span class="w"> </span><span class="k">begin</span><span class="w">             </span><span class="c1">// infers @(data)</span>
<span class="w">    </span><span class="n">a1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">b1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decode</span><span class="p">();</span>
<span class="k">end</span>

<span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span><span class="w">           </span><span class="c1">// infers @(data, sel, c, d, e)</span>
<span class="w">    </span><span class="n">a2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">b2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decode</span><span class="p">();</span>
<span class="k">end</span>

<span class="k">function</span><span class="w"> </span><span class="n">decode</span><span class="p">;</span><span class="w">        </span><span class="c1">// function with no inputs</span>
<span class="w">    </span><span class="k">begin</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>
<span class="w">            </span><span class="mh">2</span><span class="mb">&#39;b01</span><span class="o">:</span><span class="w">   </span><span class="n">decode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="w">            </span><span class="mh">2</span><span class="mb">&#39;b10</span><span class="o">:</span><span class="w">   </span><span class="n">decode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">;</span>
<span class="w">            </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">decode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">        </span><span class="k">endcase</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endfunction</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<h3 id="always_latch">always_latch</h3>
<p>和 always_comb 一样也不需要写出敏感列表，只是工具会自动推断出 latch，所以检查规则也略有变化。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always_latch</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">en</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<h3 id="always_ff">always_ff</h3>
<p>同理，always_ff 用来对触发器进行建模，设计者必须提供敏感列表，而且每个信号前面必须有前缀 posedge 或者是 negedge。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always_ff</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"> </span><span class="k">negedge</span><span class="w"> </span><span class="n">rst_n</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rst_n</span><span class="p">)</span>
<span class="w">        </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">q</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<h3 id="taskfunction">task/function</h3>
<p>SV 对 task/function 也做了一些增强，主要包括下面几点：</p>
<ul>
<li>
<p>不再强制要求 <code>begin ... end</code>，会自动推断出来</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="n">states_t</span><span class="w"> </span><span class="n">NextState</span><span class="w"> </span><span class="p">(</span><span class="n">states_t</span><span class="w"> </span><span class="n">State</span><span class="p">);</span>
<span class="w">    </span><span class="n">NextState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">State</span><span class="p">)</span>
<span class="w">        </span><span class="nl">WAITE:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="w"> </span><span class="n">NextState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LOAD</span><span class="p">;</span>
<span class="w">        </span><span class="nl">LOAD:</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">done</span><span class="p">)</span><span class="w">  </span><span class="n">NextState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STORE</span><span class="p">;</span>
<span class="w">        </span><span class="nl">STORE:</span><span class="w">            </span><span class="n">NextState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WAITE</span><span class="p">;</span>
<span class="w">    </span><span class="k">endcase</span>
<span class="k">endfunction</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>Verilog 中的 function 名字本身就是一个变量，返回值就是对同名变量赋值，最后一次给函数名所赋的值就是返回值。SV 新增了 return 语句，而且 return 语句的优先级高于同名变量，即如果有 return 语句，可以把同名变量当成一个临时变量来用</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">add_and_inc</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">endfunction</span>

<span class="k">function</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">add_and_inc</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">add_and_inc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">++</span><span class="n">add_and_inc</span><span class="p">;</span>
<span class="k">endfunction</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>新增的 void function 可以不必有返回值，可以像普通语句一样调用，就像 task 一样</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">        </span><span class="n">valid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">check</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">packet_t</span><span class="p">;</span>

<span class="k">function</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fill_packet</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">input</span><span class="w">  </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data_in</span><span class="p">,</span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="n">packet_t</span><span class="w">     </span><span class="n">data_out</span><span class="w"> </span><span class="p">);</span>

<span class="w">    </span><span class="n">data_out</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_in</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">data_out</span><span class="p">.</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">^</span><span class="n">data_in</span><span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">+:</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span>
<span class="w">    </span><span class="n">data_out</span><span class="p">.</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">endfunction</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>Verilog 只运行按位置传参，错误的传参顺序可能导致错误；SV 新增了按名传参，可以减少犯错的机会</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span>
<span class="w">    </span><span class="n">restult</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">divide</span><span class="p">(.</span><span class="n">denominator</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="p">.</span><span class="n">numerator</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>Verilog 中的 function 只能有 input 参数，唯一的 output 参数就是函数名；SV 为 function 新增了 output 参数。为了保证可综合性，带 output 的 function 不能出现在连续赋值语句中</p>
</li>
<li>
<p>Verilog 要求 function 至少有一个参数，即使内部不会用到这个参数；SV 允许 function 不带参数，前面 always_comb 有个实例</p>
</li>
<li>
<p>Verilog 要求每个参数都必须有 input/output 表明方向；SV 简化了语法，参数默认的方向是 input，除非明确声明了方向，后续的参数都是这个方向。同时 SV 默认参数是 logic 类型</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endfunction</span>

<span class="k">task</span><span class="w"> </span><span class="n">mytask</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">output</span><span class="w"> </span><span class="n">y1</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endtask</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>SV 还允许 funciton 参数有默认值，这样调用时如果不涉及，可以不传递这个参数</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">incrementer</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">incrementer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">step</span><span class="p">;</span>
<span class="k">endfunction</span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">incrementer</span><span class="p">(</span><span class="n">data_bus</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>struct、union、array 都可以作为 function 的参数</p>
</li>
</ul>
<h3 id="summary_3">summary</h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li><code>always_comb</code>, <code>always_latch</code>, <code>always_ff</code> 都是可综合的，用它们取代 <code>always</code> 增强设计</li>
<li>用 void function 代替 tasks，提高设计的安全性</li>
</ul>
</div>
<h2 id="chapter-7-systemverilog-procedural-statements">Chapter 7 Systemverilog Procedural Statements</h2>
<p>SV 新增了一些新语法和新的操作符，可以让设计者写出更加精简的可综合 RTL 代码。</p>
<h3 id="new-operators">new operators</h3>
<p><strong>自增 / 自减操作符： <code>++</code>, <code>--</code></strong></p>
<p>类似 C 语言，赋值和自增 / 自减有先后之分。因为 SV 中有阻塞 / 非阻塞两种赋值方式，<code>++</code> 和 <code>--</code> 的行为和阻塞赋值是一样的。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>不要在非阻塞赋值中使用自增 / 自减操作符。也就是说它们只能用来对组合逻辑进行建模，不能用在时序逻辑中。（例外情况：类似 for 循环下标这种用法，不是真正的信号）</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="mh">32</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">end</span>

<span class="c1">// post-increment</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">LIMIT</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">loop1</span>
<span class="w">    </span><span class="p">...</span><span class="w">     </span><span class="c1">// last value of i will be LIMIT</span>
<span class="k">end</span>

<span class="c1">// pre-increment</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">++</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">LIMIT</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">loop2</span>
<span class="w">    </span><span class="p">...</span><span class="w">     </span><span class="c1">// last value of j will be LIMIT-1</span>
<span class="k">end</span>

<span class="c1">// act as blocking assignment, following two statements are equivalent</span>
<span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

</div>
<p><strong>赋值操作符</strong></p>
<p>以 <code>+=</code> 为例，</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">out</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">in</span><span class="p">;</span><span class="w">       </span><span class="c1">// is equalitent to</span>
<span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">in</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>除了加法，<code>=</code> 还可以和其他操作符结合，所有新增赋值操作汇总如下。</p>
<p><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&lt;&lt;&lt;=</code>, <code>&gt;&gt;&gt;=</code>。</p>
<p>所有的赋值操作符的行为也和阻塞赋值一样，所以和自增 / 自减一样，只能用在组合逻辑建模中。</p>
<p><strong>带 don't care 的等价操作符</strong></p>
<p>Verilog 中有两种等价操作符 <code>==</code> 和 <code>===</code>，SV 新增的操作符 <code>==?</code> ，它们的区别在于对 x/z 的判断。</p>
<ul>
<li><code>==</code>：只要任何一个操作数带 x/z，返回结果是 1'bx</li>
<li><code>===</code>：bit-wise 比较，要求 1, 0, x, z 精确匹配，完全一样才返回 1‘b1，否则返回 1'b0 |</li>
<li><code>==?</code>：右操作数中的 x/z 当成是通配符，和左操作数对应 bit 的任何值都匹配</li>
<li><code>!=?</code>：对 <code>==?</code> 取反</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ol>
<li>如果左右位宽不匹配，会在比较前做位宽扩展，扩展规则和逻辑比较 <code>==</code> 的规则相同</li>
<li><code>==?</code> 和 <code>!=?</code> 可综合的前提是右操作数是常数，即不能是可变化的信号值。</li>
</ol>
</div>
<p><strong>判断是否存在 inside</strong></p>
<p>类似于 Python 中的 <code>in</code> 效果。<code>inside</code> 是可综合的，但是很多综合工具可能并不支持。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="p">{</span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="p">,</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b010</span><span class="p">,</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b100</span><span class="p">})</span>

<span class="c1">// equalitent</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b010</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="mh">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b100</span><span class="p">))</span>

<span class="c1">// the set of values can be an array</span>
<span class="kt">int</span><span class="w"> </span><span class="n">d_array</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">1023</span><span class="p">];</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mh">13</span><span class="w"> </span><span class="n">inside</span><span class="w"> </span><span class="p">{</span><span class="n">d_array</span><span class="p">})</span><span class="w">    </span><span class="c1">// test if value 13 occurs anywhere in array d_array</span>
</code></pre></div></td></tr></table></div>

<h3 id="for-loops">for loops</h3>
<p>Verilog 中 for 循环的 index 变量必须声明在循环外部，如果一个模块中有多个 for 循环，而且要保证名字相互之间不同，或者把声明放到 always 块中，这时候才可以重名。</p>
<p>SV 做了一下增强：</p>
<ul>
<li>
<p>可以在 for 循环中定义局部变量，不同 for 循环的局部变量可以重名</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always_ff</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">bit</span><span class="w"> </span><span class="p">[</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>

<span class="k">always_ff</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">)</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>

<p>需要注意的是，这种变量是 automatic 类型，而 automatic 类型的变量有以下限制：</p>
<ul>
<li>automatic 变量不能在外部访问</li>
<li>automatic 变量无法 dump 到 VCD 文件中</li>
</ul>
<p>所以 for 循环外部是无法访问这个变量的，如果一定要访问，那么就要挪到 for 外部定义。</p>
</li>
<li>
<p>一次可以声明多个变量，和 C 语言类似</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+=</span><span class="mi">3</span><span class="p">)</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="kt">byte</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">+=</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<h3 id="dowhile-loop">do...while loop</h3>
<p><code>do...while</code> 和 <code>while</code> 一样，在某些限制条件（这些条件是要能让综合器可以静态地判断循环次数，和 for 类似）下是可综合的，一般来说 RTL 中不会使用这两种语法，略。</p>
<h3 id="foreach_1">foreach</h3>
<p>见 Chapter 5 中关于 array 部分。</p>
<h3 id="jump-statements">jump statements</h3>
<p>SV 新增的 <code>break</code>, <code>continue</code>, <code>return</code> 都是可综合的，规则和 <code>disable</code> 一样。（一般很少用）</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// continue example</span>
<span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">[</span><span class="mh">0</span><span class="o">:</span><span class="mh">255</span><span class="p">];</span>
<span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">255</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">loop</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w">   </span><span class="c1">// skip empty elements</span>
<span class="w">        </span><span class="n">transform_function</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>

<span class="c1">// break example</span>
<span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="n">first_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mh">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="mh">63</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">start_range</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">end_range</span><span class="p">)</span><span class="w">   </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">first_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>

<span class="c1">// return example</span>
<span class="k">task</span><span class="w"> </span><span class="n">add_up_to_max</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w">  </span><span class="p">[</span><span class="w"> </span><span class="mh">5</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">max</span><span class="p">,</span>
<span class="w">                    </span><span class="k">output</span><span class="w"> </span><span class="p">[</span><span class="mh">63</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">max</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mh">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="mh">63</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">max</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">endtask</span>
</code></pre></div></td></tr></table></div>

<h3 id="block-names">block names</h3>
<p>当有多层 begin...end 嵌套时，即使有缩进，有时候也很那找到 end 对应的 begin，SV 支持给 end 后面也加上 name，这个特性对综合没有任何影响，只是为了提高代码可读性。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>end 后面的名字必须和匹配的 begin 名字相同，否则会报错。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">block_name</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">end</span><span class="o">:</span><span class="w"> </span><span class="o">&lt;</span><span class="n">block_name</span><span class="o">&gt;</span>
</code></pre></div></td></tr></table></div>

</div>
<h3 id="statement-label">statement label</h3>
<p>SV 还支持给单个语句加上 label，就和 begin...end 块一样，不过语法是类似 C 语言的风格。给语句加上 label 的好处很多，</p>
<ul>
<li>提高代码可读性</li>
<li>方便文档 / 其他地方引用具体语句</li>
<li>帮助 debug 工具和 coverage 工具分析</li>
</ul>
<p>begin...end 块也是一个 statement，所以也可以给它加上 label。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>begin...end 块不能同时使用 label 和 block name。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// &lt;label&gt; : &lt;statement&gt;</span>

<span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="nl">decoder:</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="k">endcase</span>
<span class="k">end</span>

<span class="c1">// named block</span>
<span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">block1</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">end</span><span class="o">:</span><span class="w"> </span><span class="n">block1</span>

<span class="c1">// labeled block</span>
<span class="nl">block2:</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="p">...</span>
<span class="w">        </span><span class="k">end</span>
</code></pre></div></td></tr></table></div>

</div>
<h3 id="case-statement">case statement</h3>
<p>Verilog 标准特意规定了 case 语句的选择必须是按照顺序来评估，所以暗含着优先级。会得到类似 if-else-if 的效果。如果设计本身没有优先级时，综合工具要做特别的处理，把优先级逻辑优化掉。</p>
<p>SV 为此特意定义了两个描述符来限定 case 语句：</p>
<ul>
<li>
<p><code>unique case</code> 表示无优先级的 case，它要求表达式和 case item 之间必须是一一映射的关系，表达式必须能且只能匹配一个 item，否则会报错。unique case 和 always_comb 配合使用，这两个特性带来的额外检查可以提高 RTL 的综合结果符合设计意图。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">unique</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">case_expression</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// case items</span>
<span class="k">endcase</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p><code>priority case</code> 表示有优先级的 case，它要求表达式至少要匹配一项 item，如果有多项匹配时，选择对一个匹配项。使用这个限定符表示设计者是有意这么做的，有多个匹配项也符合设计意图。有时候即使使用了 priority，如果 case item 本身是不可能同时匹配，那么综合工具也会自动把优先逻辑优化掉。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">priority</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">case_expression</span><span class="o">&gt;</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// case items</span>
<span class="k">endcase</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>Verilog 中定义了两个 program 来帮助综合工具，</p>
<ul>
<li><code>parallel_case</code>：告诉综合工具去掉优先级逻辑，所有分支是并行同级关系</li>
<li><code>full_case</code>：未使用到的 expression value 是无关紧要的，可优化掉这部分逻辑</li>
</ul>
<p>所以 unique case 实际上就相当于同时使能了 full_case 和 parallel_case，而 priority case 相当于只使能了 full_case。但是使用这两个新语法比 program 更健壮，可以减少风险。</p>
<h3 id="ifelse">if...else</h3>
<p>unique 和 priority 也可以用来限定 if-else 语句。仿真工具会按照我们书写顺序来评估每个条件，综合工具也会产生优先级逻辑来保持和仿真的一致性，但是通常，我们书写顺序并不是真正想要的效果。</p>
<ul>
<li>
<p><code>unique if...else</code> 表明设计者并不关心优先级，综合工具可以把优先级逻辑优化掉。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="n">sel</span><span class="p">;</span>
<span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">unique</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sel</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mb">3&#39;b001</span><span class="p">)</span><span class="w"> </span><span class="n">mux_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sel</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mb">3&#39;b010</span><span class="p">)</span><span class="w"> </span><span class="n">mux_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sel</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mb">3&#39;b100</span><span class="p">)</span><span class="w"> </span><span class="n">mux_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p><code>priority if...else</code> 表明设计者关心优先级，所以工具要保留优先级逻辑。</p>
</li>
</ul>
<h3 id="summary_4">summary</h3>
<div class="admonition summary">
<p class="admonition-title">Summary</p>
<ul>
<li><code>++</code> 和 <code>--</code> 都是可综合的，但是工具支持并不好，为了健壮性，避免使用这两个操作符</li>
<li>新增的赋值操作符是可综合的，有些综合工具对部分操作符有限制，为了健壮性，避免使用这些赋值操作符</li>
<li><code>==?</code> 和 <code>!=?</code> 可综合的前提是右操作数是常数</li>
<li>增强性 for 循环也是可综合的，和 Verilog 中的 for 规则相同</li>
<li><code>do...while</code> 在某些条件下是可综合的，避免使用</li>
<li><code>break</code>, <code>continue</code>, <code>return</code> 都是可综合的，避免使用</li>
<li><code>unique</code>  和 <code>priority</code> 都是可综合的，可以提高设计的健壮性</li>
</ul>
</div>
<h2 id="chapter-8-modeling-finite-state-machine-with-systemverilog">Chapter 8 Modeling Finite State Machine with Systemverilog</h2>
<p>使用前面 7 章介绍的新特性，使用 FSM 对一个交通灯控制系统建模的例子。和传统 Verilog 相比，有以下特点：</p>
<ul>
<li>统一使用 <code>logic</code> 代替 <code>reg</code>/<code>wire</code></li>
<li>使用 <code>always_comb</code> 和 <code>always_ff</code> 代替通用 <code>always</code></li>
<li>begin...end 加了 name</li>
<li>使用 enum 类型描述所有状态<ul>
<li>明确类型为 <code>logic</code>（默认是 <code>int</code>，32-bit 2-state）</li>
<li>明确给出 label 的取值（方便控制编码类型，比如 one-hot, one-cold, binary 等）</li>
<li>enum 变量只能用 label 赋值，不要用数字给 enum 变量赋值，也不要给部分 bit 赋值</li>
</ul>
</li>
<li>使用 <code>unique case</code> 代替普通 case<ul>
<li>如果是 one-hot 编码，可以调换 case expression 和 case selection items 的位置，某些综合工具下面积更优<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">traffic_light</span><span class="w"> </span><span class="p">(</span><span class="k">output</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">green_light</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">yellow_light</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">red_light</span><span class="p">,</span>
<span class="w">                      </span><span class="k">input</span><span class="w">        </span><span class="n">sensor</span><span class="p">,</span>
<span class="w">                      </span><span class="k">input</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">green_downcnt</span><span class="p">,</span>
<span class="w">                                   </span><span class="n">yellow_downcnt</span><span class="p">,</span>
<span class="w">                      </span><span class="k">input</span><span class="w">        </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="n">R_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">,</span>
<span class="w">          </span><span class="n">G_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">,</span>
<span class="w">          </span><span class="n">Y_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="p">}</span><span class="w"> </span><span class="n">state_bit</span><span class="p">;</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">RED</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R_BIT</span><span class="p">,</span><span class="w">   </span><span class="c1">// explicit enum definition</span>
<span class="w">                      </span><span class="n">GREEN</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">G_BIT</span><span class="p">,</span>
<span class="w">                      </span><span class="n">YELLOW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b001</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Y_BIT</span><span class="p">}</span><span class="w"> </span><span class="n">State</span><span class="p">,</span><span class="w"> </span><span class="n">Next</span><span class="p">;</span>

<span class="w">    </span><span class="k">always_ff</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"> </span><span class="k">negedge</span><span class="w"> </span><span class="n">resetN</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">resetN</span><span class="p">)</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w">         </span><span class="n">State</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">Next</span><span class="p">;</span>

<span class="w">    </span><span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">set_next_state</span>
<span class="w">        </span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">State</span><span class="p">;</span><span class="w">   </span><span class="c1">// the default for each branch below</span>
<span class="w">        </span><span class="n">unique</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">)</span><span class="w">  </span><span class="c1">// reversed case statement</span>
<span class="w">            </span><span class="n">State</span><span class="p">[</span><span class="n">R_BIT</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sensor</span><span class="p">)</span><span class="w">              </span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GREEN</span><span class="p">;</span>
<span class="w">            </span><span class="n">State</span><span class="p">[</span><span class="n">G_BIT</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">green_downcnt</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mh">0</span><span class="p">)</span><span class="w"> </span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YELLOW</span><span class="p">;</span>
<span class="w">            </span><span class="n">State</span><span class="p">[</span><span class="n">Y_BIT</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">yellow_downcnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0</span><span class="p">)</span><span class="w"> </span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">        </span><span class="k">endcase</span>
<span class="w">    </span><span class="k">end</span><span class="o">:</span><span class="w"> </span><span class="n">set_next_state</span>

<span class="w">    </span><span class="k">always_comb</span><span class="w"> </span><span class="k">begin</span><span class="o">:</span><span class="w"> </span><span class="n">set_outputs</span>
<span class="w">        </span><span class="p">{</span><span class="n">red_light</span><span class="p">,</span><span class="w"> </span><span class="n">green_light</span><span class="p">,</span><span class="w"> </span><span class="n">yellow_light</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b000</span><span class="p">;</span>
<span class="w">        </span><span class="n">unique</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">)</span><span class="w">  </span><span class="c1">// reversed case statement</span>
<span class="w">            </span><span class="n">State</span><span class="p">[</span><span class="n">R_BIT</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">red_light</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">            </span><span class="n">State</span><span class="p">[</span><span class="n">G_BIT</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">green_light</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">            </span><span class="n">Staet</span><span class="p">[</span><span class="n">Y_BIT</span><span class="p">]</span><span class="o">:</span><span class="w"> </span><span class="n">yellow_light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b1</span><span class="p">;</span>
<span class="w">        </span><span class="k">endcase</span>
<span class="w">    </span><span class="k">end</span><span class="o">:</span><span class="w"> </span><span class="n">set_outputs</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
</li>
</ul>
<h2 id="chapter-9-systemverilog-design-hierarchy">Chapter 9 Systemverilog Design Hierarchy</h2>
<h3 id="module-prototypes">module prototypes</h3>
<p>大型设计可能会分散定义在几十个文件中，在模块中例化另外一个文件中的模块时，综合工具要做大量工作，包括检查这个文件的模块的定义，包括端口数量、端口位宽、甚至是端口顺序。SV 提供了 <code>external module</code> 语法在例化该模块的文件中声明模块原型，可以简化综合步骤。</p>
<p>声明方式有两种：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// Verilog-1995 style</span>
<span class="n">extern</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="c1">// Verilog-2001 style</span>
<span class="n">extern</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">#(</span><span class="k">parameter</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">15</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="k">output</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="nl">N:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">cnt</span><span class="p">,</span>
<span class="w">                        </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">  </span><span class="p">[</span><span class="nl">N:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">d</span><span class="p">,</span>
<span class="w">                        </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">        </span><span class="n">clock</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">load</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">resetN</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

<p>声明模块原型可以写在任何地方：在 module/interface 之外的声明实际上定义在 $unit 中，这时模块原型声明对于和这个文件一起综合的其他文件来说都是可见的。</p>
<p>原型和模块的实际定义必须严格一致：包括端口顺序、端口位宽都必须相同，如果不同会报错。</p>
<p>如果模块参数、端口非常多，重复写两遍非常麻烦，SV 提供了新语法 <code>.*</code> 解决这个问题。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// prototype</span>
<span class="n">extern</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">#(</span><span class="k">parameter</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">15</span><span class="p">)</span>
<span class="w">                       </span><span class="p">(</span><span class="k">output</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="nl">N:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">cnt</span><span class="p">,</span>
<span class="w">                        </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">  </span><span class="p">[</span><span class="nl">N:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">d</span><span class="p">,</span>
<span class="w">                        </span><span class="k">input</span><span class="w">  </span><span class="kt">wire</span><span class="w">        </span><span class="n">clock</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">load</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">resetN</span><span class="p">);</span>

<span class="c1">// difinition</span>
<span class="k">module</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">always_ff</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="p">,</span><span class="w"> </span><span class="k">negedge</span><span class="w"> </span><span class="n">resetN</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">resetN</span><span class="p">)</span><span class="w">   </span><span class="n">cnt</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">load</span><span class="p">)</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w">           </span><span class="n">cnt</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">1</span><span class="p">;</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<h3 id="named-ending-statements">named ending statements</h3>
<p>前面介绍了 SV 允许给 begin...end 后面加上名字，以提高代码可读性，实际上很多代码块都可以加上名字：</p>
<ul>
<li>begin...end</li>
<li>package...endpackage</li>
<li>interface...endinterface</li>
<li>task...endtask</li>
<li>function...endfunction</li>
<li>module...endmodule</li>
</ul>
<h3 id="nested-module-declarations">nested module declarations</h3>
<p>Verilog 中的模块默认是全局的可见的，所以在设计中的任何地方都可以访问这些模块的定义。这个机制简单强大，但是有两个问题：</p>
<ul>
<li>模块访问是无限制的，但是有时候我们希望隐藏某些模块，防止外部访问</li>
<li>大型设计中可能产生命名冲突</li>
</ul>
<p>Verilog 虽然可以通过配置文件的方式解决问题，但是不够优雅。SV 为解决这个问题提供了一种方法：嵌套的模块定义。和 C 语言类似，嵌套的模块定义只能被父模块或者是同一层级结构的模块访问。</p>
<p>为了可维护性一般都是一个文件放一个模块，且文件名和模块名相同，嵌套模块的方式显然违背了这个原则，所以嵌套模块应该和 `include 配合使用。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">ip_core</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">);</span>
<span class="w">    </span><span class="no">`include</span><span class="w"> </span><span class="n">sub1</span><span class="p">.</span><span class="n">v</span><span class="p">;</span><span class="w">    </span><span class="c1">// sub1 is a nested module</span>
<span class="w">    </span><span class="no">`include</span><span class="w"> </span><span class="n">sub2</span><span class="p">.</span><span class="n">v</span><span class="p">;</span><span class="w">    </span><span class="c1">// sub2 is a nested module</span>
<span class="k">endmodule</span>

<span class="c1">// stored in file sub1.v</span>
<span class="k">module</span><span class="w"> </span><span class="n">sub1</span><span class="p">(...)</span>
<span class="w">    </span><span class="p">...</span>
<span class="n">endmoudle</span>

<span class="c1">// stored in file sub2.v</span>
<span class="k">module</span><span class="w"> </span><span class="n">sub2</span><span class="p">(...)</span>
<span class="w">    </span><span class="p">...</span>
<span class="n">endmoudle</span>
</code></pre></div></td></tr></table></div>

<h3 id="simplified-netlists-of-module-instances">simplified netlists of module instances</h3>
<p>Verilog 提供了两种端口连接方式：</p>
<ul>
<li>按端口顺序连接：缺点太多，大部分情况都被禁止使用</li>
<li>按端口名连接：优点是不容易出错，缺点是模块和端口数量较多时非常繁琐</li>
</ul>
<p>SV 提供了三种新的连接方式：</p>
<ul>
<li>
<p><code>.name</code> 方式：在许多端口连接上，信号名和端口名是一致的，这个时候就可以用这种方式，结合了端口顺序和端口名两种方式的优点。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">prom</span><span class="w"> </span><span class="n">prom</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">.</span><span class="n">dout</span><span class="w"> </span><span class="p">(</span><span class="n">program_data</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">clk</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">program_address</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

<div class="admonition note">
<p class="admonition-title">Note</p>
<ol>
<li>必须声明和端口同名的，用于连接的 var / net 信号</li>
<li>连线的位宽必须和模块端口保持一致</li>
<li>两个端口的也必须兼容</li>
<li>无法使用 .name 方式连接的端口必须用端口名连接</li>
</ol>
</div>
</li>
<li>
<p><code>.*</code> 方式：比 .name 更进一步，例化模块时连信号名都不需要写，直接用通配符来匹配（条件同 .name）</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">prom</span><span class="w"> </span><span class="n">prom</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">dout</span><span class="w"> </span><span class="p">(</span><span class="n">program_data</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="n">program_address</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>interface 方式：见下一章</p>
</li>
</ul>
<h3 id="net-aliasing">net aliasing</h3>
<p>SV 新增了信号别名的语法，给信号起别名的 assign 语句有点像，但是并不完全相同。因为 assign 是单方向的，等号右边的信号的值可以传递给左边，但是左边的值无法传递给右边，而 <code>alias</code> 是双向的，因为本质上多个名字指向的是同一个资源。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">wire</span><span class="w"> </span><span class="n">reset</span><span class="p">,</span><span class="w"> </span><span class="n">rst</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">,</span><span class="w"> </span><span class="n">rstN</span><span class="p">;</span>

<span class="n">alias</span><span class="w"> </span><span class="n">rst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reset</span><span class="p">;</span>
<span class="n">alias</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resetN</span><span class="p">;</span>
<span class="n">alias</span><span class="w"> </span><span class="n">resetN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rstN</span><span class="p">;</span>

<span class="n">alias</span><span class="w"> </span><span class="n">rst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resetN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rstN</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>使用别名有几个约束：</p>
<ul>
<li>只能给 net 类型起别名</li>
<li>只能在相同类型的 net 直接使用别名</li>
<li>别名必须位宽相同</li>
</ul>
<p>别名也不需要预先显式地声明好才能用，它遵守 Verilg 中模块端口的隐式推断规则可以由工具自动推断出来：</p>
<ul>
<li>alias 两端任何一个未声明的名字都会自动推断出一个 net 类型信号</li>
<li>默认是 wire 类型</li>
<li>如果 net 是模块端口信号，则其位宽和端口一致</li>
<li>如果 net 不是端口信号，则默认是 1-bit</li>
</ul>
<p>虽然 <code>.*</code> 可以减少工作量，但是有个前提条件是：模块端口名必须一样，否则还是得用传统的端口连接方式。而这个问题可以通过 alias 解决：<strong>只需要先用 alias 把不同端口名设置为别名即可，这些模块例化时端口列表只写 <code>.*</code> 即可</strong>。</p>
<h3 id="pass-values-through-module-ports">pass values through module ports</h3>
<p>Verilog 对什么信号可以做作为模块端口有严格的约束，而 SV 基本上把这些限制都去掉了，基本上任何类型都可以作为模块端口，包括任何类型的 packed/unpacked 数组、structure、union、用户自定义类型等。</p>
<p>但是 SV 还是有两个约束，这两个约束都非常直白，都是为了建模的准确性而设立的：</p>
<ul>
<li>第一条是：var 类型只能有一个源驱动。因为 SV 中的 var 只是简单地保存赋值，所以有多个赋值时会保存最后一个赋值，而硬件在多驱动时的硬件行为并不是这样。所以 SV 要求只有 net 类型信号可以有多驱动。</li>
<li>所有 unpacked 类型的信号（struct、union、array）作为端口连接时，必须一模一样，包括维度的数量、每个维度的大小、每个元素的位宽都必须一样。（隐含条件，struct、union 必须用 typedef 才能作为端口连接）。这个条件对 packed 类型并不其作用，因为 packed 类型是按照 vector 来处理的，SV/Verilog 有相应的规则处理位宽不匹配的情况</li>
</ul>
<h3 id="reference-ports">reference ports</h3>
<p>不可综合，略。</p>
<h3 id="enhanced-port-declarations">enhanced port declarations</h3>
<p>Verilog-1995 风格的端口声明已经没有人用了，但是 Verilog-2001 还是有点繁琐，</p>
<ul>
<li>所有端口都必须显式声明方向</li>
<li>多个端口一起声明时，如果要改数据类型则必须连带方向一起声明（下例中的 a, b 和 ci）</li>
<li>多个端口一起声明时，如果要改变端口位宽必须连带方向一起声明（下例中的 result 和 co）<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// verilog-2001</span>
<span class="k">module</span><span class="w"> </span><span class="n">accum</span><span class="w"> </span><span class="p">(</span><span class="k">inout</span><span class="w">  </span><span class="kt">wire</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">data</span><span class="p">,</span>
<span class="w">              </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">  </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">result</span><span class="p">,</span>
<span class="w">              </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w">          </span><span class="n">co</span><span class="p">,</span>
<span class="w">              </span><span class="k">input</span><span class="w">       </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">              </span><span class="k">input</span><span class="w">  </span><span class="n">tril</span><span class="w">         </span><span class="n">ci</span><span class="w">     </span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="c1">// SV</span>
<span class="k">module</span><span class="w"> </span><span class="n">accm</span><span class="w"> </span><span class="p">(</span><span class="kt">wire</span><span class="w">  </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">  </span><span class="n">data</span><span class="p">,</span>
<span class="w">             </span><span class="k">output</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="kt">reg</span><span class="w"> </span><span class="n">co</span><span class="p">,</span>
<span class="w">             </span><span class="k">input</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">tril</span><span class="w"> </span><span class="n">ci</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>一般为了代码健壮性、减少错误，大部分 coding style 都规定还要一行一个端口地声明，不会用到这个特性。</p>
</div>
<h3 id="parameterized-types">parameterized types</h3>
<p>Verilog 中的 parameter 只能参数化端口位宽，SV 新增了一个可综合的新语法 <code>parameter type</code>，可以对端口类型进行参数化，进一步提高了模块的多态性。实际上 Verilog 模块端口类型一般只有 wire/reg，而且是固定的，所以也不需要对类型参数化，而 SV 中有很多类型，甚至用户可以自定义类型，所以类型参数化就有必要了。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">adder</span><span class="w"> </span><span class="p">#(</span><span class="k">parameter</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="n">ADDERTYPE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">shortint</span><span class="p">)</span>
<span class="w">              </span><span class="p">(</span><span class="k">input</span><span class="w">  </span><span class="n">ADDERTYPE</span><span class="w">  </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w">  </span><span class="c1">// redefinable type</span>
<span class="w">               </span><span class="k">output</span><span class="w"> </span><span class="n">ADDERTYPE</span><span class="w">  </span><span class="n">sum</span><span class="p">,</span><span class="w">   </span><span class="c1">// redefinable type</span>
<span class="w">               </span><span class="k">output</span><span class="w"> </span><span class="kt">logic</span><span class="w">      </span><span class="n">carry</span><span class="p">);</span>
<span class="w">    </span><span class="n">ADDERTYPE</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">big_chip</span><span class="w"> </span><span class="p">(...);</span>
<span class="w">    </span><span class="kt">shortint</span><span class="w">        </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">             </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="w">    </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">wire</span><span class="w">            </span><span class="n">carry1</span><span class="p">,</span><span class="w"> </span><span class="n">carry2</span><span class="p">,</span><span class="w"> </span><span class="n">carry3</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 16-bit unsigned adder</span>
<span class="w">    </span><span class="n">adder</span><span class="w">  </span><span class="n">i1</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">carry1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 32-bit signed adder</span>
<span class="w">    </span><span class="n">adder</span><span class="w">  </span><span class="p">#(.</span><span class="n">ADDERTYPE</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span><span class="w">  </span><span class="n">i2</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">carry2</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 32-bit unsigned adder</span>
<span class="w">    </span><span class="n">adder</span><span class="w">  </span><span class="p">#(.</span><span class="n">ADDERTYPE</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="k">unsigned</span><span class="p">))</span><span class="w">  </span><span class="n">i3</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">,</span><span class="w"> </span><span class="n">carry3</span><span class="p">);</span>
<span class="n">endmoudle</span>
</code></pre></div></td></tr></table></div>

<h3 id="summary_5">summary</h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li>必要时给 begin...end 后面加上 name，增强可读性</li>
<li>nested module 和 `include 配合使用</li>
<li>顶层集成用 <code>.*</code> 配合 alias 减少工作量</li>
<li>为了减少错误，避免使用增强型的端口声明语法</li>
</ul>
</div>
<h2 id="chapter-10-systemverilog-interfacees">Chapter 10 Systemverilog Interfacees</h2>
<h3 id="concepts">concepts</h3>
<p>Verilog 中是通过模块端口进行连接，这种方式在端口数量非常多的时候很繁琐，比如说多个模块连接到总线上时，</p>
<ul>
<li>每个模块定义处都要声明总线的所有信号</li>
<li>顶层集成时也要把每个模块的所有端口都写出来</li>
<li>信号很多时连线可能出错</li>
<li>如果总线变了，多个地方都要同步修改</li>
</ul>
<p>SV 新增了一个叫 <code>interface</code> 的语法，可以把一组端口定义成一个端口，这样使用 / 修改起来就非常方便了。interface 并不是简单的把信号组合打包在一起，它里面还可以定义其他功能代码，比如其他离散的信号、接口的协议、检查协议的验证代码等：</p>
<ul>
<li>type declration</li>
<li>task/function</li>
<li>procedural block</li>
<li>program block</li>
<li>assertion<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">interface</span><span class="w"> </span><span class="n">main_bus</span><span class="p">;</span>
<span class="w">    </span><span class="kt">wire</span><span class="w">    </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">wire</span><span class="w">    </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">   </span><span class="p">[</span><span class="w"> </span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">slave_instruction</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">slave_request</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">bus_grant</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">bus_request</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">slave_ready</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">data_ready</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">mem_read</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w">          </span><span class="n">mem_write</span><span class="p">;</span>
<span class="n">endinterface</span>

<span class="k">module</span><span class="w"> </span><span class="n">processor</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">main_bus</span><span class="w">    </span><span class="n">bus</span><span class="p">,</span>
<span class="w">    </span><span class="k">output</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">15</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">jump_address</span>
<span class="w">    </span><span class="c1">//...);</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<h3 id="interface-declration">interface declration</h3>
<p>从语法上来说，interface 的定义和 module 非常像，interface 也可以有端口，这样外部信号就可以被引入 interface  成为信号的一部分。Interface 内部还可以定义任何数据类型，包括 var、net、用户自定义类型等。</p>
<p>Interface 可以定义在全局，就和普通 module 一样，其他 module 可以直接使用 interface，编译顺序对工具没有影响，所以 interface 可以先使用后编译。Interface 也可以定义在一个 module 内部，仅限内部使用。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// 上例的 main_bus 可以把 clock 和 reset 也引入到 interface 中</span>
<span class="n">interface</span><span class="w"> </span><span class="n">main_bus</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">,</span><span class="w"> </span><span class="n">test_mode</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// signal definition</span>
<span class="n">endinterface</span>

<span class="k">module</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">,</span><span class="w"> </span><span class="n">test_mode</span><span class="p">);</span>

<span class="w">    </span><span class="n">main_bus</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="p">(.</span><span class="o">*</span><span class="p">);</span><span class="w">  </span><span class="c1">// using .* connections</span>

<span class="w">    </span><span class="c1">// method 1</span>
<span class="w">    </span><span class="n">processor</span><span class="w"> </span><span class="n">proc1</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="p">.</span><span class="n">bus</span><span class="w"> </span><span class="p">(</span><span class="n">bus</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">jump_address</span><span class="w"> </span><span class="p">(</span><span class="n">jump_address</span><span class="p">),</span>
<span class="w">        </span><span class="p">.</span><span class="n">instruction</span><span class="w"> </span><span class="p">(</span><span class="n">instruction</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="c1">// method 2</span>
<span class="w">    </span><span class="n">processor</span><span class="w"> </span><span class="n">proc1</span><span class="w"> </span><span class="p">(.</span><span class="o">*</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

<h3 id="using-interface-as-module-ports">using interface as module ports</h3>
<p>Interface 可以作为 module 端口的一部分，而且不需要声明 input/output 等方向。一共有两种方式声明 interface 端口：</p>
<ul>
<li>使用 interface 的名字来声明 module 端口，这种端口只能连接到同名的 interface 端口上，目的是避免端口不匹配（推荐使用）</li>
<li>直接用 <code>interface</code> 这个关键字来声明端口，这种是通用的 interface 端口，其他任何类型的 interface 端口都可以连接到这个端口上（避免使用）</li>
</ul>
<p>这两种写法都是可综合的。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// method 1</span>
<span class="c1">// module &lt;module_name&gt; (&lt;interface_name&gt; &lt;port_name&gt;);</span>

<span class="n">interface</span><span class="w"> </span><span class="n">chip_bus</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="n">endinterface</span>

<span class="k">module</span><span class="w"> </span><span class="n">CACHE</span><span class="w"> </span><span class="p">(</span><span class="n">chip_bus</span><span class="w"> </span><span class="n">pins</span><span class="p">,</span>
<span class="w">              </span><span class="k">input</span><span class="w">    </span><span class="n">clcok</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="c1">// method 2</span>
<span class="c1">// module &lt;module_name&gt; (interface &lt;port_name&gt;);</span>
<span class="k">module</span><span class="w"> </span><span class="n">RAM</span><span class="w"> </span><span class="p">(</span><span class="n">interface</span><span class="w"> </span><span class="n">pins</span><span class="p">,</span>
<span class="w">            </span><span class="k">input</span><span class="w">     </span><span class="n">clock</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<h3 id="instantiating-and-connecting-interface">instantiating and connecting interface</h3>
<p>interface 和 module 一样都可以例化，然后连接起来，连接的语法也和 module 一样，可以用 .name，.* 等方式（前面 main_bus 的例子）。interface 还可以嵌套，比如 sub_bus 和 main_bus 都可以定义成 interface，且 sub_bus 是 main_bus 的组成部分。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>一个 module 的 interface 端口必须连接到其他 interface instance 或者是另外一个 module 的 interface 端口上，不能悬空。</p>
</div>
<h3 id="referencing-signals-within-an-interface">referencing signals within an interface</h3>
<p>使用 interface 中的信号必须通过下面的方式：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// &lt;port_name&gt;.&lt;internal_interface_signal_name&gt;</span>

<span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">bus</span><span class="p">.</span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="k">negedge</span><span class="w"> </span><span class="n">bus</span><span class="p">.</span><span class="n">resetN</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div></td></tr></table></div>

<p>因为这种方式必须把端口名前缀加上，所以为了减少工作量、提高可读性，建议给 port 起个简短的名字。</p>
<h3 id="interface-modports">interface modports</h3>
<p>interface 为模块端口连接提供了一种新方式，但是从不同模块的角度看，端口是不一样的。比如一组总线，从 slave 模块看，interrupt_request 很可能是输出端口，而从 master 模块看，它是一个输入端口。SV 提供了一种新语法来解决这个问题：用 module port 的缩写 <code>modport</code> 关键字来定义端口。一个 interface 可以有任意多个 modport，每个 modport 描述了每个相关模块角度看到的 interface 端口的方向。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">interface</span><span class="w"> </span><span class="n">chip_bus</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="n">interrupt_request</span><span class="p">,</span><span class="w"> </span><span class="n">grant</span><span class="p">,</span><span class="w"> </span><span class="n">ready</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">;</span>
<span class="w">    </span><span class="kt">logic</span><span class="w"> </span><span class="p">[</span><span class="mh">63</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>

<span class="w">    </span><span class="n">modport</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w">  </span><span class="n">interrupt_request</span><span class="p">,</span>
<span class="w">                    </span><span class="k">input</span><span class="w">  </span><span class="n">address</span><span class="p">,</span>
<span class="w">                    </span><span class="k">output</span><span class="w"> </span><span class="n">grant</span><span class="p">,</span><span class="w"> </span><span class="n">ready</span><span class="p">,</span>
<span class="w">                    </span><span class="k">inout</span><span class="w">  </span><span class="n">data</span><span class="p">,</span>
<span class="w">                    </span><span class="k">input</span><span class="w">  </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="w">    </span><span class="n">modport</span><span class="w"> </span><span class="n">slave</span><span class="w">  </span><span class="p">(</span><span class="k">output</span><span class="w"> </span><span class="n">interrupt_request</span><span class="p">,</span>
<span class="w">                    </span><span class="k">output</span><span class="w"> </span><span class="n">address</span><span class="p">,</span>
<span class="w">                    </span><span class="k">input</span><span class="w">  </span><span class="n">grant</span><span class="p">,</span><span class="w"> </span><span class="n">ready</span><span class="p">,</span>
<span class="w">                    </span><span class="k">inout</span><span class="w">  </span><span class="n">data</span><span class="p">,</span>
<span class="w">                    </span><span class="k">input</span><span class="w">  </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="n">endinterface</span>
</code></pre></div></td></tr></table></div>

<p>如上所示，modport 的定义不需要包含 vector 的位宽及数据类型（这些信息在 interface 中已定义好），只需要定义方向即可。</p>
<p>定义好之后，具体使用时要声明是从哪个角度看待 interface，即要选择具体是哪个 modport。SV 提供了两种方式：</p>
<ul>
<li>
<p>modport 作为 interface 的一部分在模块<strong>例化时</strong>确定（避免使用）</p>
<p>同时例化一个 module 和 interface，然后在连接它们时确定 modport。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// &lt;interface_instance_name&gt;.&lt;modport_name&gt;</span>

<span class="k">interface</span><span class="w"> </span><span class="n">chip_bus</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
<span class="w">    </span><span class="k">modport</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="p">(...);</span>
<span class="w">    </span><span class="k">modport</span><span class="w"> </span><span class="n">slave</span><span class="w">  </span><span class="p">(...);</span>
<span class="k">endinterface</span>

<span class="k">module</span><span class="w"> </span><span class="n">primary</span><span class="w">  </span><span class="p">(</span><span class="k">interface</span><span class="w"> </span><span class="n">pins</span><span class="p">);</span><span class="w">   </span><span class="c1">// generic interface port</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">secondary</span><span class="w"> </span><span class="p">(</span><span class="n">chip_bus</span><span class="w"> </span><span class="n">pins</span><span class="p">);</span><span class="w">   </span><span class="c1">// specific interface port</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">chip</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="w">    </span><span class="n">chip_bus</span><span class="w">    </span><span class="n">bus</span><span class="w"> </span><span class="p">(</span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="w">    </span><span class="n">primary</span><span class="w">     </span><span class="n">i1</span><span class="w">  </span><span class="p">(</span><span class="n">bus</span><span class="p">.</span><span class="n">master</span><span class="p">);</span>

<span class="w">    </span><span class="n">secondary</span><span class="w">   </span><span class="n">i2</span><span class="w">  </span><span class="p">(</span><span class="n">bus</span><span class="p">.</span><span class="n">slave</span><span class="p">);</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>modport 作为模块端口的一部分在模块<strong>定义时</strong>确定（推荐使用）</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// &lt;interface_name&gt;.&lt;modport_name&gt;</span>

<span class="k">interface</span><span class="w"> </span><span class="n">chip_bus</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
<span class="w">    </span><span class="k">modport</span><span class="w"> </span><span class="n">master</span><span class="w"> </span><span class="p">(...);</span>
<span class="w">    </span><span class="k">modport</span><span class="w"> </span><span class="n">slave</span><span class="w">  </span><span class="p">(...);</span>
<span class="k">endinterface</span>

<span class="k">module</span><span class="w"> </span><span class="n">primary</span><span class="w">  </span><span class="p">(</span><span class="n">chip_bus</span><span class="p">.</span><span class="n">master</span><span class="w"> </span><span class="n">pins</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">secondary</span><span class="w"> </span><span class="p">(</span><span class="n">chip_bus</span><span class="p">.</span><span class="n">slave</span><span class="w"> </span><span class="n">pins</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">chip</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="w">    </span><span class="n">chip_bus</span><span class="w">    </span><span class="n">bus</span><span class="w"> </span><span class="p">(</span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>

<span class="w">    </span><span class="n">primary</span><span class="w">     </span><span class="n">i1</span><span class="w">  </span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

<span class="w">    </span><span class="n">secondary</span><span class="w">   </span><span class="n">i2</span><span class="w">  </span><span class="p">(</span><span class="n">bus</span><span class="p">);</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>这两种风格都是可综合的，但是只能选择其中一种，不能同时混用：在定义和例化时都使用 modport 会报错。</p>
<p>即使 interface 中定义了 modport，但是实际中没有使用时，信号会有默认的方向：</p>
<ul>
<li>所有的 net 都是双向端口 <code>inout</code></li>
<li>所有的 var 都是 <code>ref</code> 类型端口</li>
</ul>
<p>在实际使用过程中，很有可能出现这种情况：interface 定义了一大组信号，但是不同 module 分别只需要看到其中的部分信号。显然把 interface 的所有信号都连到每个 module 上很浪费；而为每个 module 定义各自的 interface 又失去了 interface 的意义。</p>
<p>使用 modport 可以为每个 module 定义一种不同的 interface view，从而解决这个问题。因为每个 module 只能访问 modport 内的信号，所以可以利用这个特性对某些 module 隐藏 interface 中的特定信号。如果一个 module 没有用 modport 连接 interface，那么 interface 中定义的信号这个 module 都可以访问。</p>
<h3 id="using-taskfunction-in-interface">using task/function in interface</h3>
<p>假设有个 master 和 slave 通过总线交互的场景，在传统的 Verilog 代码中，master 和 slave 必须各自包含一些监控端口和处理握手的逻辑。这些逻辑分散在 master 和 slave 模块的定义中，会导致功能重叠的代码，而且不易维护，一旦总线有任何修改，相应的所有模块都需要修改。</p>
<p>SV 的 interface 内部可以定义 function/task，从而可以把总线相关的逻辑功能代码都放在 interface 中集中管理，这样相关逻辑代码只需要写一次。这些 function/task 叫做 interface method，它们可以像在 module 中一样，访问 interface 内的任何信号。具体使用时，module 首先连接到 interface，然后通过端口名前缀的方式就可以使用某个 method 了。</p>
<p>如果 interface 是通过 modport 使用，那么 method 必须通过 <code>import</code> 导入在 modport 内，有两种方式可用：</p>
<ul>
<li>
<p>通过 method 名导入</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// modport (import &lt;task_function_name&gt;);</span>

<span class="k">modport</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="k">import</span><span class="w"> </span><span class="n">Read</span><span class="p">,</span>
<span class="w">            </span><span class="k">import</span><span class="w"> </span><span class="n">parity_en</span><span class="p">,</span>
<span class="w">            </span><span class="k">input</span><span class="w">  </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

</li>
<li>
<p>通过 method 原型导入</p>
<p>这种方式要求 import 后面加上 task/function 关键字，method 名字后面还要有包含参数的圆括号。如果 interface 定义在另外一个 package 文件中时，这种方式可以提高代码可读性。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// modport (import task &lt;task_name&gt;(&lt;task_formal_arguments));</span>
<span class="c1">// modport (import function &lt;function_name&gt;(&lt;formal_args));</span>

<span class="k">modport</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="p">(</span><span class="k">import</span><span class="w"> </span><span class="k">task</span><span class="w"> </span><span class="n">Read</span><span class="p">(</span><span class="k">input</span><span class="w">  </span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">,</span>
<span class="w">                             </span><span class="k">output</span><span class="w"> </span><span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">address</span><span class="p">),</span>
<span class="w">            </span><span class="k">import</span><span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="n">parity_gen</span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="p">[</span><span class="mi">63</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">data</span><span class="p">),</span>
<span class="w">            </span><span class="k">input</span><span class="w">  </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>

</li>
</ul>
<p>通过 modport 把 function/task 导入之后，module 就可以使用这些逻辑了，使用方式和使用 interface 内的信号一样，加上 interface 端口名前缀即可。</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>为了保证可综合，导入的 task/function 必须是 automatic 类型，而且内部不能包含 static 声明。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">interface</span><span class="w"> </span><span class="n">math_bus</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a_int</span><span class="p">,</span><span class="w"> </span><span class="n">b_int</span><span class="p">,</span><span class="w"> </span><span class="n">result_int</span><span class="p">;</span>

<span class="w">    </span><span class="k">task</span><span class="w"> </span><span class="n">IntegerRead</span><span class="w"> </span><span class="p">(</span><span class="k">output</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a_int</span><span class="p">,</span><span class="w"> </span><span class="n">b_int</span><span class="p">);</span>
<span class="w">        </span><span class="p">...</span><span class="w"> </span><span class="c1">// do handshaking to fetch a and b values</span>
<span class="w">    </span><span class="k">endtask</span>

<span class="w">    </span><span class="n">modport</span><span class="w"> </span><span class="n">int_io</span><span class="w"> </span><span class="p">(</span><span class="n">import</span><span class="w"> </span><span class="n">IntegerRead</span><span class="p">,</span>
<span class="w">                    </span><span class="k">input</span><span class="w">  </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">,</span>
<span class="w">                    </span><span class="k">output</span><span class="w"> </span><span class="n">result_int</span><span class="p">);</span>
<span class="n">endinterface</span>

<span class="k">module</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="p">(</span><span class="k">input</span><span class="w"> </span><span class="kt">logic</span><span class="w"> </span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span>
<span class="w">    </span><span class="n">math_bus</span><span class="w"> </span><span class="n">bus</span><span class="w"> </span><span class="p">(</span><span class="n">clock</span><span class="p">,</span><span class="w"> </span><span class="n">resetN</span><span class="p">);</span><span class="w">   </span><span class="c1">// instance of interface</span>

<span class="w">    </span><span class="n">integer_math_unit</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="p">(</span><span class="n">bus</span><span class="p">.</span><span class="n">int_io</span><span class="p">);</span><span class="w">  </span><span class="c1">// connect to interface</span>
<span class="k">endmodule</span>

<span class="k">module</span><span class="w"> </span><span class="n">integer_math_unit</span><span class="w"> </span><span class="p">(</span><span class="n">interface</span><span class="w"> </span><span class="n">io</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a_reg</span><span class="p">,</span><span class="w"> </span><span class="n">b_reg</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">io</span><span class="p">.</span><span class="n">clock</span><span class="p">)</span>
<span class="w">        </span><span class="n">io</span><span class="p">.</span><span class="n">IntegerRead</span><span class="p">(</span><span class="n">a_reg</span><span class="p">,</span><span class="w"> </span><span class="n">b_reg</span><span class="p">);</span><span class="w">   </span><span class="c1">// call method in interface</span>
<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

</div>
<h3 id="using-procedural-blocks-in-interface">using procedural blocks in interface</h3>
<p>interface 内部还可以定义 <code>always</code>, <code>always_comb</code>, <code>always_ff</code>, <code>always_latch</code>, <code>initial</code>, <code>final</code>, <code>assign</code> 等语句块，在 Interface 中定义这些语句块的一种应用场景是做验证：在 interface 中定义相关协议的 checker，这样每次通过 interface 传递数据时，内置的 checker 会自动检查是否满足相关约束。</p>
<h3 id="reconfigurable-interface">reconfigurable interface</h3>
<p>interface 可以像 module 一样使用 parameter，也可以使用 generate 语句，所以可以定义参数化的 interface，方便复用。
（example 10-12）</p>
<h3 id="summary_6">summary</h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<ul>
<li>named interface port 和 generic interface ports 都是可综合的</li>
<li>modport 的两种使用方式都是可综合的</li>
<li>module 导入 interface 中的 function/task 是可综合的，综合时会自动在模块中产生一份本地电路，综合后的模块内已经包含了这些逻辑，不再需要去 interface 中查询</li>
<li>永远不要使用 task，用 void function 代替 task</li>
</ul>
</div>
<h2 id="chapter-11-a-complete-design-modeled-with-systemverilog">Chapter 11 A Complete Design Modeled with SystemVerilog</h2>
<p>一个用 SV 设计的通信领域的异步传输机制 ATM (Asynchronous Transfer Mode) 原型，用到了以下特性：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>解决方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>动态表示相同长度的两种数据包</td>
<td>用 packed struct + packed union 封装不同数据类型</td>
</tr>
<tr>
<td>定义总线</td>
<td>用 interface(modport + method) 封装总线接口和协议、简化代码</td>
</tr>
<tr>
<td>定义多种实现方式</td>
<td>带 parameter 的可重定义 interface</td>
</tr>
<tr>
<td>全局定义</td>
<td>类似 C 语言的 include 头保护 <code>ifndef</code>...<code>define</code>...<code>endif</code></td>
</tr>
<tr>
<td>定义状态机的状态</td>
<td>enum 类型</td>
</tr>
<tr>
<td>定义状态机跳转</td>
<td>使用 unique case</td>
</tr>
<tr>
<td>generate 语句</td>
<td>index 自增减少代码量</td>
</tr>
<tr>
<td>多层 begin...end 嵌套</td>
<td>加上 label 增强可读性</td>
</tr>
<tr>
<td>封装功能代码</td>
<td>module 内定义 function</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="chapter-12-behavioral-and-transaction-level-modeling">Chapter 12 Behavioral and Transaction Level Modeling</h2>
<p>虽然有些特定的综合工具可以处理特定的 TLM，大部分情况下 Transaction Level Modeling(TLM) 大部分情况下都是不可综合的，略。</p>
<h2 id="_1">附录</h2>
<p>一些 SV 的参考资源：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>Syntax</td>
<td><ul><li><a href="https://book.douban.com/subject/1764888/">SystemVerilog for Design</a></li><li><a href="https://www.sutherland-hdl.com/books_and_guides.html">RTL Modeling with SystemVerilog For Simulation and Synthesis</a></li><li><a href="https://book.douban.com/subject/2859647/">Verilog and SystemVerilog gotchas</a></li></ul></td>
</tr>
<tr>
<td>Coding Style</td>
<td><ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md">lowRISC coding style guide</a></li></ul></td>
</tr>
</tbody>
</table>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="https://qian-gu.github.io/posts/risc-v/risc-v-spec-notes-2-privileged.html" title="RISC-V Spec 阅读笔记 #2 —— Privileged ISA">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="https://qian-gu.github.io/posts/ic/verilog-and-systemverilog-gotchas-notes.html" title="《Verilog and SystemVerilog gotchas》笔记">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="https://qian-gu.github.io/posts/ic/verilog-and-systemverilog-gotchas-notes.html">《Verilog and SystemVerilog gotchas》笔记</a></li>
    </ul>
  </div>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-1821536199377100"
         data-ad-slot="4843941849"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

<!-- Gitalk -->
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://qian-gu.github.io/theme/gitalk/md5.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '4b3de26a6e80be727416',
  clientSecret: '993d79339c842fc56d9739ef268f38806dc93f50',
  repo: 'qian-gu.github.io',
  owner: 'qian-gu',
  admin: ['qian-gu'],
  id: md5(location.href),
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- End Gitalk -->
</article>

<footer>
<p>
  &copy; 2025  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://qian-gu.github.io/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="ligtht"
          type="text/javascript">
  </script>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://qian-gu.github.io/theme/img/cc/by-sa.png"
         width="80"
         height="15"/>
  </a>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Qian's Blog ",
  "url" : "https://qian-gu.github.io",
  "image": "https://qian-gu.github.io/images/logo.png",
  "description": "Qian's Thoughts and Writings"
}
</script><a href="https://github.com/qian-gu/qian-gu.github.io" target="_blank" class="github-corner" aria-label="View source on Github">
    <svg width="80"
         height="80"
         viewBox="0 0 250 250"
         style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
         aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor"
              style="transform-origin: 130px 106px;"
              class="octo-arm">
        </path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor"
              class="octo-body">
        </path>
    </svg>
</a>
  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://qian-gu.github.io/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://qian-gu.github.io/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://qian-gu.github.io/theme/stork/stork.js"></script>

</body>
</html>