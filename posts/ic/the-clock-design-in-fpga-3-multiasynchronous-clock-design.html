
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark)"
    href="https://qian-gu.github.io/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://qian-gu.github.io/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="/static/custom.css">

  <link rel="shortcut icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">
  <link rel="icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Microsoft EDGE -->
  <meta name="msapplication-TileColor" content="#333333">

  <link href="https://qian-gu.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Qian's Blog Atom">


<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48826831-1', 'auto');
  ga('send', 'pageview');
</script>






 

<meta name="author" content="Qian Gu" />
<meta name="description" content="总结 FPGA 中跨时钟域的设计" />
<meta name="keywords" content="clock design">


  <meta property="og:site_name" content="Qian's Blog"/>
  <meta property="og:title" content="FPGA 时钟设计 3 —— 跨时钟域设计"/>
  <meta property="og:description" content="总结 FPGA 中跨时钟域的设计"/>
  <meta property="og:locale" content="en"/>
  <meta property="og:url" content="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-3-multiasynchronous-clock-design.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2014-10-09 23:01:00+08:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://qian-gu.github.io/author/qian-gu.html">
  <meta property="article:section" content="IC"/>
  <meta property="article:tag" content="clock design"/>
  <meta property="og:image" content="https://qian-gu.github.io/images/logo.png">

  <title>Qian's Blog &ndash; FPGA 时钟设计 3 —— 跨时钟域设计</title>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-1821536199377100",
      enable_page_level_ads: true
    });
  </script>

</head>
<body >

<aside>
  <div>
    <a href="https://qian-gu.github.io/">
      <img src="https://qian-gu.github.io/images/logo.png" alt="Qian Gu" title="Qian Gu">
    </a>

    <h1>
      <a href="https://qian-gu.github.io/">Qian Gu</a>
    </h1>

    <p>Read >> Think >> Write</p>

    <div class="stork">
      <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick="loadStorkIndex()"/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>

    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://qian-gu.github.io/pages/about-me.html#about-me">
                About Me
              </a>
            </li>

      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-envelope"
rel="me"           href="mailto:guqian110@163.com"
           target="_blank">
          <i class="fa-solid fa-envelope"></i>
        </a>
      </li>
      <li>
        <a class="sc-github"
           href="https://github.com/qian-gu"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-twitter"
           href="https://twitter.com/qian_gu"
           target="_blank">
          <i class="fa-brands fa-twitter"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/feeds/all.atom.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://qian-gu.github.io/">Home</a>

  <a href="/authors.html">Authors</a>
  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://qian-gu.github.io/feeds/all.atom.xml">Atom</a>

</nav>

<article class="single">
  <header>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.1.0/css/all.css" rel="stylesheet">
      
    <h1 id="the-clock-design-in-fpga-3-multiasynchronous-clock-design">FPGA 时钟设计 3 —— 跨时钟域设计</h1>
    <p>
      Posted on 2014-10-09 23:01 in <a href="https://qian-gu.github.io/category/ic.html">IC</a>

    </p>
    <div class="tag-cloud">
      <p>
        <a href="https://qian-gu.github.io/tag/clock-design.html">clock design</a>
      </p>
    </div>
  </header>



  <div>
    <h2 id="problem">Problem</h2>
<p>在前面一篇总结 <a href="http://guqian110.github.io/pages/2014/09/23/latch-versus-flip-flop.html">Latch V.S. Flip-flop</a> 的博文中，已经解释了 flip-flop 的一些参数：建立时间 <code>setup time</code>、保持时间 <code>hold time</code>、恢复时间 <code>recovery time</code>、撤销时间 <code>removal time</code>。</p>
<p>如果不满足这些参数的要求，则会发生所谓的 亚稳态 <code>Metastability</code> 的问题。下面是 Altera 官方的一篇关于亚稳态的 white paper，详细介绍了亚稳态的产生原因、它是如何导致设计出现问题、以及描述它的参数 MTBF (Mean Time Between Failures) 如何计算。</p>
<p><a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf">Understanding Metastability in FPGAs</a></p>
<p>我们知道，一般只涉及单时钟域的设计并不多见，尤其是对于一些复杂的应用，FPGA 往往需要和多个时钟域的信号进行通信，而这些时钟之间的关系一般都是频率不同、相位也不同，也就是不同频不同相的多异步时钟域设计 <code>Mulit-Asynchronous Clock Design</code>。</p>
<p>因为这些时钟信号之间的关系一般既不同频也不同相，所以一个时钟域的信号对于另外一个时钟域来说是异步信号，那么就无法保证进入新时钟域的信号和新的时钟信号之间满足 setup/hold time 的要求，自然就会引起亚稳态的问题。</p>
<p>在 Clifford E. Cummings 大神的 paper：<a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf">Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs</a> 里面就举例说明了这种现象：</p>
<p><strong>Reason</strong></p>
<blockquote>
<p>"When sampling a changing data signal with a clock ... the order of the events determines the outcome. The smaller the time difference between the events, the longer it takes to determine which came first. When two events occur very close together, the decision process can take longer than the time allotted, and a synchronization failure occurs."</p>
</blockquote>
<p>**Illustation 1: **</p>
<p><img alt="failure" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronization-failure.png"></p>
<p>**Illustation 2: **</p>
<p>如果不加处理，亚稳态产生的错误值将会传播到设计的其他部分，导致更加严重的问题</p>
<p><img alt="propagatetion" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/propagation.png"></p>
<h2 id="synchronous-design">Synchronous Design</h2>
<p>多时钟域导致的亚稳态的问题的根本原因就是：信号和时钟是异步的，也就是设计不是同步设计 <code>Synchronous Design</code>。</p>
<p><strong>同步化设计思想</strong> 是 FPGA 中非常重要的原则：</p>
<p><strong>Asynchronous Circuits</strong></p>
<p>同步电路的核心逻辑是用 组合逻辑 <code>combination logic</code> 实现的，比如异步 FIFO/RAM 读写信号、地址译码等电路。电路的主要信号、输出信号不依赖任何一个时钟信号，不是由时钟信号驱动 flip-flop 产生的。<em>异步电路最大的缺点就是容易产生毛刺。</em></p>
<p><strong>Synchronous Circuits</strong></p>
<p>同步电路的核心逻辑是用 时序逻辑 <code>sequential logic</code> 实现的。电路的主要信号、输出信号是由某个时钟沿驱动 flip-flop 产生的。<em>同步电路可以很好的避免毛刺。</em></p>
<p><strong>Synchronous V.S. Asynchronous</strong></p>
<p><a href="http://book.douban.com/subject/10593491/">Xilinx FPGA 高级设计及应用</a></p>
<blockquote>
<p>从 ASIC 设计的角度来看，大约需要 7 个门来实现一个 D 触发器，而一个门即可实现一个 2 输入与非门，所以一般来说，在 ASIC 设计中，同步时序电路比异步电路占用更大的面积。但是，由于 FPGA 是定制好的底层单元，对于 Xilinx 器件，一个底层可编程单元 Slice 包含两个触发器（FF）和一个查找表（LUT）。其中触发器用以实现同步电路，查找表用以实现组合电路。FPGA 最终使用率用 Slice 来衡量。所以对于某个选定器件，其可实现的同步电路和异步电路的资源数量和比例是固定的，这点造成了过度使用查找表会浪费触发器资源，反之亦然。因而对于 FPGA，同步时序设计不一定比异步设计多消耗资源。单从节约资源的角度考虑，应该按照芯片配置的资源比例实现设计，但是设计者还要时刻权衡同步设计没有毛刺、信号稳定等优点，<strong>所以对于 FPGA 设计推荐采用同步设计。</strong></p>
<p>无论是用离散逻辑、可编程逻辑，还是用全定制硅器件实现的任何数字逻辑，为了成功操作，可靠的时钟是非常关键的。</p>
<p>...</p>
<p><strong>因为，FPGA 同步设计中最好的时钟解决方案是由专用全局时钟输入引脚驱动单个主时钟去控制设计项目中的每一个触发器。系统中各个功能模块使用同一同步复位信号。</strong></p>
<p>...</p>
<p><strong>FPGA 同步设计中，时序电路应尽量采用同步电路，尽可能使用同步器件，尽量减小或不使用门控时钟（为了降低系统功耗以外）。设计中不用系统主时钟经过逻辑运算得到控制信号，避免使用非时钟信号作为触发器的时钟输入。</strong></p>
</blockquote>
<p>下面提到的所有方法，就是同步化思想的应用，其核心目的就是将本时钟域外的 <strong>异步信号同步化</strong>。</p>
<h2 id="solution">Solution</h2>
<h3 id="solution-1-daul-rank-synchronizer">Solution 1: Daul Rank Synchronizer</h3>
<p>通常使用 <code>MTBF (Mean Time Between Failures)</code> 来描述 flip-flop 亚稳态指标，MTBF 越大，表示出现故障的间隔越大，表示设计越可靠。</p>
<p>以一个典型的 0.25 us 工艺的 ASIC 库中的 flip-flop 的参数计算可以得到 MTBF = 2.01 d，即两天就会出现一次亚稳态。显然这是不能接受的，但是如果将两个 flip-flop 级联在一起，计算结果则变成了 9.57×109 years，显然这个概率基本就可以忽略不计，可以看作是消除了亚稳态。</p>
<p>理论上，亚稳态是不可能完全消除的，一般级联多少个 flip-flop，由实际指标要求和设计者的强迫症习惯决定，对于普通的应用来说，2 级 flip-flop 级联已经足够了。</p>
<p>如图所示：</p>
<p><img alt="synchronizer" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer.png"></p>
<p>通常，同步器 synchronizer 由两个 flip-flop 串联而成，它们中间没有其他的组合电路。第一个 flip-flop 有很大的可能性会产生亚稳态，但是当第二个 flip-flop 获得前一个 flip-flop 的输出时，前一个 flip-flop 已经退出了亚稳态，并且输出稳定，这样就避免了第一级 flip-flop 的亚稳态对下一级逻辑造成的影响。</p>
<p>为了让 synchronizer 正常工作，从某个 时钟域传递过来的信号应该先通过原时钟域的一个 flip-flop，然后不经过两个时钟域间的任何组合逻辑，直接进入 synchronizer。之所以这样要求，是因为 synchronizer 的第一级 flip-flop 对组合逻辑产生的毛刺非常敏感，如果一个足够长的信号毛刺正好满足 setup/hold time 的要求，那么它就会通过 synchronizer，给新时钟域后续逻辑一个虚假的信号。</p>
<p>synchronizer 有很多设计方法，因为一种方法不能满足所有的应用需求。synchronizer 的类型基本上分为 3 种：</p>
<ol>
<li>
<p>level synchronizer</p>
</li>
<li>
<p>edge-detecting synchronizer</p>
</li>
<li>
<p>pulse synchronizer</p>
</li>
</ol>
<p>下面分别讨论：</p>
<h4 id="level-synchronizer">level synchronizer</h4>
<p><strong>Schematic:</strong></p>
<p>电平同步器的结构图就是前面的图，在 Clifford E. Cummings 的 <a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf">paper</a> 中有更详细的图解说明：</p>
<p><img alt="level" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/level.png"></p>
<p><strong>Code:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">LVLSYNC</span><span class="p">(</span>
<span class="w">    </span><span class="k">input</span><span class="w">           </span><span class="n">clk</span><span class="o">-</span><span class="n">src</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="k">input</span><span class="w">           </span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">           </span><span class="n">dat</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>

<span class="w">    </span><span class="k">input</span><span class="w">           </span><span class="n">clk</span><span class="o">-</span><span class="n">dst</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">           </span><span class="n">rst</span><span class="o">-</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="k">output</span><span class="w">  </span><span class="kt">reg</span><span class="w">     </span><span class="n">dat</span><span class="o">-</span><span class="n">dst</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="c1">/////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// source time domain</span>
<span class="w">    </span><span class="c1">/////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="kt">reg</span><span class="w">         </span><span class="n">dat</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">dat</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">dat</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">dat</span><span class="o">-</span><span class="n">src</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1">////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// destination time domain</span>
<span class="w">    </span><span class="c1">////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="kt">reg</span><span class="w">         </span><span class="n">dat</span><span class="o">-</span><span class="n">r</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// using two level DFF to synchronize the din-q</span>
<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="o">-</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="o">-</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">dat</span><span class="o">-</span><span class="n">r</span><span class="w">   </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">            </span><span class="n">dat</span><span class="o">-</span><span class="n">dst</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">dat</span><span class="o">-</span><span class="n">r</span><span class="w">   </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">dat</span><span class="p">;</span>
<span class="w">            </span><span class="n">dat</span><span class="o">-</span><span class="n">dst</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">dat</span><span class="o">-</span><span class="n">r</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<p><strong>RTL:</strong></p>
<p><img alt="level rtl" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/lvl-rtl.png"></p>
<p><strong>Restriction:</strong></p>
<p>使用 level synchronizer 的要求是：</p>
<ol>
<li>
<p>源时钟域的信号应先通过源时钟域的一个 DFF 后输出，然后直接进入目的时钟域的 synchronizer 的第一级 DFF。这样做的</p>
<p>这么做到原因是：synchronizer 的第一级 DFF 对组合逻辑产生的毛刺（glitch）非常敏感。如果一个足够长的毛刺刚好满足了 setup/hold time，那么 synchronizer 会将其放行，产生一个虚假的信号。</p>
</li>
<li>
<p>跨域时钟域的这个信号持续时间 &gt;= 2 个新时钟域时钟周期。</p>
<p>虽然 <a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf">Crossing the abyss: asynchronous signals in a synchronous world</a> 中是这么写的，但是我觉得这个条件应该是保险条件，而不是最低条件。level synchronizer 的最低条件应该和 edge-detecting synchronizer 相同：</p>
<p>输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。</p>
<p>首先，待同步到信号宽度 &gt; 源时钟周期，这样它才能被源时钟域的 DFF 采样到，然后输出；</p>
<p>其次，源时钟域采样输出端信号的宽度当然是源时钟周期的整数倍，它的宽度 &gt; 目标时钟域周期 + 第一个 flip-flop 的 hold time，这样它才能被目的时钟域的时钟采样到，然后进行同步。</p>
<p>所以，保险一点的条件是：待同步到信号有效时间至少是目的时钟周期的 2 倍。</p>
</li>
</ol>
<p><em>level synchronizer 是其他两种同步器的基础：</em></p>
<h4 id="edge-detecting-synchronizer">edge-detecting synchronizer</h4>
<p>边沿检测同步器 是在 level synchronizer 的输出端增加了一个 flip-flop，如下图所示。这个电路的功能是实现上升沿检测，产生一个和时钟周期等宽，高电平有效的脉冲；如果将与门的两个输入端交换，则会完成下降沿检测。如果改为非门，则可以得到一个低电平脉冲有效的电路。</p>
<p><strong>Schematic:</strong></p>
<p><img alt="edge-detecting" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/edge-detecting.png"></p>
<p><strong>Code:</strong></p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">EDGESYNC</span><span class="p">(</span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">clk</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">dat</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>

<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">clk</span><span class="o">-</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">rst</span><span class="o">-</span><span class="n">dst</span><span class="p">,</span>
<span class="w">    </span><span class="k">output</span><span class="w">  </span><span class="n">dat</span><span class="o">-</span><span class="n">dst</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="c1">/////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// source time domain</span>
<span class="w">    </span><span class="c1">/////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="kt">reg</span><span class="w">     </span><span class="n">dat</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">dat</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">dat</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">dat</span><span class="o">-</span><span class="n">src</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1">////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// destination time domain</span>
<span class="w">    </span><span class="c1">////////////////////////////////////////////////////////////</span>
<span class="w">    </span><span class="kt">reg</span><span class="w">     </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="o">-</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="o">-</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">{</span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">],</span><span class="w"> </span><span class="n">dat</span><span class="p">};</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1">// AND to get the output</span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">dat</span><span class="o">-</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">~</span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">[</span><span class="mh">2</span><span class="p">]);</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<p><strong>RTL:</strong></p>
<p>...</p>
<p><strong>Restriction:</strong></p>
<p>使用 edge-detecting synchronizer 的要求是：</p>
<ol>
<li>
<p>输入信号的宽度 &gt;= 目标时钟域周期 + 第一个 flip-flop 的 hold time。最保险的脉冲宽度是同步周期的两倍。</p>
<p>实际上，因为在源时钟域，要先用 DFF 寄存一下再输出，所以源时钟域输出的信号的宽度是其时钟周期的整数倍，它肯定是 &gt; 目标时钟周期的，因为 edge-detecting synchronizer 只能工作在慢时钟域到快时钟域的情况下。</p>
</li>
</ol>
<p><em>edge-detecting synchronizer 在将一个慢时钟域的信号同步到一个较快时钟域时可以正常工作，它会产生一个脉冲表示输入信号的上升沿或者下降沿。但是反过来，将一个快时钟域的信号同步到慢时钟域时，并不能正常工作，这时候需要使用 pusle synchronizer。</em></p>
<h4 id="pulse-synchronizer">pulse synchronizer</h4>
<p>脉冲同步器的基本功能是从某个时钟域中取出一个单时钟宽度的脉冲，然后在新的时钟域中建立另外一个单时钟宽度的脉冲。</p>
<p>源时钟域的单时钟宽度的脉冲不是直接输出的，而是先经过一个源时钟域的翻转电路。这个翻转电路在每次输入一个脉冲时，它的输出会在高、低电平之间翻转。</p>
<p>而在目的时钟域，翻转电路的输出先通过一个 level synchronizer，其输出到达异或门的一个输入端，而这个输出再经过一个 DFF，延时一个时钟周期后进入异或门的另外一个输入端。最后异或门的输出即最终的同步结果：</p>
<p>源时钟域每有一个单时钟脉冲（源时钟），synchronizer 的输出端产生一个单时钟宽度（目的时钟）的脉冲。</p>
<p><strong>Schematic:</strong></p>
<p><img alt="pusle" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/pulse.png"></p>
<p><strong>Code:</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">PULSESYNC</span><span class="p">(</span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">clk</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">pulse</span><span class="o">-</span><span class="n">src</span><span class="p">,</span>

<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">clk</span><span class="o">-</span><span class="n">dst</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">   </span><span class="n">rst</span><span class="o">-</span><span class="n">dst</span><span class="p">,</span>
<span class="w">    </span><span class="k">output</span><span class="w">  </span><span class="n">pulse</span><span class="o">-</span><span class="n">dst</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="c1">///////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// source time domain</span>
<span class="w">    </span><span class="c1">///////////////////////////////////////////////////</span>
<span class="w">    </span><span class="kt">reg</span><span class="w"> </span><span class="n">toggle</span><span class="o">-</span><span class="kt">reg</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="o">-</span><span class="n">src</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">posedge</span><span class="w"> </span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">toggle</span><span class="o">-</span><span class="kt">reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">1</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pulse</span><span class="o">-</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">                </span><span class="n">toggle</span><span class="o">-</span><span class="kt">reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">~</span><span class="n">toggle</span><span class="o">-</span><span class="kt">reg</span><span class="p">;</span>
<span class="w">            </span><span class="k">end</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1">///////////////////////////////////////////////////</span>
<span class="w">    </span><span class="c1">// destination time domain</span>
<span class="w">    </span><span class="c1">///////////////////////////////////////////////////</span>
<span class="w">    </span><span class="kt">reg</span><span class="w">     </span><span class="p">[</span><span class="mh">2</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w">   </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">clk</span><span class="o">-</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rst</span><span class="o">-</span><span class="n">dst</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mh">3</span><span class="mb">&#39;b0</span><span class="p">;</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">            </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">{</span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">[</span><span class="mh">1</span><span class="o">:</span><span class="mh">0</span><span class="p">],</span><span class="w"> </span><span class="n">toggle</span><span class="o">-</span><span class="kt">reg</span><span class="p">};</span>
<span class="w">        </span><span class="k">end</span>
<span class="w">    </span><span class="k">end</span>

<span class="w">    </span><span class="c1">// XOR to generate the pusle-dst</span>
<span class="w">    </span><span class="k">assign</span><span class="w"> </span><span class="n">pulse</span><span class="o">-</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">[</span><span class="mh">1</span><span class="p">]</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">sync</span><span class="o">-</span><span class="kt">reg</span><span class="p">[</span><span class="mh">2</span><span class="p">];</span>

<span class="k">endmodule</span>
</code></pre></div>

<p><strong>RTL:</strong></p>
<p>...</p>
<p><strong>Restriction:</strong></p>
<p>使用 pusle synchronizer 的要求是：</p>
<ol>
<li>
<p>输入脉冲之间的最小间隔 &gt;= 2 个同步时钟周期。如果两个输入脉冲相互过近，则新时钟域的输出脉冲也会紧密相邻，形成一个比单时钟周期宽的输出脉冲。</p>
<p>实际上，在一些情况下，少于 2 个时钟周期（&gt; 1 个时钟周期）也是可以同步上的。只要 synchronizer 的两个 DFF 的值不一样即可同步上，也就是说异步信号在连续的两个目的时钟采样的值不同即可，由于异步信号和时钟的相位关系不确定，所以在没有对齐的情况下，大于 1 个时钟时也能满足两个采样值不同的条件。</p>
<p>一般为了保险起见，要求其保持至少两个时钟宽度。</p>
</li>
</ol>
<h4 id="timing">Timing</h4>
<p>synchronizer 需要花费 1～2 个时钟周期来完成同步，所以粗略的估计可以认为 synchronizer 会造成目的时钟域的 2 个周期的延迟，我们在设计时需要考虑 synchronizer 对时序产生的影响。</p>
<h4 id="summary">Summary</h4>
<p>总结 3 种同步器的特点，有下表：</p>
<p><img alt="synchronizer sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/synchronizer-sum.png"></p>
<p>虽然还有其他类型的 synchronizer，但是这 3 种基本上就可以解决设计中遇到的多数问题了。</p>
<p><em>synchronizer 仅适用于简单的数据跨时钟域传输的同步，除了简单的信号之外，还有数据、地址、控制总线信号等也要跨时钟域。对于这些需求，可以使用其他的工具，比如握手协议、FIFO 等。</em></p>
<h3 id="solution-2-handshaking">Solution 2: Handshaking</h3>
<blockquote>
<p>Handshaking allows digital circuits to effectively communicate with each other when the response time of one or both circuits is unpredictable. For example, an arbitrated bus allows more than one circuit to request access to a single bus, such as PCI or AMBA (Advanced Microcontroller Bus Architecture), using arbitration to determine which circuit gains access to the bus. Each circuit signals a request, and the arbitration logic determines which request “wins.” This winning circuit receives an acknowledgment indicating that it has access to the bus. It then discontinues its request and begins the bus transaction.</p>
</blockquote>
<p>大意就是：对于（单边 / 双边）电路响应时间不确定的应用，握手协议可以有效地传输信号。比如（PCI、AMBA）总线仲裁电路，有多个电路申请访问总线时，每个电路都发出请求，由仲裁电路来决定哪个有访问权。“ 获胜 ” 的电路会收到确认信号，然后才可以访问总线。</p>
<p>这种交互方式就是握手协议，简而言之就是双方首先要握手达成一致，然后才能传输数据。</p>
<p>有两种基本握手协议：</p>
<ol>
<li>
<p>Full-handshaking</p>
</li>
<li>
<p>Partial-handshaking</p>
</li>
</ol>
<p>这两种握手协议都要用到 synchronizer，每种都有各自的优缺点，下面分别讨论：</p>
<h4 id="full-handshaking">full handshaking</h4>
<p><img alt="full" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/full.png"></p>
<p>如图所示，全握手协议中，双方电路在声明或中止各自的握手信号前都要等待对方的相应。首先，发送方电路 A 声明它的请求信号，然后接收方电路 B 检测到该请求有效后，声明它的效应信号；当电路 A 检测到响应信号有效之后，中止自己的请求信号；最后，当电路 B 检测到请求无效之后，中止自己的相应信号。这样，算是完成了一次通信。除非 A 检测到无效的响应信号，否则它不会再声明新的请求信号。这种机制要求请求电路 A 必须延迟它的下一个请求，直到它检测到无效的响应信号（意味着上次请求已完成）。</p>
<p>这种类型的握手使用了 level synchronizer。可以根据两点来粗略估计这个协议的时序：信号跨域一个时钟域需要花费 2 个时钟周期，信号在跨域时钟域之前被电路寄存花费 1 个时钟周期。所以，发送端 A 需要 5 个周期，接收端 B 需要 6 个周期。</p>
<p>全握手鲁棒性很好，因为通过检测请求和响应信号，每个电路都清楚地知道对方的状态，这种方式的不足之处是完成整个过程要花费很多时钟周期。</p>
<h4 id="partial-handshaking">partial handshaking</h4>
<p>另一中类型是部分握手。部分握手的双方不用等对方的响应就中止各自的信号，并继续执行握手命令序列。</p>
<p>部分握手比全握手在健壮性方面稍弱，因为握手信号并不指示各自电路的状态，每一电路都必须保存状态信息（在全握手里这个信息被送出去），但是，由于无需等待对方的响应，完整的时间序列花费较少的时间。</p>
<p>有两种类型的部分握手：</p>
<p>第一种握手方法中，电路 A 以有效电平声明其请求信号，电路 B 以一个单时钟宽度脉冲作为响应。此时，电路 B 并不关心电路 A 何时中止它的请求。</p>
<p><img alt="partial-1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial-1.png"></p>
<p>但是为了这种方法成立，电路 A 中止请求信号至少要 1 个时钟周期长度，否则，电路 B 就不能区别前一个和后一个新的请求。</p>
<p>在这种握手方式下，电路 B 为请求信号使用一个 level synchronizer；电路 A 为响应信号使用一个 pusle synchronizer。只有当电路 B 检测到请求信号时才发出响应脉冲，这样电路 A 控制请求信号的时序，就能控制自己 synchronizer 接收到的脉冲间隔。</p>
<p>同样，使用前面的方法可以估算出这种握手协议的时序：发送端电路 A 需要花费 3 个时钟周期，接收端 B 需要花费 5 个时钟周期。</p>
<p>第二种握手方法中，电路 A 使用一个单时钟宽度脉冲发出它的请求，电路 B 也以一个单时钟宽度脉冲响应这个请求。这种情况下，两个电路都需要保存状态，以指示请求正待处理。</p>
<p><img alt="partial-2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partial-2.png"></p>
<p>这种握手使用的是 pusle synchronizer。完整的时序是：电路 A 需要花费 2 个时钟周期，电路 B 需要花费 3 个时钟周期。</p>
<h4 id="summary_1">summary</h4>
<p><img alt="handshaing sum" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/handshaking-sum.png"></p>
<p>因为 handshaking 内部采用了 synchronizer，所以可以解决异步信号导致的亚稳态现象。根据实际要求，选择不同的 synchronizer 和握手信号，就有了前面介绍的 3 种不同的 handshaking：</p>
<ul>
<li>
<p>full handshaking
是最健壮的，因为在这种机制下，两部分电路都在等待收到对方的确认信号之后才发送新的握手信号，两部分电路是相互都知道对方目前所处于的状态，而且用了两组握手信号（request/acknowledge，de-request/de-acknowledge），相当于完成了两次握手。但是，最健壮的代价就是花费的时间最长，而且要求信号在收到对方的回复之前要保持不变，这就限制了发送信号的速率和节奏。</p>
</li>
<li>
<p>partial handshaking 是对 full 的精简，动机就是减少握手所花费的时间，从减少花费时间的方法上，就有了两种不同的 partial shandshaking。</p>
</li>
<li>
<p>partial I 精简了 1 个握手信号 de-acknowledge，剩下了 3 个握手信号，相当于完成了 1 次半的握手。而且修改了 full 中 level synchronizer 的方式，接收电路 B 发送的不再是电平信号，而是一个单时钟宽度的脉冲，所以电路 A 则必须使用 pusle synchronizer 来检测来自 B 的握手信号。通过减少一个握手信号和改进一方的 synchronizer，partial I 就比 full 方式节约了很多时间。</p>
</li>
<li>
<p>partial II 则更进一步，在 partial I 的基础上又精简掉一个握手信号，只剩下 2 个握手信号，只完成 1 次握手。而且两部分电路的 synchronizer 同时修改为 pusle 方式。这样子进一步减少了握手花费的时间。</p>
</li>
<li>
<p>partial 和 full 的本质区别不在于 synchronizer 的类型和握手信号的多少，而在于握手的方式。 partial 不用再等待对方的回答，就继续进行自己的下一步操作，而 full 必须等到对方的回复才进行下一步的操作，所以从某种意义上，full 方式才是真正的 “ 握手 ”，而 partial 并不符合 “ 握手 ” 的意思，毕竟根本不管对方的反应，自顾自地挥手叫哪门子的握手 =.=</p>
</li>
</ul>
<p><em>在许多应用中，跨时钟域传送的不只是简单的信号，数据总线、地址总线、控制总线都会同时跨域传输。因为 synchronizer 需要花费的时间是不确定的（1 or 2 个时钟周期），所以对于这些多 bit 的数据，synchronizer 无法完成同步功能，通常采用其他的方法，比如使用 FIFO。</em></p>
<h3 id="solution-3-datapath-design">Solution 3: Datapath Design</h3>
<p>在进行信号同步时，有一个重要的原则：</p>
<p><strong>不应该在设计中的多个地方对同一信号进行同步，即禁止单个信号扇出至多个同步器。</strong></p>
<p>因为 synchronizer 要花 1~2 个时钟周期，设计者不能确切预测到每个信号何时跨越时钟域，此外，在新时钟域中一组经过同步后的信号其时序是不定的，因为 synchronier 的延迟可以是 1～2 个时钟周期，这种情况下各个同步信号间形成一种 “ 竞争状况 ”，这种竞争状况在需要跨域时钟域传输的多组信号间也会发生，例如数据总线、地址总线、控制总线等。因此，<strong>不能对组中的每个信号单独使用 synchronizer，也不能对数据 / 地址总线的每一位单独使用同步器</strong>，因为在新的时钟域中，要求每个信号同时有效。</p>
<h4 id="problem_1">problem</h4>
<p>Clifford E. Cummings 在他的文章中举例说明了几种常见的错误：</p>
<blockquote>
<p>A frequent mistake made by engineers when working on multi-clock designs is passing multiple control signals from one clock domain to another and overlooking the importance of the sequencing of the control signals. <strong>Simply using synchronizers on all control signals is not always good enough</strong> as will be shown in the following examples. </p>
<p>If the order or alignment of the control signals is significant, care must be taken to correctly pass the signals into the new clock domain. All of the examples shown in this section are overly simplistic but they closely mimic situations that often arise in real designs.</p>
<p><strong>Problem - Two simultaneously required control signals</strong>
 a register in the new clock domain requires both a load signal and an
enable signal in order to load a data value into the register. If both the load and enable signals are being sent from one clock domain, there is a chance that a small skew between the control signals could cause the two signals to be synchronized into different clock cycles within the new clock domain. In this example, this would cause the data to the register to not be loaded.</p>
<p><img alt="problem 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem-1.png"></p>
<p>** Solution - Consolidating control signals before passing**</p>
<p><img alt="solution 1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution-1.png"></p>
<p><strong>Problem - Two phase-shifted sequencing control signals</strong></p>
<p>The problem is that in the first clock domain, the aen1 control signal might terminate slightly before the aen2 control signal is asserted, and the second clock domain might try to sample the aen1 and aen2 control signals in the middle of this slight time gap, causing a one-cycle gap to form in the enable control-signal chain in the second clock domain. This would cause the a2 output signal to be missed by the second flip-flop.</p>
<p><img alt="problem 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/problem-2.png"></p>
<p>** Solution - Logic to generate the proper sequencing signals**</p>
<p><img alt="solution 2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/solution-2.png"></p>
</blockquote>
<h4 id="solution_1">solution</h4>
<p>有一种解决这个问题的方法是：<strong>使用一个保持寄存器 + 一个握手信号</strong>。</p>
<p><img alt="solution" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath.png"></p>
<p>保持寄存器保持信号总线的数据，握手信号指示目标时钟域何时可以对总线进行采样，源时钟域何时可以更换当前寄存器中保存的内容。</p>
<blockquote>
<p>In this design, the transmitting circuit stores the data (signal bus) in the holding register as it asserts the request signal. These two actions can happen at once because the request signal takes at least one clock cycle before the receiving circuit detects it (the minimum handshake-synchronization delay). When the receiving circuit samples the data (signal bus), it asserts the acknowledgment signal.</p>
</blockquote>
<p>仔细分析一下，其实这里采用的原理类似于握手协议。</p>
<p>当有一组新的数据出现在数据总线上需要跨时钟域时，额外添加一对握手信号 request/acknowledge，这对信号对于两个时钟域来说分别是异步信号（接收电路不知道何时会收到 request，发送电路也不知道何时会获得 acknowledge），可能会产生亚稳态的问题，所以在两个时钟域对它们分别用 synchronizer 进行同步。</p>
<p>和 request 一起送过来的还有数据总线 上的数据信号，但是对于数据信号，不能简单地对每一位使用 synchronizer 来同步（原因前面已经说过了）。虽然对于接收电路来说，数据总线上的数据也是异步的，但是我们可以强制要求在握手过程中，数据保持不变，这样虽然数据是异步的，只要发送端满足保持寄存器数据在握手过程中不变化这一条件，那么即使数据总线上的数据到达接收时钟域有一些小的偏差 skew，但是不会超出 1 个时钟周期，在 synchronizer 最好的状态下，只花费了 1 个时钟周期就同步到了握手请求 request，这时候数据总线上的数据已经是稳定不变的有效数据了，所以可以采样到正确的有效数据，不会存在亚稳态的问题。</p>
<p>采用这种方法可以避免亚稳态的出现的原因就是它规定了异步信号（保持寄存器）什么时候可以变化，虽然是异步信号，但是在采样的时候人为地确保了它保持稳定，满足 setup/hold time 的要求，所以不会有亚稳态的问题。</p>
<p>这里的握手机制可以采用 full handshaking，也可以采用 partial handshaking，设计者应该根据实际需求来选择。</p>
<p>在 <a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960">The Art of Hardware Architecture</a> 这本书中，有详细的时序图来说明了一种握手机制下，这种机制采用了 full handshaking 中等待对方的方法，但是对握手信号进行了精简（partial II 类型）。如下图：</p>
<p><img alt="datapath timing" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/datapath-timing.png"></p>
<p><em>如果发送端的数据速率很快 / 无法控制发送端发送数据的速度，那么就有可能无法满足握手机制中要求数据保持稳定这一要求，这时候这种方法就不再适用，而应该采用其他的方法，比如 FIFO。</em></p>
<h3 id="solution-4-advanced-datapath-design">Solution 4: Advanced Datapath Design</h3>
<p>有时候，数据在跨时钟域时需要 “ 堆积 ” 起来，这时候只使用单个的寄存器就无法完成工作。比如某个传输电路突发式地发送数据，接收电路来不及采样，为了保持数据不丢失，就必须先把数据存储起来；还有一种情况是接收电路的采样速率比发送速度快，但是位宽却不够，仍然需要将没有采样的数据先暂存起来，这时候就需要使用 FIFO。</p>
<p>基本上，使用 FIFO 的目的有两个：</p>
<ol>
<li>
<p>速度匹配</p>
</li>
<li>
<p>宽度匹配</p>
</li>
</ol>
<p>FIFO 的实现可以直接使用 IP core，也可以自己写代码实现。</p>
<p>如果是自己写代码实现，那么异步信号的问题还是需要我们在实现 FIFO 是仔细考虑的；如果是采用 IP core 的方式，那么可以很大程度地缓解我们的压力，因为事实上我们是把异步信号的问题交给了设计 IP core 的人来处理 ... 这些 IP core 在内部针对异步数据读写的问题作了非常严谨复杂的设计，对外提供了非常简单的接口。采用这种方式虽然轻松，但是相应的地也有缺点：耗费更多的资源。</p>
<p>在 <a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf">Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs</a> 和 <a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf">Crossing the abyss: asynchronous signals in a synchronous world</a> 两篇 paper 和 <a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960">The Art</a> 中都有一些实现 FIFO 使用的相关技术的介绍，比如指针逻辑的处理，内部 gray code 计数器的实现等。这里就偷懒不细说了（以后再补） :P</p>
<p>=============Update March/12/2015===========================</p>
<p>FIFO 的目的在于解决数据跨时钟域传输的问题，但是在实现 FIFO 本身时，一些内部的握手信号也需要跨时钟域，这时候需要用到之前讨论过的 dual rank synchronizer 等技术。</p>
<p>比如 FIFO 内部的地址计数器，如果使用 dual rank synchronizer 来同步，计数器的不同的 bit 可能会在不同的时钟周期内传递过去，这时接收到的数据就是错误的，对导致致命性的问题。</p>
<p>而对应这个问题的解决方法就是使用 gray code。</p>
<p>==============end of update==================================</p>
<p><em>关于跨时钟域 <a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf">papaer1</a> 中还有一些其他方面的技巧，可以帮助我们更好的实现设计。</em></p>
<h3 id="design-partitioning">Design Partitioning</h3>
<p><strong>Guideline:</strong></p>
<blockquote>
<p>Only allow one clock per module.</p>
</blockquote>
<p><strong>Reason:</strong></p>
<blockquote>
<p>Static timing analysis and creating synthesis scripts is more easily accomplished on single-clock modules or groups of single-clock modules.</p>
</blockquote>
<p><strong>guideline:</strong></p>
<blockquote>
<p>Create a synchronizer module for each set of signals that pass from just one clock domain into another clock domain.</p>
</blockquote>
<p><strong>Reason:</strong></p>
<blockquote>
<p>It is given that any signal passing from one clock domain to another clock domain is going to have setup and hold time problems. No worst-case (max time) timing analysis is required for synchronizer modules. Only best case (min time) timing analysis is required between first and second stage flip-flops to ensure that all hold times are met. Also, gate-level simulations can more easily be configured to ignore setup and hold time violations on the first stage of each synchronizer.</p>
</blockquote>
<p>采用这种设计方式的原因如上所示，可以减少不必要的时序验证，而且脚本也更容易写，总之可以使时序验证工作更容易。</p>
<p>举例如下图所示：</p>
<p><img alt="partitioning" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/partitioning.png"></p>
<h3 id="clock-name-conventions">Clock Name Conventions</h3>
<p><strong>Guideline:</strong></p>
<blockquote>
<p>Use a clock naming convention to identify the clock source of every signal in a design.</p>
</blockquote>
<p><strong>Reason:</strong></p>
<blockquote>
<p>A naming convention helps all team members to identify the clock domain for every signal in a design and also makes grouping of signals for timing analysis easier to do using regular expression "wild-carding" from within a synthesis script.</p>
</blockquote>
<p>作者还举例说明了一个这样的例子：1995 年为 In Focus projectors 设计 video ASIC 时，他们就采用了这样的方法，对于 mircroprocessor 的时钟命名为 uClk，对于 video 的时钟则命名为 vClk。对应的时钟域中的信号的名字也添加了对应的前缀，比如 udata，uwrite，uadder 等。</p>
<p>使用了这样的策略后，整个设计团队的攻城狮们都可以很方便地确定某个信号是否为异步信号，如何处理。当时有个攻城狮没有按照这种策略，使用了自己的命名方式，在一次会议之后，大家墙裂建议他修改命名，结果也证明修改之后遇到的问题、出错的概率都小了很多。</p>
<h2 id="gated-clock">Gated Clock</h2>
<p>虽然 FPGA 可以用来为 ASIC 搭建原型，但是一些 ASIC 中的技术并不适用于 FPGA，比如 gated clock。一般也没有必要在 FPGA 中模拟 ASIC 的低功耗优化。事实上，由于 FPGA 时钟资源的的粗颗粒度性，并不是总能模拟成功。</p>
<p>下面简单讨论一下 ASIC 中 gated clock 的问题。（更详细的内容见 gated clock 文章，未写）</p>
<ol>
<li>
<p>dedicated clock module</p>
<p><strong>guideline</strong>: 将全部的 gated clock 时钟放在一个专门的时钟模块中，并将其从功能模块中分离出来</p>
<p><strong>reason</strong>: </p>
<ul>
<li>约束更加容易处理</li>
<li>FPGA 设计修改起来更容易（比如通过 #define 来选择编译 ASIC 还是 FPGA 设计，选择两者各自的实现代码）</li>
</ul>
</li>
<li>
<p>gating removal</p>
<p>在 FPGA 上建立模型时，有很多巧妙的方法去除 gated clock。比如下面这个例子就是最直观，但也是最繁琐的方法：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">`define FPGA</span>
<span class="c1">// `define ASIC</span>

<span class="k">module</span><span class="w"> </span><span class="n">clock</span><span class="o">-</span><span class="n">blocks</span><span class="w"> </span><span class="p">(...)</span>

<span class="w">    </span><span class="no">`ifdef</span><span class="w"> </span><span class="n">ASIC</span>
<span class="w">        </span><span class="k">assign</span><span class="w"> </span><span class="n">clock</span><span class="o">-</span><span class="n">domain</span><span class="o">-</span><span class="mh">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="o">-</span><span class="n">clock</span><span class="o">-</span><span class="mh">1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">clock</span><span class="o">-</span><span class="n">enable</span><span class="o">-</span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="no">`else</span>
<span class="w">        </span><span class="k">assign</span><span class="w"> </span><span class="n">clock</span><span class="o">-</span><span class="n">domain</span><span class="o">-</span><span class="mh">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">system</span><span class="o">-</span><span class="n">clock</span><span class="o">-</span><span class="mh">1</span><span class="p">;</span>
<span class="w">    </span><span class="no">`endif</span>

<span class="p">...</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<p>这种方法的缺点是当做出改动时，需要对 FPGA 和 ASIC 代码都作出修改。很多人对这种方式很不爽，因为他们必须写两种不同的 RTL 代码。</p>
<p>一种更加高级的方法是依靠工具，现代的很多综合工具都可以通过适当的约束，通过将条件并到数据通路，来自动消除 gated clock。</p>
<p>比如下面的这段代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="n">clockstest</span><span class="p">(</span>
<span class="w">    </span><span class="k">output</span><span class="w">  </span><span class="kt">reg</span><span class="w">  </span><span class="n">oDat</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">        </span><span class="n">iClk</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">        </span><span class="n">iEnable</span><span class="p">,</span>
<span class="w">    </span><span class="k">input</span><span class="w">        </span><span class="n">iDat</span><span class="p">);</span>

<span class="w">    </span><span class="kt">wire</span><span class="w">  </span><span class="n">gated</span><span class="o">-</span><span class="n">clock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iClk</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">iEnable</span><span class="p">;</span>

<span class="w">    </span><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="k">posedge</span><span class="w"> </span><span class="n">gated</span><span class="o">-</span><span class="n">clock</span><span class="p">)</span>
<span class="w">        </span><span class="n">oDat</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">iDat</span><span class="p">;</span>

<span class="k">endmodule</span>
</code></pre></div></td></tr></table></div>

<p>如果不打开自动消除的开关，产生的 gated clock 电路如下：</p>
<p><img alt="circuit1" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit1.png"></p>
<p>如果打开自动消除的开关，产生的没有 gated clock 电路如下：</p>
<p><img alt="circuit2" src="/images/the-clock-design-in-fpga-3-multiasynchronous-clock-design/circuit2.png"></p>
<p>现在大多数器件都提供了一个时钟使能（clock enable）端口</p>
<ul>
<li>
<p>如果器件提供了这种接口，那么就没有必要使用上述方法；</p>
</li>
<li>
<p>如果器件没有提供这种端口，那么使用这种技术虽然可以消除 gated clock，但是付出的代价是增加了 data path 的 delay。</p>
</li>
</ul>
</li>
</ol>
<h2 id="summary_2">Summary</h2>
<p>以上，就是一些在多时钟域设计中处理异步数据的常用方法，总结如下：</p>
<ol>
<li>
<p>对于简单的单比特的数据，根据实际情况选择对应的 synchronizer 即可</p>
</li>
<li>
<p>对于其他的信号，比如数据总线、地址总线、控制总线等数据，可以使用握手协议</p>
</li>
<li>
<p>总线上的数据要求同时到达新的时钟域，所以不要对总线上的信号分别进行同步，而要采用一个保持寄存器 + 握手信号的方式</p>
</li>
<li>
<p>还可以采用 FIFO 来处理异步数据的问题</p>
</li>
<li>
<p>分块设计，尽可能保证一个模块只有一个时钟域，对于跨时钟域信号，写独立的同步模块，这样可以减轻时序验证的工作</p>
</li>
<li>
<p>采用良好的命名习惯，如前缀的方式，可以帮助设计</p>
</li>
<li>
<p>注意 ASIC 和 FPGA 中对时钟信号的不同处理方法</p>
</li>
</ol>
<h2 id="reference">Reference</h2>
<p><a href="http://www.sunburst-design.com/papers/CummingsSNUG2001SJ-AsyncClk.pdf">Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs</a></p>
<p><a href="http://inst.eecs.berkeley.edu/~cs150/sp10/Collections/Papers/ClockCrossing.pdf">Crossing the abyss: asynchronous signals in a synchronous world</a></p>
<p><a href="http://book.douban.com/subject/10593491/">Xilinx FPGA 高级设计及应用</a></p>
<p><a href="http://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00FW1RTZG">FPGA 高手设计实战真经 100 则</a></p>
<p><a href="http://bbs.ednchina.com/BLOG-ARTICLE-174906.HTM">ASIC 中的异步时序设计</a></p>
<p><a href="http://bbs.ednchina.com/BLOG-ARTICLE-175526.HTM">跨越鸿沟：同步世界中的异步信号</a></p>
<p><a href="http://www.altera.com.hk/literature/wp/wp-01082-quartus-ii-metastability.pdf">Understanding Metastability in FPGAs</a></p>
<p><a href="http://www.amazon.com/The-Art-Hardware-Architecture-Techniques/dp/1461403960">The Art of Hardware Architecture</a></p>
<p><a href="http://book.douban.com/subject/2878096/">Advanced FPGA Design: Architecture, Implementation, and Optimization</a></p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="https://qian-gu.github.io/posts/ic/latch-versus-flip-flop.html" title="锁存器 Latch v.s. 触发器 Flip-Flop">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="https://qian-gu.github.io/posts/ic/clock-dividers.html" title="时钟分频器">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>

  <div class="related-posts">
    <h4>You might enjoy</h4>
    <ul class="related-posts">
      <li><a href="https://qian-gu.github.io/posts/ic/clock-dividers.html">时钟分频器</a></li>
      <li><a href="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-2-clock-design.html">FPGA 时钟设计 2 —— 时钟设计</a></li>
      <li><a href="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-1-summary-of-clock-resource.html">FPGA 时钟设计 1 —— 时钟资源总结</a></li>
    </ul>
  </div>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-1821536199377100"
         data-ad-slot="4843941849"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

<!-- Gitalk -->
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://qian-gu.github.io/theme/gitalk/md5.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '4b3de26a6e80be727416',
  clientSecret: '993d79339c842fc56d9739ef268f38806dc93f50',
  repo: 'qian-gu.github.io',
  owner: 'qian-gu',
  admin: ['qian-gu'],
  id: md5(location.href),
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- End Gitalk -->
</article>

<footer>
<p>
  &copy; 2025  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://qian-gu.github.io/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="ligtht"
          type="text/javascript">
  </script>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://qian-gu.github.io/theme/img/cc/by-sa.png"
         width="80"
         height="15"/>
  </a>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Qian's Blog ",
  "url" : "https://qian-gu.github.io",
  "image": "https://qian-gu.github.io/images/logo.png",
  "description": "Qian's Thoughts and Writings"
}
</script><a href="https://github.com/qian-gu/qian-gu.github.io" target="_blank" class="github-corner" aria-label="View source on Github">
    <svg width="80"
         height="80"
         viewBox="0 0 250 250"
         style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
         aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor"
              style="transform-origin: 130px 106px;"
              class="octo-arm">
        </path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor"
              class="octo-body">
        </path>
    </svg>
</a>
  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://qian-gu.github.io/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://qian-gu.github.io/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://qian-gu.github.io/theme/stork/stork.js"></script>

</body>
</html>