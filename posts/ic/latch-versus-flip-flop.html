
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="index, follow" />

  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400&family=Source+Sans+Pro:ital,wght@0,300;0,400;0,700;1,400&display=swap" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/stylesheet/style.min.css">

    <link id="dark-theme-style" rel="stylesheet" type="text/css"
          media="(prefers-color-scheme: dark)"
    href="https://qian-gu.github.io/theme/stylesheet/dark-theme.min.css">

    <link id="pygments-dark-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: dark)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">
    <link id="pygments-light-theme" rel="stylesheet" type="text/css"
              media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"
          href="https://qian-gu.github.io/theme/pygments/monokai.min.css">


  <link rel="stylesheet"
        type="text/css"
        href="https://qian-gu.github.io/theme/stork/stork.css" />

  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/fontawesome.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/brands.css">
  <link rel="stylesheet" type="text/css" href="https://qian-gu.github.io/theme/font-awesome/css/solid.css">

  <link rel="stylesheet" type="text/css" href="/static/custom.css">

  <link rel="shortcut icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">
  <link rel="icon" href="https://qian-gu.github.io/images/favicon_64x64.ico" type="image/x-icon">

  <!-- Chrome, Firefox OS and Opera -->
  <meta name="theme-color" content="#333333">
  <!-- Windows Phone -->
  <meta name="msapplication-navbutton-color" content="#333333">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Microsoft EDGE -->
  <meta name="msapplication-TileColor" content="#333333">

  <link href="https://qian-gu.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Qian's Blog Atom">


<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48826831-1', 'auto');
  ga('send', 'pageview');
</script>






 

<meta name="author" content="Qian Gu" />
<meta name="description" content="总结 Latch 和 Flip-Flop" />
<meta name="keywords" content="latch, flip-flop">


  <meta property="og:site_name" content="Qian's Blog"/>
  <meta property="og:title" content="锁存器 Latch v.s. 触发器 Flip-Flop"/>
  <meta property="og:description" content="总结 Latch 和 Flip-Flop"/>
  <meta property="og:locale" content="en"/>
  <meta property="og:url" content="https://qian-gu.github.io/posts/ic/latch-versus-flip-flop.html"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2014-09-23 23:02:00+08:00"/>
  <meta property="article:modified_time" content=""/>
  <meta property="article:author" content="https://qian-gu.github.io/author/qian-gu.html">
  <meta property="article:section" content="IC"/>
  <meta property="article:tag" content="latch"/>
  <meta property="article:tag" content="flip-flop"/>
  <meta property="og:image" content="https://qian-gu.github.io/images/logo.png">

  <title>Qian's Blog &ndash; 锁存器 Latch v.s. 触发器 Flip-Flop</title>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-1821536199377100",
      enable_page_level_ads: true
    });
  </script>

</head>
<body >

<aside>
  <div>
    <a href="https://qian-gu.github.io/">
      <img src="https://qian-gu.github.io/images/logo.png" alt="Qian Gu" title="Qian Gu">
    </a>

    <h1>
      <a href="https://qian-gu.github.io/">Qian Gu</a>
    </h1>

    <p>Read >> Think >> Write</p>

    <div class="stork">
      <input class="stork-input" type="text" autocomplete="off" name="q" data-stork="sitesearch" placeholder="Search..." onclick="loadStorkIndex()"/>
      <div class="stork-output" data-stork="sitesearch-output"></div>
    </div>

    <nav>
      <ul class="list">


            <li>
              <a target="_blank"
                 href="https://qian-gu.github.io/pages/about-me.html#about-me">
                About Me
              </a>
            </li>

      </ul>
    </nav>

    <ul class="social">
      <li>
        <a class="sc-envelope"
rel="me"           href="mailto:guqian110@163.com"
           target="_blank">
          <i class="fa-solid fa-envelope"></i>
        </a>
      </li>
      <li>
        <a class="sc-github"
           href="https://github.com/qian-gu"
           target="_blank">
          <i class="fa-brands fa-github"></i>
        </a>
      </li>
      <li>
        <a class="sc-twitter"
           href="https://twitter.com/qian_gu"
           target="_blank">
          <i class="fa-brands fa-twitter"></i>
        </a>
      </li>
      <li>
        <a class="sc-rss"
           href="/feeds/all.atom.xml"
           target="_blank">
          <i class="fa-solid fa-rss"></i>
        </a>
      </li>
    </ul>
  </div>

</aside>
  <main>

<nav>
  <a href="https://qian-gu.github.io/">Home</a>

  <a href="/authors.html">Authors</a>
  <a href="/archives.html">Archives</a>
  <a href="/categories.html">Categories</a>
  <a href="/tags.html">Tags</a>

  <a href="https://qian-gu.github.io/feeds/all.atom.xml">Atom</a>

</nav>

<article class="single">
  <header>
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.1.0/css/all.css" rel="stylesheet">
      
    <h1 id="latch-versus-flip-flop">锁存器 Latch v.s. 触发器 Flip-Flop</h1>
    <p>
      Posted on 2014-09-23 23:02 in <a href="https://qian-gu.github.io/category/ic.html">IC</a>

    </p>
    <div class="tag-cloud">
      <p>
        <a href="https://qian-gu.github.io/tag/latch.html">latch</a>
        <a href="https://qian-gu.github.io/tag/flip-flop.html">flip-flop</a>
      </p>
    </div>
  </header>



  <div>
    <p>根据 <a href="http://en.wikipedia.org/wiki/Flip-flop-(electronics">Wiki: Flip-flop (electronics)</a> 上的介绍</p>
<blockquote>
<p>In electronics, a <code>flip-flop</code> or <code>latch</code> is a circuit that has two stable states and can be used to store state information. A flip-flop is a <code>bistable multivibrator</code>. The circuit can be made to change state by signals applied to one or more control inputs and will have one or two outputs. It is the basic storage element in sequential logic. Flip-flops and latches are a fundamental building block of digital electronics systems used in computers, communications, and many other types of systems.</p>
</blockquote>
<p>区别一下名字：</p>
<blockquote>
<p>Flip-flops can be either simple (transparent or opaque) or clocked (synchronous or edge-triggered). Although the term flip-flop has historically referred generically to both simple and clocked circuits, in modern usage it is common to reserve the term flip-flop exclusively for discussing clocked circuits; the simple ones are commonly called latches.</p>
<p>Using this terminology, a latch is level-sensitive, whereas a flip-flop is edge-sensitive. That is, when a latch is enabled it becomes transparent, while a flip flop's output only changes on a single type (positive going or negative going) of clock edge.</p>
</blockquote>
<p>所以按照现在的约定习惯区分，latch 指的是电平触发的触发器，翻译为 “ 锁存器 ”；flip-flop 指边沿触发的触发器，就叫 “ 触发器 ”。</p>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#history">History</a></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#latch">Latch</a><ul>
<li><a href="#sr-latch">SR Latch</a></li>
<li><a href="#d-latch">D Latch</a></li>
</ul>
</li>
<li><a href="#flip-flop">Flip-Flop</a><ul>
<li><a href="#d-flip-flop">D flip-flop</a></li>
<li><a href="#jk-flip-flop">JK flip-flop</a></li>
<li><a href="#t-flip-flop">T flip-flop</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#timing-considerations">Timing considerations</a><ul>
<li><a href="#metastability">Metastability</a></li>
<li><a href="#setup-hold-recovery-removal-times">Setup, hold, recovery, removal times</a></li>
<li><a href="#propagation-delay">Propagation delay</a></li>
</ul>
</li>
<li><a href="#in-fpga">in FPGA</a><ul>
<li><a href="#reason-solution-to-unexpected-latch">Reason &amp; Solution to unexpected latch</a><ul>
<li><a href="#reason">Reason</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#application">Application</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a></li>
</ul>
</div>
<h2 id="history">History</h2>
<p><em>翻译自 <a href="http://en.wikipedia.org/wiki/Flip-flop-(electronics">wiki</a>:</em></p>
<p>第一个电子触发器 (electronic flip-flop) 由  William Eccles 和 F. W. Jordan 于 1918 年发明的。它最早被称为 ：  <code>Eccles–Jordan trigger circuit</code>，由两个真空管组成。虽然现在由逻辑门 (logic gates) 组成的触发器很常见，但是在集成电路 (intergrated circuits) 中，这种元件及它的晶体管版本仍然也很常见。早期的触发器常用来构成触发电路或者多谐振荡器 (multivibrators)。</p>
<p><img alt="flip-flop" src="http://upload.wikimedia.org/wikipedia/commons/9/98/Eccles-Jordan-trigger-circuit-flip-flip-drawings.png"></p>
<p>根据一个 JPL 的工程师，P. L. Lindley 介绍，Montgomery Phister 于 1954 年在 UCLA 的 computer design 的课程上第一次对触发器进行了分类的讨论（RS、D、T、JK），然后在他的书 Logical Design of Digital Computers 中也进行了讨论。Lindley 当时在 Hughes Aircraft 的 Eldred Nelson 手下工作，而 Nelson 命名了 JK 触发器。其他的名字则是 Phister 命名的。Lindley 解释说他是从 Nelson 口中得知 JK 触发器的故事的，当时 Hughes Aircraft 使用的触发器都是 JK 触发器。在设计逻辑系统时，Nelson 给触发器的输入命名为 A&amp;B、C&amp;D、E&amp;F、G&amp;H、J&amp;K。在 1953 年 Nelson 申请专利时，采用了 J&amp;K 的命名方案。</p>
<h2 id="implementation">Implementation</h2>
<blockquote>
<p>Flip-flops can be either simple (transparent or asynchronous) or clocked (synchronous); the transparent ones are commonly called latches. The word latch is mainly used for storage elements, while clocked devices are described as flip-flops.</p>
</blockquote>
<p>不会翻译了 ... 大意就是说 flip-flop 可以分为两类：</p>
<ul>
<li>
<p>simple</p>
<p>也可以说是 透明的 (transparent) 或者是 异步的 (asynchronous)，通常称为 <code>锁存器 Latch</code></p>
</li>
<li>
<p>clocked</p>
<p>也可以说是 同步的 (synchronous)，称为 <code>触发器 flip-flop</code></p>
</li>
</ul>
<p>下面分类讨论：</p>
<h3 id="latch">Latch</h3>
<p>Latch 可以由一对真空管、三极管、场效应管组成，在实际应用中也可以用逻辑门组成 latch。</p>
<h4 id="sr-latch">SR Latch</h4>
<p>当使用逻辑门搭建模块时，最基本的 latch 就是 <code>SR latch</code> (set-reset latch)，所有的 latch 和 flip-flop 都是建立在它的基础之上。</p>
<p>SR latch 的实现可以有两种方案：</p>
<ul>
<li>
<p><strong>SR NOR Latch</strong></p>
<p>使用或非门搭建：</p>
<p><img alt="nor" src="http://upload.wikimedia.org/wikipedia/commons/c/c6/R-S-mk2.gif"></p>
<p>功能表：</p>
<p><img alt="nor" src="/images/latch-versus-flip-flop/nor.png"></p>
</li>
<li>
<p><strong>S'R' NAND Latch</strong></p>
<p>使用与非门搭建：</p>
<p><img alt="nand" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/92/SR-Flip-flop-Diagram.svg/500px-SR-Flip-flop-Diagram.svg.png"></p>
<p>功能表：</p>
<p><img alt="nand" src="/images/latch-versus-flip-flop/nand.png"></p>
</li>
</ul>
<h4 id="d-latch">D Latch</h4>
<p>Latch 是 <code>透明的 (transparent)</code>，就是说输入的变换立即就能传递到输出端口，当几个透明的 latch 级联时，输入端的信号也能立即传递到输出端。当给 latch 添加额外的逻辑电路（比如使能信号 enable 无效时），就会使它变为 <code>不透明的 (non-transparent)</code>。下面的 D latch 就是这样的例子。</p>
<p>仔细观察 SR latch 的功能表，就可以发现，R 的取值为 S 的补。D latch 利用了这一特点，而且避免了 SR latch 中的禁止状态的出现。</p>
<p>因为 SR latch 的实现有两种，所以 <code>D latch</code> 的实现也对应有两种：</p>
<ul>
<li>
<p><strong>NOR D Latch</strong></p>
<p><img alt="nor d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/D-type-Transparent-Latch-%28NOR%29.svg/500px-D-type-Transparent-Latch-%28NOR%29.svg.png"></p>
</li>
<li>
<p><strong>NAND D Latch</strong></p>
<p><img alt="nand d latch" src="http://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/D-Type-Transparent-Latch.svg/500px-D-Type-Transparent-Latch.svg.png"></p>
</li>
</ul>
<p>D latch 的功能表：</p>
<p><img alt="d latch" src="/images/latch-versus-flip-flop/d-latch.png"></p>
<p>D latch 也称为  non-transparent、data latch、gated latch。它有一个数据输入端和一个使能端 enable(clock、control)。之所以叫透明，是因为当它使能时，输入端口的信号立刻就能传递到输出端口。</p>
<h3 id="flip-flop">Flip-Flop</h3>
<p>如果 D latch 的控制端口加入时钟信号，就得到了基本触发器，只要时钟信号 CP = 1，则触发器就会受到触发，当 CP 保持为 1 时，数据输入端口的任何变化都将影响到 latch 的状态。</p>
<p>latch 的这个特点应用到 时序电路中，就会出现比较严重的问题：</p>
<p>一般时序逻辑的输出会经过组合电路的反馈通道，返回到时序逻辑的输入。当时钟信号有效时，latch 的输出通过组合电路反馈到 latch 的输入端，如果经过组合逻辑后，反馈的信号和之前的信号不同，则反馈信号会导致 latch 的输出变为新的值。在时钟信号有效的期间内，latch 的输出一直在变化，出现了不可预测的结果，这是不可靠的工作。</p>
<p>latch 的<strong>问题</strong>就在于：<em>它在时钟有效期间内一直在被触发，这种触发时间过长。</em></p>
<p>这个问题的<strong>解决方法</strong>就是：<em>将触发条件变为时钟沿触发，这样就得到了触发器 <code>flip-flop</code></em></p>
<h4 id="d-flip-flop">D flip-flop</h4>
<p>将 latch 改造为边沿敏感的触发器，最简单的就是 <code>D flip-flop</code> (data or delay)，搭建电路最经济有效的方法就是使用 DFF，因为它需要的门电路最少，其他类型的触发器都是在 DFF 的基础上得到的。</p>
<p>实现 DFF 可以有两种方法：</p>
<ul>
<li>
<p><strong>Classical positive-edge-triggered D flip-flop</strong></p>
<p><img alt="classical" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Edge-triggered-D-flip-flop.svg/500px-Edge-triggered-D-flip-flop.svg.png"></p>
</li>
<li>
<p><strong>Master–slave edge-triggered D flip-flop</strong></p>
<p><img alt="master-slave" src="http://upload.wikimedia.org/wikipedia/en/thumb/5/52/Negative-edge-triggered-master-slave-D-flip-flop.svg/500px-Negative-edge-triggered-master-slave-D-flip-flop.svg.png"></p>
<p>clk = 1 时，master D-latch 使能，D 传递到输出端 Q；</p>
<p>clk = 0 时，slave D-latch 使能，输入 D (master D-latch 的输出 Q) 传递到输出 Q；</p>
<p>可以看到，当 clk 从 1 变为 0 时，输入端的 D 才传递到输出端 Q，也就是说在时钟的下降沿才触发，其他时刻都保持输出不变。（如果需要上升沿触发，只需要在 clk 输入端键入一个反相器）</p>
</li>
</ul>
<p>DFF 的特点就是在时钟信号的特定点触发（上升沿 or 下降沿），功能表：</p>
<p><img alt="dff" src="/images/latch-versus-flip-flop/dff.png"></p>
<h4 id="jk-flip-flop">JK flip-flop</h4>
<p>在 DFF 的基础上，可以得到 JK FF。</p>
<p>JK FF 的特点和 SR latch 类似，可以将 J 看作是 S，K 看作是 R，它和 SR latch 的区别在于它是边沿触发，并且将 S = R = 1 状态设置为 <code>翻转 (toggle)</code>，也就是在下一个时钟边沿，输出取反。当 J = K = 0 时，得到的并不是 DFF，而是保持输出不变。</p>
<p>功能表：</p>
<p><img alt="jk" src="/images/latch-versus-flip-flop/jk.png"></p>
<h4 id="t-flip-flop">T flip-flop</h4>
<p>将 JK FF 的输入端 J 和 K 连接到一起，就可以得到 <code>T FF</code> (toggle flip-flop)。</p>
<p>当 T = 0 (J = K = 0) 时，输出保持不变，时钟边沿不影响状态；当 T = 1 (J = K = 1) 时，在时钟边沿输出反相，也就是翻转。</p>
<p>功能表：</p>
<p><img alt="tff" src="/images/latch-versus-flip-flop/tff.png"></p>
<p>可以看到 TFF 有 1/2 分频的作用，这一特点在很多电路中得到了应用。</p>
<h2 id="timing-considerations">Timing considerations</h2>
<h3 id="metastability">Metastability</h3>
<p>伴随着 flip-flop 的一个问题是 <code>亚稳态 Metastability</code>。当两个输入端口 ( 比如 data 和 clk，或者 reset 和 clk) 同时变化时，就会发生亚稳态的问题，需要消耗更长的时间来使输出达到稳定状态，而且这个稳定状态是不可预测的，有可能是 1，也有可能是 0。</p>
<p>在计算机系统中，如果发生亚稳态，如果在下一个时钟使用数据时，还没有达到稳定状态，会导致数据传输错误或者程序崩溃。如果有两条路径同时用到了这个数据，有可能一条将它当作 1，另一条把它当作 0，这样会导致系统进入不一致的状态。</p>
<h3 id="setup-hold-recovery-removal-times">Setup, hold, recovery, removal times</h3>
<blockquote>
<p><strong>Setup time</strong> is the minimum amount of time the data signal should be held steady <strong>before</strong> the clock event so that the data are reliably sampled by the clock. This applies to synchronous input signals to the flip-flop.</p>
<p><strong>Hold time</strong> is the minimum amount of time the data signal should be held steady <strong>after</strong> the clock event so that the data are reliably sampled. This applies to synchronous input signals to the flip-flop.</p>
<p>Synchronous signals (like Data) should be held steady from the set-up time to the hold time, where both times are relative to the clock signal.</p>
</blockquote>
<p><img alt="meta" src="http://upload.wikimedia.org/wikipedia/en/thumb/d/d9/FF-Tsetup-Thold-Toutput.svg/500px-FF-Tsetup-Thold-Toutput.svg.png"></p>
<p>如图所示，对于同步信号 ( 同步信号的意思是想对于时钟信号而言，它的变化和时钟是同步的，比如 data)，必须满足 <code>setup time</code> 和 <code>hold time</code> 要求。</p>
<p>在有效时钟沿到来之前的 setup time 时间段内，同步信号必须保持稳定，在有效时钟沿到来之后的 hold time 时间段内，同步信号也必须保持稳定，也就是说从 setup time 到 hold time 之间，它必须保持稳定不变化，这样才能让时钟信号采样到正确的值。</p>
<p>同理，对于异步信号，有类似的要求：</p>
<blockquote>
<p><strong>Recovery time</strong> is like setup time for asynchronous ports (set, reset). It is the time available between the asynchronous signals going inactive and the active clock edge.</p>
<p><strong>Removal time</strong> is like hold time for asynchronous ports (set, reset). It is the time between active clock edge and asynchronous signal going inactive.</p>
</blockquote>
<p>找到一个更清晰的解释：</p>
<blockquote>
<p><strong>Recovery time</strong> is the minimum length of time an asynchronous control signal, for example, and preset, must be stable <strong>before</strong> the next active clock edge. The recovery slack time calculation is similar to the clock setup slack time calculation, but it applies asynchronous control signals.</p>
<p><strong>Removal time</strong> is the minimum length of time an asynchronous control signal must be stable <strong>after</strong> the active clock edge. The TimeQuest analyzer removal time slack calculation is similar to the clock hold slack calculation, but it applies asynchronous control signals.</p>
<p>recovery time specifies the time the inactive edge of the asynchronous signal has to arrive before the closing edge of the clock.</p>
<p>Removal time specifies the length of time the active phase of the asynchronous signal has to be held after the closing edge of the clock.</p>
</blockquote>
<p>也就是说 Recovery / Removal time 类似于 Setup / Hold Time，不过是用于异步信号，比如 set，reset 信号。</p>
<p><img alt="recovery-removal" src="/images/latch-versus-flip-flop/recovery-removal.jpg"></p>
<p>如图所示，在时钟沿到来之前的 recovery time 之前，异步信号必须释放 ( 变无效 )，在时钟沿到来之后的 removal time 之后，异步信号才能变有效，也就是说在从 recovery time 到 removal time 这段时间内，异步信号是不能有效的。</p>
<p>如果使 flip-flop 的输入满足 setup time 和 hold time，那么就可以避免亚稳态的出现，一般器件的手册上都会标明这些参数，从几 ns 到几百 ps 之间。根据 flip-flop 内的组织情况而定，有时候可以将 setup time 或者 hold time 两者中的一个（只能是其中之一）变为 0 甚至是负数。</p>
<p>但是，并不是总能满足这一标准，因为有可能 flip-flop 的输入端连到了外界的，设计者无法控制的一个不断变化的信号，这时候设计者所能做的事就是根据电路要求，将发生错误的概率降低到一个确定的水平。通常使用的方法就是将信号通过一条链在一起的 flip-flop 组，这样子可以将发生亚稳态的概率降低到一个可以忽略的程度，但是还是不等于 0。链中的 flip-flop 越多，这个概率就越趋近于 0，通常的情况是采用 1 个或者两个 flip-flop。</p>
<p>即使现在出现了所谓的 <code>metastable-hardened flip-flops</code>，它可以尽可能地减小 setup time 和 hold time，但是仍然无法完全避免问题的出现。<strong>这是因为亚稳态并不是简单的设计方法上的问题。</strong>当时钟信号和其他信号在相隔很近的时间内变化，flip-flop 必须判断哪一个先发生变化，哪一个后发生变化，无论我们的器件速度有多快，仍然有可能出现两者相隔的太近，以至于无法判断。所以理论上是不可能造出一个完美避免亚稳态的 flip-flop。</p>
<h3 id="propagation-delay">Propagation delay</h3>
<p>flip-flop 还有一个参数叫做 clock-to-output delay (common symbol in data sheets: <code>tco</code>) 或者是 propagation delay (<code>tp</code>)，表示的是 flip-flop 从有效时钟沿开始到输出发生变化所消耗的时间。有时候从高电平变为低电平的时间 (high-to-low transition, tPHL)) 和从低电平变为高电平的时间 (low-to-high transition, tPLH) 不相等。</p>
<p>当用同一时钟来驱动级联的 flip-flop ( 比如移位寄存器 shift register) 时，必须保证前一级的 tco 要大于后一级的 th。这是因为必须要保证前一级的数据能够正确移位到后一级中。当有效时钟沿到来时，前后两级的 ff 在同时变化，采样前一级的输出作为本级的输入，然后经过 tco 输出更新的值。当后一级 ff 在 tsu 到 th 段内采样时，必须保证前一级的输出保持不变，也就是说前一级 ff 的响应速度不能太快，至少要等后一级正确采样完成之后才能变化，即 <code>tco &gt; th</code>。如果采用物理构造完全相同的 ff，那么通常是可以保证这一条件的。</p>
<h2 id="in-fpga">in FPGA</h2>
<p>latch 和 flip-flop 的特点决定了它们各自的应用场景</p>
<p><strong>latch 的优点：</strong></p>
<ol>
<li>
<p>面积比 ff 小</p>
<p>门电路是构建组合逻辑电路的基础，而锁存器和触发器是构建时序逻辑电路的基础。门电路是由晶体管构成的，锁存器是由门电路构成的，而触发器是由锁存器构成的。也就是 晶体管 -&gt; 门电路 -&gt; 锁存器 -&gt; 触发器，前一级是后一级的基础。latch 完成同一个功能所需要的门较触发器要少，所以在 asic 中用的较多。</p>
</li>
<li>
<p>速度比 ff 快</p>
<p>用在地址锁存是很合适的，不过一定要保证所有的 latch 信号源的质量，锁存器在 CPU 设计中很常见，正是由于它的应用使得 CPU 的速度比外部 IO 部件逻辑快许多。</p>
</li>
</ol>
<p><strong>latch 的缺点：</strong></p>
<ol>
<li>
<p>电平触发，非同步设计，受布线延迟影响较大，很难保证输出没有毛刺产生</p>
</li>
<li>
<p>latch 将静态时序分析变得极为复杂</p>
</li>
</ol>
<p><strong>flip-flop 的优点：</strong></p>
<ol>
<li>
<p>边沿触发，同步设计，不容易受毛刺的印象</p>
</li>
<li>
<p>时序分析简单</p>
</li>
</ol>
<p><strong>flip-flop 的缺点：</strong></p>
<ol>
<li>面积比 latch 大，消耗的门电路比 latch 多</li>
</ol>
<p>目前 latch 只在极高端的电路中使用，如 intel 的 P4 等 CPU。而在 PLD / FPGA 中，基本单元 LE 是查找表 LUT 和触发器 FF 组成的，如果要实现 latch，反而需要更多的资源。</p>
<p><strong>一般的设计规则是：</strong></p>
<p>在绝大多数设计中避免产生 latch。它会让您设计的时序完蛋，并且它的隐蔽性很强，非老手不能查出。latch 最大的危害在于不能过滤毛刺。这对于下一级电路是极其危险的。所以，只要能用 DFF 的地方，就不用 latch。</p>
<h3 id="reason-solution-to-unexpected-latch">Reason &amp; Solution to unexpected latch</h3>
<p>在电路设计中，要对 Latch 特别谨慎，如果综合出和设计意图不一致的 Latch，会导致设计错误，包括仿真和综合。因此，要避免产生意外的 Latch。</p>
<h4 id="reason">Reason</h4>
<p>如果组合逻辑完全不使用 always 语句，那么就不会产生 latch，比如</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">assign</span><span class="w"> </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<p>电路不需要保存 dout 的前一个值，所以不会产生 latch。</p>
<p>如果组合逻辑使用了 always 语句，那么就有可能产生 Latch ：</p>
<ol>
<li>
<p>不完整的 if-else</p>
<p>code:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</code></pre></div></td></tr></table></div>

<p>RTL Schematic:</p>
<p><img alt="if-latch" src="/images/latch-versus-flip-flop/if-latch.png"></p>
</li>
<li>
<p>不完整的 case</p>
<p>code:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="n">din</span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="o">-</span><span class="n">c</span><span class="p">)</span>
<span class="w">        </span><span class="mh">2</span><span class="mb">&#39;b00</span><span class="o">:</span><span class="w"> </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="mh">2</span><span class="mb">&#39;b01</span><span class="o">:</span><span class="w"> </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">endcase</span>
<span class="k">end</span>
</code></pre></div></td></tr></table></div>

<p>RTL Schematic:</p>
<p><img alt="case-latch" src="/images/latch-versus-flip-flop/case-latch.png"></p>
</li>
</ol>
<h4 id="solution">Solution</h4>
<p>知道了原因，那么解决方法也就显而易见了：</p>
<ol>
<li>
<p>使用完整的 if-else</p>
<p>code:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">begin</span>
<span class="w">        </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span>
<span class="k">end</span>
</code></pre></div></td></tr></table></div>

<p>RTL Schematic:</p>
<p><img alt="if-else" src="/images/latch-versus-flip-flop/if-else.png"></p>
</li>
<li>
<p>使用完整的 case，添加 default 分支</p>
<p>code:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">always</span><span class="w"> </span><span class="p">@(</span><span class="n">din</span><span class="o">-</span><span class="n">c</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="o">-</span><span class="n">c</span><span class="p">)</span>
<span class="w">        </span><span class="mh">2</span><span class="mb">&#39;b00</span><span class="o">:</span><span class="w"> </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">a</span><span class="p">;</span>
<span class="w">        </span><span class="mh">2</span><span class="mb">&#39;b01</span><span class="o">:</span><span class="w"> </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">2</span><span class="mb">&#39;b00</span><span class="p">;</span>
<span class="w">    </span><span class="k">endcase</span>
<span class="k">end</span>
</code></pre></div></td></tr></table></div>

<p>RTL Schemtatic:</p>
<p><img alt="case-default" src="/images/latch-versus-flip-flop/case-default.png"></p>
</li>
</ol>
<h3 id="application">Application</h3>
<p><a href="http://book.douban.com/subject/3522845/">《Verilog HDL 程序设计与实践》</a> 笔记：</p>
<blockquote>
<p>latch 作为一种电路单元 , 必然有其存在的理由以及应用场景 , 并不像目前的很多书籍简单地将锁存器列为 “ 头等敌人 ”。其实在实际中 , 有些设计是不可避免地要用到锁存器 , 特别是在总线应用上 , 锁存器能提高驱动能力、隔离前后级。例如 , 常见的应用包括地址锁存器、数据锁存器以及复位信号锁存器等。但在更多的情况下 , 很容易在代码中产生未预料到的锁存器 , 使得逻辑功能不满足要求 , 浪费了大量的调试时间 , 从而使得大多数设计人员 “ 闻虎色变 ”。</p>
<p>因此较好的应用规则是 :<strong>要学会分析是否需要锁存器以及代码是否会产生意想不到的锁存器。只有这样才能灵活运用锁存器。</strong></p>
<p>下面通过实例来给予说明。</p>
<p><strong>example1</strong>: 通过 Verilog HDL 实现序列最大值搜索程序，并保持检测到的最大值</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="n">latch</span><span class="o">-</span><span class="n">demo</span><span class="p">(</span><span class="w">  </span>
<span class="w">          </span><span class="n">din</span><span class="p">,</span><span class="n">dout</span><span class="w">  </span>
<span class="w">      </span><span class="p">);</span><span class="w">  </span>
<span class="w">      </span><span class="k">input</span><span class="w">   </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">din</span><span class="p">;</span><span class="w">  </span>
<span class="w">      </span><span class="k">output</span><span class="w"> </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">dout</span><span class="p">;</span>

<span class="w">      </span><span class="kt">reg</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">dout</span><span class="p">;</span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w">  </span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">127</span><span class="p">)</span><span class="w">  </span>
<span class="w">            </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">endmodule</span>
</code></pre></div>

<p>上述代码在 ISE 中的综合结果会给出设计中包含 Latch 的警告。但实际上，abmax-tmp 锁存器正是我们需要的，所以，虽然有警告，但是代码设计是没有问题的。将上述代码的 if 语句补全：</p>
<div class="highlight"><pre><span></span><code><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nv">abmax</span><span class="o">-</span><span class="nv">tmp</span><span class="ss">)</span><span class="w">  </span>
<span class="w">      </span><span class="nv">abmax</span><span class="o">-</span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">a</span><span class="c1">;  </span>
<span class="w">  </span><span class="k">else</span><span class="w">  </span>
<span class="w">      </span><span class="nv">abmax</span><span class="o">-</span><span class="nv">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">abmax</span><span class="o">-</span><span class="nv">tmp</span><span class="c1">;</span>
</code></pre></div>

<p>经过综合后，仍然有 Latch 的警告。无论 Latch 是否是用户需要的，ISE 都会给出警告，主要原因就是 Latch 对整个设计的时序性能影响较大。所以，在设计中要尽量避免 Latch，但是确实需要使用的情况，也可以使用。</p>
<p><strong>example2:</strong> 用 Verilog HDL 实现一个锁存器，当输入数据大于 127 时，将输入数据输出，否则输出 0</p>
<p>不期望的 latch 指的是与设计意图不符，产生的 Latch。主要问题在于设计人员没有合理使用 Verilog HDL 语言，常见的原因是对条件语句（if、casse）的分支描述不完整，导致电路的功能不是预期的，发生了错误。</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="k">module</span><span class="w"> </span><span class="n">latch</span><span class="o">-</span><span class="n">demo</span><span class="p">(</span><span class="w">  </span>
<span class="w">      </span><span class="n">din</span><span class="p">,</span><span class="n">dout</span><span class="w">  </span>
<span class="w">  </span><span class="p">);</span><span class="w">  </span>
<span class="w">  </span><span class="k">input</span><span class="w">   </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">din</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span><span class="k">output</span><span class="w">  </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">dout</span><span class="p">;</span>

<span class="w">  </span><span class="kt">reg</span><span class="w">      </span><span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span><span class="w"> </span><span class="n">dout</span><span class="p">;</span>

<span class="w">  </span><span class="k">always</span><span class="w"> </span><span class="p">@</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="p">)</span><span class="w"> </span><span class="k">begin</span><span class="w">  </span>
<span class="w">       </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">din</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">127</span><span class="p">)</span><span class="w">  </span>
<span class="w">            </span><span class="n">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">din</span><span class="p">;</span><span class="w">  </span>
<span class="w">  </span><span class="k">end</span>

<span class="w">  </span><span class="k">endmodule</span>
</code></pre></div>

<p>综合后的结果，在比较器后面级联了锁存器，这是因为 if 语句缺少 else 分支造成的。查看仿真结果，当输入小于 127 时，输出保持了上次的 127，不是 0，没有达到设计要求。修改方法很简单，就是将 if-else 补全。</p>
<div class="highlight"><pre><span></span><code><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">din</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">127</span><span class="w"> </span><span class="ss">)</span>
<span class="w">       </span><span class="nv">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">din</span><span class="c1">;  </span>
<span class="w">   </span><span class="k">else</span><span class="w">  </span>
<span class="w">       </span><span class="nv">dout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="c1">;</span>
</code></pre></div>

<p>在 ISE 中综合后的结果中，可以看到补全 if-else 后，在比较器后面级联了与门，代替原来的锁存器，仿真结果也正确。</p>
</blockquote>
<h3 id="conclusion">Conclusion</h3>
<p>锁存器 latch 是一种基本电路单元 , 会影响到电路的时序性能 , 应该尽量避免使用 , 但出现锁存器造成设计和原始意图不符的情况 , 则是由于设计人员代码输入不正确造成的。</p>
<h2 id="reference">Reference</h2>
<p><a href="http://en.wikipedia.org/wiki/Flip-flop-(electronics">Flip-flop (electronics) --wikipedia</a></p>
<p><a href="http://book.douban.com/subject/2883561/">数字设计</a></p>
<p><a href="http://book.douban.com/subject/3522845/">Verilog HDL 程序设计与实践</a></p>
<p><a href="http://blog.csdn.net/surgeddd/article/details/4683657">锁存器、触发器、寄存器和缓冲器的区别</a></p>
  </div>


  <div class="neighbors">
    <a class="btn float-left" href="https://qian-gu.github.io/posts/ic/vhdl-notes-2-system-design.html" title="VHDL 笔记 2 —— 系统设计">
      <i class="fa fa-angle-left"></i> Previous Post
    </a>
    <a class="btn float-right" href="https://qian-gu.github.io/posts/ic/the-clock-design-in-fpga-3-multiasynchronous-clock-design.html" title="FPGA 时钟设计 3 —— 跨时钟域设计">
      Next Post <i class="fa fa-angle-right"></i>
    </a>
  </div>


    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle ads-responsive"
         data-ad-client="ca-pub-1821536199377100"
         data-ad-slot="4843941849"></ins>
    <script>
      (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

<!-- Gitalk -->
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="https://qian-gu.github.io/theme/gitalk/md5.min.js"></script>
<script>
var gitalk = new Gitalk({
  clientID: '4b3de26a6e80be727416',
  clientSecret: '993d79339c842fc56d9739ef268f38806dc93f50',
  repo: 'qian-gu.github.io',
  owner: 'qian-gu',
  admin: ['qian-gu'],
  id: md5(location.href),
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- End Gitalk -->
</article>

<footer>
<p>
  &copy; 2025  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.en_US" target="_blank">Creative Commons Attribution-ShareAlike</a>
</p>
<p>
Built with <a href="http://getpelican.com" target="_blank">Pelican</a> using <a href="http://bit.ly/flex-pelican" target="_blank">Flex</a> theme
  <span class="footer-separator">|</span>
  Switch to the <a href="javascript:void(0)" onclick="theme.switch(`dark`)">dark</a> | <a href="javascript:void(0)" onclick="theme.switch(`light`)">light</a> | <a href="javascript:void(0)" onclick="theme.switch(`browser`)">browser</a> theme
  <script id="dark-theme-script"
          src="https://qian-gu.github.io/theme/dark-theme/dark-theme.min.js"
          data-enable-auto-detect-theme="True"
          data-default-theme="ligtht"
          type="text/javascript">
  </script>
</p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
           src="https://qian-gu.github.io/theme/img/cc/by-sa.png"
         width="80"
         height="15"/>
  </a>
</p></footer>  </main>

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Qian's Blog ",
  "url" : "https://qian-gu.github.io",
  "image": "https://qian-gu.github.io/images/logo.png",
  "description": "Qian's Thoughts and Writings"
}
</script><a href="https://github.com/qian-gu/qian-gu.github.io" target="_blank" class="github-corner" aria-label="View source on Github">
    <svg width="80"
         height="80"
         viewBox="0 0 250 250"
         style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
         aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor"
              style="transform-origin: 130px 106px;"
              class="octo-arm">
        </path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor"
              class="octo-body">
        </path>
    </svg>
</a>
  <script>
    window.loadStorkIndex = function () {
      stork.initialize("https://qian-gu.github.io/theme/stork/stork.wasm")
      stork.register("sitesearch", "https://qian-gu.github.io/search-index.st", { showProgress: false });
    }
  </script>
  <script src="https://qian-gu.github.io/theme/stork/stork.js"></script>

</body>
</html>